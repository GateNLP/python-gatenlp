
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>gatenlp.annotation_set &#8212; GATE NLP library (gatenlp)  documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">GATE NLP library (gatenlp)  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for gatenlp.annotation_set</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">KeysView</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Generator</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">gatenlp.annotation</span> <span class="kn">import</span> <span class="n">Annotation</span>
<span class="kn">from</span> <span class="nn">gatenlp.exceptions</span> <span class="kn">import</span> <span class="n">InvalidOffsetException</span>
<span class="kn">from</span> <span class="nn">gatenlp.changelog</span> <span class="kn">import</span> <span class="n">ChangeLog</span>
<span class="kn">from</span> <span class="nn">gatenlp.impl</span> <span class="kn">import</span> <span class="n">SortedIntvls</span>
<span class="kn">from</span> <span class="nn">gatenlp._utils</span> <span class="kn">import</span> <span class="n">support_annotation_or_set</span>
<span class="kn">from</span> <span class="nn">gatenlp.utils</span> <span class="kn">import</span> <span class="n">to_dict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>


<div class="viewcode-block" id="AnnotationSet"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet">[docs]</a><span class="k">class</span> <span class="nc">AnnotationSet</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">owner_doc</span><span class="p">:</span> <span class="s2">&quot;Document&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new annotation set.</span>

<span class="sd">        :param name: the name of the annotation set. This is only really needed if the changelog is used.</span>
<span class="sd">        :param changelog: if a changelog is used, then all changes to the set and its annotations are logged</span>
<span class="sd">        :param owner_doc: if this is set, the set and all sets created from it can be queried for the</span>
<span class="sd">               owning document and offsets get checked against the text of the owning document, if it has</span>
<span class="sd">               text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&quot;CREATING annotation set {} with changelog {} &quot;.format(name, changelog), file=sys.stderr)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gatenlp_type</span> <span class="o">=</span> <span class="s2">&quot;AnnotationSet&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">owner_doc</span> <span class="o">=</span> <span class="n">owner_doc</span>

        <span class="c1"># NOTE: the index is only created when we actually need it!</span>
        <span class="c1"># TODO: python 3.5</span>
        <span class="c1"># self._index_by_offset: SortedIntvls = None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># internally we represent the annotations as a map from annotation id (int) to Annotation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_immutable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">changelog</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner_doc</span><span class="o">.</span><span class="n">changelog</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prevent immutable fields from getting overridden, once they have been</span>
<span class="sd">        set.</span>
<span class="sd">        :param key: attribute to set</span>
<span class="sd">        :param value: value to set attribute to</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;gatenlp_type&quot;</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;owner_doc&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;AnnotationSet attribute cannot get changed after being set&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="AnnotationSet.immutable"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.immutable">[docs]</a>    <span class="k">def</span> <span class="nf">immutable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restrict_to</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an immutable copy of this set, optionally restricted to the given annotation ids.</span>

<span class="sd">        :param restrict_to: an iterable of annotation ids</span>
<span class="sd">        :return: an immutable annotation set with all the annotations of this set or restricted to the ids</span>
<span class="sd">          in restrict_to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">annset</span> <span class="o">=</span> <span class="n">AnnotationSet</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">owner_doc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">owner_doc</span><span class="p">)</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_is_immutable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="p">{</span><span class="n">annid</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span> <span class="k">for</span> <span class="n">annid</span> <span class="ow">in</span> <span class="n">restrict_to</span><span class="p">}</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span>
        <span class="k">return</span> <span class="n">annset</span></div>

<div class="viewcode-block" id="AnnotationSet.immutable_from"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.immutable_from">[docs]</a>    <span class="k">def</span> <span class="nf">immutable_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anns</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an immutable annotation set from the annotations in anns which could by anything that</span>
<span class="sd">        can be iterated over. The owning document is the same as for this set.</span>
<span class="sd">        The next annotation id for the created set is the highest see annotation id from anns plus one.</span>

<span class="sd">        :param anns: an iterable of annotations</span>
<span class="sd">        :return: an immutable annotation set with all the annotations of this set or restricted to the ids</span>
<span class="sd">          in restrict_to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">annset</span> <span class="o">=</span> <span class="n">AnnotationSet</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">owner_doc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">owner_doc</span><span class="p">)</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_is_immutable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nextid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">anns</span><span class="p">:</span>
            <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann</span>
            <span class="k">if</span> <span class="n">ann</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">nextid</span><span class="p">:</span>
                <span class="n">nextid</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">id</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">=</span> <span class="n">nextid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">annset</span></div>

    <span class="k">def</span> <span class="nf">_create_index_by_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the offset index, if it does not already exist.</span>
<span class="sd">        The offset index is an interval tree that stores the annotation ids for the offset interval of the annotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="o">=</span> <span class="n">SortedIntvls</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_index_by_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the type index, if it does not already exist. The type index is a map from</span>
<span class="sd">        annotation type to a set of all annotation ids with that type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span><span class="p">[</span><span class="n">ann</span><span class="o">.</span><span class="n">type</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_to_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation</span><span class="p">:</span> <span class="n">Annotation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If we have created the indices, add the annotation to them.</span>

<span class="sd">        :param annotation: the annotation to add to the indices.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span><span class="p">[</span><span class="n">annotation</span><span class="o">.</span><span class="n">type</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove_from_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation</span><span class="p">:</span> <span class="n">Annotation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove an annotation from the indices.</span>

<span class="sd">        :param annotation: the annotation to remove.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span><span class="p">[</span><span class="n">annotation</span><span class="o">.</span><span class="n">type</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_intvs2idlist</span><span class="p">(</span><span class="n">intvs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert an iterable of interval tuples (start, end, id) to a list of ids</span>

<span class="sd">        :param intvs: iterable of interval tuples</span>
<span class="sd">        :return: list of ids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intvs</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_intvs2idset</span><span class="p">(</span><span class="n">intvs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert an iterable of interval tuples (start, end, id) to a set of ids</span>

<span class="sd">        :param intvs: iterable of interval tuples</span>
<span class="sd">        :return: set of ids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intvs</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_restrict_intvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intvs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">immutable</span><span class="p">(</span><span class="n">AnnotationSet</span><span class="o">.</span><span class="n">_intvs2idlist</span><span class="p">(</span><span class="n">intvs</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of annotations in the set.</span>

<span class="sd">        :return: number of annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">)</span>

<div class="viewcode-block" id="AnnotationSet.size"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of annotations in the set.</span>

<span class="sd">        :return: number of annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.get_doc"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.get_doc">[docs]</a>    <span class="k">def</span> <span class="nf">get_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Document&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the owning document, if known. If the owning document was not set, return None.</span>

<span class="sd">        :return: the document this annotation set belongs to or None if unknown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner_doc</span></div>

    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">_check_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks the offsets for the given span/annotation against the document boundaries, if we know the owning</span>
<span class="sd">        document and if the owning document has text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner_doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner_doc</span><span class="o">.</span><span class="n">text</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">doc_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner_doc</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOffsetException</span><span class="p">(</span><span class="s2">&quot;Annotation starts before 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOffsetException</span><span class="p">(</span><span class="s2">&quot;Annotation ends before 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOffsetException</span><span class="p">(</span><span class="s2">&quot;Annotation ends before it starts&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">doc_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOffsetException</span><span class="p">(</span>
                <span class="s2">&quot;Annotation starts after document ends: start=</span><span class="si">{}</span><span class="s2">, docsize=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">doc_size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">doc_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOffsetException</span><span class="p">(</span>
                <span class="s2">&quot;Annotation ends after document ends: end=</span><span class="si">{}</span><span class="s2">, docsize=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">doc_size</span><span class="p">))</span>

<div class="viewcode-block" id="AnnotationSet.start"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the start offset of the annotation set, i.e. the smallest offset of any annotation.</span>
<span class="sd">        This needs the index.</span>

<span class="sd">        :return: smallest annotation offset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">min_start</span><span class="p">()</span></div>

<div class="viewcode-block" id="AnnotationSet.end"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the end offset of the annotation set, i.e. the biggest end offset of any annotation.</span>

<span class="sd">        :return: largest end offset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">max_end</span><span class="p">()</span></div>

<div class="viewcode-block" id="AnnotationSet.add"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">anntype</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">annid</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an annotation to the set. Once an annotation has been added, the start and end offsets,</span>
<span class="sd">        the type, and the annotation id are immutable.</span>

<span class="sd">        :param start: start offset</span>
<span class="sd">        :param end: end offset</span>
<span class="sd">        :param anntype: the annotation type</span>
<span class="sd">        :param features: a map, an iterable of tuples or an existing feature map. In any case, the features are used \</span>
<span class="sd">        to create a new feature map for this annotation. If the map is empty or this parameter is None, the \</span>
<span class="sd">        annotation does not store any map at all.</span>
<span class="sd">        :param annid: the annotation id, if not specified the next free one for this set is used. NOTE: the id should\</span>
<span class="sd">        normally left unspecified and get assigned automatically.</span>
<span class="sd">        :return: the annotation id of the added annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_immutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot add an annotation to an immutable annotation set&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_offsets</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">annid</span> <span class="ow">and</span> <span class="n">annid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot add annotation with id </span><span class="si">{}</span><span class="s2">, already in set&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">annid</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">annid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">annid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ann</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">anntype</span><span class="p">,</span> <span class="n">annid</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">)</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">_owner_set</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_to_indices</span><span class="p">(</span><span class="n">ann</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;annotation:add&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">ann</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                    <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="n">ann</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">ann</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                    <span class="s2">&quot;features&quot;</span><span class="p">:</span> <span class="n">ann</span><span class="o">.</span><span class="n">_features</span><span class="p">,</span>
                    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">ann</span><span class="o">.</span><span class="n">id</span>
                <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ann</span><span class="o">.</span><span class="n">id</span></div>

<div class="viewcode-block" id="AnnotationSet.add_ann"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.add_ann">[docs]</a>    <span class="k">def</span> <span class="nf">add_ann</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ann</span><span class="p">,</span> <span class="n">annid</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a copy of the given ann to the annotation set, either with a new annotation id or</span>
<span class="sd">        with the one given.</span>

<span class="sd">        :param annid: the annotation id, if not specified the next free one for this set is used.\</span>
<span class="sd">        NOTE: the id should normally left unspecified and get assigned automatically.</span>
<span class="sd">        :return: the annotation id of the added annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">features</span><span class="p">(),</span> <span class="n">annid</span><span class="o">=</span><span class="n">annid</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.remove"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the given annotation which is either the id or the annotation instance.</span>

<span class="sd">        :param annotation: either the id (int) or the annotation instance (Annotation)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">annid</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># make pycharm happy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_immutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot remove an annotation from an immutable annotation set&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">annid</span> <span class="o">=</span> <span class="n">annotation</span>
            <span class="k">if</span> <span class="n">annid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Annotation with id </span><span class="si">{}</span><span class="s2"> not in annotation set, cannot remove&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">annid</span><span class="p">))</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">):</span>
            <span class="n">annid</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">id</span>
            <span class="k">if</span> <span class="n">annid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Annotation with id </span><span class="si">{}</span><span class="s2"> does not belong to this set, cannot remove&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">annid</span><span class="p">))</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;annotation:remove&quot;</span><span class="p">,</span>
                <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">annid</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_from_indices</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.clear"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all annotations from the set.</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;annotations:clear&quot;</span><span class="p">,</span>
                <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator for going through all the annotations of the set.</span>

<span class="sd">        Important: using the iterator will always create the index if it is not already there!</span>
<span class="sd">        For fast iteration use fastiter() which does not allow sorting or offset ranges.</span>

<span class="sd">        :return: a generator for the annotations in document order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return iter(self._annotations.values())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">()</span>

<div class="viewcode-block" id="AnnotationSet.fast_iter"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.fast_iter">[docs]</a>    <span class="k">def</span> <span class="nf">fast_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a generator for fast iteration over all annotations in arbitrary order.</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">a</span></div>

<div class="viewcode-block" id="AnnotationSet.iter"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.iter">[docs]</a>    <span class="k">def</span> <span class="nf">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">start_ge</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">start_lt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">with_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a generator for going through annotations in document order. If an iterator of annotations</span>
<span class="sd">        is given, then those annotations, optionally limited by the other parameters are returned in</span>
<span class="sd">        document order, otherwise, all annotations in the set are returned, otionally limited by the other</span>
<span class="sd">        parameters.</span>

<span class="sd">        :param annotations: an iterable of annotations from this annotation set.</span>
<span class="sd">        :param start_ge: the offset from where to start including annotations</span>
<span class="sd">        :param start_lt: the last offset to use as the starting offset of an annotation</span>
<span class="sd">        :param with_type: only annotations of this type</span>
<span class="sd">        :param reverse: process in reverse document order</span>
<span class="sd">        :return: generator for annotations in document order</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">with_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">allowedtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">allowedtypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">with_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">atype</span> <span class="ow">in</span> <span class="n">with_type</span><span class="p">:</span>
                    <span class="n">allowedtypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allowedtypes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">maxoff</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">start_ge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">start_ge</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">start_lt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">start_lt</span> <span class="o">&gt;=</span> <span class="mi">1</span>
            <span class="n">maxoff</span> <span class="o">=</span> <span class="n">start_lt</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">start_lt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_ge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">start_lt</span> <span class="o">&gt;</span> <span class="n">start_ge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_start</span><span class="p">,</span> <span class="n">_end</span><span class="p">,</span> <span class="n">annid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="n">minoff</span><span class="o">=</span><span class="n">start_ge</span><span class="p">,</span> <span class="n">maxoff</span><span class="o">=</span><span class="n">maxoff</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">allowedtypes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowedtypes</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span></div>

<div class="viewcode-block" id="AnnotationSet.reverse_iter"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.reverse_iter">[docs]</a>    <span class="k">def</span> <span class="nf">reverse_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as iter, but with the reverse parameter set to true.</span>

<span class="sd">        :param kwargs: Same as for iter(), with revers=True fixed.</span>
<span class="sd">        :return: same result as iter()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.get"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Annotation</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the annotation with the given annotation id or returns the given default.</span>

<span class="sd">        :param annid: the annotation id of the annotation to retrieve.</span>
<span class="sd">        :param default: what to return if an annotation with the given id is not found.</span>
<span class="sd">        :return: the annotation or the default value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">annid</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.first"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first annotation in the set or raise and exception if the set is empty.</span>
<span class="sd">        :return: first annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Empty set, there is no first annotation&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">annid</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span></div>

<div class="viewcode-block" id="AnnotationSet.last"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.last">[docs]</a>    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last annotation in the set or raise and exception if the set is empty.</span>
<span class="sd">        :return: first annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Empty set, there is no last annotation&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">annid</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the annotation with the given annotation id or throws an exception.</span>
<span class="sd">        :param item: the annotation id</span>
<span class="sd">        :return: annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span>

<div class="viewcode-block" id="AnnotationSet.with_type"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.with_type">[docs]</a>    <span class="k">def</span> <span class="nf">with_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">anntype</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets annotations of the specified type(s).</span>
<span class="sd">        Creates the type index if necessary.</span>

<span class="sd">        :param anntype: one or more types or type lists. The union of all types specified that way\</span>
<span class="sd">        is used to filter the annotations. If no type is specified, all annotations are selected.</span>
<span class="sd">        :return: an immutable annotation set with the matching annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atypes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atype</span> <span class="ow">in</span> <span class="n">anntype</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atype</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">atype</span><span class="p">:</span>
                    <span class="n">atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atypes</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">immutable</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_type</span><span class="p">()</span>
        <span class="n">annids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">atypes</span><span class="p">:</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idxs</span><span class="p">:</span>
                <span class="n">annids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">immutable</span><span class="p">(</span><span class="n">annids</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.type_names"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.type_names">[docs]</a>    <span class="k">def</span> <span class="nf">type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">KeysView</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the names of all types in this set. Creates the type index if necessary.</span>

<span class="sd">        :return: the set of known annotation type names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_type</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="AnnotationSet.start_eq"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.start_eq">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">start_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ignored</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets all annotations starting at the given offset (empty if none) and returns them in an immutable</span>
<span class="sd">        annotation set.</span>

<span class="sd">        :param start: the offset where annotations should start</span>
<span class="sd">        :param ignored: dummy parameter to allow the use of annotations and annotation sets</span>
<span class="sd">        :return: annotation set of matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: my assumption about how intervaltree works was wrong, so we need to filter what we get from the</span>
        <span class="c1"># point query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">starting_from</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.start_min_ge"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.start_min_ge">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">start_min_ge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ignored</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets all annotations starting at the first possible offset</span>
<span class="sd">        at or after the given offset and returns them in an immutable</span>
<span class="sd">        annotation set.</span>

<span class="sd">        :param offset: The offset</span>
<span class="sd">        :param ignored: dummy parameter to allow the use of annotations and annotation sets</span>
<span class="sd">        :return: annotation set of matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">starting_from</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="c1"># now select only those first ones which all have the same offset</span>
        <span class="n">retids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">startoff</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">intv</span> <span class="ow">in</span> <span class="n">intvs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">startoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">startoff</span> <span class="o">=</span> <span class="n">intv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">retids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">startoff</span> <span class="o">==</span> <span class="n">intv</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">retids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">immutable</span><span class="p">(</span><span class="n">retids</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.start_ge"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.start_ge">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">start_ge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ignored</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the annotations that start at or after the given start offset.</span>

<span class="sd">        :param start: Start offset</span>
<span class="sd">        :param ignored: dummy parameter to allow the use of annotations and annotation sets</span>
<span class="sd">        :return: an immutable annotation set of the matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">starting_from</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.start_lt"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.start_lt">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">start_lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ignored</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the annotations that start before the given offset (or annotation). This also accepts an annotation</span>
<span class="sd">        or set.</span>

<span class="sd">        :param offset: offset before which the annotations should start</span>
<span class="sd">        :param ignored: dummy parameter to allow the use of annotations and annotation sets</span>
<span class="sd">        :return: an immutable annotation set of the matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">starting_before</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">)</span></div>


<div class="viewcode-block" id="AnnotationSet.overlapping"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.overlapping">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">overlapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets annotations overlapping with the given span. Instead of the start and end offsets,</span>
<span class="sd">        also accepts an annotation or annotation set.</span>

<span class="sd">        :param start: start offset of the span</span>
<span class="sd">        :param end: end offset of the span</span>
<span class="sd">        :return: an immutable annotation set with the matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.covering"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.covering">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">covering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the annotations which contain the given offset range (or annotation/annotation set)</span>

<span class="sd">        :param start: the start offset of the span</span>
<span class="sd">        :param end: the end offset of the span</span>
<span class="sd">        :return: an immutable annotation set with the matching annotations, if any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is not directly supported so we find the overlapping ones and then filter those where the</span>
        <span class="c1"># start and end fits</span>
        <span class="c1"># This may not be optimal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">covering</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.within"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.within">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets annotations that fall completely within the given offset range</span>

<span class="sd">        :param start: start offset of the range</span>
<span class="sd">        :param end: end offset of the range</span>
<span class="sd">        :return: an immutable annotation set with the matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">intvs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid offset range: </span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
            <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.coextensive"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.coextensive">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">coextensive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an immutable annotation set with all annotations that start and end at the given offsets.</span>

<span class="sd">        :param start: start offset of the span</span>
<span class="sd">        :param end: end offset of the span</span>
<span class="sd">        :return: annotation set with all annotations that have the same start and end offsets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.span"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.span">[docs]</a>    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple with the start and end offset the corresponds to the smallest start offset of any annotation</span>
<span class="sd">        and the largest end offset of any annotation.</span>
<span class="sd">        (Builds the offset index)</span>

<span class="sd">        :return: tuple of minimum start offset and maximum end offset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">min_start</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">max_end</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annorannid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides &#39;annotation in annotation_set&#39; functionality</span>

<span class="sd">        :param annorannid: the annotation instance or annotation id to check</span>
<span class="sd">        :return: true if the annotation exists in the set, false otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annorannid</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">annorannid</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span>
        <span class="k">return</span> <span class="n">annorannid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span>  <span class="c1"># On the off chance someone passed an ID in directly</span>

    <span class="n">contains</span> <span class="o">=</span> <span class="fm">__contains__</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of the set.</span>

<span class="sd">        :return: string representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;AnnotationSet(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">())))</span>

    <span class="k">def</span> <span class="nf">_json_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;annotations&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">ann</span><span class="o">.</span><span class="n">_json_repr</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span>
            <span class="s2">&quot;next_annid&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;gatenlp_type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gatenlp_type</span>
        <span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_from_json_map</span><span class="p">(</span><span class="n">jsonmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="n">annset</span> <span class="o">=</span> <span class="n">AnnotationSet</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">jsonmap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">))</span>
        <span class="n">annmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">jsonmap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;annotations&quot;</span><span class="p">):</span>
            <span class="n">ann</span><span class="o">.</span><span class="n">_owner_set</span> <span class="o">=</span> <span class="n">annset</span>
            <span class="n">annmap</span><span class="p">[</span><span class="n">ann</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="n">annmap</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">=</span> <span class="n">jsonmap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;next_annid&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">annset</span>

<div class="viewcode-block" id="AnnotationSet.to_dict"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="c1"># NOTE: Changelog is not getting added as it is stored in the document part!</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;annotations&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="s2">&quot;next_annid&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span><span class="p">,</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="AnnotationSet.from_dict"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.annotation_set.AnnotationSet.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">dictrepr</span><span class="p">,</span> <span class="n">owner_doc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">annset</span> <span class="o">=</span> <span class="n">AnnotationSet</span><span class="p">(</span><span class="n">dictrepr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">),</span> <span class="n">owner_doc</span><span class="o">=</span><span class="n">owner_doc</span><span class="p">)</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">=</span> <span class="n">dictrepr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;next_annid&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dictrepr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;annotations&quot;</span><span class="p">):</span>
            <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]),</span> <span class="n">Annotation</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">owner_set</span><span class="o">=</span><span class="n">annset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dictrepr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;annotations&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">annset</span></div></div>


</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">GATE NLP library (gatenlp)  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, University of Sheffield.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.3.
    </div>
  </body>
</html>