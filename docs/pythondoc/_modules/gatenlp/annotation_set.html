
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gatenlp.annotation_set &#8212; GATE NLP library (gatenlp)  documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">GATE NLP library (gatenlp)  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">gatenlp.annotation_set</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for gatenlp.annotation_set</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">KeysView</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Generator</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">gatenlp.annotation</span> <span class="kn">import</span> <span class="n">Annotation</span>
<span class="kn">from</span> <span class="nn">gatenlp.impl</span> <span class="kn">import</span> <span class="n">SortedIntvls</span>
<span class="kn">from</span> <span class="nn">gatenlp._utils</span> <span class="kn">import</span> <span class="n">support_annotation_or_set</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>


<div class="viewcode-block" id="InvalidOffsetError"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.InvalidOffsetError">[docs]</a><span class="k">class</span> <span class="nc">InvalidOffsetError</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="AnnotationSet"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet">[docs]</a><span class="k">class</span> <span class="nc">AnnotationSet</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">owner_doc</span><span class="p">:</span> <span class="s2">&quot;Document&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new annotation set.</span>

<span class="sd">        :param name: the name of the annotation set. This is only really needed if the changelog is used.</span>
<span class="sd">        :param changelog: if a changelog is used, then all changes to the set and its annotations are logged</span>
<span class="sd">        :param owner_doc: if this is set, the set and all sets created from it can be queried for the</span>
<span class="sd">               owning document and offsets get checked against the text of the owning document, if it has</span>
<span class="sd">               text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&quot;CREATING annotation set {} with changelog {} &quot;.format(name, changelog), file=sys.stderr)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_owner_doc</span> <span class="o">=</span> <span class="n">owner_doc</span>

        <span class="c1"># NOTE: the index is only created when we actually need it!</span>
        <span class="c1"># TODO: python 3.5</span>
        <span class="c1"># self._index_by_offset: SortedIntvls = None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># internally we represent the annotations as a map from annotation id (int) to Annotation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_immutable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the name of the annotation set. NOTE: the name of a set cannot be changed.</span>

<span class="sd">        :return: name of annotation set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">changelog</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner_doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner_doc</span><span class="o">.</span><span class="n">changelog</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prevent immutable fields from getting overridden, once they have been</span>
<span class="sd">        set.</span>

<span class="sd">        :param key: attribute to set</span>
<span class="sd">        :param value: value to set attribute to</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;owner_doc&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;AnnotationSet attribute cannot get changed after being set&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="AnnotationSet.detach"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.detach">[docs]</a>    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restrict_to</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an immutable copy of this set, optionally restricted to the given annotation ids.</span>

<span class="sd">        :param restrict_to: an iterable of annotation ids, if None, all the annotations from this set.</span>
<span class="sd">        :return: an immutable annotation set with all the annotations of this set or restricted to the ids</span>
<span class="sd">          in restrict_to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">annset</span> <span class="o">=</span> <span class="n">AnnotationSet</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;detached-from:&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_is_immutable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">restrict_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="p">{</span><span class="n">annid</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span> <span class="k">for</span> <span class="n">annid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="p">{</span><span class="n">annid</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span> <span class="k">for</span> <span class="n">annid</span> <span class="ow">in</span> <span class="n">restrict_to</span><span class="p">}</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span>
        <span class="k">return</span> <span class="n">annset</span></div>

<div class="viewcode-block" id="AnnotationSet.detach_from"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.detach_from">[docs]</a>    <span class="k">def</span> <span class="nf">detach_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anns</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an immutable detached annotation set from the annotations in anns which could by</span>
<span class="sd">        either a collection of annotations or annotation ids (int numbers) which are assumed to</span>
<span class="sd">        be the annotation ids from this set.</span>

<span class="sd">        The next annotation id for the created set is the highest seen annotation id from anns plus one.</span>

<span class="sd">        :param anns: an iterable of annotations</span>
<span class="sd">        :return: an immutable annotation set with all the annotations of this set or restricted to the ids</span>
<span class="sd">          in restrict_to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">annset</span> <span class="o">=</span> <span class="n">AnnotationSet</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;detached-from:&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_is_immutable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nextid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">anns</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">ann</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">ann</span><span class="p">]</span>
                <span class="n">annid</span> <span class="o">=</span> <span class="n">ann</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann</span>
                <span class="n">annid</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">id</span>
            <span class="k">if</span> <span class="n">annid</span> <span class="o">&gt;</span> <span class="n">nextid</span><span class="p">:</span>
                <span class="n">nextid</span> <span class="o">=</span> <span class="n">annid</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">=</span> <span class="n">nextid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">annset</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">immutable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the annotation set is immutable.</span>

<span class="sd">        :return: True if immutable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_immutable</span>

    <span class="nd">@immutable</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">immutable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the annotationset to mutable (False) or immutable (True)</span>

<span class="sd">        :param val: boolean, True to set to immutable, False, otherwise.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_immutable</span> <span class="o">=</span> <span class="n">val</span>

<div class="viewcode-block" id="AnnotationSet.isdetached"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.isdetached">[docs]</a>    <span class="k">def</span> <span class="nf">isdetached</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner_doc</span> <span class="ow">is</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_create_index_by_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the offset index, if it does not already exist.</span>
<span class="sd">        The offset index is an interval tree that stores the annotation ids for the offset interval of the annotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="o">=</span> <span class="n">SortedIntvls</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_index_by_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the type index, if it does not already exist. The type index is a map from</span>
<span class="sd">        annotation type to a set of all annotation ids with that type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span><span class="p">[</span><span class="n">ann</span><span class="o">.</span><span class="n">type</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_to_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation</span><span class="p">:</span> <span class="n">Annotation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If we have created the indices, add the annotation to them.</span>

<span class="sd">        :param annotation: the annotation to add to the indices.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span><span class="p">[</span><span class="n">annotation</span><span class="o">.</span><span class="n">type</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove_from_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation</span><span class="p">:</span> <span class="n">Annotation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove an annotation from the indices.</span>

<span class="sd">        :param annotation: the annotation to remove.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span><span class="p">[</span><span class="n">annotation</span><span class="o">.</span><span class="n">type</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_intvs2idlist</span><span class="p">(</span><span class="n">intvs</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert an iterable of interval tuples (start, end, id) to a list of ids</span>

<span class="sd">        :param intvs: iterable of interval tuples</span>
<span class="sd">        :param ignore: an optional annotation id that should not get included in the result</span>
<span class="sd">        :return: list of ids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intvs</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ignore</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intvs</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_intvs2idset</span><span class="p">(</span><span class="n">intvs</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert an iterable of interval tuples (start, end, id) to a set of ids</span>

<span class="sd">        :param intvs: iterable of interval tuples</span>
<span class="sd">        :return: set of ids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intvs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ignore</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intvs</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_restrict_intvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intvs</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">restrict_to</span><span class="o">=</span><span class="n">AnnotationSet</span><span class="o">.</span><span class="n">_intvs2idlist</span><span class="p">(</span><span class="n">intvs</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of annotations in the set.</span>

<span class="sd">        :return: number of annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of annotations in the set.</span>

<span class="sd">        :return: number of annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">document</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Document&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the owning document, if known. If the owning document was not set, return None.</span>

<span class="sd">        :return: the document this annotation set belongs to or None if unknown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner_doc</span>

    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">_check_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">annid</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks the offsets for the given span/annotation against the document boundaries, if we know the owning</span>
<span class="sd">        document and if the owning document has text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner_doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner_doc</span><span class="o">.</span><span class="n">text</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">doc_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner_doc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOffsetError</span><span class="p">(</span><span class="s2">&quot;Annotation starts before 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOffsetError</span><span class="p">(</span><span class="s2">&quot;Annotation ends before 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOffsetError</span><span class="p">(</span><span class="s2">&quot;Annotation ends before it starts&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">doc_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOffsetError</span><span class="p">(</span>
                <span class="s2">&quot;Annotation starts after document ends: start=</span><span class="si">{}</span><span class="s2">, docsize=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">doc_size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">doc_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOffsetError</span><span class="p">(</span>
                <span class="s2">&quot;Annotation ends after document ends: end=</span><span class="si">{}</span><span class="s2">, docsize=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">doc_size</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the start offset of the annotation set, i.e. the smallest offset of any annotation.</span>
<span class="sd">        This needs the index and creates it if necessary.</span>

<span class="sd">        Throws an exception if there are no annotations in the set.</span>

<span class="sd">        :return: smallest annotation offset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Annotation set is empty, cannot determine start offset&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">min_start</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the end offset of the annotation set, i.e. the biggest end offset of any annotation.</span>
<span class="sd">        This needs the index and creates it if necessary.</span>

<span class="sd">        :return: largest end offset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Annotation set is empty, cannot determine end offset&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">max_end</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the length of the span covered by to first to last annotation.</span>
<span class="sd">        This needs the index and creates it if necessary.</span>

<span class="sd">        :return: length of the annotation set span</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<div class="viewcode-block" id="AnnotationSet.add"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">anntype</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">annid</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an annotation to the set. Once an annotation has been added, the start and end offsets,</span>
<span class="sd">        the type, and the annotation id are immutable.</span>

<span class="sd">        :param start: start offset</span>
<span class="sd">        :param end: end offset</span>
<span class="sd">        :param anntype: the annotation type</span>
<span class="sd">        :param features: a map, an iterable of tuples or an existing feature map. In any case, the features are used</span>
<span class="sd">          to create a new feature map for this annotation. If the map is empty or this parameter is None, the</span>
<span class="sd">          annotation does not store any map at all.</span>
<span class="sd">        :param annid: the annotation id, if not specified the next free one for this set is used. NOTE: the id should</span>
<span class="sd">          normally left unspecified and get assigned automatically.</span>
<span class="sd">        :return: the new annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">annid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annid</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Parameter annid must be an int, mixed up with features?&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Parameter features must not be an int: mixed up with annid?&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_immutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot add an annotation to an immutable annotation set&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_offsets</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">annid</span> <span class="ow">and</span> <span class="n">annid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot add annotation with id </span><span class="si">{}</span><span class="s2">, already in set&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">annid</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">annid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">annid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ann</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">anntype</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">annid</span><span class="o">=</span><span class="n">annid</span><span class="p">)</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">_owner_set</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_to_indices</span><span class="p">(</span><span class="n">ann</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;annotation:add&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">ann</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                    <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="n">ann</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">ann</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                    <span class="s2">&quot;features&quot;</span><span class="p">:</span> <span class="n">ann</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span>
                    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">ann</span><span class="o">.</span><span class="n">id</span>
                <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ann</span></div>

<div class="viewcode-block" id="AnnotationSet.add_ann"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.add_ann">[docs]</a>    <span class="k">def</span> <span class="nf">add_ann</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ann</span><span class="p">,</span> <span class="n">annid</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a copy of the given ann to the annotation set, either with a new annotation id or</span>
<span class="sd">        with the one given.</span>

<span class="sd">        :param annid: the annotation id, if not specified the next free one for this set is used.</span>
<span class="sd">          NOTE: the id should normally left unspecified and get assigned automatically.</span>
<span class="sd">        :return: the annotation id of the added annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="n">annid</span><span class="o">=</span><span class="n">annid</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.remove"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the given annotation which is either the id or the annotation instance.</span>

<span class="sd">        :param annotation: either the id (int) or the annotation instance (Annotation)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">annid</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># make pycharm happy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_immutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot remove an annotation from an immutable annotation set&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">annid</span> <span class="o">=</span> <span class="n">annotation</span>
            <span class="k">if</span> <span class="n">annid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Annotation with id </span><span class="si">{}</span><span class="s2"> not in annotation set, cannot remove&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">annid</span><span class="p">))</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">):</span>
            <span class="n">annid</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">id</span>
            <span class="k">if</span> <span class="n">annid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Annotation with id </span><span class="si">{}</span><span class="s2"> does not belong to this set, cannot remove&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">annid</span><span class="p">))</span>
        <span class="c1"># NOTE: once the annotation has been removed from the set, it could still be referenced</span>
        <span class="c1"># somewhere else and its features could get modified. In order to prevent logging of such changes,</span>
        <span class="c1"># the owning set gets cleared for the annotation</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">_owner_set</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;annotation:remove&quot;</span><span class="p">,</span>
                <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">annid</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_from_indices</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.clear"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all annotations from the set.</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changelog</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;annotations:clear&quot;</span><span class="p">,</span>
                <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">})</span></div>

<div class="viewcode-block" id="AnnotationSet.clone_anns"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.clone_anns">[docs]</a>    <span class="k">def</span> <span class="nf">clone_anns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the annotations in this set with copies of the originals. If this is a detached set,</span>
<span class="sd">        then this makes sure that any modifications to the annotations do not affect the original annotations</span>
<span class="sd">        in the attached set. If this is an attached set, it makes sure that all other detached sets cannot affect</span>
<span class="sd">        the annotations in this set any more. The owning set of the annotations that get cloned is cleared.</span>

<span class="sd">        :param memo: for internal use by our __deepcopy__ implementation.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmpdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">annid</span><span class="p">,</span> <span class="n">ann</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">newann</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
            <span class="n">ann</span><span class="o">.</span><span class="n">_owner_set</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">tmpdict</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span> <span class="o">=</span> <span class="n">newann</span>
        <span class="k">for</span> <span class="n">annid</span><span class="p">,</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">tmpdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann</span></div>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NOTE: creating a copy always creates a detached set, but a mutable one.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_is_immutable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">c</span>

<div class="viewcode-block" id="AnnotationSet.copy"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_is_immutable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">c</span><span class="o">.</span><span class="n">clone_anns</span><span class="p">(</span><span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span>

<div class="viewcode-block" id="AnnotationSet.deepcopy"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator for going through all the annotations of the set.</span>

<span class="sd">        Important: using the iterator will always create the index if it is not already there!</span>
<span class="sd">        For fast iteration use fast_iter() which does not allow sorting or offset ranges.</span>

<span class="sd">        :return: a generator for the annotations in document order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return iter(self._annotations.values())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">()</span>

<div class="viewcode-block" id="AnnotationSet.fast_iter"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.fast_iter">[docs]</a>    <span class="k">def</span> <span class="nf">fast_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a generator for fast iteration over all annotations in arbitrary order.</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">annid</span><span class="p">,</span> <span class="n">ann</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">ann</span></div>

<div class="viewcode-block" id="AnnotationSet.iter"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.iter">[docs]</a>    <span class="k">def</span> <span class="nf">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">start_ge</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">start_lt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">with_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a generator for going through annotations in document order, otionally limited</span>
<span class="sd">        by the other parameters. If two annoations start at the same offset, they are always</span>
<span class="sd">        ordered by increasing annotation id.</span>

<span class="sd">        :param annotations: an iterable of annotations from this annotation set.</span>
<span class="sd">        :param start_ge: the offset from where to start including annotations</span>
<span class="sd">        :param start_lt: the last offset to use as the starting offset of an annotation</span>
<span class="sd">        :param with_type: only annotations of this type</span>
<span class="sd">        :param reverse: process in reverse document order</span>
<span class="sd">        :return: generator for annotations in document order</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">with_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">allowedtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">allowedtypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">with_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">atype</span> <span class="ow">in</span> <span class="n">with_type</span><span class="p">:</span>
                    <span class="n">allowedtypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allowedtypes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">maxoff</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">start_ge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">start_ge</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">start_lt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">start_lt</span> <span class="o">&gt;=</span> <span class="mi">1</span>
            <span class="n">maxoff</span> <span class="o">=</span> <span class="n">start_lt</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">start_lt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_ge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">start_lt</span> <span class="o">&gt;</span> <span class="n">start_ge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_start</span><span class="p">,</span> <span class="n">_end</span><span class="p">,</span> <span class="n">annid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="n">minoff</span><span class="o">=</span><span class="n">start_ge</span><span class="p">,</span> <span class="n">maxoff</span><span class="o">=</span><span class="n">maxoff</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">allowedtypes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowedtypes</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span></div>

<div class="viewcode-block" id="AnnotationSet.reverse_iter"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.reverse_iter">[docs]</a>    <span class="k">def</span> <span class="nf">reverse_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as iter, but with the reverse parameter set to true.</span>

<span class="sd">        :param kwargs: Same as for iter(), with revers=True fixed.</span>
<span class="sd">        :return: same result as iter()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.get"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Annotation</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the annotation with the given annotation id or returns the given default.</span>

<span class="sd">        NOTE: for handling cases where legacy code still expects the add method to return</span>
<span class="sd">        an id and not the annotation, this will accept an annotation so the the frequent</span>
<span class="sd">        pattern still works:</span>

<span class="sd">           annid = annset.add(b,e,t).id</span>
<span class="sd">           ann = annset.get(annid)</span>

<span class="sd">        If an annotation is passed the annotation from the set with the id of that annotation is</span>
<span class="sd">        returned, if the annotation is from that set, this will return the same object, if it is</span>
<span class="sd">        still in the set (or return the default value).</span>

<span class="sd">        :param annid: the annotation id of the annotation to retrieve.</span>
<span class="sd">        :param default: what to return if an annotation with the given id is not found.</span>
<span class="sd">        :return: the annotation or the default value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annid</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">):</span>
            <span class="n">annid</span> <span class="o">=</span> <span class="n">annid</span><span class="o">.</span><span class="n">id</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">annid</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.first"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first annotation in the set or raise an exception if the set is empty.</span>

<span class="sd">        :return: first annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Empty set, there is no first annotation&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">annid</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span></div>

<div class="viewcode-block" id="AnnotationSet.last"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.last">[docs]</a>    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last annotation in the set or raise and exception if the set is empty.</span>

<span class="sd">        :return: first annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Empty set, there is no last annotation&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">annid</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the annotation with the given annotation id or throws an exception.</span>

<span class="sd">        :param item: the annotation id</span>
<span class="sd">        :return: annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">annid</span><span class="p">]</span>

<div class="viewcode-block" id="AnnotationSet.with_type"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.with_type">[docs]</a>    <span class="k">def</span> <span class="nf">with_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">anntype</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">],</span>
                  <span class="n">non_overlapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets annotations of the specified type(s).</span>
<span class="sd">        Creates the type index if necessary.</span>

<span class="sd">        :param anntype: one or more types or type lists. The union of all types specified that way</span>
<span class="sd">          is used to filter the annotations. If no type is specified, all annotations are selected.</span>
<span class="sd">        :param non_overlapping: if True, only return annotations of any of the given types which</span>
<span class="sd">          do not overlap with other annotations. If there are several annotations that start at</span>
<span class="sd">          the same offset, use the type that comes first in the parameters, if there are more</span>
<span class="sd">          than one of that type, use the one that would come first in the usual sort order.</span>
<span class="sd">        :return: an immutable annotation set with the matching annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atypes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atype</span> <span class="ow">in</span> <span class="n">anntype</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atype</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">atype</span><span class="p">:</span>
                    <span class="n">atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atypes</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_type</span><span class="p">()</span>
        <span class="n">annids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">atypes</span><span class="p">:</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idxs</span><span class="p">:</span>
                <span class="n">annids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">non_overlapping</span><span class="p">:</span>
            <span class="c1"># need to get annotations grouped by start offset and sorted according to</span>
            <span class="c1"># what the Annotation class defines</span>
            <span class="n">allanns</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">annids</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
            <span class="n">allanns</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">allanns</span><span class="p">]</span>
            <span class="n">allannsgrouped</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">curstart</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">curset</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">allanns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">curstart</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">curset</span> <span class="o">=</span> <span class="p">[</span><span class="n">ann</span><span class="p">]</span>
                    <span class="n">curstart</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">start</span>
                <span class="k">elif</span> <span class="n">curstart</span> <span class="o">==</span> <span class="n">ann</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                    <span class="n">curset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ann</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">allannsgrouped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curset</span><span class="p">)</span>
                    <span class="n">curset</span> <span class="o">=</span> <span class="p">[</span><span class="n">ann</span><span class="p">]</span>
                    <span class="n">curstart</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">start</span>
            <span class="k">if</span> <span class="n">curset</span><span class="p">:</span>
                <span class="n">allannsgrouped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curset</span><span class="p">)</span>
            <span class="n">retanns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># now go through all the grouped annoations and select the top priority one</span>
            <span class="c1"># then skip to the next group that does not overlap with the one we just selected</span>
            <span class="n">typepriority</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atype</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atypes</span><span class="p">):</span>
                <span class="n">typepriority</span><span class="p">[</span><span class="n">atype</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atypes</span><span class="p">)</span><span class="o">-</span><span class="n">i</span>
            <span class="n">curminoffset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">allannsgrouped</span><span class="p">:</span>
                <span class="c1"># instead of sorting, go through the group and find the top priority one</span>
                <span class="n">topann</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">curminoffset</span><span class="p">:</span>
                        <span class="n">topann</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;We should never get a 0 size group here!&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ann</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ann</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">curminoffset</span><span class="p">:</span>
                            <span class="n">topann</span> <span class="o">=</span> <span class="n">ann</span>
                            <span class="k">break</span>
                    <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">if</span> <span class="n">ann</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">curminoffset</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">typepriority</span><span class="p">[</span><span class="n">ann</span><span class="o">.</span><span class="n">type</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">typepriority</span><span class="p">[</span><span class="n">topann</span><span class="o">.</span><span class="n">type</span><span class="p">]:</span>
                            <span class="n">topann</span> <span class="o">=</span> <span class="n">ann</span>
                        <span class="k">elif</span> <span class="n">typepriority</span><span class="p">[</span><span class="n">ann</span><span class="o">.</span><span class="n">type</span><span class="p">]</span> <span class="o">==</span> <span class="n">typepriority</span><span class="p">[</span><span class="n">topann</span><span class="o">.</span><span class="n">type</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">ann</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">topann</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                                <span class="n">topann</span> <span class="o">=</span> <span class="n">ann</span>
                            <span class="k">elif</span> <span class="n">ann</span><span class="o">.</span><span class="n">end</span> <span class="o">==</span> <span class="n">topann</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">ann</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">topann</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
                                    <span class="n">topann</span> <span class="o">=</span> <span class="n">ann</span>
                <span class="k">if</span> <span class="n">topann</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">retanns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">topann</span><span class="p">)</span>
                    <span class="n">curminoffset</span> <span class="o">=</span> <span class="n">topann</span><span class="o">.</span><span class="n">end</span>
            <span class="n">annids</span> <span class="o">=</span> <span class="p">[</span><span class="n">ann</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">retanns</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">restrict_to</span><span class="o">=</span><span class="n">annids</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.by_offset"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.by_offset">[docs]</a>    <span class="k">def</span> <span class="nf">by_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return annotations as a collection of lists, where each list contains all</span>
<span class="sd">        annotations that start at the same offset, sorted in their natural order.</span>

<span class="sd">        NOTE: creates the index!</span>

<span class="sd">        :return: a generator for lists of annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">lastoff</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">curlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ann</span><span class="o">.</span><span class="n">start</span> <span class="o">!=</span> <span class="n">lastoff</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lastoff</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">curlist</span>
                <span class="n">lastoff</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">start</span>
                <span class="n">curlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">ann</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ann</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lastoff</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">curlist</span></div>

<div class="viewcode-block" id="AnnotationSet.by_span"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.by_span">[docs]</a>    <span class="k">def</span> <span class="nf">by_span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return annotations as a collection of lists, where each list contains all</span>
<span class="sd">        annotations with identical spans.</span>

<span class="sd">        NOTE: creates the index!</span>

<span class="sd">        :return: a generator for lists of annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">lastsoff</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">lasteoff</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">curlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ann</span><span class="o">.</span><span class="n">start</span> <span class="o">!=</span> <span class="n">lastsoff</span> <span class="ow">or</span> <span class="n">ann</span><span class="o">.</span><span class="n">end</span> <span class="o">!=</span> <span class="n">lasteoff</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lastsoff</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">curlist</span>
                <span class="n">lastsoff</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">start</span>
                <span class="n">lasteoff</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">end</span>
                <span class="n">curlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">ann</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ann</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lastsoff</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">curlist</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">KeysView</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the names of all types in this set. Creates the type index if necessary.</span>

<span class="sd">        :return: the set of known annotation type names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_type</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_type</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

<div class="viewcode-block" id="AnnotationSet.start_eq"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.start_eq">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">start_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ignored</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">annid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_self</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets all annotations starting at the given offset (empty if none) and returns them in an immutable</span>
<span class="sd">        annotation set.</span>

<span class="sd">        :param start: the offset where annotations should start</span>
<span class="sd">        :param ignored: dummy parameter to allow the use of annotations and annotation sets</span>
<span class="sd">        :return: annotation set of matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: my assumption about how intervaltree works was wrong, so we need to filter what we get from the</span>
        <span class="c1"># point query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">starting_from</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_self</span> <span class="ow">and</span> <span class="n">annid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="n">annid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.start_min_ge"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.start_min_ge">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">start_min_ge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ignored</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">annid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_self</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets all annotations starting at the first possible offset</span>
<span class="sd">        at or after the given offset and returns them in an immutable</span>
<span class="sd">        annotation set.</span>

<span class="sd">        :param offset: The offset</span>
<span class="sd">        :param ignored: dummy parameter to allow the use of annotations and annotation sets</span>
<span class="sd">        :return: annotation set of matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">starting_from</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="c1"># now select only those first ones which all have the same offset</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_self</span> <span class="ow">and</span> <span class="n">annid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="n">annid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">retids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">startoff</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">intv</span> <span class="ow">in</span> <span class="n">intvs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">startoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">startoff</span> <span class="o">=</span> <span class="n">intv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ignore</span> <span class="o">!=</span> <span class="n">intv</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">retids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">retids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">startoff</span> <span class="o">==</span> <span class="n">intv</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ignore</span> <span class="o">!=</span> <span class="n">intv</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">retids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">retids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">restrict_to</span><span class="o">=</span><span class="n">retids</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.start_ge"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.start_ge">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">start_ge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ignored</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">annid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_self</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the annotations that start at or after the given start offset.</span>

<span class="sd">        :param start: Start offset</span>
<span class="sd">        :param ignored: dummy parameter to allow the use of annotations and annotation sets</span>
<span class="sd">        :return: an immutable annotation set of the matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">starting_from</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_self</span> <span class="ow">and</span> <span class="n">annid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="n">annid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.start_lt"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.start_lt">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">start_lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ignored</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">annid</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the annotations that start before the given offset (or annotation). This also accepts an annotation</span>
<span class="sd">        or set.</span>

<span class="sd">        :param offset: offset before which the annotations should start</span>
<span class="sd">        :param ignored: dummy parameter to allow the use of annotations and annotation sets</span>
<span class="sd">        :return: an immutable annotation set of the matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">starting_before</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">)</span></div>


<div class="viewcode-block" id="AnnotationSet.overlapping"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.overlapping">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">overlapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">annid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_self</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets annotations overlapping with the given span. Instead of the start and end offsets,</span>
<span class="sd">        also accepts an annotation or annotation set.</span>

<span class="sd">        For each annotation ann in the result set, ann.overlapping(span) is True</span>

<span class="sd">        :param start: start offset of the span</span>
<span class="sd">        :param end: end offset of the span</span>
<span class="sd">        :param annid: the annotation id of the annotation representing the span.</span>
<span class="sd">        :param include_self: if True and the annotation id for the span is given, do not include that</span>
<span class="sd">          annotation in the result set.</span>
<span class="sd">        :return: an immutable annotation set with the matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">overlapping</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_self</span> <span class="ow">and</span> <span class="n">annid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="n">annid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.covering"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.covering">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">covering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">annid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_self</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the annotations which contain the given offset range (or annotation/annotation set),</span>
<span class="sd">        i.e. annotations such that the given offset range is within the annotation.</span>

<span class="sd">        For each annotation ann in the result set, ann.covering(span) is True.</span>

<span class="sd">        :param start: the start offset of the span</span>
<span class="sd">        :param end: the end offset of the span</span>
<span class="sd">        :param annid: the annotation id of the annotation representing the span.</span>
<span class="sd">        :param include_self: if True and the annotation id for the span is given, do not include that</span>
<span class="sd">          annotation in the result set.</span>
<span class="sd">        :return: an immutable annotation set with the matching annotations, if any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">covering</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_self</span> <span class="ow">and</span> <span class="n">annid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="n">annid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.within"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.within">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">annid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_self</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets annotations that fall completely within the given offset range, i.e. annotations</span>
<span class="sd">        such that the offset range is covering each of the annotation.</span>

<span class="sd">        For each annotation ann in the result set, ann.within(span) is True.</span>

<span class="sd">        :param start: start offset of the range</span>
<span class="sd">        :param end: end offset of the range</span>
<span class="sd">        :param annid: the annotation id of the annotation representing the span.</span>
<span class="sd">        :param include_self: if True and the annotation id for the span is given, do not include that</span>
<span class="sd">          annotation in the result set.</span>
<span class="sd">        :return: an immutable annotation set with the matching annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">intvs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid offset range: </span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
            <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_self</span> <span class="ow">and</span> <span class="n">annid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="n">annid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnnotationSet.coextensive"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.coextensive">[docs]</a>    <span class="nd">@support_annotation_or_set</span>
    <span class="k">def</span> <span class="nf">coextensive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">annid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_self</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AnnotationSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an immutable annotation set with all annotations that start and end at the given offsets.</span>

<span class="sd">        For each annotation ann in the result set, ann.coextensive(span) is True.</span>

<span class="sd">        :param start: start offset of the span</span>
<span class="sd">        :param end: end offset of the span</span>
<span class="sd">        :param annid: the annotation id of the annotation representing the span.</span>
<span class="sd">        :param include_self: if True and the annotation id for the span is given, do not include that</span>
<span class="sd">          annotation in the result set.</span>
<span class="sd">        :return: annotation set with all annotations that have the same start and end offsets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="n">intvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_self</span> <span class="ow">and</span> <span class="n">annid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="n">annid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restrict_intvs</span><span class="p">(</span><span class="n">intvs</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple with the start and end offset the corresponds to the smallest start offset of any annotation</span>
<span class="sd">        and the largest end offset of any annotation.</span>
<span class="sd">        (Builds the offset index)</span>

<span class="sd">        :return: tuple of minimum start offset and maximum end offset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_index_by_offset</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">min_start</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_by_offset</span><span class="o">.</span><span class="n">max_end</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annorannid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides &#39;annotation in annotation_set&#39; functionality</span>

<span class="sd">        :param annorannid: the annotation instance or annotation id to check</span>
<span class="sd">        :return: true if the annotation exists in the set, false otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annorannid</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">annorannid</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span>
        <span class="k">return</span> <span class="n">annorannid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span>  <span class="c1"># On the off chance someone passed an ID in directly</span>

    <span class="n">contains</span> <span class="o">=</span> <span class="fm">__contains__</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of the set.</span>

<span class="sd">        :return: string representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;AnnotationSet(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">())))</span>

<div class="viewcode-block" id="AnnotationSet.to_dict"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="c1"># NOTE: Changelog is not getting added as it is stored in the document part!</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;annotations&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="s2">&quot;next_annid&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_annid</span><span class="p">,</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="AnnotationSet.from_dict"><a class="viewcode-back" href="../../gatenlp.annotation_set.html#gatenlp.AnnotationSet.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">dictrepr</span><span class="p">,</span> <span class="n">owner_doc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">annset</span> <span class="o">=</span> <span class="n">AnnotationSet</span><span class="p">(</span><span class="n">dictrepr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">),</span> <span class="n">owner_doc</span><span class="o">=</span><span class="n">owner_doc</span><span class="p">)</span>
        <span class="n">annset</span><span class="o">.</span><span class="n">_next_annid</span> <span class="o">=</span> <span class="n">dictrepr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;next_annid&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dictrepr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;annotations&quot;</span><span class="p">):</span>
            <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]),</span> <span class="n">Annotation</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">owner_set</span><span class="o">=</span><span class="n">annset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dictrepr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;annotations&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">annset</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">annset</span></div></div>


</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">GATE NLP library (gatenlp)  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">gatenlp.annotation_set</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, University of Sheffield.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.1.
    </div>
  </body>
</html>