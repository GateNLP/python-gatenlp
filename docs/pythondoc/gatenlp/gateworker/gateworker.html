<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gatenlp.gateworker.gateworker API documentation</title>
<meta name="description" content="Module for interacting with a Java GATE process." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.gateworker.gateworker</code></h1>
</header>
<section id="section-intro">
<p>Module for interacting with a Java GATE process.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
&#34;&#34;&#34;
Module for interacting with a Java GATE process.
&#34;&#34;&#34;
import socket

import py4j
from py4j.java_gateway import JavaGateway
from typing import Optional, List, Tuple, Union
import sys
import subprocess
import os
import pathlib
import platform as sysplatform
import logging
import atexit
import secrets
import argparse
import signal
import glob
import json
from gatenlp.annotation_set import AnnotationSet

# NOTE: we delay importing py4j to the class initializer. This allows us to make GateWorker available via gatenlp
# but does not force everyone to actually have py4j installed if they do not use the GateWorker
# from py4j.java_gateway import JavaGateway, GatewayParameters
from gatenlp import Document
from gatenlp.utils import init_logger

JARVERSION = &#34;1.0&#34;

logging.basicConfig()
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


def jar_loc() -&gt; str:
    &#34;&#34;&#34;Return the path to the gate worker jar as a string.&#34;&#34;&#34;
    return str(pathlib.Path(__file__).parent.parent.
               joinpath(&#34;_jars&#34;).joinpath(f&#34;gatetools-gatenlpworker-{JARVERSION}.jar&#34;))


def classpath_sep(platform: Optional[str] = None) -&gt; str:  # pragma: no cover
    &#34;&#34;&#34;
    Get the system-specific classpath separator character.

    Args:
      platform:  (Default value = None) &#34;win&#34; or &#34;windows&#34; for Windows, anything else for non-windows
        If not specified, tries to determine automatically (which may fail)

    Returns:
      classpath separator character

    &#34;&#34;&#34;
    if not platform:
        myplatform = sysplatform.system()
        if not myplatform:
            raise Exception(
                &#34;Could not determine operating system, please use platform parameter&#34;
            )
        platform = myplatform
    if platform.lower() == &#34;windows&#34; or platform.lower() == &#34;win&#34;:
        return &#34;;&#34;
    else:
        return &#34;:&#34;


def gate_classpath(gatehome: str, platform: Optional[str] = None) -&gt; str:  # pragma: no cover
    &#34;&#34;&#34;
    Return the GATE classpath components as a string, with the path seperator characters appropriate
    for the operating system.

    Args:
      gatehome: path where GATE is installed, either as a cloned git repo or a downloaded installation dir.
      platform:  (Default value = None) &#34;win&#34; or &#34;windows&#34; for Windows, anything else for non-Windows.

    Returns:
      GATE classpath

    Raises:
        Exception if classpath could not be determined.

    &#34;&#34;&#34;
    # check which kind of GATE home we have: if there is a distro subdirectory, assume cloned git repo
    if not os.path.exists(gatehome):
        raise Exception(&#34;GATE home directory does not exist: {}&#34;.format(gatehome))
    if not os.path.isdir(gatehome):
        raise Exception(&#34;GATE home directory does not a directory: {}&#34;.format(gatehome))
    cpsep = classpath_sep(platform)
    cpfile = os.path.join(gatehome, &#34;gate.classpath&#34;)
    bindir = os.path.join(gatehome, &#34;bin&#34;)
    # logger.info(&#34;DEBUG checking for {}&#34;.format(cpfile))
    if os.path.exists(cpfile):
        if not os.path.exists(cpfile):
            raise Exception(
                &#34;File not found {}, distribution may need compiling&#34;.format(cpfile)
            )
        with open(cpfile, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
            c_p = infp.read()
            return c_p + cpsep + bindir
    else:
        # logger.info(&#34;DEBUG {} does not exist&#34;.format(cpfile))
        libdir = os.path.join(gatehome, &#34;lib&#34;)
        bindir = os.path.join(gatehome, &#34;bin&#34;)
        if not os.path.isdir(libdir):
            raise Exception(
                &#34;Could not determine class path from {}, no lib directory&#34;.format(
                    gatehome
                )
            )
        jars = glob.glob(os.path.join(libdir, &#34;*.jar&#34;))
        libcp = cpsep.join(jars)

        return libcp + cpsep + bindir


def start_gate_worker(
        port: int = 25333,
        host: str = &#34;127.0.0.1&#34;,
        auth_token: Optional[str] = None,
        use_auth_token: bool = True,
        java: str = &#34;java&#34;,
        platform: Optional[str] = None,
        gatehome: Optional[str] = None,
        log_actions: bool = False,
        keep: bool = False,
        debug: bool = False,
):   # pragma: no cover
    &#34;&#34;&#34;
    Run the gate worker program. This starts the Java program included with gatenlp to
    run GATE and execute the gate worker within GATE so that Python can connect to it.

    This methods waits for the subprocess to end.

    Args:
        port:  (Default value = 25333) Port number to use
        host:  (Default value = &#34;127.0.0.1&#34;) Host address to bind to
        auth_token:  (Default value = None)  Authorization token to use. If None, creates a random token.
        use_auth_token:  (Default value = True) If False, do not aue an authorization token at all.
           This allows anyone who can connect to the host address to connect and use the gate worker process.
        java:  (Default value = &#34;java&#34;) Java command (if on the binary path) or full path to the binary
           to use for running the gate worker program.
        platform:  (Default value = None) &#34;win&#34; or &#34;windows&#34; for Windows, anything else for non-Windows.
           If None, tries to determine automatically.
        gatehome:  (Default value = None) The path to where GATE is installed. If None, the environment
           variable &#34;GATE_HOME&#34; is used.
        log_actions:  (Default value = False) If True, the GATE Worker process will log everything it is
           ordered to do.
        keep:  (Default value = False) passed on to the gate worker process and tells the process if it should
           report to the using Python process that it can be closed or not.
        debug: (Default valuye = False) Show debug messages.
    &#34;&#34;&#34;
    logger = init_logger(__name__)
    if debug:
        logger.setLevel(logging.DEBUG)

    if gatehome is None:
        gatehome = os.environ.get(&#34;GATE_HOME&#34;)
        if gatehome is None:
            raise Exception(
                &#34;Parameter gatehome is None and environment var GATE_HOME not set&#34;
            )
    if use_auth_token:
        if not auth_token:
            auth_token = secrets.token_urlsafe(20)
    else:
        auth_token = &#34;&#34;
    if log_actions:
        log_actions = &#34;1&#34;
    else:
        log_actions = &#34;0&#34;
    if keep:
        keep = &#34;1&#34;
    else:
        keep = &#34;0&#34;
    logger.debug(
        f&#34;Starting gate worker, gatehome={gatehome}, auth_token={auth_token}, log_actions={log_actions}, keep={keep}&#34;
    )
    jarloc = jar_loc()
    if not os.path.exists(jarloc):
        raise Exception(&#34;Could not find jar, {} does not exist&#34;.format(jarloc))
    logger.debug(f&#34;Using JAR: {jarloc}&#34;)
    cmdandparms = [java, &#34;-cp&#34;]
    cpsep = classpath_sep(platform=platform)
    cmdandparms.append(jarloc + cpsep + gate_classpath(gatehome, platform=platform))
    cmdandparms.append(&#34;gate.tools.gatenlpworker.GatenlpWorker&#34;)
    cmdandparms.append(str(port))
    cmdandparms.append(host)
    cmdandparms.append(log_actions)
    cmdandparms.append(keep)
    os.environ[&#34;GATENLP_WORKER_TOKEN_&#34; + str(port)] = auth_token
    cmd = &#34; &#34;.join(cmdandparms)
    logger.debug(f&#34;Running command: {cmd}&#34;)
    subproc = subprocess.Popen(
        cmdandparms, stderr=subprocess.PIPE, bufsize=0, encoding=&#34;utf-8&#34;
    )
    logger.info(f&#34;Running as process with PID {subproc.pid}&#34;)

    def shutdown():
        &#34;&#34;&#34;
        Handler that gets invoked when the calling Python program exits.
        This terminates the gate worker by sending the SIGINT signal to it.
        &#34;&#34;&#34;
        subproc.send_signal(signal.SIGINT)
        for line in subproc.stderr:
            print(line, file=sys.stderr, end=&#34;&#34;)

    atexit.register(shutdown)
    while True:
        line = subproc.stderr.readline()
        if line == &#34;&#34;:
            break
        line = line.rstrip(&#34;\n\r&#34;)
        if line == &#34;PythonWorkerRunner.java: server start OK&#34;:
            break
        if line == &#34;PythonWorkerRunner.java: server start NOT OK&#34;:
            raise Exception(&#34;Could not start server, giving up&#34;)
        print(line, file=sys.stderr)
    try:
        subproc.wait()
    except KeyboardInterrupt:
        print(&#34;Received keyboard interrupt, shutting down server...&#34;)
        shutdown()

# pylint: disable=C0103


def check_port_used(host: str, port: int) -&gt; bool:
    &#34;&#34;&#34;
    Check if the given port on the given host is in use.
    &#34;&#34;&#34;
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn = sock.connect_ex((host, port))
    used = False
    if conn == 0:
        used = True
    sock.close()
    return used


class GateWorker:
    &#34;&#34;&#34;
    Gate worker for remotely running arbitrary GATE and other JAVA operations in a separate
    Java GATE process.
    &#34;&#34;&#34;

    def __init__(
            self,
            port: int = 25333,
            retry_ports: int = 10,
            start: bool = True,
            java: str = &#34;java&#34;,
            host: str = &#34;127.0.0.1&#34;,
            gatehome: Optional[str] = None,
            platform: Optional[str] = None,
            auth_token: Optional[str] = None,
            use_auth_token: bool = True,
            log_actions: bool = False,
            keep: bool = False,
            debug: bool = False,
            ):
        &#34;&#34;&#34;
        Create an instance of the GateWorker and either start our own Java GATE process for it to use
        (start=True) or connect to an existing one (start=False).

        After the GateWorker instance has been create successfully, it is possible to:

        * Use one of the methods of the instance to perform operations on the Java side or exchange data

        * use GateWorker.worker to invoke methods from the PythonWorker class on the Java side (but for most of these
          method there is a shortcut implementation directly on GateWorker which should be preferred!)

        * use GateWorker.jvm to directly construct objects or call instance or static methods

        NOTE: the GATE process must not output anything important/big to stderr because everything from
        stderr gets captured and used for communication between the Java and Python processes. At least
        part of the output to stderr may only be passed on after the GATE process has ended.

        Example:

            ```python
            gw = GateWorker()
            pipeline = gw.loadPipelineFromFile(&#34;thePipeline.xgapp&#34;)
            doc = gw.createDocument(&#34;Some document text&#34;)
            gw.worker.run4Document(pipeline,doc)
            pdoc = gw.gdoc2pdoc(doc)
            gw.deleteResource(doc)
            # process the document pdoc ...
            ```

        port: port to use
        retry_ports: if start=True and the specified port is in use, try this many
            additional ports before giving up (default: 10) Note: this uses a simple implementation which checks
            in advance if the port is in use; this strategy may fail in cases where a port that was found to be
            free is getting used in the short time between the check and the actual use by the gate worker.
        start: if True, try to start our own GATE process, otherwise expect an already started
            process at the host/port address
        java: path to the java binary to run or the java command to use from the PATH (for start=True)
        host: host an existing Java GATE process is running on (only relevant for start=False)
        gatehome: where GATE is installed (only relevant if start=True). If None, expects
            environment variable GATE_HOME to be set.
        platform: system platform we run on, one of Windows, Linux (also for MacOs) or Java
        auth_token: if None or &#34;&#34; and use_auth_token is True, generate a random token which
            is then accessible via the auth_token attribute, otherwise use the given auth token.
        use_auth_token: if False, do not use an auth token, otherwise either use the one specified
            via auth_token or generate a random one.
        log_actions: if the gate worker should log the actions it is doing
        keep: normally if gs.close() is called and we are not connected to the PythonWorkerLr,
            the worker will be shut down. If this is True, the gs.close() method does not shut down
            the worker.
        debug: show debug messages (default: False)
        &#34;&#34;&#34;
        if debug:
            self.logger = init_logger(&#34;GateWorker&#34;, lvl=&#34;DEBUG&#34;)
        else:
            self.logger = init_logger(&#34;GateWorker&#34;)

        from py4j.java_gateway import JavaGateway, GatewayParameters

        self._gatehome = gatehome
        self._port = port
        self._host = host
        self._platform = platform
        self._gateprocess = None
        self._gateway = None
        self._closed = False
        if use_auth_token:
            if not auth_token:
                self._auth_token = secrets.token_urlsafe(20)
            else:
                self._auth_token = auth_token
        else:
            self._auth_token = &#34;&#34;
        if gatehome is None and start:
            gatehome = os.environ.get(&#34;GATE_HOME&#34;)
            if gatehome is None:
                raise Exception(
                    &#34;Parameter gatehome is None and environment var GATE_HOME not set&#34;
                )
            self._gatehome = gatehome
        if start:
            # make sure we find the jar we need
            # logger.info(&#34;DEBUG: file location: {}&#34;.format(__file__))
            used = True
            if retry_ports:
                for i in range(retry_ports):
                    port = self.port + i
                    used = check_port_used(self.host, port)
                    if not used:
                        self._port = port
                        break
                    logger.info(f&#34;Port {port} is already in use&#34;)
                if used:
                    raise Exception(f&#34;Port(s) in use: {self.port} to {port}&#34;)
            jarloc = jar_loc()
            if not os.path.exists(jarloc):
                raise Exception(&#34;Could not find jar, {} does not exist&#34;.format(jarloc))
            cmdandparms = [java, &#34;-cp&#34;]
            cpsep = classpath_sep(platform=platform)
            cmdandparms.append(
                jarloc + cpsep + gate_classpath(self.gatehome, platform=platform)
            )
            cmdandparms.append(&#34;gate.tools.gatenlpworker.GatenlpWorker&#34;)
            cmdandparms.append(str(port))
            cmdandparms.append(host)
            if log_actions:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            if keep:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            os.environ[&#34;GATENLP_WORKER_TOKEN_&#34; + str(self.port)] = self._auth_token
            cmd = &#34; &#34;.join(cmdandparms)
            self.logger.debug(f&#34;Running command: {cmd}&#34;)
            subproc = subprocess.Popen(
                cmdandparms, stderr=subprocess.PIPE, bufsize=0, encoding=&#34;utf-8&#34;
            )
            self._gateprocess = subproc
            haveerror = False
            while True:
                # NOTE: the following line can block when the subprocess ends with an error
                line = subproc.stderr.readline()
                if line == &#34;&#34;:
                    break
                line = line.rstrip(&#34;\n\r&#34;)
                if line == &#34;PythonWorkerRunner.java: server start OK&#34;:
                    break
                if line == &#34;PythonWorkerRunner.java: server start NOT OK&#34;:
                    haveerror = True
                    # if we get an error we continue to loop through stderr until we get end of stream (line==&#34;&#34;)
                    # and only raise the exception after the loop.
                if line.startswith(&#34;Java GatenlpWorker ENDING&#34;):
                    break
                print(line, file=sys.stderr)
            if haveerror:
                raise Exception(&#34;Error when starting server&#34;)
            atexit.register(self.close)
        self._gateway = JavaGateway(
            gateway_parameters=GatewayParameters(port=port, auth_token=self._auth_token)
        )
        # do not wait until the gateway is used by the user to detect a problem, instead, retrieve the GATE
        # version here to check basic functionality
        _ = self.gate_version

    def __repr__(self):
        return f&#34;Gateworker(port={self.port},host={self.host},gate_home={self.gatehome})&#34;

    @property
    def jvm(self) -&gt; py4j.java_gateway.JVMView:
        &#34;&#34;&#34;
        Returns the JVM instance which allows to interact with Java.

        Returns:
            The JVMView instance

        &#34;&#34;&#34;
        return self.gateway.jvm

    @property
    def worker(self) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        A JavaObject which provides the methods on the Java side.

        Returns:
            The worker JavaObject

        &#34;&#34;&#34;
        return self.gateway.entry_point

    @property
    def gate_version(self) -&gt; str:
        &#34;&#34;&#34;
        Return the GATE version of the connected GATE process.
        &#34;&#34;&#34;
        return self.jvm.gate.Main.version

    @property
    def gate_build(self) -&gt; str:
        &#34;&#34;&#34;
        Return the GATE build id of the connected GATE process.
        &#34;&#34;&#34;
        return self.jvm.gate.Main.build

    @property
    def worker_version(self) -&gt; str:
        &#34;&#34;&#34;
        Return the Gate Worker version of the connected GATE process.
        &#34;&#34;&#34;
        return self.worker.pluginVersion()

    @property
    def worker_build(self) -&gt; str:
        &#34;&#34;&#34;
        Return the build id of the Worker of the connected GATE proces..
        &#34;&#34;&#34;
        return self.worker.pluginBuild()

    @property
    def gatehome(self) -&gt; str:
        &#34;&#34;&#34;
        Return the GATE home path of the connected GATE process as a string.
        &#34;&#34;&#34;
        return self._gatehome

    @property
    def port(self) -&gt; int:
        &#34;&#34;&#34;
        Return the port of the connected GATE process as an int.
        &#34;&#34;&#34;
        return self._port

    @property
    def host(self) -&gt; str:
        &#34;&#34;&#34;
        Return the host name or address of the connected GATE process as a str.
        &#34;&#34;&#34;
        return self._host

    @property
    def platform(self) -&gt; Optional[str]:
        return self._platform

    @property
    def gateprocess(self) -&gt; subprocess.Popen:
        &#34;&#34;&#34;
        Get the process.

        Returns:
            A subprocess.Popen object.
            See https://docs.python.org/3/library/subprocess.html#popen-objects for methods
            that can be used on this object.

        &#34;&#34;&#34;
        return self._gateprocess

    @property
    def getpid(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
        Get the process id (or None if no process).

        Returns:
            Process ID (int)

        &#34;&#34;&#34;
        proc = self.gateprocess
        if proc:
            return proc.pid

    @property
    def gateway(self) -&gt; py4j.java_gateway.JavaGateway:
        &#34;&#34;&#34;
        Return the py4j JavaGateway instance. This object provides the method
        help(jvm.some.object) for getting help about known Java objects.
        &#34;&#34;&#34;
        return self._gateway

    # @staticmethod
    # def download():
    #     &#34;&#34;&#34;
    #     Download GATE libraries into a standard location so we can run the GATE worker even if GATE_HOME
    #     is not set.
    #
    #     NOTE YET IMPLEMENTED.
    #     &#34;&#34;&#34;
    #     # TODO: this should use the command and bootstrapping jar in gate-downloader:
    #     # copy the whole directory into the standard per-user config directory for the system
    #     # run the command
    #     # use the generated gate.classpath as for a compiled local git repo
    #     # NOTE: should change error message if GATE_HOME is not set to hint at this!
    #     # (option --downlaod for the script)
    #     # NOTE: add to documentation
    #     raise Exception(&#34;Not yet implemented&#34;)

    def close(self):
        &#34;&#34;&#34;
        Clean up: if the gate worker process was started by us, we will shut it down.
        Otherwise we can still close it if it was started by the workerrunner, not the Lr
        Note: if it was started by us, it was started via the workerrunner.
        &#34;&#34;&#34;
        if not self._closed and self.worker.isClosable():
            self._closed = True
            self.gateway.shutdown()
            if self.gateprocess is not None:
                for line in self.gateprocess.stderr:
                    print(line, file=sys.stderr, end=&#34;&#34;)
                self.gateprocess.wait()

    def __enter__(self):
        return self

    def __exit__(self, _exptype, _value, _traceback):
        self.close()

    def log_actions(self, onoff: bool):
        &#34;&#34;&#34;
        Switch logging actions at the worker on or off.

        Args:
          onoff: True to log actions, False to not log them
        &#34;&#34;&#34;
        self.worker.logActions(onoff)

    def load_gdoc(self, path: str, mimetype: Optional[str] = None) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Let GATE load a document from the given path and return a handle to it.

        Args:
          path: path to the gate document to load.
          mimetype: a mimetype to use when loading. (Default value = None)

        Returns:
          a handle to the Java GATE document
        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        return self.worker.loadDocumentFromFile(path, mimetype)

    def save_gdoc(self,
                  gdoc: py4j.java_gateway.JavaObject,
                  path: str,
                  mimetype: Optional[str] = None,
                  inline_anntypes: Optional[List[str]] = None,
                  inline_annset: Optional[str] = &#34;&#34;,
                  inline_features: Optional[bool] = True):
        &#34;&#34;&#34;
        Save GATE document to the given path.

        Args:
          gdoc: GATE document handle
          path: destination path
          mimetype: mimtetype, only the following types are allowed: &#34;&#34;/None: GATE XML,
                application/fastinfoset, text/xml for inline XML, 
                and all mimetypes supported by the
                Format_Bdoc plugin. (Default value = None). 
          inline_anntypes: annotation types for inline XML export. Only works with mimetype xml.
                If None, all types in the inline_annset are exported, if a list, only the 
                types in the list are exported.
          inline_annset: annotation set for inline XML export.
          inline_features: save features as attribute for inline XML export.
        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        self.worker.saveDocumentToFile(gdoc, path, mimetype, self.panntype2ganntype(inline_anntypes), inline_annset, inline_features)

    def gdoc2pdoc(self, gdoc: py4j.java_gateway.JavaObject) -&gt; Document:
        &#34;&#34;&#34;
        Convert the GATE document to a python document and return it.

        Args:
          gdoc: the handle to a GATE document

        Returns:
          a gatenlp Document instance
        &#34;&#34;&#34;
        bjs = self.worker.getBdocJson(gdoc)
        return Document.load_mem(bjs, fmt=&#34;bdocjs&#34;)

    def pdoc2gdoc(self, pdoc: Document, annspec: Optional[List[Tuple]] = None) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Convert the Python gatenlp document to a GATE document and return a handle to it.

        Args:
            pdoc: python gatenlp Document
            annspec: a list of either set names, or tuples where the first element is a set name and the
                second element is either a type name or a list of type names.

        Returns:
            handle to GATE document
        &#34;&#34;&#34;
        jsondata = pdoc.save_mem(fmt=&#34;bdocjs&#34;, annspec=annspec)
        return self.worker.getDocument4BdocJson(jsondata)

    def gdocanns2pdoc(self, gdoc: py4j.java_gateway.JavaObject, pdoc: Document,
                      annspec: Optional[List[Tuple]] = None, replace: bool = False) -&gt; Document:
        &#34;&#34;&#34;
        Retrieve the annotations from the GATE document and add them to the python gatenlp document.
        This modifies the pdoc in place and returns it.

        Args:
            gdoc: a handle to a Java GATE document
            pdoc: Python gatenlp document
            annspec: if not None, an annotation specification: a list of set names or tuples where the first
                element is a set name and the second element is either a type name or a list of type names
            replace: if True, replaces all annotations with the same set and annotation id, otherwise adds
                annotaitons with potentially a new annotation id.

        Returns:
            the modified pdoc
        &#34;&#34;&#34;
        # to make it easier on the Java side to interpret the annotation specification, convert it so that
        # all elements are a list where first element is always the set name and all remaining elements
        # are tyepe names. If there is one remaining element which is null, include all types for that set.
        newannspec = self.pannspec2gannspec(annspec)
        # now retrieve the BDOC JSON representation of the annotations
        thejson = self.jsonAnnsets4Doc(gdoc, newannspec)
        dictrep = json.loads(thejson)
        for name, adict in dictrep.items():
            annset = AnnotationSet.from_dict(adict, owner_doc=None)
            targetset = pdoc.annset(name)
            # add the annotations in annset to the pdoc, depending on replace
            for ann in annset._annotations.values():
                # if the annotation id already exists in the target set, proceed according to replace,
                # if not, just add it as is
                if ann.id in targetset._annotations:
                    if replace:
                        # for now, the simplified version: remove existing add new
                        targetset.remove(ann.id)
                        targetset.add_ann(ann, annid=ann.id)
                    else:
                        targetset.add_ann(ann)
                else:
                    targetset.add_ann(ann)
        return pdoc

    def load_pdoc(self, path: str, mimetype: Optional[str] = None) -&gt; Document:
        &#34;&#34;&#34;
        Load a document from the given path, using GATE and convert and return as gatenlp Python document.

        Args:
          path: path to load document from
          mimetype: mime type to use (Default value = None)

        Returns:
          gatenlp document
        &#34;&#34;&#34;
        gdoc = self.load_gdoc(path, mimetype)
        return self.gdoc2pdoc(gdoc)

    def del_resource(self, resource: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        DEPRECATED: please use deleteResource(resource) instead!

        Delete/unload a GATE resource (Document, Corpus, ProcessingResource etc) from GATE.

        Args:
          resource: the Java GATE resource, e.g. a document to remove
        &#34;&#34;&#34;
        self.jvm.gate.Factory.deleteResource(resource)

    def show_gui(self):
        &#34;&#34;&#34;
        Show the GUI for the started GATE process.

        NOTE: this is more of a hack and may cause sync problems
        when closing down the GATE worker.
        &#34;&#34;&#34;
        self.worker.showGui()

    # methods that mirror the methods from the Java gate.plugin.python.PythonWorker methods
    # These could get called directly via gs.worker.METHODNAME calls but are implemented here
    # to provide easier discovery and better documentation on the Python side
    # Since these are really local mirrors of Java methods, they follow Java naming conventions
    def createDocument(self, content: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Create a Java GATE document from the content string and return a handle to it.

        Args:
            content: the text of the document

        Returns:
            handle to Java GATE document
        &#34;&#34;&#34;
        return self.worker.createDocument(content)

    def deleteResource(self, resource: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        Delete/unload a Java GATE resource (Document, Corpus, ProcessingResource etc) from GATE.
        This is particularly important to do when processing a large number of documents for each document
        that is finished processing, otherwise the documents
        will accumulate in the Java process and eat up all memory. NOTE: just removing all references to a
        GATE document does not delete/unload the document!

        Args:
            resource: a handle to some Java GATE resource
        &#34;&#34;&#34;
        self.worker.deleteResource(resource)

    def findMavenPlugin(self, group: str, artifact: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Find a Java GATE Maven plugin and return a handle to it, or None if nothing found.

        Args:
            group: the Maven group for the plugin
            artifact: the artifact name for the plugin

        Returns:
            a handle to the plugin or None if not found
        &#34;&#34;&#34;
        return self.worker.findMavenPlugin(group, artifact)

    def getBdocJson(self, gdoc: py4j.java_gateway.JavaObject) -&gt; str:
        &#34;&#34;&#34;
        Return the Bdoc JSON serialization of a Java GATE document as string.

        Args:
            gdoc: a handle to a GATE document

        Returns:
            BDOC serialization JSON string
        &#34;&#34;&#34;
        return self.worker.getBdocJson(gdoc)

    def getCorpus4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Return a handle to the first Java GATE corpus with the given name or None if none found.

        Args:
            name: corpus name

        Returns:
            first matching corpus or None
        &#34;&#34;&#34;
        return self.worker.getCorpus4Name(name)

    def getCorpusNames(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Return a list of all Java GATE corpus names known.

        Returns:
            list of corpus names
        &#34;&#34;&#34;
        return self.worker.getCorpusNames()

    def getDocument4BdocJson(self, bdocjson: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Returns a handle to a Java GATE document created from the Bdoc JSON string.

        Args:
            bdocjson: a BDOC JSON string

        Returns:
            handle to the Java GATE document
        &#34;&#34;&#34;
        return self.worker.getDocument4BdocJson(bdocjson)

    def getDocument4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Return a handle to the first Java GATE document that has the given name or None if none found.

        Args:
            name: the document name

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.worker.getDocument4Name(name)

    def getDocumentNames(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Return a list of known Java GATE document names.

        Returns:
            list of Java GATE document names
        &#34;&#34;&#34;
        return self.worker.getDocumentNames()

    def getPipeline4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Return a handle to the first Java GATE pipeline/controller that has the given name or
        None if none found.

        Args:
            name: name of the pipeline

        Returns:
            handle to the pipeline
        &#34;&#34;&#34;
        return self.worker.getPipeline4Name(name)

    def getPipelineNames(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Return a list of all know Java GATE pipeline names.

        Returns:
            list of pipeline names
        &#34;&#34;&#34;
        return self.worker.getPipelineNames()

    def getPr4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Return a handle to the first Java GATE processing resource that has the given name
        or None if none found.

        Args:
            name: the name of the processing resource

        Returns:
            a handle to the processing resource or None
        &#34;&#34;&#34;
        return self.worker.getPr4Name(name)

    def getPrNames(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Return a list of known Java GATE  processing resource names.

        Returns:
            list of PR names
        &#34;&#34;&#34;
        return self.worker.getPrNames()

    def getResources4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Return a (possibly empty) list of all Java GATE resources with the given name.

        Args:
            name: name of the resources

        Returns:
            list of matching resources
        &#34;&#34;&#34;
        return self.worker.getResources4Name(name)

    def getResources4NameClass(self, name: str, clazz: str) -&gt; List[py4j.java_gateway.JavaObject]:
        &#34;&#34;&#34;
        Return a (possibly empty) list of all Java GATE resources with the given name and class name.

        Args:
            name: name of the resources
            clazz: the name of the java class the resource must be an instance of

        Returns:
            list of matching resources
        &#34;&#34;&#34;
        return self.worker.getResources4Name(name, clazz)

    def loadDocumentFromFile(self, filename: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Load a Java GATE document from the given file name and return a handle to it.

        Args:
            filename: the file name/path of the Java GATE document to load.

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.worker.loadDocumentFromFile(filename)

    def loadDocumentFromFile4Mime(self, filename: str, mimetype: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Load a Java GATE document from the given file name, using the given mime type
        and return a handle to it.

        Args:
            filename: the file name/path of the Java GATE document to load.
            mimetype: the mimetype to use

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.worker.loadDocumentFromFile(filename, mimetype)

    def loadMavenPlugin(self, group: str, artifact: str, version: str):
        &#34;&#34;&#34;
        Load the given Maven plugin into Java GATE.

        Args:
            group: group id of the plugin
            artifact:  artifact id of the plugin
            version: version of the plugin
        &#34;&#34;&#34;
        self.worker.loadMavenPlugin(group, artifact, version)

    def loadPipelineFromFile(self, filename: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Load a pipeline/controller from the given file into Java GATE and return a CorpusController handle to it.

        Args:
            filename: the filename/path of the pipeline file

        Returns:
            a CorpusController handle to the loaded Java GATE pipeline
        &#34;&#34;&#34;
        return self.worker.loadPipelineFromFile(filename)

    def loadPipelineFromUri(self, uri: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Load a pipeline/controller from the given uri into Java GATE and return a CorpusController handle to it.

        Args:
            uri: the uri of the pipeline file

        Returns:
            a CorpusController handle to the loaded Java GATE pipeline
        &#34;&#34;&#34;
        return self.worker.loadPipelineFromUri(uri)

    def loadPipelineFromPlugin(self, group: str, artifact: str, path: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Load a prepared pipeline from the given loaded GATE Mave plugin into Java GATE and return
        a CorpusController handle to it.

        Args:
            group: maven group id the plugin
            artifact: artifact id of the plugin
            path: path of the pipeline in the JAR

        Returns:
            a CorpusController handle to the pipeline
        &#34;&#34;&#34;
        return self.worker.loadPipelineFromPlugin(group, artifact, path)

    def logActions(self, flag: bool):
        &#34;&#34;&#34;
        Enable/disable logging of actions carried out on the Java GATE side to the Java GATE logger.

        Args:
            flag: True to enable logging of actions
        &#34;&#34;&#34;
        self.worker.logActions(flag)

    def newCorpus(self) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Create and return a handle to a new Java GATE corpus.

        Returns:
            handle to the Java GATE corpus
        &#34;&#34;&#34;
        return self.worker.newCorpus()

    def pluginBuild(self) -&gt; str:
        &#34;&#34;&#34;
        Return the short commit id of the Python plugin on the Java GATE side.

        Returns:
            commit id of Python plugin
        &#34;&#34;&#34;
        return self.worker.pluginBuild()

    def pluginVersion(self) -&gt; str:
        &#34;&#34;&#34;
        Return the version string of the Python plugin on the Java GATE side.

        Returns:
            version string of Python plugin
        &#34;&#34;&#34;
        return self.worker.pluginVersion()

    def print2err(self, message: str):
        &#34;&#34;&#34;
        Output the given message to System.err on the Java GATE side.

        Args:
            message: string to output
        &#34;&#34;&#34;
        self.worker.print2err(message)

    def print2out(self, message: str):
        &#34;&#34;&#34;
        Output the given message to System.out on the Java GATE side.

        Args:
            message: string to output
        &#34;&#34;&#34;
        self.worker.print2out(message)

    def run4Corpus(self, pipeline: py4j.java_gateway.JavaObject, corpus: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        Run the given Java GATE pipeline on the given Java GATE corpus.

        Args:
            pipeline: handle to a Java GATE pipeline
            corpus: handle to a Java GATE corpus
        &#34;&#34;&#34;
        self.worker.run4Corpus(pipeline, corpus)

    def run4Document(self, pipeline: py4j.java_gateway.JavaObject, gdoc: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        Run the given Java GATE pipeline on the given Java GATE document.

        Args:
            pipeline: handle to a Java GATE pipeline
            gdoc: handle to a Java GATE document
        &#34;&#34;&#34;
        self.worker.run4Document(pipeline, gdoc)

    def runExcecutionFinished(self, pipeline: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        Run the execution finished method for the given Java GATE pipeline.

        Args:
            pipeline: handle to a Java GATE pipeline
        &#34;&#34;&#34;
        self.worker.runExecutionFinished(pipeline)

    def runExcecutionStarted(self, pipeline: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        Run the execution started method for the given Java GATE pipeline.

        Args:
            pipeline: handle to a Java GATE pipeline
        &#34;&#34;&#34;
        self.worker.runExecutionStarted(pipeline)

    def saveDocumentToFile(self,
                           gdoc: py4j.java_gateway.JavaObject,
                           filename: str,
                           mimetype: str=&#34;&#34;,
                           inline_anntypes: Optional[List[str]]=None,
                           inline_annset: str=&#34;&#34;,
                           inline_features: bool=True):
        &#34;&#34;&#34;
        Save the Java GATE document to the given file, using the given mime type.
        At the moment this supports the GATE XML format (mimetype=&#34;&#34;) as well as
        formats supported by the FastInfoset  FormatBdoc plugins.

        Args:
            gdoc: handle to Java GATE document
            filename: name/path of the file to save to
            mimetype: the mime type to determine the format, &#34;&#34; for GATE XML, text/xml for GATE inline XML
            inline_anntypes: annotation types for inline XML export.
            inline_annset: annotation set name.
            inline_features: save features as attributes.
        &#34;&#34;&#34;
        self.worker.saveDocumentToFile(gdoc, filename, mimetype, self.panntype2ganntype(inline_anntypes), inline_annset, inline_features)

    def pannspec2gannspec(self,
                          annspec: Union[str, List[Union[str, Tuple]]]=None) -&gt; Optional[py4j.java_gateway.JavaObject]:
        &#34;&#34;&#34;
        Convert from our convention to specifiy annotation sets and types to a Java list.
        This is necessary because py4j does not by default convert lists properly and also
        because our Java representation of the annspec specification has a different structure.
        The list returned from this is already a Java list!

        Args:
            annspec: annotation specification to convert

        Returns:
            java representation of the annotation specification (or None)
        &#34;&#34;&#34;
        if annspec is None:
            return None
        # annspec is a python collection and cannot be passed directly to Java
        # see https://www.py4j.org/advanced_topics.html#collections-conversion
        from py4j.java_collections import ListConverter
        if isinstance(annspec, str):
            annspec = [annspec]
        newannspec = []
        for spec in annspec:
            if isinstance(spec, str):
                plist = [spec, None]
            else:
                setname, types = spec
                if isinstance(types, str):
                    plist = [setname, types]
                else:
                    # types must be a list:
                    plist = [setname]
                    plist.extend(types)
            jlist = ListConverter().convert(plist, self.gateway._gateway_client)
            newannspec.append(jlist)
        jnewannspec = ListConverter().convert(newannspec, self.gateway._gateway_client)
        return jnewannspec

    def panntype2ganntype(self, inline_anntypes: List[str]) -&gt; Optional[py4j.java_gateway.JavaObject]:
        &#34;&#34;&#34;
        Convert annotations types string list to a Java list.
        &#34;&#34;&#34;
        if inline_anntypes is None:
            return None
        # annspec is a python collection and cannot be passed directly to Java
        # see https://www.py4j.org/advanced_topics.html#collections-conversion
        from py4j.java_collections import ListConverter
        return ListConverter().convert(inline_anntypes, self.gateway._gateway_client)

    def jsonAnnsets4Doc(self,
                        gdoc: py4j.java_gateway.JavaObject,
                        jannspec: py4j.java_gateway.JavaObject) -&gt; str:
        &#34;&#34;&#34;
        Return the JSON representation of the annotation sets in the GATE document, optionally
        filtered by the given annotation specification.

        The jannspec specification should have the format as expected on the Java side: a list
        of lists of string. Each inner list has the set name to include as the first element
        and either null as the second element to include all types, or the types to include
        as the 2nd and subsequent elements.

        The method pannspec2gannspec(annspec) can be used to convert from our standard annotation
        specification to the Java annotation specification.

        Args:
            gdoc: handle to Java GATE document
            jannspec: the annotation specification list as a Java list

        Returns:
            JSON string
        &#34;&#34;&#34;
        return self.worker.jsonAnnsets4Doc(gdoc, jannspec)

    def showGui(self):
        &#34;&#34;&#34;
        (CAUTION: EXPERIMENTAL) this shows the GATE GUI if we a re connected to a GATE process that runs without
        showing the GUI.
        &#34;&#34;&#34;
        self.worker.showGui()


def run_gate_worker():   # pragma: no cover
    &#34;&#34;&#34;
    Start a GATE worker from the command line.

    This is available as command `gatenlp-gate-worker`.
    Use option `--help` to get help about command line arguments.
    &#34;&#34;&#34;
    argparser = argparse.ArgumentParser(description=&#34;Start Java GATE Worker&#34;)
    argparser.add_argument(
        &#34;--download&#34;,
        action=&#34;store_true&#34;,
        help=&#34;Download GATE libraries to run GATE worker&#34;,
    )
    argparser.add_argument(&#34;--port&#34;, default=25333, type=int, help=&#34;Port (25333)&#34;)
    argparser.add_argument(
        &#34;--host&#34;, default=&#34;127.0.0.1&#34;, type=str, help=&#34;Host to bind to (127.0.0.1)&#34;
    )
    argparser.add_argument(
        &#34;--auth&#34;, default=None, type=str, help=&#34;Auth token to use (generate random)&#34;
    )
    argparser.add_argument(&#34;--noauth&#34;, action=&#34;store_true&#34;, help=&#34;Do not use auth token&#34;)
    argparser.add_argument(
        &#34;--gatehome&#34;,
        default=None,
        type=str,
        help=&#34;Location of GATE (environment variable GATE_HOME)&#34;,
    )
    argparser.add_argument(
        &#34;--platform&#34;,
        default=None,
        type=str,
        help=&#34;OS/Platform: windows or linux (autodetect)&#34;,
    )
    argparser.add_argument(
        &#34;--log_actions&#34;, action=&#34;store_true&#34;, help=&#34;If worker actions should be logged&#34;
    )
    argparser.add_argument(
        &#34;--keep&#34;, action=&#34;store_true&#34;, help=&#34;Prevent shutting down the worker&#34;
    )
    argparser.add_argument(&#34;--debug&#34;, action=&#34;store_true&#34;, help=&#34;Show debug messages&#34;)
    args = argparser.parse_args()
    if args.download:
        raise Exception(&#34;--download not implemented yet &#34;)
    #subprocess =
    start_gate_worker(
        port=args.port,
        host=args.host,
        auth_token=args.auth,
        use_auth_token=not args.noauth,
        gatehome=args.gatehome,
        platform=args.platform,
        log_actions=args.log_actions,
        keep=args.keep,
        debug=args.debug,
    )
    #logger.info(f&#34;Running with PID {subprocess.pid}&#34;)


if __name__ == &#34;__main__&#34;:   # pragma: no cover
    run_gate_worker()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gatenlp.gateworker.gateworker.check_port_used"><code class="name flex">
<span>def <span class="ident">check_port_used</span></span>(<span>host:str, port:int) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the given port on the given host is in use.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_port_used(host: str, port: int) -&gt; bool:
    &#34;&#34;&#34;
    Check if the given port on the given host is in use.
    &#34;&#34;&#34;
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn = sock.connect_ex((host, port))
    used = False
    if conn == 0:
        used = True
    sock.close()
    return used</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.classpath_sep"><code class="name flex">
<span>def <span class="ident">classpath_sep</span></span>(<span>platform:Optional[str]=None) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the system-specific classpath separator character.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>platform</code></strong></dt>
<dd>(Default value = None) "win" or "windows" for Windows, anything else for non-windows
If not specified, tries to determine automatically (which may fail)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>classpath separator character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def classpath_sep(platform: Optional[str] = None) -&gt; str:  # pragma: no cover
    &#34;&#34;&#34;
    Get the system-specific classpath separator character.

    Args:
      platform:  (Default value = None) &#34;win&#34; or &#34;windows&#34; for Windows, anything else for non-windows
        If not specified, tries to determine automatically (which may fail)

    Returns:
      classpath separator character

    &#34;&#34;&#34;
    if not platform:
        myplatform = sysplatform.system()
        if not myplatform:
            raise Exception(
                &#34;Could not determine operating system, please use platform parameter&#34;
            )
        platform = myplatform
    if platform.lower() == &#34;windows&#34; or platform.lower() == &#34;win&#34;:
        return &#34;;&#34;
    else:
        return &#34;:&#34;</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.gate_classpath"><code class="name flex">
<span>def <span class="ident">gate_classpath</span></span>(<span>gatehome:str, platform:Optional[str]=None) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the GATE classpath components as a string, with the path seperator characters appropriate
for the operating system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gatehome</code></strong></dt>
<dd>path where GATE is installed, either as a cloned git repo or a downloaded installation dir.</dd>
<dt><strong><code>platform</code></strong></dt>
<dd>(Default value = None) "win" or "windows" for Windows, anything else for non-Windows.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>GATE classpath</p>
<h2 id="raises">Raises</h2>
<p>Exception if classpath could not be determined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gate_classpath(gatehome: str, platform: Optional[str] = None) -&gt; str:  # pragma: no cover
    &#34;&#34;&#34;
    Return the GATE classpath components as a string, with the path seperator characters appropriate
    for the operating system.

    Args:
      gatehome: path where GATE is installed, either as a cloned git repo or a downloaded installation dir.
      platform:  (Default value = None) &#34;win&#34; or &#34;windows&#34; for Windows, anything else for non-Windows.

    Returns:
      GATE classpath

    Raises:
        Exception if classpath could not be determined.

    &#34;&#34;&#34;
    # check which kind of GATE home we have: if there is a distro subdirectory, assume cloned git repo
    if not os.path.exists(gatehome):
        raise Exception(&#34;GATE home directory does not exist: {}&#34;.format(gatehome))
    if not os.path.isdir(gatehome):
        raise Exception(&#34;GATE home directory does not a directory: {}&#34;.format(gatehome))
    cpsep = classpath_sep(platform)
    cpfile = os.path.join(gatehome, &#34;gate.classpath&#34;)
    bindir = os.path.join(gatehome, &#34;bin&#34;)
    # logger.info(&#34;DEBUG checking for {}&#34;.format(cpfile))
    if os.path.exists(cpfile):
        if not os.path.exists(cpfile):
            raise Exception(
                &#34;File not found {}, distribution may need compiling&#34;.format(cpfile)
            )
        with open(cpfile, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
            c_p = infp.read()
            return c_p + cpsep + bindir
    else:
        # logger.info(&#34;DEBUG {} does not exist&#34;.format(cpfile))
        libdir = os.path.join(gatehome, &#34;lib&#34;)
        bindir = os.path.join(gatehome, &#34;bin&#34;)
        if not os.path.isdir(libdir):
            raise Exception(
                &#34;Could not determine class path from {}, no lib directory&#34;.format(
                    gatehome
                )
            )
        jars = glob.glob(os.path.join(libdir, &#34;*.jar&#34;))
        libcp = cpsep.join(jars)

        return libcp + cpsep + bindir</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.jar_loc"><code class="name flex">
<span>def <span class="ident">jar_loc</span></span>(<span>) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the path to the gate worker jar as a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jar_loc() -&gt; str:
    &#34;&#34;&#34;Return the path to the gate worker jar as a string.&#34;&#34;&#34;
    return str(pathlib.Path(__file__).parent.parent.
               joinpath(&#34;_jars&#34;).joinpath(f&#34;gatetools-gatenlpworker-{JARVERSION}.jar&#34;))</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.run_gate_worker"><code class="name flex">
<span>def <span class="ident">run_gate_worker</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a GATE worker from the command line.</p>
<p>This is available as command <code>gatenlp-gate-worker</code>.
Use option <code>--help</code> to get help about command line arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_gate_worker():   # pragma: no cover
    &#34;&#34;&#34;
    Start a GATE worker from the command line.

    This is available as command `gatenlp-gate-worker`.
    Use option `--help` to get help about command line arguments.
    &#34;&#34;&#34;
    argparser = argparse.ArgumentParser(description=&#34;Start Java GATE Worker&#34;)
    argparser.add_argument(
        &#34;--download&#34;,
        action=&#34;store_true&#34;,
        help=&#34;Download GATE libraries to run GATE worker&#34;,
    )
    argparser.add_argument(&#34;--port&#34;, default=25333, type=int, help=&#34;Port (25333)&#34;)
    argparser.add_argument(
        &#34;--host&#34;, default=&#34;127.0.0.1&#34;, type=str, help=&#34;Host to bind to (127.0.0.1)&#34;
    )
    argparser.add_argument(
        &#34;--auth&#34;, default=None, type=str, help=&#34;Auth token to use (generate random)&#34;
    )
    argparser.add_argument(&#34;--noauth&#34;, action=&#34;store_true&#34;, help=&#34;Do not use auth token&#34;)
    argparser.add_argument(
        &#34;--gatehome&#34;,
        default=None,
        type=str,
        help=&#34;Location of GATE (environment variable GATE_HOME)&#34;,
    )
    argparser.add_argument(
        &#34;--platform&#34;,
        default=None,
        type=str,
        help=&#34;OS/Platform: windows or linux (autodetect)&#34;,
    )
    argparser.add_argument(
        &#34;--log_actions&#34;, action=&#34;store_true&#34;, help=&#34;If worker actions should be logged&#34;
    )
    argparser.add_argument(
        &#34;--keep&#34;, action=&#34;store_true&#34;, help=&#34;Prevent shutting down the worker&#34;
    )
    argparser.add_argument(&#34;--debug&#34;, action=&#34;store_true&#34;, help=&#34;Show debug messages&#34;)
    args = argparser.parse_args()
    if args.download:
        raise Exception(&#34;--download not implemented yet &#34;)
    #subprocess =
    start_gate_worker(
        port=args.port,
        host=args.host,
        auth_token=args.auth,
        use_auth_token=not args.noauth,
        gatehome=args.gatehome,
        platform=args.platform,
        log_actions=args.log_actions,
        keep=args.keep,
        debug=args.debug,
    )</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.start_gate_worker"><code class="name flex">
<span>def <span class="ident">start_gate_worker</span></span>(<span>port:int=25333, host:str='127.0.0.1', auth_token:Optional[str]=None, use_auth_token:bool=True, java:str='java', platform:Optional[str]=None, gatehome:Optional[str]=None, log_actions:bool=False, keep:bool=False, debug:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the gate worker program. This starts the Java program included with gatenlp to
run GATE and execute the gate worker within GATE so that Python can connect to it.</p>
<p>This methods waits for the subprocess to end.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>port</code></strong></dt>
<dd>(Default value = 25333) Port number to use</dd>
<dt><strong><code>host</code></strong></dt>
<dd>(Default value = "127.0.0.1") Host address to bind to</dd>
<dt><strong><code>auth_token</code></strong></dt>
<dd>(Default value = None)
Authorization token to use. If None, creates a random token.</dd>
<dt><strong><code>use_auth_token</code></strong></dt>
<dd>(Default value = True) If False, do not aue an authorization token at all.
This allows anyone who can connect to the host address to connect and use the gate worker process.</dd>
<dt><strong><code>java</code></strong></dt>
<dd>(Default value = "java") Java command (if on the binary path) or full path to the binary
to use for running the gate worker program.</dd>
<dt><strong><code>platform</code></strong></dt>
<dd>(Default value = None) "win" or "windows" for Windows, anything else for non-Windows.
If None, tries to determine automatically.</dd>
<dt><strong><code>gatehome</code></strong></dt>
<dd>(Default value = None) The path to where GATE is installed. If None, the environment
variable "GATE_HOME" is used.</dd>
<dt><strong><code>log_actions</code></strong></dt>
<dd>(Default value = False) If True, the GATE Worker process will log everything it is
ordered to do.</dd>
<dt><strong><code>keep</code></strong></dt>
<dd>(Default value = False) passed on to the gate worker process and tells the process if it should
report to the using Python process that it can be closed or not.</dd>
<dt><strong><code>debug</code></strong></dt>
<dd>(Default valuye = False) Show debug messages.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_gate_worker(
        port: int = 25333,
        host: str = &#34;127.0.0.1&#34;,
        auth_token: Optional[str] = None,
        use_auth_token: bool = True,
        java: str = &#34;java&#34;,
        platform: Optional[str] = None,
        gatehome: Optional[str] = None,
        log_actions: bool = False,
        keep: bool = False,
        debug: bool = False,
):   # pragma: no cover
    &#34;&#34;&#34;
    Run the gate worker program. This starts the Java program included with gatenlp to
    run GATE and execute the gate worker within GATE so that Python can connect to it.

    This methods waits for the subprocess to end.

    Args:
        port:  (Default value = 25333) Port number to use
        host:  (Default value = &#34;127.0.0.1&#34;) Host address to bind to
        auth_token:  (Default value = None)  Authorization token to use. If None, creates a random token.
        use_auth_token:  (Default value = True) If False, do not aue an authorization token at all.
           This allows anyone who can connect to the host address to connect and use the gate worker process.
        java:  (Default value = &#34;java&#34;) Java command (if on the binary path) or full path to the binary
           to use for running the gate worker program.
        platform:  (Default value = None) &#34;win&#34; or &#34;windows&#34; for Windows, anything else for non-Windows.
           If None, tries to determine automatically.
        gatehome:  (Default value = None) The path to where GATE is installed. If None, the environment
           variable &#34;GATE_HOME&#34; is used.
        log_actions:  (Default value = False) If True, the GATE Worker process will log everything it is
           ordered to do.
        keep:  (Default value = False) passed on to the gate worker process and tells the process if it should
           report to the using Python process that it can be closed or not.
        debug: (Default valuye = False) Show debug messages.
    &#34;&#34;&#34;
    logger = init_logger(__name__)
    if debug:
        logger.setLevel(logging.DEBUG)

    if gatehome is None:
        gatehome = os.environ.get(&#34;GATE_HOME&#34;)
        if gatehome is None:
            raise Exception(
                &#34;Parameter gatehome is None and environment var GATE_HOME not set&#34;
            )
    if use_auth_token:
        if not auth_token:
            auth_token = secrets.token_urlsafe(20)
    else:
        auth_token = &#34;&#34;
    if log_actions:
        log_actions = &#34;1&#34;
    else:
        log_actions = &#34;0&#34;
    if keep:
        keep = &#34;1&#34;
    else:
        keep = &#34;0&#34;
    logger.debug(
        f&#34;Starting gate worker, gatehome={gatehome}, auth_token={auth_token}, log_actions={log_actions}, keep={keep}&#34;
    )
    jarloc = jar_loc()
    if not os.path.exists(jarloc):
        raise Exception(&#34;Could not find jar, {} does not exist&#34;.format(jarloc))
    logger.debug(f&#34;Using JAR: {jarloc}&#34;)
    cmdandparms = [java, &#34;-cp&#34;]
    cpsep = classpath_sep(platform=platform)
    cmdandparms.append(jarloc + cpsep + gate_classpath(gatehome, platform=platform))
    cmdandparms.append(&#34;gate.tools.gatenlpworker.GatenlpWorker&#34;)
    cmdandparms.append(str(port))
    cmdandparms.append(host)
    cmdandparms.append(log_actions)
    cmdandparms.append(keep)
    os.environ[&#34;GATENLP_WORKER_TOKEN_&#34; + str(port)] = auth_token
    cmd = &#34; &#34;.join(cmdandparms)
    logger.debug(f&#34;Running command: {cmd}&#34;)
    subproc = subprocess.Popen(
        cmdandparms, stderr=subprocess.PIPE, bufsize=0, encoding=&#34;utf-8&#34;
    )
    logger.info(f&#34;Running as process with PID {subproc.pid}&#34;)

    def shutdown():
        &#34;&#34;&#34;
        Handler that gets invoked when the calling Python program exits.
        This terminates the gate worker by sending the SIGINT signal to it.
        &#34;&#34;&#34;
        subproc.send_signal(signal.SIGINT)
        for line in subproc.stderr:
            print(line, file=sys.stderr, end=&#34;&#34;)

    atexit.register(shutdown)
    while True:
        line = subproc.stderr.readline()
        if line == &#34;&#34;:
            break
        line = line.rstrip(&#34;\n\r&#34;)
        if line == &#34;PythonWorkerRunner.java: server start OK&#34;:
            break
        if line == &#34;PythonWorkerRunner.java: server start NOT OK&#34;:
            raise Exception(&#34;Could not start server, giving up&#34;)
        print(line, file=sys.stderr)
    try:
        subproc.wait()
    except KeyboardInterrupt:
        print(&#34;Received keyboard interrupt, shutting down server...&#34;)
        shutdown()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.gateworker.gateworker.GateWorker"><code class="flex name class">
<span>class <span class="ident">GateWorker</span></span>
<span>(</span><span>port:int=25333, retry_ports:int=10, start:bool=True, java:str='java', host:str='127.0.0.1', gatehome:Optional[str]=None, platform:Optional[str]=None, auth_token:Optional[str]=None, use_auth_token:bool=True, log_actions:bool=False, keep:bool=False, debug:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gate worker for remotely running arbitrary GATE and other JAVA operations in a separate
Java GATE process.</p>
<p>Create an instance of the GateWorker and either start our own Java GATE process for it to use
(start=True) or connect to an existing one (start=False).</p>
<p>After the GateWorker instance has been create successfully, it is possible to:</p>
<ul>
<li>
<p>Use one of the methods of the instance to perform operations on the Java side or exchange data</p>
</li>
<li>
<p>use GateWorker.worker to invoke methods from the PythonWorker class on the Java side (but for most of these
method there is a shortcut implementation directly on GateWorker which should be preferred!)</p>
</li>
<li>
<p>use GateWorker.jvm to directly construct objects or call instance or static methods</p>
</li>
</ul>
<p>NOTE: the GATE process must not output anything important/big to stderr because everything from
stderr gets captured and used for communication between the Java and Python processes. At least
part of the output to stderr may only be passed on after the GATE process has ended.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">gw = GateWorker()
pipeline = gw.loadPipelineFromFile(&quot;thePipeline.xgapp&quot;)
doc = gw.createDocument(&quot;Some document text&quot;)
gw.worker.run4Document(pipeline,doc)
pdoc = gw.gdoc2pdoc(doc)
gw.deleteResource(doc)
# process the document pdoc ...
</code></pre>
<p>port: port to use
retry_ports: if start=True and the specified port is in use, try this many
additional ports before giving up (default: 10) Note: this uses a simple implementation which checks
in advance if the port is in use; this strategy may fail in cases where a port that was found to be
free is getting used in the short time between the check and the actual use by the gate worker.
start: if True, try to start our own GATE process, otherwise expect an already started
process at the host/port address
java: path to the java binary to run or the java command to use from the PATH (for start=True)
host: host an existing Java GATE process is running on (only relevant for start=False)
gatehome: where GATE is installed (only relevant if start=True). If None, expects
environment variable GATE_HOME to be set.
platform: system platform we run on, one of Windows, Linux (also for MacOs) or Java
auth_token: if None or "" and use_auth_token is True, generate a random token which
is then accessible via the auth_token attribute, otherwise use the given auth token.
use_auth_token: if False, do not use an auth token, otherwise either use the one specified
via auth_token or generate a random one.
log_actions: if the gate worker should log the actions it is doing
keep: normally if gs.close() is called and we are not connected to the PythonWorkerLr,
the worker will be shut down. If this is True, the gs.close() method does not shut down
the worker.
debug: show debug messages (default: False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GateWorker:
    &#34;&#34;&#34;
    Gate worker for remotely running arbitrary GATE and other JAVA operations in a separate
    Java GATE process.
    &#34;&#34;&#34;

    def __init__(
            self,
            port: int = 25333,
            retry_ports: int = 10,
            start: bool = True,
            java: str = &#34;java&#34;,
            host: str = &#34;127.0.0.1&#34;,
            gatehome: Optional[str] = None,
            platform: Optional[str] = None,
            auth_token: Optional[str] = None,
            use_auth_token: bool = True,
            log_actions: bool = False,
            keep: bool = False,
            debug: bool = False,
            ):
        &#34;&#34;&#34;
        Create an instance of the GateWorker and either start our own Java GATE process for it to use
        (start=True) or connect to an existing one (start=False).

        After the GateWorker instance has been create successfully, it is possible to:

        * Use one of the methods of the instance to perform operations on the Java side or exchange data

        * use GateWorker.worker to invoke methods from the PythonWorker class on the Java side (but for most of these
          method there is a shortcut implementation directly on GateWorker which should be preferred!)

        * use GateWorker.jvm to directly construct objects or call instance or static methods

        NOTE: the GATE process must not output anything important/big to stderr because everything from
        stderr gets captured and used for communication between the Java and Python processes. At least
        part of the output to stderr may only be passed on after the GATE process has ended.

        Example:

            ```python
            gw = GateWorker()
            pipeline = gw.loadPipelineFromFile(&#34;thePipeline.xgapp&#34;)
            doc = gw.createDocument(&#34;Some document text&#34;)
            gw.worker.run4Document(pipeline,doc)
            pdoc = gw.gdoc2pdoc(doc)
            gw.deleteResource(doc)
            # process the document pdoc ...
            ```

        port: port to use
        retry_ports: if start=True and the specified port is in use, try this many
            additional ports before giving up (default: 10) Note: this uses a simple implementation which checks
            in advance if the port is in use; this strategy may fail in cases where a port that was found to be
            free is getting used in the short time between the check and the actual use by the gate worker.
        start: if True, try to start our own GATE process, otherwise expect an already started
            process at the host/port address
        java: path to the java binary to run or the java command to use from the PATH (for start=True)
        host: host an existing Java GATE process is running on (only relevant for start=False)
        gatehome: where GATE is installed (only relevant if start=True). If None, expects
            environment variable GATE_HOME to be set.
        platform: system platform we run on, one of Windows, Linux (also for MacOs) or Java
        auth_token: if None or &#34;&#34; and use_auth_token is True, generate a random token which
            is then accessible via the auth_token attribute, otherwise use the given auth token.
        use_auth_token: if False, do not use an auth token, otherwise either use the one specified
            via auth_token or generate a random one.
        log_actions: if the gate worker should log the actions it is doing
        keep: normally if gs.close() is called and we are not connected to the PythonWorkerLr,
            the worker will be shut down. If this is True, the gs.close() method does not shut down
            the worker.
        debug: show debug messages (default: False)
        &#34;&#34;&#34;
        if debug:
            self.logger = init_logger(&#34;GateWorker&#34;, lvl=&#34;DEBUG&#34;)
        else:
            self.logger = init_logger(&#34;GateWorker&#34;)

        from py4j.java_gateway import JavaGateway, GatewayParameters

        self._gatehome = gatehome
        self._port = port
        self._host = host
        self._platform = platform
        self._gateprocess = None
        self._gateway = None
        self._closed = False
        if use_auth_token:
            if not auth_token:
                self._auth_token = secrets.token_urlsafe(20)
            else:
                self._auth_token = auth_token
        else:
            self._auth_token = &#34;&#34;
        if gatehome is None and start:
            gatehome = os.environ.get(&#34;GATE_HOME&#34;)
            if gatehome is None:
                raise Exception(
                    &#34;Parameter gatehome is None and environment var GATE_HOME not set&#34;
                )
            self._gatehome = gatehome
        if start:
            # make sure we find the jar we need
            # logger.info(&#34;DEBUG: file location: {}&#34;.format(__file__))
            used = True
            if retry_ports:
                for i in range(retry_ports):
                    port = self.port + i
                    used = check_port_used(self.host, port)
                    if not used:
                        self._port = port
                        break
                    logger.info(f&#34;Port {port} is already in use&#34;)
                if used:
                    raise Exception(f&#34;Port(s) in use: {self.port} to {port}&#34;)
            jarloc = jar_loc()
            if not os.path.exists(jarloc):
                raise Exception(&#34;Could not find jar, {} does not exist&#34;.format(jarloc))
            cmdandparms = [java, &#34;-cp&#34;]
            cpsep = classpath_sep(platform=platform)
            cmdandparms.append(
                jarloc + cpsep + gate_classpath(self.gatehome, platform=platform)
            )
            cmdandparms.append(&#34;gate.tools.gatenlpworker.GatenlpWorker&#34;)
            cmdandparms.append(str(port))
            cmdandparms.append(host)
            if log_actions:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            if keep:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            os.environ[&#34;GATENLP_WORKER_TOKEN_&#34; + str(self.port)] = self._auth_token
            cmd = &#34; &#34;.join(cmdandparms)
            self.logger.debug(f&#34;Running command: {cmd}&#34;)
            subproc = subprocess.Popen(
                cmdandparms, stderr=subprocess.PIPE, bufsize=0, encoding=&#34;utf-8&#34;
            )
            self._gateprocess = subproc
            haveerror = False
            while True:
                # NOTE: the following line can block when the subprocess ends with an error
                line = subproc.stderr.readline()
                if line == &#34;&#34;:
                    break
                line = line.rstrip(&#34;\n\r&#34;)
                if line == &#34;PythonWorkerRunner.java: server start OK&#34;:
                    break
                if line == &#34;PythonWorkerRunner.java: server start NOT OK&#34;:
                    haveerror = True
                    # if we get an error we continue to loop through stderr until we get end of stream (line==&#34;&#34;)
                    # and only raise the exception after the loop.
                if line.startswith(&#34;Java GatenlpWorker ENDING&#34;):
                    break
                print(line, file=sys.stderr)
            if haveerror:
                raise Exception(&#34;Error when starting server&#34;)
            atexit.register(self.close)
        self._gateway = JavaGateway(
            gateway_parameters=GatewayParameters(port=port, auth_token=self._auth_token)
        )
        # do not wait until the gateway is used by the user to detect a problem, instead, retrieve the GATE
        # version here to check basic functionality
        _ = self.gate_version

    def __repr__(self):
        return f&#34;Gateworker(port={self.port},host={self.host},gate_home={self.gatehome})&#34;

    @property
    def jvm(self) -&gt; py4j.java_gateway.JVMView:
        &#34;&#34;&#34;
        Returns the JVM instance which allows to interact with Java.

        Returns:
            The JVMView instance

        &#34;&#34;&#34;
        return self.gateway.jvm

    @property
    def worker(self) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        A JavaObject which provides the methods on the Java side.

        Returns:
            The worker JavaObject

        &#34;&#34;&#34;
        return self.gateway.entry_point

    @property
    def gate_version(self) -&gt; str:
        &#34;&#34;&#34;
        Return the GATE version of the connected GATE process.
        &#34;&#34;&#34;
        return self.jvm.gate.Main.version

    @property
    def gate_build(self) -&gt; str:
        &#34;&#34;&#34;
        Return the GATE build id of the connected GATE process.
        &#34;&#34;&#34;
        return self.jvm.gate.Main.build

    @property
    def worker_version(self) -&gt; str:
        &#34;&#34;&#34;
        Return the Gate Worker version of the connected GATE process.
        &#34;&#34;&#34;
        return self.worker.pluginVersion()

    @property
    def worker_build(self) -&gt; str:
        &#34;&#34;&#34;
        Return the build id of the Worker of the connected GATE proces..
        &#34;&#34;&#34;
        return self.worker.pluginBuild()

    @property
    def gatehome(self) -&gt; str:
        &#34;&#34;&#34;
        Return the GATE home path of the connected GATE process as a string.
        &#34;&#34;&#34;
        return self._gatehome

    @property
    def port(self) -&gt; int:
        &#34;&#34;&#34;
        Return the port of the connected GATE process as an int.
        &#34;&#34;&#34;
        return self._port

    @property
    def host(self) -&gt; str:
        &#34;&#34;&#34;
        Return the host name or address of the connected GATE process as a str.
        &#34;&#34;&#34;
        return self._host

    @property
    def platform(self) -&gt; Optional[str]:
        return self._platform

    @property
    def gateprocess(self) -&gt; subprocess.Popen:
        &#34;&#34;&#34;
        Get the process.

        Returns:
            A subprocess.Popen object.
            See https://docs.python.org/3/library/subprocess.html#popen-objects for methods
            that can be used on this object.

        &#34;&#34;&#34;
        return self._gateprocess

    @property
    def getpid(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
        Get the process id (or None if no process).

        Returns:
            Process ID (int)

        &#34;&#34;&#34;
        proc = self.gateprocess
        if proc:
            return proc.pid

    @property
    def gateway(self) -&gt; py4j.java_gateway.JavaGateway:
        &#34;&#34;&#34;
        Return the py4j JavaGateway instance. This object provides the method
        help(jvm.some.object) for getting help about known Java objects.
        &#34;&#34;&#34;
        return self._gateway

    # @staticmethod
    # def download():
    #     &#34;&#34;&#34;
    #     Download GATE libraries into a standard location so we can run the GATE worker even if GATE_HOME
    #     is not set.
    #
    #     NOTE YET IMPLEMENTED.
    #     &#34;&#34;&#34;
    #     # TODO: this should use the command and bootstrapping jar in gate-downloader:
    #     # copy the whole directory into the standard per-user config directory for the system
    #     # run the command
    #     # use the generated gate.classpath as for a compiled local git repo
    #     # NOTE: should change error message if GATE_HOME is not set to hint at this!
    #     # (option --downlaod for the script)
    #     # NOTE: add to documentation
    #     raise Exception(&#34;Not yet implemented&#34;)

    def close(self):
        &#34;&#34;&#34;
        Clean up: if the gate worker process was started by us, we will shut it down.
        Otherwise we can still close it if it was started by the workerrunner, not the Lr
        Note: if it was started by us, it was started via the workerrunner.
        &#34;&#34;&#34;
        if not self._closed and self.worker.isClosable():
            self._closed = True
            self.gateway.shutdown()
            if self.gateprocess is not None:
                for line in self.gateprocess.stderr:
                    print(line, file=sys.stderr, end=&#34;&#34;)
                self.gateprocess.wait()

    def __enter__(self):
        return self

    def __exit__(self, _exptype, _value, _traceback):
        self.close()

    def log_actions(self, onoff: bool):
        &#34;&#34;&#34;
        Switch logging actions at the worker on or off.

        Args:
          onoff: True to log actions, False to not log them
        &#34;&#34;&#34;
        self.worker.logActions(onoff)

    def load_gdoc(self, path: str, mimetype: Optional[str] = None) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Let GATE load a document from the given path and return a handle to it.

        Args:
          path: path to the gate document to load.
          mimetype: a mimetype to use when loading. (Default value = None)

        Returns:
          a handle to the Java GATE document
        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        return self.worker.loadDocumentFromFile(path, mimetype)

    def save_gdoc(self,
                  gdoc: py4j.java_gateway.JavaObject,
                  path: str,
                  mimetype: Optional[str] = None,
                  inline_anntypes: Optional[List[str]] = None,
                  inline_annset: Optional[str] = &#34;&#34;,
                  inline_features: Optional[bool] = True):
        &#34;&#34;&#34;
        Save GATE document to the given path.

        Args:
          gdoc: GATE document handle
          path: destination path
          mimetype: mimtetype, only the following types are allowed: &#34;&#34;/None: GATE XML,
                application/fastinfoset, text/xml for inline XML, 
                and all mimetypes supported by the
                Format_Bdoc plugin. (Default value = None). 
          inline_anntypes: annotation types for inline XML export. Only works with mimetype xml.
                If None, all types in the inline_annset are exported, if a list, only the 
                types in the list are exported.
          inline_annset: annotation set for inline XML export.
          inline_features: save features as attribute for inline XML export.
        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        self.worker.saveDocumentToFile(gdoc, path, mimetype, self.panntype2ganntype(inline_anntypes), inline_annset, inline_features)

    def gdoc2pdoc(self, gdoc: py4j.java_gateway.JavaObject) -&gt; Document:
        &#34;&#34;&#34;
        Convert the GATE document to a python document and return it.

        Args:
          gdoc: the handle to a GATE document

        Returns:
          a gatenlp Document instance
        &#34;&#34;&#34;
        bjs = self.worker.getBdocJson(gdoc)
        return Document.load_mem(bjs, fmt=&#34;bdocjs&#34;)

    def pdoc2gdoc(self, pdoc: Document, annspec: Optional[List[Tuple]] = None) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Convert the Python gatenlp document to a GATE document and return a handle to it.

        Args:
            pdoc: python gatenlp Document
            annspec: a list of either set names, or tuples where the first element is a set name and the
                second element is either a type name or a list of type names.

        Returns:
            handle to GATE document
        &#34;&#34;&#34;
        jsondata = pdoc.save_mem(fmt=&#34;bdocjs&#34;, annspec=annspec)
        return self.worker.getDocument4BdocJson(jsondata)

    def gdocanns2pdoc(self, gdoc: py4j.java_gateway.JavaObject, pdoc: Document,
                      annspec: Optional[List[Tuple]] = None, replace: bool = False) -&gt; Document:
        &#34;&#34;&#34;
        Retrieve the annotations from the GATE document and add them to the python gatenlp document.
        This modifies the pdoc in place and returns it.

        Args:
            gdoc: a handle to a Java GATE document
            pdoc: Python gatenlp document
            annspec: if not None, an annotation specification: a list of set names or tuples where the first
                element is a set name and the second element is either a type name or a list of type names
            replace: if True, replaces all annotations with the same set and annotation id, otherwise adds
                annotaitons with potentially a new annotation id.

        Returns:
            the modified pdoc
        &#34;&#34;&#34;
        # to make it easier on the Java side to interpret the annotation specification, convert it so that
        # all elements are a list where first element is always the set name and all remaining elements
        # are tyepe names. If there is one remaining element which is null, include all types for that set.
        newannspec = self.pannspec2gannspec(annspec)
        # now retrieve the BDOC JSON representation of the annotations
        thejson = self.jsonAnnsets4Doc(gdoc, newannspec)
        dictrep = json.loads(thejson)
        for name, adict in dictrep.items():
            annset = AnnotationSet.from_dict(adict, owner_doc=None)
            targetset = pdoc.annset(name)
            # add the annotations in annset to the pdoc, depending on replace
            for ann in annset._annotations.values():
                # if the annotation id already exists in the target set, proceed according to replace,
                # if not, just add it as is
                if ann.id in targetset._annotations:
                    if replace:
                        # for now, the simplified version: remove existing add new
                        targetset.remove(ann.id)
                        targetset.add_ann(ann, annid=ann.id)
                    else:
                        targetset.add_ann(ann)
                else:
                    targetset.add_ann(ann)
        return pdoc

    def load_pdoc(self, path: str, mimetype: Optional[str] = None) -&gt; Document:
        &#34;&#34;&#34;
        Load a document from the given path, using GATE and convert and return as gatenlp Python document.

        Args:
          path: path to load document from
          mimetype: mime type to use (Default value = None)

        Returns:
          gatenlp document
        &#34;&#34;&#34;
        gdoc = self.load_gdoc(path, mimetype)
        return self.gdoc2pdoc(gdoc)

    def del_resource(self, resource: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        DEPRECATED: please use deleteResource(resource) instead!

        Delete/unload a GATE resource (Document, Corpus, ProcessingResource etc) from GATE.

        Args:
          resource: the Java GATE resource, e.g. a document to remove
        &#34;&#34;&#34;
        self.jvm.gate.Factory.deleteResource(resource)

    def show_gui(self):
        &#34;&#34;&#34;
        Show the GUI for the started GATE process.

        NOTE: this is more of a hack and may cause sync problems
        when closing down the GATE worker.
        &#34;&#34;&#34;
        self.worker.showGui()

    # methods that mirror the methods from the Java gate.plugin.python.PythonWorker methods
    # These could get called directly via gs.worker.METHODNAME calls but are implemented here
    # to provide easier discovery and better documentation on the Python side
    # Since these are really local mirrors of Java methods, they follow Java naming conventions
    def createDocument(self, content: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Create a Java GATE document from the content string and return a handle to it.

        Args:
            content: the text of the document

        Returns:
            handle to Java GATE document
        &#34;&#34;&#34;
        return self.worker.createDocument(content)

    def deleteResource(self, resource: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        Delete/unload a Java GATE resource (Document, Corpus, ProcessingResource etc) from GATE.
        This is particularly important to do when processing a large number of documents for each document
        that is finished processing, otherwise the documents
        will accumulate in the Java process and eat up all memory. NOTE: just removing all references to a
        GATE document does not delete/unload the document!

        Args:
            resource: a handle to some Java GATE resource
        &#34;&#34;&#34;
        self.worker.deleteResource(resource)

    def findMavenPlugin(self, group: str, artifact: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Find a Java GATE Maven plugin and return a handle to it, or None if nothing found.

        Args:
            group: the Maven group for the plugin
            artifact: the artifact name for the plugin

        Returns:
            a handle to the plugin or None if not found
        &#34;&#34;&#34;
        return self.worker.findMavenPlugin(group, artifact)

    def getBdocJson(self, gdoc: py4j.java_gateway.JavaObject) -&gt; str:
        &#34;&#34;&#34;
        Return the Bdoc JSON serialization of a Java GATE document as string.

        Args:
            gdoc: a handle to a GATE document

        Returns:
            BDOC serialization JSON string
        &#34;&#34;&#34;
        return self.worker.getBdocJson(gdoc)

    def getCorpus4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Return a handle to the first Java GATE corpus with the given name or None if none found.

        Args:
            name: corpus name

        Returns:
            first matching corpus or None
        &#34;&#34;&#34;
        return self.worker.getCorpus4Name(name)

    def getCorpusNames(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Return a list of all Java GATE corpus names known.

        Returns:
            list of corpus names
        &#34;&#34;&#34;
        return self.worker.getCorpusNames()

    def getDocument4BdocJson(self, bdocjson: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Returns a handle to a Java GATE document created from the Bdoc JSON string.

        Args:
            bdocjson: a BDOC JSON string

        Returns:
            handle to the Java GATE document
        &#34;&#34;&#34;
        return self.worker.getDocument4BdocJson(bdocjson)

    def getDocument4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Return a handle to the first Java GATE document that has the given name or None if none found.

        Args:
            name: the document name

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.worker.getDocument4Name(name)

    def getDocumentNames(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Return a list of known Java GATE document names.

        Returns:
            list of Java GATE document names
        &#34;&#34;&#34;
        return self.worker.getDocumentNames()

    def getPipeline4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Return a handle to the first Java GATE pipeline/controller that has the given name or
        None if none found.

        Args:
            name: name of the pipeline

        Returns:
            handle to the pipeline
        &#34;&#34;&#34;
        return self.worker.getPipeline4Name(name)

    def getPipelineNames(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Return a list of all know Java GATE pipeline names.

        Returns:
            list of pipeline names
        &#34;&#34;&#34;
        return self.worker.getPipelineNames()

    def getPr4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Return a handle to the first Java GATE processing resource that has the given name
        or None if none found.

        Args:
            name: the name of the processing resource

        Returns:
            a handle to the processing resource or None
        &#34;&#34;&#34;
        return self.worker.getPr4Name(name)

    def getPrNames(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Return a list of known Java GATE  processing resource names.

        Returns:
            list of PR names
        &#34;&#34;&#34;
        return self.worker.getPrNames()

    def getResources4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Return a (possibly empty) list of all Java GATE resources with the given name.

        Args:
            name: name of the resources

        Returns:
            list of matching resources
        &#34;&#34;&#34;
        return self.worker.getResources4Name(name)

    def getResources4NameClass(self, name: str, clazz: str) -&gt; List[py4j.java_gateway.JavaObject]:
        &#34;&#34;&#34;
        Return a (possibly empty) list of all Java GATE resources with the given name and class name.

        Args:
            name: name of the resources
            clazz: the name of the java class the resource must be an instance of

        Returns:
            list of matching resources
        &#34;&#34;&#34;
        return self.worker.getResources4Name(name, clazz)

    def loadDocumentFromFile(self, filename: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Load a Java GATE document from the given file name and return a handle to it.

        Args:
            filename: the file name/path of the Java GATE document to load.

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.worker.loadDocumentFromFile(filename)

    def loadDocumentFromFile4Mime(self, filename: str, mimetype: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Load a Java GATE document from the given file name, using the given mime type
        and return a handle to it.

        Args:
            filename: the file name/path of the Java GATE document to load.
            mimetype: the mimetype to use

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.worker.loadDocumentFromFile(filename, mimetype)

    def loadMavenPlugin(self, group: str, artifact: str, version: str):
        &#34;&#34;&#34;
        Load the given Maven plugin into Java GATE.

        Args:
            group: group id of the plugin
            artifact:  artifact id of the plugin
            version: version of the plugin
        &#34;&#34;&#34;
        self.worker.loadMavenPlugin(group, artifact, version)

    def loadPipelineFromFile(self, filename: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Load a pipeline/controller from the given file into Java GATE and return a CorpusController handle to it.

        Args:
            filename: the filename/path of the pipeline file

        Returns:
            a CorpusController handle to the loaded Java GATE pipeline
        &#34;&#34;&#34;
        return self.worker.loadPipelineFromFile(filename)

    def loadPipelineFromUri(self, uri: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Load a pipeline/controller from the given uri into Java GATE and return a CorpusController handle to it.

        Args:
            uri: the uri of the pipeline file

        Returns:
            a CorpusController handle to the loaded Java GATE pipeline
        &#34;&#34;&#34;
        return self.worker.loadPipelineFromUri(uri)

    def loadPipelineFromPlugin(self, group: str, artifact: str, path: str) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Load a prepared pipeline from the given loaded GATE Mave plugin into Java GATE and return
        a CorpusController handle to it.

        Args:
            group: maven group id the plugin
            artifact: artifact id of the plugin
            path: path of the pipeline in the JAR

        Returns:
            a CorpusController handle to the pipeline
        &#34;&#34;&#34;
        return self.worker.loadPipelineFromPlugin(group, artifact, path)

    def logActions(self, flag: bool):
        &#34;&#34;&#34;
        Enable/disable logging of actions carried out on the Java GATE side to the Java GATE logger.

        Args:
            flag: True to enable logging of actions
        &#34;&#34;&#34;
        self.worker.logActions(flag)

    def newCorpus(self) -&gt; py4j.java_gateway.JavaObject:
        &#34;&#34;&#34;
        Create and return a handle to a new Java GATE corpus.

        Returns:
            handle to the Java GATE corpus
        &#34;&#34;&#34;
        return self.worker.newCorpus()

    def pluginBuild(self) -&gt; str:
        &#34;&#34;&#34;
        Return the short commit id of the Python plugin on the Java GATE side.

        Returns:
            commit id of Python plugin
        &#34;&#34;&#34;
        return self.worker.pluginBuild()

    def pluginVersion(self) -&gt; str:
        &#34;&#34;&#34;
        Return the version string of the Python plugin on the Java GATE side.

        Returns:
            version string of Python plugin
        &#34;&#34;&#34;
        return self.worker.pluginVersion()

    def print2err(self, message: str):
        &#34;&#34;&#34;
        Output the given message to System.err on the Java GATE side.

        Args:
            message: string to output
        &#34;&#34;&#34;
        self.worker.print2err(message)

    def print2out(self, message: str):
        &#34;&#34;&#34;
        Output the given message to System.out on the Java GATE side.

        Args:
            message: string to output
        &#34;&#34;&#34;
        self.worker.print2out(message)

    def run4Corpus(self, pipeline: py4j.java_gateway.JavaObject, corpus: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        Run the given Java GATE pipeline on the given Java GATE corpus.

        Args:
            pipeline: handle to a Java GATE pipeline
            corpus: handle to a Java GATE corpus
        &#34;&#34;&#34;
        self.worker.run4Corpus(pipeline, corpus)

    def run4Document(self, pipeline: py4j.java_gateway.JavaObject, gdoc: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        Run the given Java GATE pipeline on the given Java GATE document.

        Args:
            pipeline: handle to a Java GATE pipeline
            gdoc: handle to a Java GATE document
        &#34;&#34;&#34;
        self.worker.run4Document(pipeline, gdoc)

    def runExcecutionFinished(self, pipeline: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        Run the execution finished method for the given Java GATE pipeline.

        Args:
            pipeline: handle to a Java GATE pipeline
        &#34;&#34;&#34;
        self.worker.runExecutionFinished(pipeline)

    def runExcecutionStarted(self, pipeline: py4j.java_gateway.JavaObject):
        &#34;&#34;&#34;
        Run the execution started method for the given Java GATE pipeline.

        Args:
            pipeline: handle to a Java GATE pipeline
        &#34;&#34;&#34;
        self.worker.runExecutionStarted(pipeline)

    def saveDocumentToFile(self,
                           gdoc: py4j.java_gateway.JavaObject,
                           filename: str,
                           mimetype: str=&#34;&#34;,
                           inline_anntypes: Optional[List[str]]=None,
                           inline_annset: str=&#34;&#34;,
                           inline_features: bool=True):
        &#34;&#34;&#34;
        Save the Java GATE document to the given file, using the given mime type.
        At the moment this supports the GATE XML format (mimetype=&#34;&#34;) as well as
        formats supported by the FastInfoset  FormatBdoc plugins.

        Args:
            gdoc: handle to Java GATE document
            filename: name/path of the file to save to
            mimetype: the mime type to determine the format, &#34;&#34; for GATE XML, text/xml for GATE inline XML
            inline_anntypes: annotation types for inline XML export.
            inline_annset: annotation set name.
            inline_features: save features as attributes.
        &#34;&#34;&#34;
        self.worker.saveDocumentToFile(gdoc, filename, mimetype, self.panntype2ganntype(inline_anntypes), inline_annset, inline_features)

    def pannspec2gannspec(self,
                          annspec: Union[str, List[Union[str, Tuple]]]=None) -&gt; Optional[py4j.java_gateway.JavaObject]:
        &#34;&#34;&#34;
        Convert from our convention to specifiy annotation sets and types to a Java list.
        This is necessary because py4j does not by default convert lists properly and also
        because our Java representation of the annspec specification has a different structure.
        The list returned from this is already a Java list!

        Args:
            annspec: annotation specification to convert

        Returns:
            java representation of the annotation specification (or None)
        &#34;&#34;&#34;
        if annspec is None:
            return None
        # annspec is a python collection and cannot be passed directly to Java
        # see https://www.py4j.org/advanced_topics.html#collections-conversion
        from py4j.java_collections import ListConverter
        if isinstance(annspec, str):
            annspec = [annspec]
        newannspec = []
        for spec in annspec:
            if isinstance(spec, str):
                plist = [spec, None]
            else:
                setname, types = spec
                if isinstance(types, str):
                    plist = [setname, types]
                else:
                    # types must be a list:
                    plist = [setname]
                    plist.extend(types)
            jlist = ListConverter().convert(plist, self.gateway._gateway_client)
            newannspec.append(jlist)
        jnewannspec = ListConverter().convert(newannspec, self.gateway._gateway_client)
        return jnewannspec

    def panntype2ganntype(self, inline_anntypes: List[str]) -&gt; Optional[py4j.java_gateway.JavaObject]:
        &#34;&#34;&#34;
        Convert annotations types string list to a Java list.
        &#34;&#34;&#34;
        if inline_anntypes is None:
            return None
        # annspec is a python collection and cannot be passed directly to Java
        # see https://www.py4j.org/advanced_topics.html#collections-conversion
        from py4j.java_collections import ListConverter
        return ListConverter().convert(inline_anntypes, self.gateway._gateway_client)

    def jsonAnnsets4Doc(self,
                        gdoc: py4j.java_gateway.JavaObject,
                        jannspec: py4j.java_gateway.JavaObject) -&gt; str:
        &#34;&#34;&#34;
        Return the JSON representation of the annotation sets in the GATE document, optionally
        filtered by the given annotation specification.

        The jannspec specification should have the format as expected on the Java side: a list
        of lists of string. Each inner list has the set name to include as the first element
        and either null as the second element to include all types, or the types to include
        as the 2nd and subsequent elements.

        The method pannspec2gannspec(annspec) can be used to convert from our standard annotation
        specification to the Java annotation specification.

        Args:
            gdoc: handle to Java GATE document
            jannspec: the annotation specification list as a Java list

        Returns:
            JSON string
        &#34;&#34;&#34;
        return self.worker.jsonAnnsets4Doc(gdoc, jannspec)

    def showGui(self):
        &#34;&#34;&#34;
        (CAUTION: EXPERIMENTAL) this shows the GATE GUI if we a re connected to a GATE process that runs without
        showing the GUI.
        &#34;&#34;&#34;
        self.worker.showGui()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="gatenlp.gateworker.gateworker.GateWorker.gate_build"><code class="name">var <span class="ident">gate_build</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the GATE build id of the connected GATE process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gate_build(self) -&gt; str:
    &#34;&#34;&#34;
    Return the GATE build id of the connected GATE process.
    &#34;&#34;&#34;
    return self.jvm.gate.Main.build</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.gate_version"><code class="name">var <span class="ident">gate_version</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the GATE version of the connected GATE process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gate_version(self) -&gt; str:
    &#34;&#34;&#34;
    Return the GATE version of the connected GATE process.
    &#34;&#34;&#34;
    return self.jvm.gate.Main.version</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.gatehome"><code class="name">var <span class="ident">gatehome</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the GATE home path of the connected GATE process as a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gatehome(self) -&gt; str:
    &#34;&#34;&#34;
    Return the GATE home path of the connected GATE process as a string.
    &#34;&#34;&#34;
    return self._gatehome</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.gateprocess"><code class="name">var <span class="ident">gateprocess</span> :subprocess.Popen</code></dt>
<dd>
<div class="desc"><p>Get the process.</p>
<h2 id="returns">Returns</h2>
<p>A subprocess.Popen object.
See <a href="https://docs.python.org/3/library/subprocess.html#popen-objects">https://docs.python.org/3/library/subprocess.html#popen-objects</a> for methods
that can be used on this object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gateprocess(self) -&gt; subprocess.Popen:
    &#34;&#34;&#34;
    Get the process.

    Returns:
        A subprocess.Popen object.
        See https://docs.python.org/3/library/subprocess.html#popen-objects for methods
        that can be used on this object.

    &#34;&#34;&#34;
    return self._gateprocess</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.gateway"><code class="name">var <span class="ident">gateway</span> :py4j.java_gateway.JavaGateway</code></dt>
<dd>
<div class="desc"><p>Return the py4j JavaGateway instance. This object provides the method
help(jvm.some.object) for getting help about known Java objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gateway(self) -&gt; py4j.java_gateway.JavaGateway:
    &#34;&#34;&#34;
    Return the py4j JavaGateway instance. This object provides the method
    help(jvm.some.object) for getting help about known Java objects.
    &#34;&#34;&#34;
    return self._gateway</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getpid"><code class="name">var <span class="ident">getpid</span> :Optional[int]</code></dt>
<dd>
<div class="desc"><p>Get the process id (or None if no process).</p>
<h2 id="returns">Returns</h2>
<p>Process ID (int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def getpid(self) -&gt; Optional[int]:
    &#34;&#34;&#34;
    Get the process id (or None if no process).

    Returns:
        Process ID (int)

    &#34;&#34;&#34;
    proc = self.gateprocess
    if proc:
        return proc.pid</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.host"><code class="name">var <span class="ident">host</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the host name or address of the connected GATE process as a str.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def host(self) -&gt; str:
    &#34;&#34;&#34;
    Return the host name or address of the connected GATE process as a str.
    &#34;&#34;&#34;
    return self._host</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.jvm"><code class="name">var <span class="ident">jvm</span> :py4j.java_gateway.JVMView</code></dt>
<dd>
<div class="desc"><p>Returns the JVM instance which allows to interact with Java.</p>
<h2 id="returns">Returns</h2>
<p>The JVMView instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def jvm(self) -&gt; py4j.java_gateway.JVMView:
    &#34;&#34;&#34;
    Returns the JVM instance which allows to interact with Java.

    Returns:
        The JVMView instance

    &#34;&#34;&#34;
    return self.gateway.jvm</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.platform"><code class="name">var <span class="ident">platform</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def platform(self) -&gt; Optional[str]:
    return self._platform</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.port"><code class="name">var <span class="ident">port</span> :int</code></dt>
<dd>
<div class="desc"><p>Return the port of the connected GATE process as an int.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def port(self) -&gt; int:
    &#34;&#34;&#34;
    Return the port of the connected GATE process as an int.
    &#34;&#34;&#34;
    return self._port</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.worker"><code class="name">var <span class="ident">worker</span> :py4j.java_gateway.JavaObject</code></dt>
<dd>
<div class="desc"><p>A JavaObject which provides the methods on the Java side.</p>
<h2 id="returns">Returns</h2>
<p>The worker JavaObject</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def worker(self) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    A JavaObject which provides the methods on the Java side.

    Returns:
        The worker JavaObject

    &#34;&#34;&#34;
    return self.gateway.entry_point</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.worker_build"><code class="name">var <span class="ident">worker_build</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the build id of the Worker of the connected GATE proces..</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def worker_build(self) -&gt; str:
    &#34;&#34;&#34;
    Return the build id of the Worker of the connected GATE proces..
    &#34;&#34;&#34;
    return self.worker.pluginBuild()</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.worker_version"><code class="name">var <span class="ident">worker_version</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the Gate Worker version of the connected GATE process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def worker_version(self) -&gt; str:
    &#34;&#34;&#34;
    Return the Gate Worker version of the connected GATE process.
    &#34;&#34;&#34;
    return self.worker.pluginVersion()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.gateworker.gateworker.GateWorker.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clean up: if the gate worker process was started by us, we will shut it down.
Otherwise we can still close it if it was started by the workerrunner, not the Lr
Note: if it was started by us, it was started via the workerrunner.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Clean up: if the gate worker process was started by us, we will shut it down.
    Otherwise we can still close it if it was started by the workerrunner, not the Lr
    Note: if it was started by us, it was started via the workerrunner.
    &#34;&#34;&#34;
    if not self._closed and self.worker.isClosable():
        self._closed = True
        self.gateway.shutdown()
        if self.gateprocess is not None:
            for line in self.gateprocess.stderr:
                print(line, file=sys.stderr, end=&#34;&#34;)
            self.gateprocess.wait()</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.createDocument"><code class="name flex">
<span>def <span class="ident">createDocument</span></span>(<span>self, content:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Java GATE document from the content string and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>content</code></strong></dt>
<dd>the text of the document</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>handle to Java GATE document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createDocument(self, content: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Create a Java GATE document from the content string and return a handle to it.

    Args:
        content: the text of the document

    Returns:
        handle to Java GATE document
    &#34;&#34;&#34;
    return self.worker.createDocument(content)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.del_resource"><code class="name flex">
<span>def <span class="ident">del_resource</span></span>(<span>self, resource:py4j.java_gateway.JavaObject)</span>
</code></dt>
<dd>
<div class="desc"><p>DEPRECATED: please use deleteResource(resource) instead!</p>
<p>Delete/unload a GATE resource (Document, Corpus, ProcessingResource etc) from GATE.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource</code></strong></dt>
<dd>the Java GATE resource, e.g. a document to remove</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_resource(self, resource: py4j.java_gateway.JavaObject):
    &#34;&#34;&#34;
    DEPRECATED: please use deleteResource(resource) instead!

    Delete/unload a GATE resource (Document, Corpus, ProcessingResource etc) from GATE.

    Args:
      resource: the Java GATE resource, e.g. a document to remove
    &#34;&#34;&#34;
    self.jvm.gate.Factory.deleteResource(resource)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.deleteResource"><code class="name flex">
<span>def <span class="ident">deleteResource</span></span>(<span>self, resource:py4j.java_gateway.JavaObject)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete/unload a Java GATE resource (Document, Corpus, ProcessingResource etc) from GATE.
This is particularly important to do when processing a large number of documents for each document
that is finished processing, otherwise the documents
will accumulate in the Java process and eat up all memory. NOTE: just removing all references to a
GATE document does not delete/unload the document!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource</code></strong></dt>
<dd>a handle to some Java GATE resource</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteResource(self, resource: py4j.java_gateway.JavaObject):
    &#34;&#34;&#34;
    Delete/unload a Java GATE resource (Document, Corpus, ProcessingResource etc) from GATE.
    This is particularly important to do when processing a large number of documents for each document
    that is finished processing, otherwise the documents
    will accumulate in the Java process and eat up all memory. NOTE: just removing all references to a
    GATE document does not delete/unload the document!

    Args:
        resource: a handle to some Java GATE resource
    &#34;&#34;&#34;
    self.worker.deleteResource(resource)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.findMavenPlugin"><code class="name flex">
<span>def <span class="ident">findMavenPlugin</span></span>(<span>self, group:str, artifact:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Find a Java GATE Maven plugin and return a handle to it, or None if nothing found.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>group</code></strong></dt>
<dd>the Maven group for the plugin</dd>
<dt><strong><code>artifact</code></strong></dt>
<dd>the artifact name for the plugin</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the plugin or None if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findMavenPlugin(self, group: str, artifact: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Find a Java GATE Maven plugin and return a handle to it, or None if nothing found.

    Args:
        group: the Maven group for the plugin
        artifact: the artifact name for the plugin

    Returns:
        a handle to the plugin or None if not found
    &#34;&#34;&#34;
    return self.worker.findMavenPlugin(group, artifact)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.gdoc2pdoc"><code class="name flex">
<span>def <span class="ident">gdoc2pdoc</span></span>(<span>self, gdoc:py4j.java_gateway.JavaObject) ><a title="gatenlp.document.Document" href="../document.html#gatenlp.document.Document">Document</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert the GATE document to a python document and return it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>the handle to a GATE document</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a gatenlp Document instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gdoc2pdoc(self, gdoc: py4j.java_gateway.JavaObject) -&gt; Document:
    &#34;&#34;&#34;
    Convert the GATE document to a python document and return it.

    Args:
      gdoc: the handle to a GATE document

    Returns:
      a gatenlp Document instance
    &#34;&#34;&#34;
    bjs = self.worker.getBdocJson(gdoc)
    return Document.load_mem(bjs, fmt=&#34;bdocjs&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.gdocanns2pdoc"><code class="name flex">
<span>def <span class="ident">gdocanns2pdoc</span></span>(<span>self, gdoc:py4j.java_gateway.JavaObject, pdoc:<a title="gatenlp.document.Document" href="../document.html#gatenlp.document.Document">Document</a>, annspec:Optional[List[Tuple[]]]=None, replace:bool=False) ><a title="gatenlp.document.Document" href="../document.html#gatenlp.document.Document">Document</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the annotations from the GATE document and add them to the python gatenlp document.
This modifies the pdoc in place and returns it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>a handle to a Java GATE document</dd>
<dt><strong><code>pdoc</code></strong></dt>
<dd>Python gatenlp document</dd>
<dt><strong><code>annspec</code></strong></dt>
<dd>if not None, an annotation specification: a list of set names or tuples where the first
element is a set name and the second element is either a type name or a list of type names</dd>
<dt><strong><code>replace</code></strong></dt>
<dd>if True, replaces all annotations with the same set and annotation id, otherwise adds
annotaitons with potentially a new annotation id.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the modified pdoc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gdocanns2pdoc(self, gdoc: py4j.java_gateway.JavaObject, pdoc: Document,
                  annspec: Optional[List[Tuple]] = None, replace: bool = False) -&gt; Document:
    &#34;&#34;&#34;
    Retrieve the annotations from the GATE document and add them to the python gatenlp document.
    This modifies the pdoc in place and returns it.

    Args:
        gdoc: a handle to a Java GATE document
        pdoc: Python gatenlp document
        annspec: if not None, an annotation specification: a list of set names or tuples where the first
            element is a set name and the second element is either a type name or a list of type names
        replace: if True, replaces all annotations with the same set and annotation id, otherwise adds
            annotaitons with potentially a new annotation id.

    Returns:
        the modified pdoc
    &#34;&#34;&#34;
    # to make it easier on the Java side to interpret the annotation specification, convert it so that
    # all elements are a list where first element is always the set name and all remaining elements
    # are tyepe names. If there is one remaining element which is null, include all types for that set.
    newannspec = self.pannspec2gannspec(annspec)
    # now retrieve the BDOC JSON representation of the annotations
    thejson = self.jsonAnnsets4Doc(gdoc, newannspec)
    dictrep = json.loads(thejson)
    for name, adict in dictrep.items():
        annset = AnnotationSet.from_dict(adict, owner_doc=None)
        targetset = pdoc.annset(name)
        # add the annotations in annset to the pdoc, depending on replace
        for ann in annset._annotations.values():
            # if the annotation id already exists in the target set, proceed according to replace,
            # if not, just add it as is
            if ann.id in targetset._annotations:
                if replace:
                    # for now, the simplified version: remove existing add new
                    targetset.remove(ann.id)
                    targetset.add_ann(ann, annid=ann.id)
                else:
                    targetset.add_ann(ann)
            else:
                targetset.add_ann(ann)
    return pdoc</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getBdocJson"><code class="name flex">
<span>def <span class="ident">getBdocJson</span></span>(<span>self, gdoc:py4j.java_gateway.JavaObject) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the Bdoc JSON serialization of a Java GATE document as string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>a handle to a GATE document</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>BDOC serialization JSON string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBdocJson(self, gdoc: py4j.java_gateway.JavaObject) -&gt; str:
    &#34;&#34;&#34;
    Return the Bdoc JSON serialization of a Java GATE document as string.

    Args:
        gdoc: a handle to a GATE document

    Returns:
        BDOC serialization JSON string
    &#34;&#34;&#34;
    return self.worker.getBdocJson(gdoc)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getCorpus4Name"><code class="name flex">
<span>def <span class="ident">getCorpus4Name</span></span>(<span>self, name:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Return a handle to the first Java GATE corpus with the given name or None if none found.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>corpus name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>first matching corpus or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCorpus4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Return a handle to the first Java GATE corpus with the given name or None if none found.

    Args:
        name: corpus name

    Returns:
        first matching corpus or None
    &#34;&#34;&#34;
    return self.worker.getCorpus4Name(name)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getCorpusNames"><code class="name flex">
<span>def <span class="ident">getCorpusNames</span></span>(<span>self) >List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of all Java GATE corpus names known.</p>
<h2 id="returns">Returns</h2>
<p>list of corpus names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCorpusNames(self) -&gt; List[str]:
    &#34;&#34;&#34;
    Return a list of all Java GATE corpus names known.

    Returns:
        list of corpus names
    &#34;&#34;&#34;
    return self.worker.getCorpusNames()</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getDocument4BdocJson"><code class="name flex">
<span>def <span class="ident">getDocument4BdocJson</span></span>(<span>self, bdocjson:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a handle to a Java GATE document created from the Bdoc JSON string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bdocjson</code></strong></dt>
<dd>a BDOC JSON string</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>handle to the Java GATE document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDocument4BdocJson(self, bdocjson: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Returns a handle to a Java GATE document created from the Bdoc JSON string.

    Args:
        bdocjson: a BDOC JSON string

    Returns:
        handle to the Java GATE document
    &#34;&#34;&#34;
    return self.worker.getDocument4BdocJson(bdocjson)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getDocument4Name"><code class="name flex">
<span>def <span class="ident">getDocument4Name</span></span>(<span>self, name:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Return a handle to the first Java GATE document that has the given name or None if none found.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>the document name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the Java GATE document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDocument4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Return a handle to the first Java GATE document that has the given name or None if none found.

    Args:
        name: the document name

    Returns:
        a handle to the Java GATE document
    &#34;&#34;&#34;
    return self.worker.getDocument4Name(name)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getDocumentNames"><code class="name flex">
<span>def <span class="ident">getDocumentNames</span></span>(<span>self) >List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of known Java GATE document names.</p>
<h2 id="returns">Returns</h2>
<p>list of Java GATE document names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDocumentNames(self) -&gt; List[str]:
    &#34;&#34;&#34;
    Return a list of known Java GATE document names.

    Returns:
        list of Java GATE document names
    &#34;&#34;&#34;
    return self.worker.getDocumentNames()</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getPipeline4Name"><code class="name flex">
<span>def <span class="ident">getPipeline4Name</span></span>(<span>self, name:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Return a handle to the first Java GATE pipeline/controller that has the given name or
None if none found.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name of the pipeline</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>handle to the pipeline</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPipeline4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Return a handle to the first Java GATE pipeline/controller that has the given name or
    None if none found.

    Args:
        name: name of the pipeline

    Returns:
        handle to the pipeline
    &#34;&#34;&#34;
    return self.worker.getPipeline4Name(name)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getPipelineNames"><code class="name flex">
<span>def <span class="ident">getPipelineNames</span></span>(<span>self) >List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of all know Java GATE pipeline names.</p>
<h2 id="returns">Returns</h2>
<p>list of pipeline names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPipelineNames(self) -&gt; List[str]:
    &#34;&#34;&#34;
    Return a list of all know Java GATE pipeline names.

    Returns:
        list of pipeline names
    &#34;&#34;&#34;
    return self.worker.getPipelineNames()</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getPr4Name"><code class="name flex">
<span>def <span class="ident">getPr4Name</span></span>(<span>self, name:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Return a handle to the first Java GATE processing resource that has the given name
or None if none found.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the processing resource</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the processing resource or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPr4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Return a handle to the first Java GATE processing resource that has the given name
    or None if none found.

    Args:
        name: the name of the processing resource

    Returns:
        a handle to the processing resource or None
    &#34;&#34;&#34;
    return self.worker.getPr4Name(name)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getPrNames"><code class="name flex">
<span>def <span class="ident">getPrNames</span></span>(<span>self) >List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of known Java GATE
processing resource names.</p>
<h2 id="returns">Returns</h2>
<p>list of PR names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPrNames(self) -&gt; List[str]:
    &#34;&#34;&#34;
    Return a list of known Java GATE  processing resource names.

    Returns:
        list of PR names
    &#34;&#34;&#34;
    return self.worker.getPrNames()</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getResources4Name"><code class="name flex">
<span>def <span class="ident">getResources4Name</span></span>(<span>self, name:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Return a (possibly empty) list of all Java GATE resources with the given name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name of the resources</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of matching resources</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getResources4Name(self, name: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Return a (possibly empty) list of all Java GATE resources with the given name.

    Args:
        name: name of the resources

    Returns:
        list of matching resources
    &#34;&#34;&#34;
    return self.worker.getResources4Name(name)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.getResources4NameClass"><code class="name flex">
<span>def <span class="ident">getResources4NameClass</span></span>(<span>self, name:str, clazz:str) >List[py4j.java_gateway.JavaObject]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a (possibly empty) list of all Java GATE resources with the given name and class name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name of the resources</dd>
<dt><strong><code>clazz</code></strong></dt>
<dd>the name of the java class the resource must be an instance of</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of matching resources</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getResources4NameClass(self, name: str, clazz: str) -&gt; List[py4j.java_gateway.JavaObject]:
    &#34;&#34;&#34;
    Return a (possibly empty) list of all Java GATE resources with the given name and class name.

    Args:
        name: name of the resources
        clazz: the name of the java class the resource must be an instance of

    Returns:
        list of matching resources
    &#34;&#34;&#34;
    return self.worker.getResources4Name(name, clazz)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.jsonAnnsets4Doc"><code class="name flex">
<span>def <span class="ident">jsonAnnsets4Doc</span></span>(<span>self, gdoc:py4j.java_gateway.JavaObject, jannspec:py4j.java_gateway.JavaObject) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the JSON representation of the annotation sets in the GATE document, optionally
filtered by the given annotation specification.</p>
<p>The jannspec specification should have the format as expected on the Java side: a list
of lists of string. Each inner list has the set name to include as the first element
and either null as the second element to include all types, or the types to include
as the 2nd and subsequent elements.</p>
<p>The method pannspec2gannspec(annspec) can be used to convert from our standard annotation
specification to the Java annotation specification.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>handle to Java GATE document</dd>
<dt><strong><code>jannspec</code></strong></dt>
<dd>the annotation specification list as a Java list</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>JSON string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsonAnnsets4Doc(self,
                    gdoc: py4j.java_gateway.JavaObject,
                    jannspec: py4j.java_gateway.JavaObject) -&gt; str:
    &#34;&#34;&#34;
    Return the JSON representation of the annotation sets in the GATE document, optionally
    filtered by the given annotation specification.

    The jannspec specification should have the format as expected on the Java side: a list
    of lists of string. Each inner list has the set name to include as the first element
    and either null as the second element to include all types, or the types to include
    as the 2nd and subsequent elements.

    The method pannspec2gannspec(annspec) can be used to convert from our standard annotation
    specification to the Java annotation specification.

    Args:
        gdoc: handle to Java GATE document
        jannspec: the annotation specification list as a Java list

    Returns:
        JSON string
    &#34;&#34;&#34;
    return self.worker.jsonAnnsets4Doc(gdoc, jannspec)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.loadDocumentFromFile"><code class="name flex">
<span>def <span class="ident">loadDocumentFromFile</span></span>(<span>self, filename:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Load a Java GATE document from the given file name and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>the file name/path of the Java GATE document to load.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the Java GATE document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadDocumentFromFile(self, filename: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Load a Java GATE document from the given file name and return a handle to it.

    Args:
        filename: the file name/path of the Java GATE document to load.

    Returns:
        a handle to the Java GATE document
    &#34;&#34;&#34;
    return self.worker.loadDocumentFromFile(filename)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.loadDocumentFromFile4Mime"><code class="name flex">
<span>def <span class="ident">loadDocumentFromFile4Mime</span></span>(<span>self, filename:str, mimetype:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Load a Java GATE document from the given file name, using the given mime type
and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>the file name/path of the Java GATE document to load.</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>the mimetype to use</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the Java GATE document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadDocumentFromFile4Mime(self, filename: str, mimetype: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Load a Java GATE document from the given file name, using the given mime type
    and return a handle to it.

    Args:
        filename: the file name/path of the Java GATE document to load.
        mimetype: the mimetype to use

    Returns:
        a handle to the Java GATE document
    &#34;&#34;&#34;
    return self.worker.loadDocumentFromFile(filename, mimetype)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.loadMavenPlugin"><code class="name flex">
<span>def <span class="ident">loadMavenPlugin</span></span>(<span>self, group:str, artifact:str, version:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the given Maven plugin into Java GATE.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>group</code></strong></dt>
<dd>group id of the plugin</dd>
<dt><strong><code>artifact</code></strong></dt>
<dd>artifact id of the plugin</dd>
<dt><strong><code>version</code></strong></dt>
<dd>version of the plugin</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadMavenPlugin(self, group: str, artifact: str, version: str):
    &#34;&#34;&#34;
    Load the given Maven plugin into Java GATE.

    Args:
        group: group id of the plugin
        artifact:  artifact id of the plugin
        version: version of the plugin
    &#34;&#34;&#34;
    self.worker.loadMavenPlugin(group, artifact, version)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.loadPipelineFromFile"><code class="name flex">
<span>def <span class="ident">loadPipelineFromFile</span></span>(<span>self, filename:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Load a pipeline/controller from the given file into Java GATE and return a CorpusController handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>the filename/path of the pipeline file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a CorpusController handle to the loaded Java GATE pipeline</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadPipelineFromFile(self, filename: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Load a pipeline/controller from the given file into Java GATE and return a CorpusController handle to it.

    Args:
        filename: the filename/path of the pipeline file

    Returns:
        a CorpusController handle to the loaded Java GATE pipeline
    &#34;&#34;&#34;
    return self.worker.loadPipelineFromFile(filename)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.loadPipelineFromPlugin"><code class="name flex">
<span>def <span class="ident">loadPipelineFromPlugin</span></span>(<span>self, group:str, artifact:str, path:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Load a prepared pipeline from the given loaded GATE Mave plugin into Java GATE and return
a CorpusController handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>group</code></strong></dt>
<dd>maven group id the plugin</dd>
<dt><strong><code>artifact</code></strong></dt>
<dd>artifact id of the plugin</dd>
<dt><strong><code>path</code></strong></dt>
<dd>path of the pipeline in the JAR</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a CorpusController handle to the pipeline</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadPipelineFromPlugin(self, group: str, artifact: str, path: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Load a prepared pipeline from the given loaded GATE Mave plugin into Java GATE and return
    a CorpusController handle to it.

    Args:
        group: maven group id the plugin
        artifact: artifact id of the plugin
        path: path of the pipeline in the JAR

    Returns:
        a CorpusController handle to the pipeline
    &#34;&#34;&#34;
    return self.worker.loadPipelineFromPlugin(group, artifact, path)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.loadPipelineFromUri"><code class="name flex">
<span>def <span class="ident">loadPipelineFromUri</span></span>(<span>self, uri:str) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Load a pipeline/controller from the given uri into Java GATE and return a CorpusController handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uri</code></strong></dt>
<dd>the uri of the pipeline file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a CorpusController handle to the loaded Java GATE pipeline</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadPipelineFromUri(self, uri: str) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Load a pipeline/controller from the given uri into Java GATE and return a CorpusController handle to it.

    Args:
        uri: the uri of the pipeline file

    Returns:
        a CorpusController handle to the loaded Java GATE pipeline
    &#34;&#34;&#34;
    return self.worker.loadPipelineFromUri(uri)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.load_gdoc"><code class="name flex">
<span>def <span class="ident">load_gdoc</span></span>(<span>self, path:str, mimetype:Optional[str]=None) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Let GATE load a document from the given path and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>path to the gate document to load.</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>a mimetype to use when loading. (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the Java GATE document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_gdoc(self, path: str, mimetype: Optional[str] = None) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Let GATE load a document from the given path and return a handle to it.

    Args:
      path: path to the gate document to load.
      mimetype: a mimetype to use when loading. (Default value = None)

    Returns:
      a handle to the Java GATE document
    &#34;&#34;&#34;
    if mimetype is None:
        mimetype = &#34;&#34;
    return self.worker.loadDocumentFromFile(path, mimetype)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.load_pdoc"><code class="name flex">
<span>def <span class="ident">load_pdoc</span></span>(<span>self, path:str, mimetype:Optional[str]=None) ><a title="gatenlp.document.Document" href="../document.html#gatenlp.document.Document">Document</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load a document from the given path, using GATE and convert and return as gatenlp Python document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>path to load document from</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>mime type to use (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>gatenlp document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_pdoc(self, path: str, mimetype: Optional[str] = None) -&gt; Document:
    &#34;&#34;&#34;
    Load a document from the given path, using GATE and convert and return as gatenlp Python document.

    Args:
      path: path to load document from
      mimetype: mime type to use (Default value = None)

    Returns:
      gatenlp document
    &#34;&#34;&#34;
    gdoc = self.load_gdoc(path, mimetype)
    return self.gdoc2pdoc(gdoc)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.logActions"><code class="name flex">
<span>def <span class="ident">logActions</span></span>(<span>self, flag:bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable/disable logging of actions carried out on the Java GATE side to the Java GATE logger.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flag</code></strong></dt>
<dd>True to enable logging of actions</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logActions(self, flag: bool):
    &#34;&#34;&#34;
    Enable/disable logging of actions carried out on the Java GATE side to the Java GATE logger.

    Args:
        flag: True to enable logging of actions
    &#34;&#34;&#34;
    self.worker.logActions(flag)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.log_actions"><code class="name flex">
<span>def <span class="ident">log_actions</span></span>(<span>self, onoff:bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Switch logging actions at the worker on or off.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>onoff</code></strong></dt>
<dd>True to log actions, False to not log them</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_actions(self, onoff: bool):
    &#34;&#34;&#34;
    Switch logging actions at the worker on or off.

    Args:
      onoff: True to log actions, False to not log them
    &#34;&#34;&#34;
    self.worker.logActions(onoff)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.newCorpus"><code class="name flex">
<span>def <span class="ident">newCorpus</span></span>(<span>self) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a handle to a new Java GATE corpus.</p>
<h2 id="returns">Returns</h2>
<p>handle to the Java GATE corpus</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newCorpus(self) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Create and return a handle to a new Java GATE corpus.

    Returns:
        handle to the Java GATE corpus
    &#34;&#34;&#34;
    return self.worker.newCorpus()</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.pannspec2gannspec"><code class="name flex">
<span>def <span class="ident">pannspec2gannspec</span></span>(<span>self, annspec:Union[str,List[Union[str,Tuple[]]]]=None) >Optional[py4j.java_gateway.JavaObject]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from our convention to specifiy annotation sets and types to a Java list.
This is necessary because py4j does not by default convert lists properly and also
because our Java representation of the annspec specification has a different structure.
The list returned from this is already a Java list!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annspec</code></strong></dt>
<dd>annotation specification to convert</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>java representation of the annotation specification (or None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pannspec2gannspec(self,
                      annspec: Union[str, List[Union[str, Tuple]]]=None) -&gt; Optional[py4j.java_gateway.JavaObject]:
    &#34;&#34;&#34;
    Convert from our convention to specifiy annotation sets and types to a Java list.
    This is necessary because py4j does not by default convert lists properly and also
    because our Java representation of the annspec specification has a different structure.
    The list returned from this is already a Java list!

    Args:
        annspec: annotation specification to convert

    Returns:
        java representation of the annotation specification (or None)
    &#34;&#34;&#34;
    if annspec is None:
        return None
    # annspec is a python collection and cannot be passed directly to Java
    # see https://www.py4j.org/advanced_topics.html#collections-conversion
    from py4j.java_collections import ListConverter
    if isinstance(annspec, str):
        annspec = [annspec]
    newannspec = []
    for spec in annspec:
        if isinstance(spec, str):
            plist = [spec, None]
        else:
            setname, types = spec
            if isinstance(types, str):
                plist = [setname, types]
            else:
                # types must be a list:
                plist = [setname]
                plist.extend(types)
        jlist = ListConverter().convert(plist, self.gateway._gateway_client)
        newannspec.append(jlist)
    jnewannspec = ListConverter().convert(newannspec, self.gateway._gateway_client)
    return jnewannspec</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.panntype2ganntype"><code class="name flex">
<span>def <span class="ident">panntype2ganntype</span></span>(<span>self, inline_anntypes:List[str]) >Optional[py4j.java_gateway.JavaObject]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert annotations types string list to a Java list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def panntype2ganntype(self, inline_anntypes: List[str]) -&gt; Optional[py4j.java_gateway.JavaObject]:
    &#34;&#34;&#34;
    Convert annotations types string list to a Java list.
    &#34;&#34;&#34;
    if inline_anntypes is None:
        return None
    # annspec is a python collection and cannot be passed directly to Java
    # see https://www.py4j.org/advanced_topics.html#collections-conversion
    from py4j.java_collections import ListConverter
    return ListConverter().convert(inline_anntypes, self.gateway._gateway_client)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.pdoc2gdoc"><code class="name flex">
<span>def <span class="ident">pdoc2gdoc</span></span>(<span>self, pdoc:<a title="gatenlp.document.Document" href="../document.html#gatenlp.document.Document">Document</a>, annspec:Optional[List[Tuple[]]]=None) >py4j.java_gateway.JavaObject</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the Python gatenlp document to a GATE document and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdoc</code></strong></dt>
<dd>python gatenlp Document</dd>
<dt><strong><code>annspec</code></strong></dt>
<dd>a list of either set names, or tuples where the first element is a set name and the
second element is either a type name or a list of type names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>handle to GATE document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdoc2gdoc(self, pdoc: Document, annspec: Optional[List[Tuple]] = None) -&gt; py4j.java_gateway.JavaObject:
    &#34;&#34;&#34;
    Convert the Python gatenlp document to a GATE document and return a handle to it.

    Args:
        pdoc: python gatenlp Document
        annspec: a list of either set names, or tuples where the first element is a set name and the
            second element is either a type name or a list of type names.

    Returns:
        handle to GATE document
    &#34;&#34;&#34;
    jsondata = pdoc.save_mem(fmt=&#34;bdocjs&#34;, annspec=annspec)
    return self.worker.getDocument4BdocJson(jsondata)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.pluginBuild"><code class="name flex">
<span>def <span class="ident">pluginBuild</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the short commit id of the Python plugin on the Java GATE side.</p>
<h2 id="returns">Returns</h2>
<p>commit id of Python plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pluginBuild(self) -&gt; str:
    &#34;&#34;&#34;
    Return the short commit id of the Python plugin on the Java GATE side.

    Returns:
        commit id of Python plugin
    &#34;&#34;&#34;
    return self.worker.pluginBuild()</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.pluginVersion"><code class="name flex">
<span>def <span class="ident">pluginVersion</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the version string of the Python plugin on the Java GATE side.</p>
<h2 id="returns">Returns</h2>
<p>version string of Python plugin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pluginVersion(self) -&gt; str:
    &#34;&#34;&#34;
    Return the version string of the Python plugin on the Java GATE side.

    Returns:
        version string of Python plugin
    &#34;&#34;&#34;
    return self.worker.pluginVersion()</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.print2err"><code class="name flex">
<span>def <span class="ident">print2err</span></span>(<span>self, message:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Output the given message to System.err on the Java GATE side.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>string to output</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print2err(self, message: str):
    &#34;&#34;&#34;
    Output the given message to System.err on the Java GATE side.

    Args:
        message: string to output
    &#34;&#34;&#34;
    self.worker.print2err(message)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.print2out"><code class="name flex">
<span>def <span class="ident">print2out</span></span>(<span>self, message:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Output the given message to System.out on the Java GATE side.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>string to output</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print2out(self, message: str):
    &#34;&#34;&#34;
    Output the given message to System.out on the Java GATE side.

    Args:
        message: string to output
    &#34;&#34;&#34;
    self.worker.print2out(message)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.run4Corpus"><code class="name flex">
<span>def <span class="ident">run4Corpus</span></span>(<span>self, pipeline:py4j.java_gateway.JavaObject, corpus:py4j.java_gateway.JavaObject)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the given Java GATE pipeline on the given Java GATE corpus.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pipeline</code></strong></dt>
<dd>handle to a Java GATE pipeline</dd>
<dt><strong><code>corpus</code></strong></dt>
<dd>handle to a Java GATE corpus</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run4Corpus(self, pipeline: py4j.java_gateway.JavaObject, corpus: py4j.java_gateway.JavaObject):
    &#34;&#34;&#34;
    Run the given Java GATE pipeline on the given Java GATE corpus.

    Args:
        pipeline: handle to a Java GATE pipeline
        corpus: handle to a Java GATE corpus
    &#34;&#34;&#34;
    self.worker.run4Corpus(pipeline, corpus)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.run4Document"><code class="name flex">
<span>def <span class="ident">run4Document</span></span>(<span>self, pipeline:py4j.java_gateway.JavaObject, gdoc:py4j.java_gateway.JavaObject)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the given Java GATE pipeline on the given Java GATE document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pipeline</code></strong></dt>
<dd>handle to a Java GATE pipeline</dd>
<dt><strong><code>gdoc</code></strong></dt>
<dd>handle to a Java GATE document</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run4Document(self, pipeline: py4j.java_gateway.JavaObject, gdoc: py4j.java_gateway.JavaObject):
    &#34;&#34;&#34;
    Run the given Java GATE pipeline on the given Java GATE document.

    Args:
        pipeline: handle to a Java GATE pipeline
        gdoc: handle to a Java GATE document
    &#34;&#34;&#34;
    self.worker.run4Document(pipeline, gdoc)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.runExcecutionFinished"><code class="name flex">
<span>def <span class="ident">runExcecutionFinished</span></span>(<span>self, pipeline:py4j.java_gateway.JavaObject)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the execution finished method for the given Java GATE pipeline.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pipeline</code></strong></dt>
<dd>handle to a Java GATE pipeline</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runExcecutionFinished(self, pipeline: py4j.java_gateway.JavaObject):
    &#34;&#34;&#34;
    Run the execution finished method for the given Java GATE pipeline.

    Args:
        pipeline: handle to a Java GATE pipeline
    &#34;&#34;&#34;
    self.worker.runExecutionFinished(pipeline)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.runExcecutionStarted"><code class="name flex">
<span>def <span class="ident">runExcecutionStarted</span></span>(<span>self, pipeline:py4j.java_gateway.JavaObject)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the execution started method for the given Java GATE pipeline.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pipeline</code></strong></dt>
<dd>handle to a Java GATE pipeline</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runExcecutionStarted(self, pipeline: py4j.java_gateway.JavaObject):
    &#34;&#34;&#34;
    Run the execution started method for the given Java GATE pipeline.

    Args:
        pipeline: handle to a Java GATE pipeline
    &#34;&#34;&#34;
    self.worker.runExecutionStarted(pipeline)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.saveDocumentToFile"><code class="name flex">
<span>def <span class="ident">saveDocumentToFile</span></span>(<span>self, gdoc:py4j.java_gateway.JavaObject, filename:str, mimetype:str='', inline_anntypes:Optional[List[str]]=None, inline_annset:str='', inline_features:bool=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the Java GATE document to the given file, using the given mime type.
At the moment this supports the GATE XML format (mimetype="") as well as
formats supported by the FastInfoset
FormatBdoc plugins.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>handle to Java GATE document</dd>
<dt><strong><code>filename</code></strong></dt>
<dd>name/path of the file to save to</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>the mime type to determine the format, "" for GATE XML, text/xml for GATE inline XML</dd>
<dt><strong><code>inline_anntypes</code></strong></dt>
<dd>annotation types for inline XML export.</dd>
<dt><strong><code>inline_annset</code></strong></dt>
<dd>annotation set name.</dd>
<dt><strong><code>inline_features</code></strong></dt>
<dd>save features as attributes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveDocumentToFile(self,
                       gdoc: py4j.java_gateway.JavaObject,
                       filename: str,
                       mimetype: str=&#34;&#34;,
                       inline_anntypes: Optional[List[str]]=None,
                       inline_annset: str=&#34;&#34;,
                       inline_features: bool=True):
    &#34;&#34;&#34;
    Save the Java GATE document to the given file, using the given mime type.
    At the moment this supports the GATE XML format (mimetype=&#34;&#34;) as well as
    formats supported by the FastInfoset  FormatBdoc plugins.

    Args:
        gdoc: handle to Java GATE document
        filename: name/path of the file to save to
        mimetype: the mime type to determine the format, &#34;&#34; for GATE XML, text/xml for GATE inline XML
        inline_anntypes: annotation types for inline XML export.
        inline_annset: annotation set name.
        inline_features: save features as attributes.
    &#34;&#34;&#34;
    self.worker.saveDocumentToFile(gdoc, filename, mimetype, self.panntype2ganntype(inline_anntypes), inline_annset, inline_features)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.save_gdoc"><code class="name flex">
<span>def <span class="ident">save_gdoc</span></span>(<span>self, gdoc:py4j.java_gateway.JavaObject, path:str, mimetype:Optional[str]=None, inline_anntypes:Optional[List[str]]=None, inline_annset:Optional[str]='', inline_features:Optional[bool]=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save GATE document to the given path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>GATE document handle</dd>
<dt><strong><code>path</code></strong></dt>
<dd>destination path</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>mimtetype, only the following types are allowed: ""/None: GATE XML,
application/fastinfoset, text/xml for inline XML,
and all mimetypes supported by the
Format_Bdoc plugin. (Default value = None). </dd>
<dt><strong><code>inline_anntypes</code></strong></dt>
<dd>annotation types for inline XML export. Only works with mimetype xml.
If None, all types in the inline_annset are exported, if a list, only the
types in the list are exported.</dd>
<dt><strong><code>inline_annset</code></strong></dt>
<dd>annotation set for inline XML export.</dd>
<dt><strong><code>inline_features</code></strong></dt>
<dd>save features as attribute for inline XML export.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_gdoc(self,
              gdoc: py4j.java_gateway.JavaObject,
              path: str,
              mimetype: Optional[str] = None,
              inline_anntypes: Optional[List[str]] = None,
              inline_annset: Optional[str] = &#34;&#34;,
              inline_features: Optional[bool] = True):
    &#34;&#34;&#34;
    Save GATE document to the given path.

    Args:
      gdoc: GATE document handle
      path: destination path
      mimetype: mimtetype, only the following types are allowed: &#34;&#34;/None: GATE XML,
            application/fastinfoset, text/xml for inline XML, 
            and all mimetypes supported by the
            Format_Bdoc plugin. (Default value = None). 
      inline_anntypes: annotation types for inline XML export. Only works with mimetype xml.
            If None, all types in the inline_annset are exported, if a list, only the 
            types in the list are exported.
      inline_annset: annotation set for inline XML export.
      inline_features: save features as attribute for inline XML export.
    &#34;&#34;&#34;
    if mimetype is None:
        mimetype = &#34;&#34;
    self.worker.saveDocumentToFile(gdoc, path, mimetype, self.panntype2ganntype(inline_anntypes), inline_annset, inline_features)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.showGui"><code class="name flex">
<span>def <span class="ident">showGui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>(CAUTION: EXPERIMENTAL) this shows the GATE GUI if we a re connected to a GATE process that runs without
showing the GUI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showGui(self):
    &#34;&#34;&#34;
    (CAUTION: EXPERIMENTAL) this shows the GATE GUI if we a re connected to a GATE process that runs without
    showing the GUI.
    &#34;&#34;&#34;
    self.worker.showGui()</code></pre>
</details>
</dd>
<dt id="gatenlp.gateworker.gateworker.GateWorker.show_gui"><code class="name flex">
<span>def <span class="ident">show_gui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the GUI for the started GATE process.</p>
<p>NOTE: this is more of a hack and may cause sync problems
when closing down the GATE worker.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_gui(self):
    &#34;&#34;&#34;
    Show the GUI for the started GATE process.

    NOTE: this is more of a hack and may cause sync problems
    when closing down the GATE worker.
    &#34;&#34;&#34;
    self.worker.showGui()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.gateworker" href="index.html">gatenlp.gateworker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="gatenlp.gateworker.gateworker.check_port_used" href="#gatenlp.gateworker.gateworker.check_port_used">check_port_used</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.classpath_sep" href="#gatenlp.gateworker.gateworker.classpath_sep">classpath_sep</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.gate_classpath" href="#gatenlp.gateworker.gateworker.gate_classpath">gate_classpath</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.jar_loc" href="#gatenlp.gateworker.gateworker.jar_loc">jar_loc</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.run_gate_worker" href="#gatenlp.gateworker.gateworker.run_gate_worker">run_gate_worker</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.start_gate_worker" href="#gatenlp.gateworker.gateworker.start_gate_worker">start_gate_worker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.gateworker.gateworker.GateWorker" href="#gatenlp.gateworker.gateworker.GateWorker">GateWorker</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.close" href="#gatenlp.gateworker.gateworker.GateWorker.close">close</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.createDocument" href="#gatenlp.gateworker.gateworker.GateWorker.createDocument">createDocument</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.del_resource" href="#gatenlp.gateworker.gateworker.GateWorker.del_resource">del_resource</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.deleteResource" href="#gatenlp.gateworker.gateworker.GateWorker.deleteResource">deleteResource</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.findMavenPlugin" href="#gatenlp.gateworker.gateworker.GateWorker.findMavenPlugin">findMavenPlugin</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.gate_build" href="#gatenlp.gateworker.gateworker.GateWorker.gate_build">gate_build</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.gate_version" href="#gatenlp.gateworker.gateworker.GateWorker.gate_version">gate_version</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.gatehome" href="#gatenlp.gateworker.gateworker.GateWorker.gatehome">gatehome</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.gateprocess" href="#gatenlp.gateworker.gateworker.GateWorker.gateprocess">gateprocess</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.gateway" href="#gatenlp.gateworker.gateworker.GateWorker.gateway">gateway</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.gdoc2pdoc" href="#gatenlp.gateworker.gateworker.GateWorker.gdoc2pdoc">gdoc2pdoc</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.gdocanns2pdoc" href="#gatenlp.gateworker.gateworker.GateWorker.gdocanns2pdoc">gdocanns2pdoc</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getBdocJson" href="#gatenlp.gateworker.gateworker.GateWorker.getBdocJson">getBdocJson</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getCorpus4Name" href="#gatenlp.gateworker.gateworker.GateWorker.getCorpus4Name">getCorpus4Name</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getCorpusNames" href="#gatenlp.gateworker.gateworker.GateWorker.getCorpusNames">getCorpusNames</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getDocument4BdocJson" href="#gatenlp.gateworker.gateworker.GateWorker.getDocument4BdocJson">getDocument4BdocJson</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getDocument4Name" href="#gatenlp.gateworker.gateworker.GateWorker.getDocument4Name">getDocument4Name</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getDocumentNames" href="#gatenlp.gateworker.gateworker.GateWorker.getDocumentNames">getDocumentNames</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getPipeline4Name" href="#gatenlp.gateworker.gateworker.GateWorker.getPipeline4Name">getPipeline4Name</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getPipelineNames" href="#gatenlp.gateworker.gateworker.GateWorker.getPipelineNames">getPipelineNames</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getPr4Name" href="#gatenlp.gateworker.gateworker.GateWorker.getPr4Name">getPr4Name</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getPrNames" href="#gatenlp.gateworker.gateworker.GateWorker.getPrNames">getPrNames</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getResources4Name" href="#gatenlp.gateworker.gateworker.GateWorker.getResources4Name">getResources4Name</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getResources4NameClass" href="#gatenlp.gateworker.gateworker.GateWorker.getResources4NameClass">getResources4NameClass</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.getpid" href="#gatenlp.gateworker.gateworker.GateWorker.getpid">getpid</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.host" href="#gatenlp.gateworker.gateworker.GateWorker.host">host</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.jsonAnnsets4Doc" href="#gatenlp.gateworker.gateworker.GateWorker.jsonAnnsets4Doc">jsonAnnsets4Doc</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.jvm" href="#gatenlp.gateworker.gateworker.GateWorker.jvm">jvm</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.loadDocumentFromFile" href="#gatenlp.gateworker.gateworker.GateWorker.loadDocumentFromFile">loadDocumentFromFile</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.loadDocumentFromFile4Mime" href="#gatenlp.gateworker.gateworker.GateWorker.loadDocumentFromFile4Mime">loadDocumentFromFile4Mime</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.loadMavenPlugin" href="#gatenlp.gateworker.gateworker.GateWorker.loadMavenPlugin">loadMavenPlugin</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.loadPipelineFromFile" href="#gatenlp.gateworker.gateworker.GateWorker.loadPipelineFromFile">loadPipelineFromFile</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.loadPipelineFromPlugin" href="#gatenlp.gateworker.gateworker.GateWorker.loadPipelineFromPlugin">loadPipelineFromPlugin</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.loadPipelineFromUri" href="#gatenlp.gateworker.gateworker.GateWorker.loadPipelineFromUri">loadPipelineFromUri</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.load_gdoc" href="#gatenlp.gateworker.gateworker.GateWorker.load_gdoc">load_gdoc</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.load_pdoc" href="#gatenlp.gateworker.gateworker.GateWorker.load_pdoc">load_pdoc</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.logActions" href="#gatenlp.gateworker.gateworker.GateWorker.logActions">logActions</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.log_actions" href="#gatenlp.gateworker.gateworker.GateWorker.log_actions">log_actions</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.newCorpus" href="#gatenlp.gateworker.gateworker.GateWorker.newCorpus">newCorpus</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.pannspec2gannspec" href="#gatenlp.gateworker.gateworker.GateWorker.pannspec2gannspec">pannspec2gannspec</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.panntype2ganntype" href="#gatenlp.gateworker.gateworker.GateWorker.panntype2ganntype">panntype2ganntype</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.pdoc2gdoc" href="#gatenlp.gateworker.gateworker.GateWorker.pdoc2gdoc">pdoc2gdoc</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.platform" href="#gatenlp.gateworker.gateworker.GateWorker.platform">platform</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.pluginBuild" href="#gatenlp.gateworker.gateworker.GateWorker.pluginBuild">pluginBuild</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.pluginVersion" href="#gatenlp.gateworker.gateworker.GateWorker.pluginVersion">pluginVersion</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.port" href="#gatenlp.gateworker.gateworker.GateWorker.port">port</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.print2err" href="#gatenlp.gateworker.gateworker.GateWorker.print2err">print2err</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.print2out" href="#gatenlp.gateworker.gateworker.GateWorker.print2out">print2out</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.run4Corpus" href="#gatenlp.gateworker.gateworker.GateWorker.run4Corpus">run4Corpus</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.run4Document" href="#gatenlp.gateworker.gateworker.GateWorker.run4Document">run4Document</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.runExcecutionFinished" href="#gatenlp.gateworker.gateworker.GateWorker.runExcecutionFinished">runExcecutionFinished</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.runExcecutionStarted" href="#gatenlp.gateworker.gateworker.GateWorker.runExcecutionStarted">runExcecutionStarted</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.saveDocumentToFile" href="#gatenlp.gateworker.gateworker.GateWorker.saveDocumentToFile">saveDocumentToFile</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.save_gdoc" href="#gatenlp.gateworker.gateworker.GateWorker.save_gdoc">save_gdoc</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.showGui" href="#gatenlp.gateworker.gateworker.GateWorker.showGui">showGui</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.show_gui" href="#gatenlp.gateworker.gateworker.GateWorker.show_gui">show_gui</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.worker" href="#gatenlp.gateworker.gateworker.GateWorker.worker">worker</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.worker_build" href="#gatenlp.gateworker.gateworker.GateWorker.worker_build">worker_build</a></code></li>
<li><code><a title="gatenlp.gateworker.gateworker.GateWorker.worker_version" href="#gatenlp.gateworker.gateworker.GateWorker.worker_version">worker_version</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>