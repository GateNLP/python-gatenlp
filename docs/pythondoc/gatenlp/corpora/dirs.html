<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gatenlp.corpora.dirs API documentation</title>
<meta name="description" content="Module that defines Corpus and DocumentSource/DocumentDestination classes which access documents
as files in a directory." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.corpora.dirs</code></h1>
</header>
<section id="section-intro">
<p>Module that defines Corpus and DocumentSource/DocumentDestination classes which access documents
as files in a directory.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that defines Corpus and DocumentSource/DocumentDestination classes which access documents
as files in a directory.
&#34;&#34;&#34;

import os
from gatenlp.urlfileutils import yield_lines_from
from gatenlp.document import Document
from gatenlp.corpora.base import DocumentSource, DocumentDestination, Corpus
from gatenlp.corpora.base import MultiProcessingAble
from gatenlp.corpora.base import EveryNthBase


def matching_paths(dirpath, exts=None, recursive=True, relative=True):
    &#34;&#34;&#34;
    Yields all relative file paths from dirpath which match the list of extensions
    and which do not start with a dot.

    Args:
        dirpath: the directory to traverse
        exts: a list of allowed extensions (inluding the dot)
        recursive: if True (default) include all matching paths from all subdirectories as well, otherwise
          only paths from the top directory.
        relative: if True (default), the paths are relative to the directory path
    &#34;&#34;&#34;
    if recursive:
        for root, _, filenames in os.walk(dirpath):
            for fname in filenames:
                if exts:
                    for ext in exts:
                        if fname.endswith(ext) and not fname.startswith(&#34;.&#34;):
                            if relative:
                                yield os.path.relpath(
                                    os.path.join(root, fname), dirpath
                                )
                            else:
                                yield os.path.join(root, fname)
                            break
                else:
                    if not fname.startswith(&#34;.&#34;):
                        if relative:
                            yield os.path.relpath(os.path.join(root, fname), dirpath)
                        else:
                            yield os.path.join(root, fname)
    else:
        for fname in os.listdir(dirpath):
            full = os.path.join(dirpath, fname)
            if not os.path.isfile(full) or fname.startswith(&#34;.&#34;):
                pass
            elif exts:
                for ext in exts:
                    if fname.endswith(ext):
                        if relative:
                            yield os.path.relpath(full, dirpath)
                        else:
                            yield full
                        break
            else:
                if relative:
                    yield os.path.relpath(full, dirpath)
                else:
                    yield full


def maker_file_path_fromidx(digits=1, levels=1):
    &#34;&#34;&#34;
    Creates a method that returns a file path for the given number of leading digits and levels.

    Args:
        digits: minimum number of digits to use for the path, any number with less digits will have leading zeros
           added.
        levels: how to split the original sequence of digits into a hierarchical path name. For example if digits=10
           and levels=3, the generated function will convert the index number 23 into 0/000/000/023

    Returns:
        a function that takes the keyword arguments idx and doc and returns a relative path name (str)
    &#34;&#34;&#34;
    if (
        not isinstance(digits, int)
        or not isinstance(levels, int)
        or digits &lt; 1
        or levels &lt; 1
        or digits &lt; levels
    ):
        raise Exception(
            &#34;digits and levels must be integers larger than 0 and digits must not be smaller than &#34;
            f&#34;levels, got {digits}/{levels}&#34;
        )

    def file_path_fromidx(doc=None, idx=None):
        # NOTE: doc is unused here but used with other methods to create the file path!
        if idx is None or not isinstance(idx, int) or idx &lt; 0:
            raise Exception(&#34;Index must be an integer &gt;= 0&#34;)
        per = int(digits / levels)
        asstr = str(idx)
        digs = max(0, digits - len(asstr))
        tmp = &#34;0&#34; * digs
        tmp += str(idx)
        path = &#34;&#34;
        fromdigit = len(tmp) - per
        todigit = len(tmp)
        for _lvl in range(levels - 1):
            path = tmp[fromdigit:todigit] + path
            # print(&#34;per=&#34;, per, &#34;from=&#34;, fromdigit, &#34;to=&#34;, todigit, &#34;sec=&#34;, tmp[fromdigit:todigit])
            path = &#34;/&#34; + path
            fromdigit = fromdigit - per
            todigit = todigit - per
        path = tmp[:todigit] + path
        return path

    return file_path_fromidx


# TODO: set the special features for the relative path, index number, document id?
class DirFilesSource(DocumentSource, EveryNthBase, MultiProcessingAble):
    &#34;&#34;&#34;
    A document source which iterates over documents represented as files in a directory.
    &#34;&#34;&#34;
    def __init__(
        self,
        dirpath,
        paths=None,
        paths_from=None,
        exts=None,
        fmt=None,
        recursive=True,
        sort=False,
        nparts=1,
        partnr=0,
    ):
        &#34;&#34;&#34;
        Create a DirFilesSource.

        Args:
            dirpath: the directory that contains the file to load as documents.
            paths:  if not None, must be an iterable of relate file paths to load from the directory
            paths_from: if not None, must be a file or URL to load a list of file paths from
            exts: an iterable of allowed file extensions or file extension regexps
            fmt: the format to use for loading files. This is only useful if all files have the same format
               but the file extensions does not indicate the format.
            recursive: recursively include paths from all subdirectories as well
            sort: sort paths so they get processed in sort order. The paths get always sorted if every_n is &gt; 1.
            nshards: only yield every nshards-th document (default 1: every document)
            shardnr: start with that index, before yieldieng every nshards-th document (default 0: start at beginning)
        &#34;&#34;&#34;
        self.dirpath = dirpath
        if paths is not None and paths_from is not None:
            raise Exception(&#34;Parameters paths and paths_from cannot be both specified&#34;)
        super().__init__(nparts=nparts, partnr=partnr)
        if paths is not None:
            self.paths = paths
        elif paths_from is not None:
            self.paths = []
            for pth in yield_lines_from(paths_from):
                self.paths.append(pth.rstrip(&#34;\n\r&#34;))
        else:
            self.paths = list(matching_paths(dirpath, exts=exts, recursive=recursive))
        if sort or nparts &gt; 1:
            self.paths.sort()
        if nparts &gt; 1:
            self.paths = [
                p
                for idx, p in enumerate(self.paths)
                if ((idx - partnr) % nparts) == 0
            ]
        self.fmt = fmt

    def __iter__(self):
        &#34;&#34;&#34;
        Yield the next document from the source.
        &#34;&#34;&#34;
        for p in self.paths:
            yield Document.load(os.path.join(self.dirpath, p), fmt=self.fmt)


class DirFilesDestination(DocumentDestination):
    &#34;&#34;&#34;
    A destination where each document is stored in a file in a directory or directory tree in some
    known serialization format. The filename or path of the file can be derived from a document feature,
    the document name, the running number of file added, or any function that can derive a file path
    from the document and the running number.
    &#34;&#34;&#34;

    def __init__(self, dirpath, path_from=&#34;idx&#34;, ext=&#34;bdocjs&#34;, fmt=None):
        &#34;&#34;&#34;
        Create a destination to store documents in files inside a directory or directory tree.

        Args:
            dirpath: the directory to contain the files
            path_from: one of options listed below. If a string is used as a path name, then the forward slash
                 is always used as the directory path separator, on all systems!
               * &#34;idx&#34;: just use the index/running number of the added document as the base name
               * &#34;idx:5&#34;: use the index/running number with at least 5 digits in the name.
               * &#34;idx:10:2&#34;: use the index and organize a total of 10 digits into a hierarchical
                   pathname of 2 levels, so 10:2 would mean the first 5 digits are for the name of the subdirectory
                   and the second 5 digits are for the file base name. 10:3 would have for levels, the first
                   subdirectory level with 1 digit, the next two with 3 digits and the remaining 3 digits for the
                   filename.
                   NOTE: &#34;idx&#34; by itself is equivalent to idx:1:1
                * &#34;feature:fname&#34;: use the document feature with the feature name fname as a relative path as is
                   but add the extension
                * &#34;name&#34;: use the document name as the relative path, but add extension.
                * somefunction: a function that should return the pathname (without extension) and should take two
                   keyword arguments: doc (the document) and idx (the running index of the document).
            ext: the file extension to add to all generated file names
            fmt: the format to use for serializing the document, if None, will try to determine from the extension.
        &#34;&#34;&#34;
        if not os.path.isdir(dirpath):
            raise Exception(&#34;Not a directory: &#34;, dirpath)
        self.dirpath = dirpath
        self.idx = 0
        if path_from.startswith(&#34;idx&#34;):
            rest = path_from[
                3:
            ]  # if we have digits or levels, there is a leading colon!
            if len(rest) == 0:
                digits = 1
                levels = 1
            else:
                parms = rest.split(&#34;:&#34;)
                parms.append(1)
                digits, levels = parms[1:3]
                digits = int(digits)
                levels = int(levels)
            self.file_path_maker = maker_file_path_fromidx(digits, levels)
        elif path_from.startswith(&#34;feature&#34;):
            _, fname = path_from.split(&#34;:&#34;)
            self.file_path_maker = lambda doc: doc.features[fname]
        elif path_from == &#34;name&#34;:
            self.file_path_maker = lambda doc: doc.name
        elif callable(path_from):
            self.file_path_maker = path_from
        else:
            raise Exception(f&#34;Not allowed for path_from: {path_from}&#34;)
        if not ext.startswith(&#34;.&#34;):
            ext = &#34;.&#34; + ext
        self.ext = ext
        self.fmt = fmt

    def append(self, doc):
        &#34;&#34;&#34;
        Add a document to the destination.

        Args:
            doc: the document or None, if None, no action is performed.
        &#34;&#34;&#34;
        if doc is None:
            return
        assert isinstance(doc, Document)
        path = self.file_path_maker(doc=doc, idx=self.idx)
        path = os.path.normpath(
            path
        )  # convert forward slashes to backslashes on windows
        path = os.path.join(self.dirpath, path) + self.ext
        # check if we need to create the directories. For this we first need to get the directories part of the path,
        # which is everything left of the last slash
        if os.path.sep in path:
            dirs = path[: path.rindex(os.path.sep)]
            if not os.path.exists(os.path.normpath(dirs)):
                os.makedirs(dirs)
        Document.save(doc, path, fmt=self.fmt)
        self.idx += 1

    def close(self):
        pass


class DirFilesCorpus(Corpus, MultiProcessingAble):
    &#34;&#34;&#34;
    A corpus representing all files in a directory that match the given extension.
    &#34;&#34;&#34;

    def __init__(self, dirpath, ext=&#34;bdocjs&#34;, fmt=None, recursive=True, sort=False, sort_reverse=False):
        &#34;&#34;&#34;
        Creates the DirCorpus.

        Args:
            dirpath: the directory path
            ext: the file extension that must be matched by all files for the corpus
            fmt: the format to use, if None, will be determined from the extension
            recursive: if True (default) all matching files from all subdirectories are included
            sort: if True, sort by file paths, if a function sort by that function (default: False)
            sort_reverse: if sort is not False and this is True, sort in reverse order
        &#34;&#34;&#34;
        if not ext.startswith(&#34;.&#34;):
            ext = &#34;.&#34; + ext
        self.dirpath = dirpath
        self.ext = ext
        self.fmt = fmt
        self.paths = list(matching_paths(dirpath, exts=[ext], recursive=recursive))
        if sort:
            if callable(sort):
                self.paths.sort(key=sort, reverse=sort_reverse)
            else:
                self.paths.sort(reverse=sort_reverse)
        self.size = len(self.paths)

    def __len__(self):
        return self.size

    def __getitem__(self, idx):
        assert isinstance(idx, int)
        path = self.paths[idx]
        abspath = os.path.join(self.dirpath, path)
        doc = Document.load(abspath, fmt=self.fmt)
        doc.features[self.idxfeatname()] = idx
        # doc.features[&#34;__idx&#34;] = idx
        # doc.features[&#34;__relpath&#34;] = path
        # doc.features[&#34;__abspath&#34;] = abspath
        return doc

    def __setitem__(self, idx, doc):
        &#34;&#34;&#34;
        Set the document for a specific index.

        Args:
            idx: the index of the document
            doc: the Document, if None, no action is performed and the existing document is left unchanged
        &#34;&#34;&#34;
        if doc is None:
            return
        assert isinstance(idx, int)
        assert isinstance(doc, Document)
        path = self.paths[idx]
        doc.save(os.path.join(self.dirpath, path), fmt=self.fmt)


class NumberedDirFilesCorpus(Corpus, MultiProcessingAble):
    &#34;&#34;&#34;
    A corpus that represents files from a (nested) directory, where the filename is derived from
    the index number of the document. This corpus can represent missing elements as None, both
    on reading (when the corresponding expected document does not exist) and on writing (the
    corresponding document gets deleted).
    &#34;&#34;&#34;

    def __init__(
        self,
        dirpath,
        digits=1,
        levels=1,
        ext=&#34;bdocjs&#34;,
        fmt=None,
        size=None,
        store_none=True,
    ):
        &#34;&#34;&#34;
        Creates the NumberedDirFilesCorpus. This corpus, is able to return None for non-existing documents
        and remove document files by setting to None depending on the parameters.

        Args:
            dirpath: the directory path
            digits: the number of digits to use for the file path
            levels: the number of levels to split the digits up which are then used as subdire names.
            ext: the file extension used for all files in the corpus
            fmt: the format to use, if None, determined from the extension
            size: the size of the corpus. This can be used to create a corpus from an empty directory
                to contain only None elements initially.  It can also be used to limit access to only the
                first size elements if the directory contains more documents.
            store_none: if True, will store None in the corpus, i.e. remove the corresponding file from
                the directory. If False, will ignore the action and leave whatever is at the index unchanged.
        &#34;&#34;&#34;
        if not ext.startswith(&#34;.&#34;):
            ext = &#34;.&#34; + ext
        self.dirpath = dirpath
        self.ext = ext
        self.fmt = fmt
        self.size = size
        self.store_none = store_none
        self.file_path_maker = maker_file_path_fromidx(digits, levels)

    def __len__(self):
        return self.size

    def __getitem__(self, idx):
        assert isinstance(idx, int)
        path = self.file_path_maker(idx)
        path = path + self.ext
        abspath = os.path.join(self.dirpath, path)
        if os.path.exists(path):
            doc = Document.load(abspath, fmt=self.fmt)
            doc.features[self.idxfeatname()] = idx
            # doc.features[&#34;__idx&#34;] = idx
            # doc.features[&#34;__relpath&#34;] = path
            # doc.features[&#34;__abspath&#34;] = abspath
        else:
            doc = None
        return doc

    def __setitem__(self, idx, doc):
        assert isinstance(idx, int)
        assert doc is None or isinstance(doc, Document)
        path = self.file_path_maker(idx)
        path = path + self.ext
        if doc is None:
            if self.store_none:
                if os.path.exists(path):
                    os.remove(path)
        else:
            Document.save(os.path.join(self.dirpath, path), fmt=self.fmt)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gatenlp.corpora.dirs.maker_file_path_fromidx"><code class="name flex">
<span>def <span class="ident">maker_file_path_fromidx</span></span>(<span>digits=1, levels=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a method that returns a file path for the given number of leading digits and levels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>digits</code></strong></dt>
<dd>minimum number of digits to use for the path, any number with less digits will have leading zeros
added.</dd>
<dt><strong><code>levels</code></strong></dt>
<dd>how to split the original sequence of digits into a hierarchical path name. For example if digits=10
and levels=3, the generated function will convert the index number 23 into 0/000/000/023</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a function that takes the keyword arguments idx and doc and returns a relative path name (str)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maker_file_path_fromidx(digits=1, levels=1):
    &#34;&#34;&#34;
    Creates a method that returns a file path for the given number of leading digits and levels.

    Args:
        digits: minimum number of digits to use for the path, any number with less digits will have leading zeros
           added.
        levels: how to split the original sequence of digits into a hierarchical path name. For example if digits=10
           and levels=3, the generated function will convert the index number 23 into 0/000/000/023

    Returns:
        a function that takes the keyword arguments idx and doc and returns a relative path name (str)
    &#34;&#34;&#34;
    if (
        not isinstance(digits, int)
        or not isinstance(levels, int)
        or digits &lt; 1
        or levels &lt; 1
        or digits &lt; levels
    ):
        raise Exception(
            &#34;digits and levels must be integers larger than 0 and digits must not be smaller than &#34;
            f&#34;levels, got {digits}/{levels}&#34;
        )

    def file_path_fromidx(doc=None, idx=None):
        # NOTE: doc is unused here but used with other methods to create the file path!
        if idx is None or not isinstance(idx, int) or idx &lt; 0:
            raise Exception(&#34;Index must be an integer &gt;= 0&#34;)
        per = int(digits / levels)
        asstr = str(idx)
        digs = max(0, digits - len(asstr))
        tmp = &#34;0&#34; * digs
        tmp += str(idx)
        path = &#34;&#34;
        fromdigit = len(tmp) - per
        todigit = len(tmp)
        for _lvl in range(levels - 1):
            path = tmp[fromdigit:todigit] + path
            # print(&#34;per=&#34;, per, &#34;from=&#34;, fromdigit, &#34;to=&#34;, todigit, &#34;sec=&#34;, tmp[fromdigit:todigit])
            path = &#34;/&#34; + path
            fromdigit = fromdigit - per
            todigit = todigit - per
        path = tmp[:todigit] + path
        return path

    return file_path_fromidx</code></pre>
</details>
</dd>
<dt id="gatenlp.corpora.dirs.matching_paths"><code class="name flex">
<span>def <span class="ident">matching_paths</span></span>(<span>dirpath, exts=None, recursive=True, relative=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Yields all relative file paths from dirpath which match the list of extensions
and which do not start with a dot.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dirpath</code></strong></dt>
<dd>the directory to traverse</dd>
<dt><strong><code>exts</code></strong></dt>
<dd>a list of allowed extensions (inluding the dot)</dd>
<dt><strong><code>recursive</code></strong></dt>
<dd>if True (default) include all matching paths from all subdirectories as well, otherwise
only paths from the top directory.</dd>
<dt><strong><code>relative</code></strong></dt>
<dd>if True (default), the paths are relative to the directory path</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matching_paths(dirpath, exts=None, recursive=True, relative=True):
    &#34;&#34;&#34;
    Yields all relative file paths from dirpath which match the list of extensions
    and which do not start with a dot.

    Args:
        dirpath: the directory to traverse
        exts: a list of allowed extensions (inluding the dot)
        recursive: if True (default) include all matching paths from all subdirectories as well, otherwise
          only paths from the top directory.
        relative: if True (default), the paths are relative to the directory path
    &#34;&#34;&#34;
    if recursive:
        for root, _, filenames in os.walk(dirpath):
            for fname in filenames:
                if exts:
                    for ext in exts:
                        if fname.endswith(ext) and not fname.startswith(&#34;.&#34;):
                            if relative:
                                yield os.path.relpath(
                                    os.path.join(root, fname), dirpath
                                )
                            else:
                                yield os.path.join(root, fname)
                            break
                else:
                    if not fname.startswith(&#34;.&#34;):
                        if relative:
                            yield os.path.relpath(os.path.join(root, fname), dirpath)
                        else:
                            yield os.path.join(root, fname)
    else:
        for fname in os.listdir(dirpath):
            full = os.path.join(dirpath, fname)
            if not os.path.isfile(full) or fname.startswith(&#34;.&#34;):
                pass
            elif exts:
                for ext in exts:
                    if fname.endswith(ext):
                        if relative:
                            yield os.path.relpath(full, dirpath)
                        else:
                            yield full
                        break
            else:
                if relative:
                    yield os.path.relpath(full, dirpath)
                else:
                    yield full</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.corpora.dirs.DirFilesCorpus"><code class="flex name class">
<span>class <span class="ident">DirFilesCorpus</span></span>
<span>(</span><span>dirpath, ext='bdocjs', fmt=None, recursive=True, sort=False, sort_reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A corpus representing all files in a directory that match the given extension.</p>
<p>Creates the DirCorpus.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dirpath</code></strong></dt>
<dd>the directory path</dd>
<dt><strong><code>ext</code></strong></dt>
<dd>the file extension that must be matched by all files for the corpus</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>the format to use, if None, will be determined from the extension</dd>
<dt><strong><code>recursive</code></strong></dt>
<dd>if True (default) all matching files from all subdirectories are included</dd>
<dt><strong><code>sort</code></strong></dt>
<dd>if True, sort by file paths, if a function sort by that function (default: False)</dd>
<dt><strong><code>sort_reverse</code></strong></dt>
<dd>if sort is not False and this is True, sort in reverse order</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirFilesCorpus(Corpus, MultiProcessingAble):
    &#34;&#34;&#34;
    A corpus representing all files in a directory that match the given extension.
    &#34;&#34;&#34;

    def __init__(self, dirpath, ext=&#34;bdocjs&#34;, fmt=None, recursive=True, sort=False, sort_reverse=False):
        &#34;&#34;&#34;
        Creates the DirCorpus.

        Args:
            dirpath: the directory path
            ext: the file extension that must be matched by all files for the corpus
            fmt: the format to use, if None, will be determined from the extension
            recursive: if True (default) all matching files from all subdirectories are included
            sort: if True, sort by file paths, if a function sort by that function (default: False)
            sort_reverse: if sort is not False and this is True, sort in reverse order
        &#34;&#34;&#34;
        if not ext.startswith(&#34;.&#34;):
            ext = &#34;.&#34; + ext
        self.dirpath = dirpath
        self.ext = ext
        self.fmt = fmt
        self.paths = list(matching_paths(dirpath, exts=[ext], recursive=recursive))
        if sort:
            if callable(sort):
                self.paths.sort(key=sort, reverse=sort_reverse)
            else:
                self.paths.sort(reverse=sort_reverse)
        self.size = len(self.paths)

    def __len__(self):
        return self.size

    def __getitem__(self, idx):
        assert isinstance(idx, int)
        path = self.paths[idx]
        abspath = os.path.join(self.dirpath, path)
        doc = Document.load(abspath, fmt=self.fmt)
        doc.features[self.idxfeatname()] = idx
        # doc.features[&#34;__idx&#34;] = idx
        # doc.features[&#34;__relpath&#34;] = path
        # doc.features[&#34;__abspath&#34;] = abspath
        return doc

    def __setitem__(self, idx, doc):
        &#34;&#34;&#34;
        Set the document for a specific index.

        Args:
            idx: the index of the document
            doc: the Document, if None, no action is performed and the existing document is left unchanged
        &#34;&#34;&#34;
        if doc is None:
            return
        assert isinstance(idx, int)
        assert isinstance(doc, Document)
        path = self.paths[idx]
        doc.save(os.path.join(self.dirpath, path), fmt=self.fmt)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.corpora.base.Corpus" href="base.html#gatenlp.corpora.base.Corpus">Corpus</a></li>
<li>abc.ABC</li>
<li><a title="gatenlp.corpora.base.CorpusSourceBase" href="base.html#gatenlp.corpora.base.CorpusSourceBase">CorpusSourceBase</a></li>
<li>collections.abc.Sized</li>
<li>typing.Generic</li>
<li><a title="gatenlp.corpora.base.MultiProcessingAble" href="base.html#gatenlp.corpora.base.MultiProcessingAble">MultiProcessingAble</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.corpora.base.Corpus" href="base.html#gatenlp.corpora.base.Corpus">Corpus</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.corpora.base.Corpus.__getitem__" href="base.html#gatenlp.corpora.base.Corpus.__getitem__">__getitem__</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.__len__" href="base.html#gatenlp.corpora.base.Corpus.__len__">__len__</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.__setitem__" href="base.html#gatenlp.corpora.base.Corpus.__setitem__">__setitem__</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.append" href="base.html#gatenlp.corpora.base.Corpus.append">append</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.idxfeatname" href="base.html#gatenlp.corpora.base.Corpus.idxfeatname">idxfeatname</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.nparts" href="base.html#gatenlp.corpora.base.CorpusSourceBase.nparts">nparts</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.partnr" href="base.html#gatenlp.corpora.base.CorpusSourceBase.partnr">partnr</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.setidxfeature" href="base.html#gatenlp.corpora.base.Corpus.setidxfeature">setidxfeature</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.store" href="base.html#gatenlp.corpora.base.Corpus.store">store</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.corpora.dirs.DirFilesDestination"><code class="flex name class">
<span>class <span class="ident">DirFilesDestination</span></span>
<span>(</span><span>dirpath, path_from='idx', ext='bdocjs', fmt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A destination where each document is stored in a file in a directory or directory tree in some
known serialization format. The filename or path of the file can be derived from a document feature,
the document name, the running number of file added, or any function that can derive a file path
from the document and the running number.</p>
<p>Create a destination to store documents in files inside a directory or directory tree.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dirpath</code></strong></dt>
<dd>the directory to contain the files</dd>
<dt><strong><code>path_from</code></strong></dt>
<dd>one of options listed below. If a string is used as a path name, then the forward slash
is always used as the directory path separator, on all systems!
* "idx": just use the index/running number of the added document as the base name
* "idx:5": use the index/running number with at least 5 digits in the name.
* "idx:10:2": use the index and organize a total of 10 digits into a hierarchical
pathname of 2 levels, so 10:2 would mean the first 5 digits are for the name of the subdirectory
and the second 5 digits are for the file base name. 10:3 would have for levels, the first
subdirectory level with 1 digit, the next two with 3 digits and the remaining 3 digits for the
filename.
NOTE: "idx" by itself is equivalent to idx:1:1
* "feature:fname": use the document feature with the feature name fname as a relative path as is
but add the extension
* "name": use the document name as the relative path, but add extension.
* somefunction: a function that should return the pathname (without extension) and should take two
keyword arguments: doc (the document) and idx (the running index of the document).</dd>
<dt><strong><code>ext</code></strong></dt>
<dd>the file extension to add to all generated file names</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>the format to use for serializing the document, if None, will try to determine from the extension.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirFilesDestination(DocumentDestination):
    &#34;&#34;&#34;
    A destination where each document is stored in a file in a directory or directory tree in some
    known serialization format. The filename or path of the file can be derived from a document feature,
    the document name, the running number of file added, or any function that can derive a file path
    from the document and the running number.
    &#34;&#34;&#34;

    def __init__(self, dirpath, path_from=&#34;idx&#34;, ext=&#34;bdocjs&#34;, fmt=None):
        &#34;&#34;&#34;
        Create a destination to store documents in files inside a directory or directory tree.

        Args:
            dirpath: the directory to contain the files
            path_from: one of options listed below. If a string is used as a path name, then the forward slash
                 is always used as the directory path separator, on all systems!
               * &#34;idx&#34;: just use the index/running number of the added document as the base name
               * &#34;idx:5&#34;: use the index/running number with at least 5 digits in the name.
               * &#34;idx:10:2&#34;: use the index and organize a total of 10 digits into a hierarchical
                   pathname of 2 levels, so 10:2 would mean the first 5 digits are for the name of the subdirectory
                   and the second 5 digits are for the file base name. 10:3 would have for levels, the first
                   subdirectory level with 1 digit, the next two with 3 digits and the remaining 3 digits for the
                   filename.
                   NOTE: &#34;idx&#34; by itself is equivalent to idx:1:1
                * &#34;feature:fname&#34;: use the document feature with the feature name fname as a relative path as is
                   but add the extension
                * &#34;name&#34;: use the document name as the relative path, but add extension.
                * somefunction: a function that should return the pathname (without extension) and should take two
                   keyword arguments: doc (the document) and idx (the running index of the document).
            ext: the file extension to add to all generated file names
            fmt: the format to use for serializing the document, if None, will try to determine from the extension.
        &#34;&#34;&#34;
        if not os.path.isdir(dirpath):
            raise Exception(&#34;Not a directory: &#34;, dirpath)
        self.dirpath = dirpath
        self.idx = 0
        if path_from.startswith(&#34;idx&#34;):
            rest = path_from[
                3:
            ]  # if we have digits or levels, there is a leading colon!
            if len(rest) == 0:
                digits = 1
                levels = 1
            else:
                parms = rest.split(&#34;:&#34;)
                parms.append(1)
                digits, levels = parms[1:3]
                digits = int(digits)
                levels = int(levels)
            self.file_path_maker = maker_file_path_fromidx(digits, levels)
        elif path_from.startswith(&#34;feature&#34;):
            _, fname = path_from.split(&#34;:&#34;)
            self.file_path_maker = lambda doc: doc.features[fname]
        elif path_from == &#34;name&#34;:
            self.file_path_maker = lambda doc: doc.name
        elif callable(path_from):
            self.file_path_maker = path_from
        else:
            raise Exception(f&#34;Not allowed for path_from: {path_from}&#34;)
        if not ext.startswith(&#34;.&#34;):
            ext = &#34;.&#34; + ext
        self.ext = ext
        self.fmt = fmt

    def append(self, doc):
        &#34;&#34;&#34;
        Add a document to the destination.

        Args:
            doc: the document or None, if None, no action is performed.
        &#34;&#34;&#34;
        if doc is None:
            return
        assert isinstance(doc, Document)
        path = self.file_path_maker(doc=doc, idx=self.idx)
        path = os.path.normpath(
            path
        )  # convert forward slashes to backslashes on windows
        path = os.path.join(self.dirpath, path) + self.ext
        # check if we need to create the directories. For this we first need to get the directories part of the path,
        # which is everything left of the last slash
        if os.path.sep in path:
            dirs = path[: path.rindex(os.path.sep)]
            if not os.path.exists(os.path.normpath(dirs)):
                os.makedirs(dirs)
        Document.save(doc, path, fmt=self.fmt)
        self.idx += 1

    def close(self):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.corpora.base.DocumentDestination" href="base.html#gatenlp.corpora.base.DocumentDestination">DocumentDestination</a></li>
<li>contextlib.AbstractContextManager</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.corpora.dirs.DirFilesDestination.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, doc)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a document to the destination.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>doc</code></strong></dt>
<dd>the document or None, if None, no action is performed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, doc):
    &#34;&#34;&#34;
    Add a document to the destination.

    Args:
        doc: the document or None, if None, no action is performed.
    &#34;&#34;&#34;
    if doc is None:
        return
    assert isinstance(doc, Document)
    path = self.file_path_maker(doc=doc, idx=self.idx)
    path = os.path.normpath(
        path
    )  # convert forward slashes to backslashes on windows
    path = os.path.join(self.dirpath, path) + self.ext
    # check if we need to create the directories. For this we first need to get the directories part of the path,
    # which is everything left of the last slash
    if os.path.sep in path:
        dirs = path[: path.rindex(os.path.sep)]
        if not os.path.exists(os.path.normpath(dirs)):
            os.makedirs(dirs)
    Document.save(doc, path, fmt=self.fmt)
    self.idx += 1</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.corpora.base.DocumentDestination" href="base.html#gatenlp.corpora.base.DocumentDestination">DocumentDestination</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.corpora.base.DocumentDestination.close" href="base.html#gatenlp.corpora.base.DocumentDestination.close">close</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.corpora.dirs.DirFilesSource"><code class="flex name class">
<span>class <span class="ident">DirFilesSource</span></span>
<span>(</span><span>dirpath, paths=None, paths_from=None, exts=None, fmt=None, recursive=True, sort=False, nparts=1, partnr=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A document source which iterates over documents represented as files in a directory.</p>
<p>Create a DirFilesSource.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dirpath</code></strong></dt>
<dd>the directory that contains the file to load as documents.</dd>
<dt><strong><code>paths</code></strong></dt>
<dd>if not None, must be an iterable of relate file paths to load from the directory</dd>
<dt><strong><code>paths_from</code></strong></dt>
<dd>if not None, must be a file or URL to load a list of file paths from</dd>
<dt><strong><code>exts</code></strong></dt>
<dd>an iterable of allowed file extensions or file extension regexps</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>the format to use for loading files. This is only useful if all files have the same format
but the file extensions does not indicate the format.</dd>
<dt><strong><code>recursive</code></strong></dt>
<dd>recursively include paths from all subdirectories as well</dd>
<dt><strong><code>sort</code></strong></dt>
<dd>sort paths so they get processed in sort order. The paths get always sorted if every_n is &gt; 1.</dd>
<dt><strong><code>nshards</code></strong></dt>
<dd>only yield every nshards-th document (default 1: every document)</dd>
<dt><strong><code>shardnr</code></strong></dt>
<dd>start with that index, before yieldieng every nshards-th document (default 0: start at beginning)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirFilesSource(DocumentSource, EveryNthBase, MultiProcessingAble):
    &#34;&#34;&#34;
    A document source which iterates over documents represented as files in a directory.
    &#34;&#34;&#34;
    def __init__(
        self,
        dirpath,
        paths=None,
        paths_from=None,
        exts=None,
        fmt=None,
        recursive=True,
        sort=False,
        nparts=1,
        partnr=0,
    ):
        &#34;&#34;&#34;
        Create a DirFilesSource.

        Args:
            dirpath: the directory that contains the file to load as documents.
            paths:  if not None, must be an iterable of relate file paths to load from the directory
            paths_from: if not None, must be a file or URL to load a list of file paths from
            exts: an iterable of allowed file extensions or file extension regexps
            fmt: the format to use for loading files. This is only useful if all files have the same format
               but the file extensions does not indicate the format.
            recursive: recursively include paths from all subdirectories as well
            sort: sort paths so they get processed in sort order. The paths get always sorted if every_n is &gt; 1.
            nshards: only yield every nshards-th document (default 1: every document)
            shardnr: start with that index, before yieldieng every nshards-th document (default 0: start at beginning)
        &#34;&#34;&#34;
        self.dirpath = dirpath
        if paths is not None and paths_from is not None:
            raise Exception(&#34;Parameters paths and paths_from cannot be both specified&#34;)
        super().__init__(nparts=nparts, partnr=partnr)
        if paths is not None:
            self.paths = paths
        elif paths_from is not None:
            self.paths = []
            for pth in yield_lines_from(paths_from):
                self.paths.append(pth.rstrip(&#34;\n\r&#34;))
        else:
            self.paths = list(matching_paths(dirpath, exts=exts, recursive=recursive))
        if sort or nparts &gt; 1:
            self.paths.sort()
        if nparts &gt; 1:
            self.paths = [
                p
                for idx, p in enumerate(self.paths)
                if ((idx - partnr) % nparts) == 0
            ]
        self.fmt = fmt

    def __iter__(self):
        &#34;&#34;&#34;
        Yield the next document from the source.
        &#34;&#34;&#34;
        for p in self.paths:
            yield Document.load(os.path.join(self.dirpath, p), fmt=self.fmt)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.corpora.base.DocumentSource" href="base.html#gatenlp.corpora.base.DocumentSource">DocumentSource</a></li>
<li>abc.ABC</li>
<li>collections.abc.Iterable</li>
<li>typing.Generic</li>
<li><a title="gatenlp.corpora.base.CorpusSourceBase" href="base.html#gatenlp.corpora.base.CorpusSourceBase">CorpusSourceBase</a></li>
<li><a title="gatenlp.corpora.base.EveryNthBase" href="base.html#gatenlp.corpora.base.EveryNthBase">EveryNthBase</a></li>
<li><a title="gatenlp.corpora.base.MultiProcessingAble" href="base.html#gatenlp.corpora.base.MultiProcessingAble">MultiProcessingAble</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.corpora.base.DocumentSource" href="base.html#gatenlp.corpora.base.DocumentSource">DocumentSource</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.corpora.base.DocumentSource.nparts" href="base.html#gatenlp.corpora.base.CorpusSourceBase.nparts">nparts</a></code></li>
<li><code><a title="gatenlp.corpora.base.DocumentSource.partnr" href="base.html#gatenlp.corpora.base.CorpusSourceBase.partnr">partnr</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.corpora.dirs.NumberedDirFilesCorpus"><code class="flex name class">
<span>class <span class="ident">NumberedDirFilesCorpus</span></span>
<span>(</span><span>dirpath, digits=1, levels=1, ext='bdocjs', fmt=None, size=None, store_none=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A corpus that represents files from a (nested) directory, where the filename is derived from
the index number of the document. This corpus can represent missing elements as None, both
on reading (when the corresponding expected document does not exist) and on writing (the
corresponding document gets deleted).</p>
<p>Creates the NumberedDirFilesCorpus. This corpus, is able to return None for non-existing documents
and remove document files by setting to None depending on the parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dirpath</code></strong></dt>
<dd>the directory path</dd>
<dt><strong><code>digits</code></strong></dt>
<dd>the number of digits to use for the file path</dd>
<dt><strong><code>levels</code></strong></dt>
<dd>the number of levels to split the digits up which are then used as subdire names.</dd>
<dt><strong><code>ext</code></strong></dt>
<dd>the file extension used for all files in the corpus</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>the format to use, if None, determined from the extension</dd>
<dt><strong><code>size</code></strong></dt>
<dd>the size of the corpus. This can be used to create a corpus from an empty directory
to contain only None elements initially.
It can also be used to limit access to only the
first size elements if the directory contains more documents.</dd>
<dt><strong><code>store_none</code></strong></dt>
<dd>if True, will store None in the corpus, i.e. remove the corresponding file from
the directory. If False, will ignore the action and leave whatever is at the index unchanged.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NumberedDirFilesCorpus(Corpus, MultiProcessingAble):
    &#34;&#34;&#34;
    A corpus that represents files from a (nested) directory, where the filename is derived from
    the index number of the document. This corpus can represent missing elements as None, both
    on reading (when the corresponding expected document does not exist) and on writing (the
    corresponding document gets deleted).
    &#34;&#34;&#34;

    def __init__(
        self,
        dirpath,
        digits=1,
        levels=1,
        ext=&#34;bdocjs&#34;,
        fmt=None,
        size=None,
        store_none=True,
    ):
        &#34;&#34;&#34;
        Creates the NumberedDirFilesCorpus. This corpus, is able to return None for non-existing documents
        and remove document files by setting to None depending on the parameters.

        Args:
            dirpath: the directory path
            digits: the number of digits to use for the file path
            levels: the number of levels to split the digits up which are then used as subdire names.
            ext: the file extension used for all files in the corpus
            fmt: the format to use, if None, determined from the extension
            size: the size of the corpus. This can be used to create a corpus from an empty directory
                to contain only None elements initially.  It can also be used to limit access to only the
                first size elements if the directory contains more documents.
            store_none: if True, will store None in the corpus, i.e. remove the corresponding file from
                the directory. If False, will ignore the action and leave whatever is at the index unchanged.
        &#34;&#34;&#34;
        if not ext.startswith(&#34;.&#34;):
            ext = &#34;.&#34; + ext
        self.dirpath = dirpath
        self.ext = ext
        self.fmt = fmt
        self.size = size
        self.store_none = store_none
        self.file_path_maker = maker_file_path_fromidx(digits, levels)

    def __len__(self):
        return self.size

    def __getitem__(self, idx):
        assert isinstance(idx, int)
        path = self.file_path_maker(idx)
        path = path + self.ext
        abspath = os.path.join(self.dirpath, path)
        if os.path.exists(path):
            doc = Document.load(abspath, fmt=self.fmt)
            doc.features[self.idxfeatname()] = idx
            # doc.features[&#34;__idx&#34;] = idx
            # doc.features[&#34;__relpath&#34;] = path
            # doc.features[&#34;__abspath&#34;] = abspath
        else:
            doc = None
        return doc

    def __setitem__(self, idx, doc):
        assert isinstance(idx, int)
        assert doc is None or isinstance(doc, Document)
        path = self.file_path_maker(idx)
        path = path + self.ext
        if doc is None:
            if self.store_none:
                if os.path.exists(path):
                    os.remove(path)
        else:
            Document.save(os.path.join(self.dirpath, path), fmt=self.fmt)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.corpora.base.Corpus" href="base.html#gatenlp.corpora.base.Corpus">Corpus</a></li>
<li>abc.ABC</li>
<li><a title="gatenlp.corpora.base.CorpusSourceBase" href="base.html#gatenlp.corpora.base.CorpusSourceBase">CorpusSourceBase</a></li>
<li>collections.abc.Sized</li>
<li>typing.Generic</li>
<li><a title="gatenlp.corpora.base.MultiProcessingAble" href="base.html#gatenlp.corpora.base.MultiProcessingAble">MultiProcessingAble</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.corpora.base.Corpus" href="base.html#gatenlp.corpora.base.Corpus">Corpus</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.corpora.base.Corpus.__getitem__" href="base.html#gatenlp.corpora.base.Corpus.__getitem__">__getitem__</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.__len__" href="base.html#gatenlp.corpora.base.Corpus.__len__">__len__</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.__setitem__" href="base.html#gatenlp.corpora.base.Corpus.__setitem__">__setitem__</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.append" href="base.html#gatenlp.corpora.base.Corpus.append">append</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.idxfeatname" href="base.html#gatenlp.corpora.base.Corpus.idxfeatname">idxfeatname</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.nparts" href="base.html#gatenlp.corpora.base.CorpusSourceBase.nparts">nparts</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.partnr" href="base.html#gatenlp.corpora.base.CorpusSourceBase.partnr">partnr</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.setidxfeature" href="base.html#gatenlp.corpora.base.Corpus.setidxfeature">setidxfeature</a></code></li>
<li><code><a title="gatenlp.corpora.base.Corpus.store" href="base.html#gatenlp.corpora.base.Corpus.store">store</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.corpora" href="index.html">gatenlp.corpora</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gatenlp.corpora.dirs.maker_file_path_fromidx" href="#gatenlp.corpora.dirs.maker_file_path_fromidx">maker_file_path_fromidx</a></code></li>
<li><code><a title="gatenlp.corpora.dirs.matching_paths" href="#gatenlp.corpora.dirs.matching_paths">matching_paths</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.corpora.dirs.DirFilesCorpus" href="#gatenlp.corpora.dirs.DirFilesCorpus">DirFilesCorpus</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.corpora.dirs.DirFilesDestination" href="#gatenlp.corpora.dirs.DirFilesDestination">DirFilesDestination</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.corpora.dirs.DirFilesDestination.append" href="#gatenlp.corpora.dirs.DirFilesDestination.append">append</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.corpora.dirs.DirFilesSource" href="#gatenlp.corpora.dirs.DirFilesSource">DirFilesSource</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.corpora.dirs.NumberedDirFilesCorpus" href="#gatenlp.corpora.dirs.NumberedDirFilesCorpus">NumberedDirFilesCorpus</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>