<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev16+g8c2bb0d.d20201028" />
<title>gatenlp.pam.pampac API documentation</title>
<meta name="description" content="Module for PAMPAC (Pattern Matching wit PArser Combinators) which allows to create parsers that can match
patterns in annotations and text and carry â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.pam.pampac</code></h1>
</header>
<section id="section-intro">
<p>Module for PAMPAC (Pattern Matching wit PArser Combinators) which allows to create parsers that can match
patterns in annotations and text and carry out actions if a match occurs.</p>
<p>NOTE: this implementation has been inspired by <a href="https://github.com/google/compynator">https://github.com/google/compynator</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module for PAMPAC (Pattern Matching wit PArser Combinators) which allows to create parsers that can match
patterns in annotations and text and carry out actions if a match occurs.

NOTE: this implementation has been inspired by https://github.com/google/compynator
&#34;&#34;&#34;
import functools
from collections.abc import Iterable, Sized
from .matcher import AnnMatcher, CLASS_REGEX_PATTERN, CLASS_RE_PATTERN
from gatenlp.utils import support_annotation_or_set
from gatenlp import AnnotationSet
from gatenlp.utils import init_logger
from gatenlp import Span

# NOTES: Backreferences: to hard to implement this in a flexible way, simply use Filter on the final result

# TODO: implement pre-canned actions:
# AddAnn(): default span is the first result
# UpdateAnn(features, data=...)

# TODO: implement accessor functions
# accessor functions: ResultData(0, &#34;name&#34;, 2) - returns a function that accesses the 2nd data
#   of all the datas in the 0th result that match the given name
# ResultSpan(0), ResultAnn(0,&#34;name&#34;,2), ResultText(0,&#34;name&#34;,1)
# or better ResultSpan(&#34;name&#34;) or ResultSpan(name=&#34;name&#34;, result=0, data=2) with defaults for result, data
# ResultAnn(&#34;name&#34;) returns a function that returns the annotation later
# ResultAnn(&#34;name&#34;) / ResultAnnFeatures / ResultAnnFeature / ResultAnnType

# TODO: check that Context.end is respected with all individual parsers: we should not match beyond that offset!

# TODO: figure out which parser parameters could be implemented as parser modifiers instead/in addition???

# TODO: implement Gazetteer(gaz, matchtype=None) parser? Or TokenGazetteer(gaz, ...)
# TODO: implement Forward() / fwd.set(fwd | Ann(&#34;X&#34;))
# TODO: implement support for literal Text/Regexp: Seq(Ann(&#34;Token&#34;), &#34;text&#34;, regexp) and Ann &gt;&gt; &#34;text&#34; and &#34;text&#34; &gt;&gt; Ann()
#   and Ann() | text etc.
# !!TODO: options for skip:
# !!TODO: * overlapping=True/False: sequence element can overlap with previous match
# !!TODO: * skip=True/False: skip forward in annotation list until we find annotation that fits
# !!TODO: * mingap=n, maxgap=n: gap between annotation must be in this range
# !!TODO: so A.followedby(B) is equal to Seq(A,B, mingap=0, maxgap=0, skip=False/True)
# mindist, maxdist: from start to start (mingap/maxgap; from end to start).
# !!TODO: implement memoize: save recursive result and check max recursion, modifier: parser.memoize(maxdepth=5)
#   for the wrapped parsers, before each call to the wrapped parser, we first check if the result is already in
#   the memotable and return it. If not, calculate recursion depth and Fail if too deep, otherwise call wrapped
#   parser and memoize (store Success or Failure)


class Location:
    &#34;&#34;&#34;
    A ParseLocation represents the next location in the text and annotation list where a parser will try to
    match, i.e. the location after everything that has been consumed by the parser so far.

    The text offset equal to the length of the text represent the EndOfText condition and the annotation index
    equal to the length of the annotation list represents the EndOfAnns condition.
    &#34;&#34;&#34;

    def __init__(self, text_location=0, ann_location=0):
        self.text_location = text_location
        self.ann_location = ann_location

    def __str__(self):
        return f&#34;Location({self.text_location},{self.ann_location})&#34;

    def __repr__(self):
        return f&#34;Location({self.text_location},{self.ann_location})&#34;

    def __eq__(self, other):
        if not isinstance(other, Location):
            return False
        return (
            self.text_location == other.text_location
            and self.ann_location == other.ann_location
        )


class Result:
    &#34;&#34;&#34;
    Represents an individual parser result. A successful parse can have any number of parser results which
    are alternate ways of how the parser can match the document.
    &#34;&#34;&#34;
    def __init__(self, data=None, location=None, span=None):
        &#34;&#34;&#34;
        Creata parser result.

        Args:
            data: the data associated with the result, this should be a dictionary or None.
            location: the location where the result was matched, i.e. the location *before* matching was done.
            span: the span representing the start and end text offset for the match
        &#34;&#34;&#34;
        assert location is not None
        assert span is not None
        if data is not None:
            if isinstance(data, dict):
                self.data = [data]
            elif isinstance(data, Iterable):
                self.data = list(data)
            else:
                self.data = [data]
        else:
            self.data = []
        self.location = location
        self.span = span

    def data4name(self, name):
        &#34;&#34;&#34;
        Return a list of data dictionaries with the given name.
        &#34;&#34;&#34;
        return [d for d in self.data if d.get(&#34;name&#34;) == name]

    def __str__(self):
        return f&#34;Result(loc={self.location},span=({self.span.start},{self.span.end}),ndata={len(self.data)})&#34;

    def __repr__(self):
        return f&#34;Result(loc={self.location},span=({self.span.start},{self.span.end}),data={self.data})&#34;


class Failure:
    &#34;&#34;&#34;
    Represents a parse failure.
    &#34;&#34;&#34;

    def __init__(
        self,
        message=None,
        parser=None,
        location=None,
        causes=None,
        context=None,
    ):
        self.context = context
        self._parser = parser
        if not message:
            message = &#34;Parser Error&#34;
        self.message = message
        if location:
            self._cur_text = location.text_location
            self._cur_ann = location.ann_location
        else:
            self._cur_text = &#34;?&#34;
            self._cur_ann = &#34;?&#34;
        if isinstance(causes, Failure):
            self._causes = [causes]
        else:
            self._causes = causes

    def issuccess(self):
        return False

    def _get_causes(self):
        for cause in self._causes:
            if not cause._causes:
                # The root cause since there&#39;s no further failures.
                yield cause
            else:
                yield from cause._get_causes()

    def describe(self, indent=4, level=0):
        lead = &#34; &#34; * indent * level
        desc = (
            f&#34;{lead}{self._parser} at {self._cur_text}/{self._cur_ann}: &#34;
            f&#34;{self.message}&#34;
        )
        tail = &#34;&#34;
        if self._causes:
            tail = f&#34;\n{lead}Caused by:\n&#34; + &#34;\n&#34;.join(
                x.describe(indent, level + 1) for x in self._get_causes()
            )
        return desc + tail

    def __str__(self):
        return self.describe()

    def __repr__(self):
        return (
            f&#34;{self.__class__.__name__}({self.message!r}, &#34;
            f&#34;{self._cur_text!r}/{self._cur_ann}, {self._causes!r})&#34;
        )


class Success(Iterable, Sized):
    &#34;&#34;&#34;
    Represents a parse success as a possibly empty list of result elements.
    &#34;&#34;&#34;

    def __init__(self, results, context):
        if results is None:
            self._results = []
        elif isinstance(results, Iterable):
            self._results = list(results)
        else:
            self._results = [results]
        self.context = context

    def issuccess(self):
        return True

    def add(self, result, ifnew=False):
        # TODO: not sure if the ifnew parameter and treatment makes sense: do we ever not want
        # to add a result if it is already there (meaning, the same match and the same remaining text/anns).
        if isinstance(result, Iterable):
            for re in result:
                self.add(re, ifnew=ifnew)
        else:
            if ifnew:
                if result not in self._results:
                    self._results.append(result)
            else:
                self._results.append(result)
        return self

    def pprint(self, file=None):
        for idx, res in enumerate(self._results):
            if file:
                print(f&#34;Result {idx}, location={res.location}:&#34;, file=file)
            else:
                print(f&#34;Result {idx}, location={res.location}:&#34;, file=file)
            for jdx, d in enumerate(res.data):
                if file:
                    print(f&#34;  {jdx}: {d}&#34;, file)
                else:
                    print(f&#34;  {jdx}: {d}&#34;, file)

    @staticmethod
    def select_result(results, matchtype=&#34;first&#34;):
        &#34;&#34;&#34;
        Return the result described by parameter matchtype. If &#34;all&#34; returns the whole list of matches.

        Args:
            results: list of results to select from
            matchtype: one of  &#34;first&#34;, &#34;shortest&#34;, &#34;longest&#34;, &#34;all&#34;. If there is more than one longest or shortest
               result, the first one of those in the list is returned.

        Returns:
            the filtered match or matches
        &#34;&#34;&#34;
        if matchtype == None:
            matchtype = &#34;first&#34;
        if matchtype == &#34;all&#34;:
            return results
        elif matchtype == &#34;first&#34;:
            return results[0]
        elif matchtype == &#34;longest&#34;:
            result = results[0]
            loc = result.location
            for res in results:
                if res.location.text_location &gt; loc.text_location:
                    loc = res.location
                    result = res
            return result
        elif matchtype == &#34;shortest&#34;:
            result = results[0]
            loc = result.location
            for res in results:
                if res.location.text_location &lt; loc.text_location:
                    loc = res.location
                    result = res
            return result
        else:
            raise Exception(f&#34;Not a valid value for matchtype: {matchtype}&#34;)

    def result(self, matchtype=&#34;first&#34;):
        &#34;&#34;&#34;
        Return the result described by parameter matchtype. If &#34;all&#34; returns the whole list of matches.

        Args:
            matchtype: one of  &#34;first&#34;, &#34;shortest&#34;, &#34;longest&#34;, &#34;all&#34;. If there is more than one longest or shortest
               result, the first one of those in the list is returned.

        Returns:
            the filtered match or matches
        &#34;&#34;&#34;
        return Success.select_result(self._results, matchtype)

    def __iter__(self):
        return iter(self._results)

    def __len__(self):
        return len(self._results)

    def __eq__(self, other):
        if not isinstance(other, Success):
            return False
        return self._results == other._results

    def __str__(self):
        return str(self._results)

    def __getitem__(self, item):
        return self._results[item]


class Context:
    &#34;&#34;&#34;
    Context contains data and refers to data for carrying out the parse.
    &#34;&#34;&#34;

    def __init__(
        self, doc, anns, start=None, end=None, outset=None, memoize=False, max_recusion=None
    ):
        &#34;&#34;&#34;
        Initialize a parse context.

        Args:
            doc: the document which should get parsed
            anns: an iterable of annotations to use for the parsing
            start: the starting text offset for the parse
            end: the ending text offset for the parse
            outset: an annotation set for where to add any new annotations in an action
            memoize: If memoization should be used (NOT YET IMPLEMENTED)
            max_recusion: the maximum recursion depth for recursive parse rules (NOT YET IMPLEMENTED)
        &#34;&#34;&#34;
        self._memotable = {}
        self.max_recursion = max_recusion
        self.doc = doc
        self.outset = outset
        self._annset = None    # cache for the annotations as a detached immutable set, if needed
        # make sure the start and end offsets are plausible or set the default to start/end of document
        if start is None:
            self.start = 0
        else:
            if start &gt;= len(doc.text) or start &lt; 0:
                raise Exception(
                    &#34;Invalid start offset: {start}, document length is {len(doc.text}&#34;
                )
            self.start = start
        if end is None:
            self.end = len(doc.text)  # offset after the last text character!
        else:
            if end &lt;= start or end &gt; len(doc.text):
                raise Exception(&#34;Invalid end offset: {end}, start is {self.start}&#34;)
            self.end = end
        # make sure all the anns are within the given offset range
        anns = [a for a in anns if a.start &gt;= self.start and a.end &lt;= self.end]
        self.anns = anns
        self.memoize = memoize

    @property
    def annset(self):
        &#34;&#34;&#34;
        Return the annotations as a set.

        Returns:
            annotations as a detached immutable AnnotationSet

        &#34;&#34;&#34;
        if self._annset is None:
            self._annset = AnnotationSet.from_anns(self.anns)
        return self._annset

    def get_ann(self, location):
        &#34;&#34;&#34;
        Return the ann at the given location, or None if there is none (mainly for the end-of-anns index).

        Returns:
            annotation or None
        &#34;&#34;&#34;
        if location.ann_location &gt;= len(self.anns):
            return None
        return self.anns[location.ann_location]

    def nextidx4offset(self, location, offset, next_ann=False):
        &#34;&#34;&#34;
        Return the index of the next annotation that starts at or after the given text offset.
        If no such annotation exists the end of annotations index (equal to length of annotations) is returned.

        Args:
            location: current location, the annotation is searched from the annotation index following the one in the
               current location
            offset: offset to look for
            next_ann: if True, always finds the NEXT annotation after the one pointed at with the current location.
               If false keeps the current one if it is still the next one.

        Returns:
            annotation index
        &#34;&#34;&#34;
        idx = location.ann_location
        if next_ann:
            idx += 1
        while True:
            if idx &gt;= len(self.anns):
                return len(self.anns)
            ann = self.anns[idx]
            if ann.start &gt;= offset:
                return idx
            idx += 1

    def inc_location(self, location, by_offset=None, by_index=None):
        &#34;&#34;&#34;
        Return a new location which represents the given location incremented by either the given number of index
        count (usually 1), or by the given offset length. Only one of the by parameters should be specified.

        If the update occurs by offset, then the annotation index is updated to that of the next index with
        a start offset equal or larger than the updated text offset.  This may be the end of annotations index.
        If the text offset hits the end of text offset, the annotation index is set to the end of annotations index.

        If the update occurs by index, then the text offset is updated to the offset corresponding to the end offset
        of the annotation, if there is one.


        Args:
            location:
            by_offset: the number of text characters to increment the text offset by
            by_index:  the number of annotations to increment the index by

        Returns:
            new location
        &#34;&#34;&#34;
        newloc = Location(
            text_location=location.text_location, ann_location=location.ann_location
        )
        if by_index is not None:
            # get the annotation before the one we want to point at next, so we get the end offset of the
            # last annotation consumed
            newloc.ann_location += by_index - 1
            ann = self.get_ann(location)
            # if we already are at the end of the annotations, just leave everything as it is
            if not ann:
                return location
            newloc.text_location = ann.end
            # this is now the index of the next ann or the end of anns index
            newloc.ann_location += 1
        else:
            # update by text offset
            if newloc.text_location + by_offset &gt;= self.end:
                # if we reach the end of the text, update the annotation index to end of annotations as well
                newloc.text_location = self.end
                newloc.ann_location = len(self.anns)
            else:
                # otherwise try to find the next matching annotation
                newloc.text_location += by_offset
                newloc.ann_location = self.nextidx4offset(
                    location, newloc.text_location
                )
                # if we got end of annotations index, we do NOT update the text to end of text!
                # we could still want to match something in the text after the last annotation.
        return newloc

    def update_location_byoffset(self, location):
        &#34;&#34;&#34;
        Update the passed location so that the annotation index is updated by the text offset: all annotations are
        skipped until the start offset of the annotation is at or past the text offset.

        Args:
            location: the location to update

        Returns:
            a new location with the annotation index updated
        &#34;&#34;&#34;
        for i in range(location.ann_location, len(self.anns)):
            if self.anns[i].start &gt;= location.text_location:
                return Location(location.text_location, i)
        return Location(location.text_location, len(self.anns))

    def update_location_byindex(self, location):
        &#34;&#34;&#34;
        Update the passed location from the annotation index and make sure it points to the end of the current
        annotation or the end of the document.

        Args:
            location: the location to update

        Returns:
            a new location with the text offset updated
        &#34;&#34;&#34;
        if location.ann_location == len(self.anns):
            return Location(len(self.doc.text), location.ann_location)
        else:
            return Location(
                location.text_location, self.anns[location.ann_location].end
            )

    def at_endoftext(self, location):
        &#34;&#34;&#34;
        Returns true if the location represents the end of text location

        Args:
            location: location

        Returns:
            True if we are at end of text
        &#34;&#34;&#34;
        return location.text_location &gt;= self.end

    def at_endofanns(self, location):
        &#34;&#34;&#34;
        Returns true if the location represents the end of anns location

        Args:
            location: location

        Returns:
            True if we are at end of anns
        &#34;&#34;&#34;
        return location.ann_location &gt;= len(self.anns)


class PampacParser:
    &#34;&#34;&#34;
    A Pampac parser, something that takes a context and returns a result.
    This can be used to decorate a function that should be used as the parser,
    or for subclassing specific parsers.

    When subclassing, the parse(location, context) method must be overriden!
    &#34;&#34;&#34;

    def __init__(self, parser_function):
        self.name = None
        self._parser_function = parser_function
        self.name = parser_function.__name__
        functools.update_wrapper(self, parser_function)

    def parse(self, location, context):
        return self._parser_function(location, context)

    def match(self, doc, anns=None, start=None, end=None, location=None):
        &#34;&#34;&#34;
        Runs the matcher on the given document and the given annotations. Annotations may be empty in which
        case only matching on text makes sense.

        Args:
            doc: the document to run matching on.
            anns: (default: None) a set or Iterable of annotations. If this is a list or Iterable, the annotations
               will get matched in the order given. If it is a set the &#34;natural&#34; order of annotations used
               by the annotation set iterator will be used.
            start:  the minimum text offset of a range where to look for matches. No annotations that start before
               that offset are included.
            end: the maximum text offset of a range where to look for matches. No annotation that ends after that
               offset and not text that ends after that offset should get included in the result.

        Returns:
            Either Success or Failure

        &#34;&#34;&#34;
        if anns is None:
            anns = []
        else:
            anns = list(anns)
        ctx = Context(doc, anns, start=start, end=end)
        if location is None:
            location = Location(ctx.start, 0)
        return self.parse(location, ctx)

    __call__ = match

    def call(self, func, onfailure=None):
        &#34;&#34;&#34;
        Returns a parser that is equivalent to this parser, but also calls the given function if there is success.

        Args:
            func: the function to call on the success. Should take the success object and arbitrary kwargs.
                context and location are kwargs that get passed.
            onfailure: the function to call on failure. Should take the failure object and arbitrary kwargs.
                context and location are kwargs that get passed.

        Returns:

        &#34;&#34;&#34;
        return Call(self, func, onfailure=onfailure)

    def __or__(self, other):
        return Or(self, other)

    def __rshift__(self, other):
        return Seq(self, other)

    def __and__(self, other):
        return And(self, other)

    def __xor__(self, other):
        &#34;&#34;&#34;
        Return a parser that succeeds if this or the other parser succeeds and return the union of all results.
        Fails if both parsers fail.

        NOTE: `a ^ b ^ c` is NOT the same as All(a,b,c) as the first will fail if b fails but the second will
        still return `a ^ c`

        Args:
            other:

        Returns:

        &#34;&#34;&#34;
        return All(self, other)

    def where(self, predicate, take_if=True):
        return Filter(self, predicate, take_if=take_if)

    def repeat(self, min=1, max=1):
        return N(self, min=min, max=max)

    def __mul__(self, n):
        if isinstance(n, int):
            return N(self, min=n, max=n)
        elif isinstance(n, tuple) and len(n) == 2:
            return N(self, min=n[0], max=n[1])
        elif isinstance(n, list) and len(n) == 2:
            return N(self, min=n[0], max=n[1])
        else:
            raise Exception(&#34;Not an integer or tuple or list of two integers&#34;)

    def _make_constraint_predicate(self, matcher, matchtype, constraint):
        &#34;&#34;&#34;
        Create predicate that can be used to filter results according to one of the
        annotation-based constraints like .within, .coextensive.

        Args:
            matcher: the annotation matcher
            matchtype: the matchtype for the filter
            constraint: the constraint to use on the annotation set

        Returns:
            predicate function

        &#34;&#34;&#34;
        def _predicate(result, context=None, **kwargs):
            anns = set()
            for d in result.data:
                ann = d.get(&#34;ann&#34;)
                if ann:
                    anns.add(ann)
            annset = context.annset
            # TODO: !!!!!!!  CHECK IF THIS IS CORRECT
            tocall = getattr(annset, constraint)
            annstocheck = tocall(result.span)
            for anntocheck in annstocheck:
                if matcher(anntocheck, context.doc):
                    if anntocheck in anns:
                        continue
                    return True
            return False
        return _predicate

    def _make_notconstraint_predicate(self, matcher, matchtype, constraint):
        &#34;&#34;&#34;
        Create predicate that can be used to filter results according to one of the
        annotation-based negated constraints like .notwithin, .notcoextensive.

        Args:
            matcher: the annotation matcher
            matchtype: the matchtype for the filter
            constraint: the constraint to use on the annotation set

        Returns:
            predicate function

        &#34;&#34;&#34;
        def _predicate(result, context=None, **kwargs):
            anns = set()
            for d in result.data:
                ann = d.get(&#34;ann&#34;)
                if ann:
                    anns.add(ann)
            annset = context.annset
            # TODO: !!!!!!!!!!!!! CHECK IF CORRECT, SPAN CORRECT?
            tocall = getattr(annset, constraint)
            annstocheck = tocall(result.span)
            matched = False
            for anntocheck in annstocheck:
                if matcher(anntocheck, context.doc):
                    if anntocheck in anns:
                        continue
                    matched = True
            return not matched
        return _predicate

    def within(self, type=None, features=None, features_eq=None, text=None, matchtype=&#34;first&#34;):
        &#34;&#34;&#34;
        Parser that succeeds if there is a success for the current parser that is within any annotation
        that matches the given properties and is different from that annotation.

        Args:
            type:
            features:
            features_eq:
            text:
            matchtype: return matches of all that are within the span according to the given strategy

        Returns:
            Parser modified to only match within a matching annotation
        &#34;&#34;&#34;
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_constraint_predicate(matcher, matchtype, &#34;covering&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def notwithin(self, type=None, features=None, features_eq=None, text=None, matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;covering&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def coextensive(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_constraint_predicate(matcher, matchtype, &#34;coextensive&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def notcoextensive(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;coextensive&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def overlapping(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_constraint_predicate(matcher, matchtype, &#34;overlapping&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def notoverlapping(self,type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;overlapping&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def covering(self, type=None, features=None, features_eq=None, text=None, matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_constraint_predicate(matcher, matchtype, &#34;within&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def notcovering(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;within&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def at(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_constraint_predicate(matcher, matchtype, &#34;start_eq&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def noat(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;start_eq&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def before(self, type=None, features=None, features_eq=None, text=None, immediately=False, matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )

        # predicate for this needs to check if there are matching annotations that start at or after
        # the END of the result
        def _predicate(result, context=None, **kwargs):
            anns = set()
            for d in result.data:
                ann = d.get(&#34;ann&#34;)
                if ann:
                    anns.add(ann)
            annset = context.annset
            if immediately:
                annstocheck = annset.start_eq(result.span.end)
            else:
                annstocheck = annset.start_ge(result.span.end)
            for anntocheck in annstocheck:
                if matcher(anntocheck, context.doc):
                    if anntocheck in anns:
                        continue
                    return True
            return False
        return Filter(self, _predicate, matchtype=matchtype)

    @support_annotation_or_set
    def notbefore(self,  type=None, features=None, features_eq=None, text=None, immediately=False, matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )

        def _predicate(result, context=None, **kwargs):
            anns = set()
            for d in result.data:
                ann = d.get(&#34;ann&#34;)
                if ann:
                    anns.add(ann)
            annset = context.annset
            if immediately:
                annstocheck = annset.start_eq(result.span.end)
            else:
                annstocheck = annset.start_ge(result.span.end)
            matched = False
            for anntocheck in annstocheck:
                if matcher(anntocheck, context.doc):
                    if anntocheck in anns:
                        continue
                    matched = True
            return not matched
        return Filter(self, _predicate, matchtype=matchtype)

    def lookahead(self, parser):
        &#34;&#34;&#34;
        Return a parser that makes sure the given parser has at least one match before returning success.

        Args:
            parser:

        Returns:

        &#34;&#34;&#34;
        return Lookahead(self, parser)


class Lookahead(PampacParser):
    def __init__(self, parser, laparser):
        self.parser = parser
        self.laparser = laparser

    def parse(self, location, context):
        if context.parse(location, context).issuccess():
            return self.parser.parse(location, context)
        else:
            return Failure(
                context=context, message=&#34;Lookahead failed&#34;, location=location
            )


class Filter(PampacParser):
    &#34;&#34;&#34;
    Select only some of the results returned by a parser success, call the predicate function on each to check.
    This can also be used to check a single result and decide if it should be a success or failure.
    &#34;&#34;&#34;

    def __init__(self, parser, predicate, take_if=True, matchtype=&#34;first&#34;):
        &#34;&#34;&#34;
        Invoke predicate with each result of a successful parse of parser and return success with the remaining
        list. If the remaining list is empty, return Failure.

        Args:
            parser: the parser to use
            predicate: the function to call for each result of the parser success
            take_if: if True takes if predicate returns True, otherwise if predicate returns false
            matchtype: how to choose among all the selected results
        &#34;&#34;&#34;
        self.parser = parser
        self.predicate = predicate
        self.take_if = take_if
        self.matchtype = matchtype

    def parse(self, location, context):
        ret = self.parser.parse(location, context)
        if ret.issuccess():
            res = []
            for r in ret:
                if self.predicate(r, context=context, location=location) == self.take_if:
                    res.append(r)
            if len(r) == 0:
                return Failure(
                    context=context,
                    location=location,
                    message=&#34;No result satisfies predicate&#34;,
                )
            else:
                return Success(res)
        else:
            return ret


class Call(PampacParser):
    def __init__(self, parser, func, onfailure=None):
        self.parser = parser
        self.func = func
        self.onfailure = onfailure

    def parse(self, location, context):
        ret = self.parser.parse(location, context)
        if ret.issuccess():
            self.func(ret,
                      context=context,
                      location=location,
                      name=self.parser.name,
                      parser=self.parser.__class__.__name__)
        else:
            if self.onfailure:
                self.onfailure(
                    ret,
                    context=context,
                    location=location,
                    name=self.parser.name,
                    parser=self.parser.__class__.__name__
                )
        return ret


class _AnnBase(PampacParser):
    &#34;&#34;&#34;
    Common code for both Ann and AnnAt&#34;
    &#34;&#34;&#34;
    def gap(self, min=0, max=0):
        &#34;&#34;&#34;
        Return a parser which only matches self if the next annotation offset starts at this distance
        from the current next text offset.

        Args:
            min: minimum gap size (default: 0)
            max: maximum gap size (default: 0)

        Returns:
            parser that tries to match only if the next annotation is within the gap range
        &#34;&#34;&#34;
        def _parse(location, context):
            ann = context.get_ann(location.ann_location)
            if ann is None:
                return Failure(context=context, location=location, message=&#34;No annotation left&#34;)
            if ann.start &gt;= location.text_location + min and ann.start &lt;= location.text_location + max:
                return self.parse(location, context)
            else:
                return Failure(context=context, location=location, message=&#34;Next ann not withing gap&#34;)
        return PampacParser(parser_function=_parse)

    def findgap(self, min=0, max=0):
        &#34;&#34;&#34;
        Return a parser which matches at the next location where an annotation satisfies the gap constraint
        with respect to the current text location.

        Args:
            min: minimum gap size (default 0)
            max: maximum gap size (default 0)

        Returns:
            parser that tries to match at the next annotation found within the gap range
        &#34;&#34;&#34;
        def _parse(location, context):
            idx = location.ann_location
            while True:
                ann = context.get_ann(idx)
                if ann is None:
                    return Failure(context=context, location=location, message=&#34;No annotation left&#34;)
                if ann.start &gt;= location.text_location + min and ann.start &lt;= location.text_location + max:
                    return self.parse(location, context)
                if ann.ann.start &gt; location.text_location + max:
                    return Failure(context=context, location=location, message=&#34;No annotation found withing gap&#34;)
                idx + 1
        return PampacParser(parser_function=_parse)


class AnnAt(_AnnBase):
    &#34;&#34;&#34;
    Parser for matching the first or all annotations at the offset for the next annotation in the list.
    &#34;&#34;&#34;

    def __init__(
        self,
        type=None,
        features=None,
        features_eq=None,
        text=None,
        matchtype=&#34;first&#34;,
        name=None,
        useoffset=True,
    ):
        self.type = type
        self.features = features
        self.features_eq = features_eq
        self.text = text
        self.name = name
        self._matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        self.matchtype = matchtype
        self.useoffset = useoffset

    def parse(self, location, context):
        if self.useoffset:
            location = context.update_location_byoffset(location)
        next_ann = context.get_ann(location)
        if not next_ann:
            return Failure(
                context=context,
                location=location,
                parser=self,
                message=&#34;No annotation left&#34;,
            )
        results = []
        start = next_ann.start
        matched = False
        while True:
            if self._matcher(next_ann):
                matched = True
                matchlocation = Location(
                    text_location=start, ann_location=location.ann_location
                )
                if self.name is None:
                    data = None
                else:
                    data = dict(
                        span=Span(next_ann),
                        location=matchlocation,
                        ann=next_ann,
                        name=self.name,
                    )
                # update location
                location = context.inc_location(location, by_index=1)
                result = Result(
                    data=data, location=location, span=Span(next_ann.start, next_ann.end)
                )
                if self.matchtype == &#34;first&#34;:
                    return Success(result, context)
                results.append(result)
                next_ann = context.get_ann(location)
                if not next_ann or next_ann.start != start:
                    break
            else:
                location = context.inc_location(location, by_index=1)
                next_ann = context.get_ann(location)
                if not next_ann or next_ann.start != start:
                    break
        if not matched:
            return Failure(
                context=context,
                parser=self,
                location=location,
                message=&#34;No matching annotation&#34;,
            )
        else:
            res = Success.select_result(results, matchtype=self.matchtype)
            return Success(res, context)


class Ann(_AnnBase):
    &#34;&#34;&#34;
    Parser for matching the next annotation in the annotation list.
    &#34;&#34;&#34;

    def __init__(
        self,
        type=None,
        features=None,
        features_eq=None,
        text=None,
        name=None,
        useoffset=True,
    ):
        &#34;&#34;&#34;

        Args:
            type: (default: None): type to match, string, regexp or predicate function
            features: (default: None): features to match, dictionary where each value is value, regexp or predicate function
               Annotation can contain additional features.
            features_eq: (default: None): features to match, annotation must not contain additional features
            text: (default: None): document text to match, string or regexp
            name: (default: None): if set to a non-empty string, saves the data and assigns that name to the data
            useoffset: if True, and a location is give where the next annotation starts before the text offset, skips
               forward in the annotation list until an annotation is found at or after that offset.
               If no such annotation found, fails. If False, always uses the next annotation in the list, no matter
               the offset.
        &#34;&#34;&#34;
        self.type = type
        self.features = features
        self.features_eq = features_eq
        self.text = text
        self.name = name
        self.useoffset = useoffset
        self._matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )

    def parse(self, location, context):
        &#34;&#34;&#34;
        Try to match the given annotation at the current context location. If we succeed,

        Args:
            location: the location of where to parse next
            context: parser context

        Returns:
            Success or Failure
        &#34;&#34;&#34;
        if self.useoffset:
            location = context.update_location_byoffset(location)
        next_ann = context.get_ann(location)
        if not next_ann:
            return Failure(
                context=context,
                parser=self,
                location=location,
                message=&#34;No annotation left&#34;,
            )
        # try to match it
        if self._matcher(next_ann, doc=context.doc):
            newlocation = context.inc_location(location, by_index=1)
            if self.name is not None:
                data = dict(
                    span=Span(next_ann),
                    location=location,
                    ann=next_ann,
                    name=self.name,
                )
            else:
                data = None
            span = Span(next_ann.start, next_ann.end)
            return Success(Result(data=data, span=span, location=newlocation), context)
        else:
            return Failure(location=location, context=context, parser=self)


class Find(PampacParser):
    &#34;&#34;&#34;
    A parser that tries another parser until it matches.
    &#34;&#34;&#34;

    def __init__(self, parser, by_anns=True):
        &#34;&#34;&#34;

        Args:
            parser: the parser to use for finding the match
            by_anns: if True, tries at each annotation index and the corresponding text offset, otherwise tries
               at each text offset and the corresponding ann index.
        &#34;&#34;&#34;
        self.parser = parser
        self.by_anns = by_anns

    def parse(self, location, context):
        while True:
            ret = self.parser.parse(location, context)
            if ret.issuccess():
                return ret
            else:
                if self.by_anns:
                    location = context.inc_location(location, by_index=1)
                    if context.at_endofanns(location):
                        return Failure(
                            context=context,
                            message=&#34;Not found via anns&#34;,
                            location=location,
                        )
                else:
                    location = context.inc_location(location, by_offset=1)
                    if context.at_endoftext(location):
                        return Failure(
                            context=context,
                            message=&#34;Not found via text&#34;,
                            location=location,
                        )


class Text(PampacParser):
    &#34;&#34;&#34;
    A parser that matches some text or regular expression
    &#34;&#34;&#34;

    def __init__(self, text, name=None, matchcase=True):
        &#34;&#34;&#34;

        Args:
            text: either text or a compiled regular expression
            name:  the name of the matcher, if None, no data is stored
            matchcase: if text is actual text, whether the match should be case sensitive or not
        &#34;&#34;&#34;
        self.text = text
        if isinstance(self.text, str) and not matchcase:
            self.text = self.text.upper()
        self.name = name
        self.matchcase = matchcase

    def parse(self, location, context):
        location = context.update_location_byindex(location)
        txt = context.doc.text[location.text_location :]
        if isinstance(self.text, CLASS_RE_PATTERN) or isinstance(
            self.text, CLASS_REGEX_PATTERN
        ):
            m = self.text.match(txt)
            if m:
                l = len(m.group())
                newlocation = context.inc_location(location, by_offset=l)
                if self.name:
                    data = dict(
                        location=location,
                        span=Span(location.text_location, location.text_location+len(m.group())),
                        text=m.group(),
                        groups=m.groups(),
                        name=self.name,
                    )
                else:
                    data = None
                span = Span(location.text_location, location.text_location + len(m.group()))
                return Success(
                    Result(data=data, location=newlocation, span=span), context
                )
            else:
                return Failure(context=context)
        else:
            if not self.matchcase:
                txt = txt.upper()
            if txt.startswith(self.text):
                if self.name:
                    data = dict(
                        span=Span(location.text_location, location.text_location+len(self.text)),
                        location=location,
                        text=self.text,
                        name=self.name,
                    )
                else:
                    data = None
                newlocation = context.inc_location(location, by_offset=len(self.text))
                span = Span(location.text_location, location.text_location + len(self.text))
                return Success(
                    Result(data=data, location=newlocation, span=span), context
                )
            else:
                return Failure(context=context)


class Or(PampacParser):
    &#34;&#34;&#34;
    Create a parser that accepts the first of all the parsers specified.
    &#34;&#34;&#34;

    def __init__(self, *parsers, matchtype=&#34;all&#34;):
        &#34;&#34;&#34;
        Creates a parser that tries each of the given parsers in order and uses the first
        one that finds a successful match only.

        Args:
            *parsers: two or more parsers to each try in sequence
            matchtype: which of the results from the successful parser to return.
        &#34;&#34;&#34;
        assert len(parsers) &gt; 0
        self.parsers = parsers
        self.matchtype = matchtype

    def parse(self, location, context):
        for p in self.parsers:
            ret = p.parse(location, context)
            if ret.issuccess():
                if self.matchtype == &#34;all&#34;:
                    return ret
                result = ret.result(self.matchtype)
                newloc = result.location
                return Success(
                    Result(result.data, location=newloc, span=result.span), context
                )
        return Failure(
            context=context, location=location, message=&#34;None of the choices match&#34;
        )


class And(PampacParser):
    &#34;&#34;&#34;
    Return a parser that is successful if all the parsers match at some location, and
    fails otherwise. Success always contains all results from all parsers.

    &#34;&#34;&#34;
    def __init__(self, *parsers):
        self.parsers = parsers

    def parse(self, location, context):
        results = []
        for p in self.parsers:
            ret = p.parse(location, context)
            if ret.issuccess():
                for r in ret:
                    results.append(r)
            else:
                return Failure(
                    context=context,
                    location=location,
                    message=&#34;Not all parsers succeed&#34;,
                )
        return Success(results)


class All(PampacParser):
    &#34;&#34;&#34;
    Return a parser that succeeds if one or more parsers succeed at some location.
    If success, all results from all succeeding parsers are included.
    &#34;&#34;&#34;
    def __init__(self, *parsers):
        self.parsers = parsers

    def parse(self, location, context):
        results = []
        for p in self.parsers:
            ret = p.parse(location, context)
            if ret.issuccess():
                for r in ret:
                    results.append(r)
        if len(results) &gt; 0:
            return Success(results)
        else:
            return Failure(
                context=context,
                location=location,
                message=&#34;None of the parsers succeeded&#34;,
            )


class Seq(PampacParser):
    &#34;&#34;&#34;
    A parser that represents a sequence of matching parsers. Each result of this parser combines
    all the data from the sequence element parsers. For matchtype all and select all, all paths
    through all the possible ways to match the sequence get combined into separate results of
    a successful parse.
    &#34;&#34;&#34;

    def __init__(self, *parsers, matchtype=&#34;first&#34;, select=&#34;first&#34;, name=None):
        &#34;&#34;&#34;

        Args:
            *parsers: one or more parsers
            matchtype: (default &#34;first&#34;) one of &#34;first&#34;, &#34;longest&#34;, &#34;shortest&#34;, &#34;all&#34;: which match to return.
              Note that even if a matchtype for a single match is specified, the parser may still need to
              generate an exponential number of combinations for all the results to select from.
            select: (default &#34;first&#34;) one of &#34;first&#34;, &#34;longest&#34;, &#34;shortest&#34;, &#34;all&#34;: which match to choose from each
              of the parsers. Only if &#34;all&#34; is used will more than one result be generated.
            name: if not None, a separate data element is added to the result with that name and
              a span that represents the span of the result.
        &#34;&#34;&#34;
        assert len(parsers) &gt; 0
        self.parsers = parsers
        if matchtype is None:
            matchtype = &#34;first&#34;
        assert matchtype in [&#34;first&#34;, &#34;longest&#34;, &#34;shortest&#34;, &#34;all&#34;]
        self.select = select
        self.matchtype = matchtype
        self.name = name

    def parse(self, location, context):
        if self.select != &#34;all&#34;:
            datas = []
            first = True
            start = None
            end = None
            for parser in self.parsers:
                ret = parser.parse(location, context)
                if ret.issuccess():
                    result = ret.result(self.select)
                    for d in result.data:
                        datas.append(d)
                    location = result.location
                    if first:
                        first = False
                        start = result.span.start
                    end = result.span.end
                else:
                    return Failure(
                        context=context, location=location, message=&#34;Mismatch in Seq&#34;
                    )
            if self.name:
                datas.append(dict(span=Span(start,end), name=self.name, location=location))
            return Success(
                Result(data=datas, location=location, span=Span(start, end)), context
            )
        else:
            # This does a depth-first enumeration of all matches: each successive parser gets tried
            # for each result of the previous one.

            def depthfirst(lvl, result):
                parser = self.parsers[lvl]
                ret = parser.parse(result.location, context)
                if ret.issuccess():
                    for res in ret:
                        datas = result.data.copy()
                        for d in res.data:
                            datas.append(d)
                        loc = res.location
                        span = Span(location.text_location, res.location.text_location)
                        if lvl == len(self.parsers) - 1:
                            if self.name:
                                datas.append(dict(span=Span(start, end),
                                                  location=loc,
                                                  name=self.name))
                            newresult = Result(datas, location=loc, span=span)
                            yield newresult
                        else:
                            newresult = Result(datas, location=loc, span=span)
                            yield from depthfirst(lvl + 1, newresult)

            gen = depthfirst(0, Result(data=[], location=location, span=Span(None, None)))
            all = []
            best = None
            for idx, result in enumerate(gen):
                if self.matchtype == &#34;first&#34; and idx == 0:
                    return Success(result, context)
                if self.matchtype == &#34;all&#34;:
                    all.append(result)
                elif self.matchtype == &#34;longest&#34;:
                    if best is None:
                        best = result
                    elif result.span.end&gt; best.span.end:
                        best = result
                elif self.matchtype == &#34;shortest&#34;:
                    if best is None:
                        best = result
                    elif result.span.end &lt; best.span.end:
                        best = result
            if self.matchtype == &#34;all&#34;:
                if len(all) &gt; 0:
                    return Success(all, context)
                else:
                    return Failure(context=context, location=location)
            else:
                if best is not None:
                    return Success(best, context)
                else:
                    return Failure(context=context, location=location)


class N(PampacParser):
    &#34;&#34;&#34;
    A parser that represents a sequence of k to l matching parsers, greedy.
    &#34;&#34;&#34;

    def __init__(
        self, parser, min=1, max=1, matchtype=&#34;first&#34;, select=&#34;first&#34;, until=None, name=None
    ):
        &#34;&#34;&#34;
        Return a parser that matches min to max matches of parser in sequence. If until is specified, that
        parser is tried to match before each iteration and as soon as it matched, the parser succeeds.
        If after ming to max matches of the parser, until does not match, the parser fails.

        Args:
            parser: the parser that should match min to max times
            min: minimum number of times to match for a success
            max: maximum number of times to match for a success
            matchtype: which results to include in a successful match, one of first, longest, shortest, all
            until: parser that terminates the repetition
            name: if not None, adds an additional data element to the result which contains the
              and span of the whole sequence.
        &#34;&#34;&#34;
        self.parser = parser
        self.min = min
        self.max = max
        self.matchtype = matchtype
        self.until = until
        self.select = select
        self.name = name

    def parse(self, location, context):
        start = location.text_location
        end = start
        if self.select != &#34;all&#34;:
            datas = []
            i = 0
            first = True
            # location is the location where we try to match
            while True:
                if self.until and i &gt;= self.min:
                    ret = self.until.parse(location, context)
                    if ret.issuccess():
                        res = ret.result(self.select)
                        data = res.data
                        for d in data:
                            datas.append(d)
                        loc = res.location
                        end = res.span.end
                        if self.name:
                            datas.append(dict(span=Span(start,end),
                                              location=loc,
                                              name=self.name))
                        return Success(
                            Result(datas, location=loc, span=Span(start, end)), context
                        )
                ret = self.parser.parse(location, context)
                if not ret.issuccess():
                    if i &lt; self.min:
                        return Failure(
                            context=context,
                            location=location,
                            message=f&#34;Not at least {self.min} matches&#34;,
                        )
                    else:
                        if self.name:
                            datas.append(dict(span=Span(start,end),
                                              location=location,
                                              name=self.name))
                        return Success(
                            Result(data=datas, location=location, span=Span(start, end)),
                            context,
                        )
                else:
                    result = ret.result(self.select)
                    if first:
                        first = False
                        start = result.span.start
                    end = result.span.end
                    data = result.data
                    for d in data:
                        datas.append(d)
                    location = result.location
                    i += 1
                    if i == self.max:
                        break
            if self.until:
                ret = self.until.parse(location, context)
                if ret.issuccess():
                    res = ret.result(self.select)
                    data = res.data
                    loc = res.location
                    end = res.span.end
                    for d in data:
                        datas.append(d)
                    if self.name:
                        datas.append(dict(span=Span(start, end),
                                          location=loc,
                                          name=self.name))
                    return Success(
                        Result(datas, location=loc, span=Span(start, end)), context
                    )
                else:
                    return Failure(
                        context=context,
                        location=location,
                        message=&#34;Until parser not successful&#34;,
                    )
            if self.name:
                datas.append(dict(span=Span(start, end),
                                  location=location,
                                  name=self.name))
            return Success(
                Result(data=datas, location=location, span=Span(start, end)), context
            )
        else:
            # This does a depth-first enumeration of all matches: each successive parser gets tried
            # for each result of the previous one.
            def depthfirst(lvl, result):
                # if we already have min matches and we can terminate early, do it
                if self.until and lvl &gt;= self.min:
                    ret = self.until.parse(result.location, context)
                    if ret.issuccess():
                        for res in ret:
                            data = result.data.copy()
                            for dtmp in res.data:
                                data.append(dtmp)
                            loc = res.location
                            end = res.span.end
                            if self.name:
                                data.append(dict(span=Span(start, end),
                                                 location=location,
                                                 name=self.name))
                            yield Result(data, location=loc, span=Span(start, end))
                            return
                # if we got here after the max number of matches, and self.until is set, then
                # the parse we did above did not succeed, so we end without a result
                if self.until and lvl &gt; self.max:
                    return
                # if we got here after the max number of matches and self.util is not set, we
                # can yield the current result as we found max matches
                if lvl &gt;= self.max:
                    yield result
                    return
                # lvl is still smaller than max, so we try to match more
                ret = self.parser.parse(result.location, context)
                if ret.issuccess():
                    # for each of the results, try to continue matching
                    for res in ret:
                        datas = result.data.copy()
                        for d in res.data:
                            datas.append(d)
                        loc = res.location
                        span = Span(location.text_location, res.location.text_location)
                        newresult = Result(datas, location=loc, span=span)
                        yield from depthfirst(lvl + 1, newresult)
                else:
                    if lvl &lt;= self.min:
                        return
                    else:
                        # we already have at least min matches: if we have no until, we can yield the result
                        if not self.until:
                            data = result.data
                            end = result.span.end
                            if self.name:
                                data.append(dict(span=Span(start, end),
                                                 location=result.location,
                                                 name=self.name))
                            yield result
                        else:
                            # if we have until, then the until above did not match so neither the normal parser
                            # nor the until did match so we do not have a success
                            return

            gen = depthfirst(0, Result(data=[], location=location, span=(None, None)))
            all = []
            best = None
            for idx, result in enumerate(gen):
                if self.matchtype == &#34;first&#34; and idx == 0:
                    return Success(result, context)
                if self.matchtype == &#34;all&#34;:
                    all.append(result)
                elif self.matchtype == &#34;longest&#34;:
                    if best is None:
                        best = result
                    elif result.span.end &gt; best.span.end:
                        best = result
                elif self.matchtype == &#34;shortest&#34;:
                    if best is None:
                        best = result
                    elif result.span.end &lt; best.span.end:
                        best = result
            if self.matchtype == &#34;all&#34;:
                if len(all) &gt; 0:
                    return Success(all, context)
                else:
                    return Failure(context=context, location=location)
            else:
                if best is not None:
                    return Success(best, context)
                else:
                    return Failure(context=context, location=location)


class Rule(PampacParser):
    &#34;&#34;&#34;
    A matching rule: this defines the parser and some action (a function) to carry out if the rule matches
    as it is tried as one of many rules with a Pampac instance. Depending on select setting for pampac
    the action only fires under certain circumstances (e.g. the rule is the first that matches at a location).
    Rule is thus different from pattern.call() or Call(pattern, func) as these always call the function if
    there is a successful match.
    &#34;&#34;&#34;

    def __init__(self, parser, action, priority=0):
        self.parser = parser
        self.action = action
        self.priority = priority

    def set_priority(self, val):
        &#34;&#34;&#34;
        Different way of setting the priority.
        &#34;&#34;&#34;
        self.priority = val
        return self

    def parse(self, location, context):
        &#34;&#34;&#34;
        Return the parse result. This does NOT automatically invoke the action if the parse result is a success.
        The invoking Pampac instance decides, based on its setting, for which matching rules the action is
        actually carried out.

        Returns:
            Success or failure of the parser

        &#34;&#34;&#34;
        return self.parser.parse(location, context)


class Pampac:
    &#34;&#34;&#34;
    A class for applying a sequence of rules to a document.

    &#34;&#34;&#34;
    def __init__(self, *rules, skip=&#34;longest&#34;, select=&#34;first&#34;):
        &#34;&#34;&#34;
        Initialize Pampac.

        Args:
            *rules: one or more rules
            skip:  how proceed after something has been matched at a position. One of: &#34;longest&#34; to proceed
              at the next text offset after the end of the longest match. &#34;next&#34; to use a location with the highest
              text and annotation index over all matches. &#34;one&#34; to increment the text offset by one and adjust
              the annotation index to point to the next annotation at or after the new text offset.
              &#34;once&#34;: do not advance after the first location where a rule matches. NOTE: if skipping depends on
              on the match(es), only those matches for which a rule fires are considered.
            select: which of those rules that match to actually apply, i.e. call the action part of the rule.
              One of: &#34;first&#34;: try all rules in sequence and call only the first one that matches. &#34;highest&#34;: try
              all rules and only call the rules which has the highest priority, if there is more than one, the first
              of those.
        &#34;&#34;&#34;
        assert len(rules) &gt; 0
        assert skip in [&#34;one&#34;, &#34;longest&#34;, &#34;next&#34;, &#34;once&#34;]
        assert select in [&#34;first&#34;, &#34;highest&#34;, &#34;all&#34;]
        for r in rules:
            assert isinstance(r, Rule)
        self.rules = rules
        self.priorities = [r.priority for r in self.rules]
        self.max_priority = max(self.priorities)
        for idx, r in enumerate(rules):
            if r.priority == self.max_priority:
                self.hp_rule = r
                self.hp_rule_idx = idx
                break
        self.skip = skip
        self.select = select

    def set_skip(self, val):
        &#34;&#34;&#34;
        Different way to set the skip parameter.
        &#34;&#34;&#34;
        self.skip = val
        return self

    def set_select(self, val):
        &#34;&#34;&#34;
        Different way to set the select parameter.
        &#34;&#34;&#34;
        self.select = val
        return self

    def run(self, doc, annotations, outset=None, start=None, end=None, debug=False):
        &#34;&#34;&#34;
        Run the rules from location start to location end (default: full document), using the annotation set or list.

        Args:
            doc: the document to run on
            annotations: the annotation set or iterable to use
            outset: the output annotation set.
            start: the text offset where to start matching
            end: the text offset where to end matching

        Returns:
            a list of tuples (offset, actionreturnvals) for each location where one or more matches occurred
        &#34;&#34;&#34;
        logger = init_logger(debug=debug)
        ctx = Context(doc=doc, anns=annotations, outset=outset, start=start, end=end)
        returntuples = []
        location = Location(ctx.start, 0)
        while True:
            # try the rules at the current position
            cur_offset = location.text_location
            frets = []
            rets = dict()
            for idx, r in enumerate(self.rules):
                logger.debug(f&#34;Trying rule {idx} at location {location}&#34;)
                ret = r.parse(location, ctx)
                if ret.issuccess():
                    rets[idx] = ret
                    logger.debug(f&#34;Success for rule {idx}, {len(ret)} results&#34;)
                    if self.select == &#34;first&#34;:
                        break
            # we now got all the matching results in rets
            # if we have at least one matching ...
            if len(rets) &gt; 0:
                fired_rets = []
                # choose the rules to fire and call the actions
                if self.select == &#34;first&#34;:
                    idx, ret = list(rets.items())[0]
                    logger.debug(f&#34;Firing rule {idx} at {location}&#34;)
                    fret = self.rules[idx].action(ret, context=ctx, location=location)
                    frets.append(fret)
                    fired_rets.append(ret)
                elif self.select == &#34;all&#34;:
                    for idx, ret in rets.items():
                        logger.debug(f&#34;Firing rule {idx} at {location}&#34;)
                        fret = self.rules[idx].action(ret, context=ctx, location=location)
                        frets.append(fret)
                        fired_rets.append(ret)
                elif self.select == &#34;highest&#34;:
                    for idx, ret in rets.items():
                        if idx == self.hp_rule_idx:
                            logger.debug(f&#34;Firing rule {idx} at {location}&#34;)
                            fret = self.rules[idx].action(ret, context=ctx, location=location)
                            frets.append(fret)
                            fired_rets.append(ret)
                # now that we have fired rules, find out how to advance to the next position
                if self.skip == &#34;once&#34;:
                    return frets
                elif self.skip == &#34;once&#34;:
                    location = ctx.inc_location(location, by_offset=1)
                elif self.skip == &#34;longest&#34;:
                    longest = 0
                    for ret in fired_rets:
                        for res in ret:
                            if res.location.text_location &gt; longest:
                                longest = res.location.text_location
                    location.text_location = longest
                    location = ctx.update_location_byoffset(location)
                elif self.skip == &#34;next&#34;:
                    for ret in fired_rets:
                        for res in ret:
                            if res.location.text_location &gt; location.text_location:
                                location.text_location = res.location.text_location
                                location.ann_location = res.location.ann_location
                            elif res.location.text_location == location.text_location and \
                                    res.location.ann_location &gt; location.ann_location:
                                location.ann_location = res.location.ann_location
                returntuples.append((cur_offset, frets))
            else:
                # we had no match, just continue from the next offset
                location = ctx.inc_location(location, by_offset=1)
            if ctx.at_endofanns(location) or ctx.at_endoftext(location):
                break
        return returntuples

    __call__ = run


def _get_data(succ, name, resultidx=0, dataidx=0, silent_fail=False):
    &#34;&#34;&#34;
    Helper method to return the data for the given result index and name, or None.

    Args:
        succ: success instance
        name: name of the data
        resultidx: index of the result in success
        dataidx: if there is more than one matching data with that name, which one to return
        silent_fail: if True, return None, if False, raise an exception if the data is not present

    Returns:
        the data or None

    &#34;&#34;&#34;
    if resultidx &gt;= len(succ):
        if not silent_fail:
            raise Exception(f&#34;No resultidx {resultidx}, only {len(succ)} results&#34;)
        else:
            return
    res = succ[resultidx]
    data = res.data4name(name)
    if not data:
        if not silent_fail:
            raise Exception(f&#34;No data with name {name} in result&#34;)
        else:
            return
    if dataidx &gt;= len(data):
        if not silent_fail:
            raise Exception(f&#34;No data with index {dataidx}, length is {len(data)}&#34;)
        else:
            return
    return data[dataidx]


# ACTIONS:

class AddAnn:
    def __init__(self,
                 name=None,
                 ann=None,   # create a copy of this ann retrieved with GetAnn
                 anntype=None,  # or create a new annotation with this type
                 features=None,
                 span=None,   # use literal span, GetSpan, if none, span from match
                 resultidx=0, dataidx=0,
                 silent_fail=False,
                 ):
        # span is either a span, the index of data to take the span from, or a callable that will return the
        # span at firing time
        assert name
        assert anntype is not None or ann is not None
        self.name = name
        self.anntype = anntype
        self.ann = ann
        self.features = features
        self.span = span
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        span = data[&#34;span&#34;]
        outset = context.outset
        if self.ann:
            ann = self.ann(succ)
            if ann is None:
                if self.silent_fail:
                    return
                else:
                    raise Exception(&#34;No matching annotation found&#34;)
            outset.add_ann(ann)
        else:
            if self.span:
                if callable(self.span):
                    span = self.span(succ, context=context, location=location)
                else:
                    span = self.span
            if callable(self.anntype):
                anntype = self.anntype(succ, context=context, location=location)
            else:
                anntype = self.anntype
            if self.features:
                if callable(self.features):
                    features = self.features(succ, context=context, location=location)
                else:
                    features = self.features
            else:
                features = None
            outset.add(span.start, span.end, anntype, features=features)


class UpdateAnnFeatures:
    def __init__(self, name,
                 ann=None,  # ann to update
                 features=None,
                 replace=False,  # replace existing features rather than updating
                 resultidx=0, dataidx=0,
                 silent_fail=False,
                 ):
        # span is either a span, the index of data to take the span from, or a callable that will return the
        # span at firing time
        assert isinstance(ann, GetAnn)
        assert features is not None
        self.name = name
        self.ann = ann
        self.replace = replace
        self.features = features
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        ann = self.ann(succ)
        if ann is None:
            if self.silent_fail:
                return
            else:
                raise Exception(&#34;No matching annotation found&#34;)
        if callable(self.features):
            features = self.features(succ, context=context, location=location)
        else:
            features = self.features
        if self.replace:
            ann.features.clear()
        ann.features.update(features)

# GETTERS


class GetAnn:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        ann = data.get(&#34;ann&#34;)
        if ann is None:
            if not self.silent_fail:
                raise Exception(f&#34;No annotation found for name {self.name}, {self.resultidx}, {self.dataidx}&#34;)
        return ann


class GetFeatures:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        ann = data.get(&#34;ann&#34;)
        if ann is None:
            if not self.silent_fail:
                raise Exception(f&#34;No annotation found for name {self.name}, {self.resultidx}, {self.dataidx}&#34;)
        return ann.features


class GetType:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        ann = data.get(&#34;ann&#34;)
        if ann is None:
            if not self.silent_fail:
                raise Exception(f&#34;No annotation found for name {self.name}, {self.resultidx}, {self.dataidx}&#34;)
        return ann.type


class GetStart:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        span = data[&#34;span&#34;]
        return span.start


class GetEnd:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        span = data[&#34;span&#34;]
        return span.end


class GetFeature:
    def __init__(self, name, featurename, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail
        self.featurename = featurename

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        ann = data.get(&#34;ann&#34;)
        if ann is None:
            if not self.silent_fail:
                raise Exception(f&#34;No annotation found for name {self.name}, {self.resultidx}, {self.dataidx}&#34;)
        return ann.features.get(self.featurename)


class GetText:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        span = data.get(&#34;span&#34;)
        if span:
            return context.doc[span]
        else:
            if self.silent_fail:
                return
            else:
                raise Exception(&#34;Could not find a span for data&#34;)


class GetRegexGroup:
    def __init__(self, name, group=0, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.group = group
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        groups = data.get(&#34;groups&#34;)
        if groups:
            return groups[self.group]
        else:
            if self.silent_fail:
                return
            else:
                raise Exception(&#34;Could not find regexp groups for data&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.pam.pampac.AddAnn"><code class="flex name class">
<span>class <span class="ident">AddAnn</span></span>
<span>(</span><span>name=None, ann=None, anntype=None, features=None, span=None, resultidx=0, dataidx=0, silent_fail=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AddAnn:
    def __init__(self,
                 name=None,
                 ann=None,   # create a copy of this ann retrieved with GetAnn
                 anntype=None,  # or create a new annotation with this type
                 features=None,
                 span=None,   # use literal span, GetSpan, if none, span from match
                 resultidx=0, dataidx=0,
                 silent_fail=False,
                 ):
        # span is either a span, the index of data to take the span from, or a callable that will return the
        # span at firing time
        assert name
        assert anntype is not None or ann is not None
        self.name = name
        self.anntype = anntype
        self.ann = ann
        self.features = features
        self.span = span
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        span = data[&#34;span&#34;]
        outset = context.outset
        if self.ann:
            ann = self.ann(succ)
            if ann is None:
                if self.silent_fail:
                    return
                else:
                    raise Exception(&#34;No matching annotation found&#34;)
            outset.add_ann(ann)
        else:
            if self.span:
                if callable(self.span):
                    span = self.span(succ, context=context, location=location)
                else:
                    span = self.span
            if callable(self.anntype):
                anntype = self.anntype(succ, context=context, location=location)
            else:
                anntype = self.anntype
            if self.features:
                if callable(self.features):
                    features = self.features(succ, context=context, location=location)
                else:
                    features = self.features
            else:
                features = None
            outset.add(span.start, span.end, anntype, features=features)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.All"><code class="flex name class">
<span>class <span class="ident">All</span></span>
<span>(</span><span>*parsers)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a parser that succeeds if one or more parsers succeed at some location.
If success, all results from all succeeding parsers are included.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class All(PampacParser):
    &#34;&#34;&#34;
    Return a parser that succeeds if one or more parsers succeed at some location.
    If success, all results from all succeeding parsers are included.
    &#34;&#34;&#34;
    def __init__(self, *parsers):
        self.parsers = parsers

    def parse(self, location, context):
        results = []
        for p in self.parsers:
            ret = p.parse(location, context)
            if ret.issuccess():
                for r in ret:
                    results.append(r)
        if len(results) &gt; 0:
            return Success(results)
        else:
            return Failure(
                context=context,
                location=location,
                message=&#34;None of the parsers succeeded&#34;,
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.All.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    results = []
    for p in self.parsers:
        ret = p.parse(location, context)
        if ret.issuccess():
            for r in ret:
                results.append(r)
    if len(results) &gt; 0:
        return Success(results)
    else:
        return Failure(
            context=context,
            location=location,
            message=&#34;None of the parsers succeeded&#34;,
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.And"><code class="flex name class">
<span>class <span class="ident">And</span></span>
<span>(</span><span>*parsers)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a parser that is successful if all the parsers match at some location, and
fails otherwise. Success always contains all results from all parsers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class And(PampacParser):
    &#34;&#34;&#34;
    Return a parser that is successful if all the parsers match at some location, and
    fails otherwise. Success always contains all results from all parsers.

    &#34;&#34;&#34;
    def __init__(self, *parsers):
        self.parsers = parsers

    def parse(self, location, context):
        results = []
        for p in self.parsers:
            ret = p.parse(location, context)
            if ret.issuccess():
                for r in ret:
                    results.append(r)
            else:
                return Failure(
                    context=context,
                    location=location,
                    message=&#34;Not all parsers succeed&#34;,
                )
        return Success(results)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.And.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    results = []
    for p in self.parsers:
        ret = p.parse(location, context)
        if ret.issuccess():
            for r in ret:
                results.append(r)
        else:
            return Failure(
                context=context,
                location=location,
                message=&#34;Not all parsers succeed&#34;,
            )
    return Success(results)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.Ann"><code class="flex name class">
<span>class <span class="ident">Ann</span></span>
<span>(</span><span>type=None, features=None, features_eq=None, text=None, name=None, useoffset=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Parser for matching the next annotation in the annotation list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong></dt>
<dd>(default: None): type to match, string, regexp or predicate function</dd>
<dt><strong><code>features</code></strong></dt>
<dd>(default: None): features to match, dictionary where each value is value, regexp or predicate function
Annotation can contain additional features.</dd>
<dt><strong><code>features_eq</code></strong></dt>
<dd>(default: None): features to match, annotation must not contain additional features</dd>
<dt><strong><code>text</code></strong></dt>
<dd>(default: None): document text to match, string or regexp</dd>
<dt><strong><code>name</code></strong></dt>
<dd>(default: None): if set to a non-empty string, saves the data and assigns that name to the data</dd>
<dt><strong><code>useoffset</code></strong></dt>
<dd>if True, and a location is give where the next annotation starts before the text offset, skips
forward in the annotation list until an annotation is found at or after that offset.
If no such annotation found, fails. If False, always uses the next annotation in the list, no matter
the offset.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ann(_AnnBase):
    &#34;&#34;&#34;
    Parser for matching the next annotation in the annotation list.
    &#34;&#34;&#34;

    def __init__(
        self,
        type=None,
        features=None,
        features_eq=None,
        text=None,
        name=None,
        useoffset=True,
    ):
        &#34;&#34;&#34;

        Args:
            type: (default: None): type to match, string, regexp or predicate function
            features: (default: None): features to match, dictionary where each value is value, regexp or predicate function
               Annotation can contain additional features.
            features_eq: (default: None): features to match, annotation must not contain additional features
            text: (default: None): document text to match, string or regexp
            name: (default: None): if set to a non-empty string, saves the data and assigns that name to the data
            useoffset: if True, and a location is give where the next annotation starts before the text offset, skips
               forward in the annotation list until an annotation is found at or after that offset.
               If no such annotation found, fails. If False, always uses the next annotation in the list, no matter
               the offset.
        &#34;&#34;&#34;
        self.type = type
        self.features = features
        self.features_eq = features_eq
        self.text = text
        self.name = name
        self.useoffset = useoffset
        self._matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )

    def parse(self, location, context):
        &#34;&#34;&#34;
        Try to match the given annotation at the current context location. If we succeed,

        Args:
            location: the location of where to parse next
            context: parser context

        Returns:
            Success or Failure
        &#34;&#34;&#34;
        if self.useoffset:
            location = context.update_location_byoffset(location)
        next_ann = context.get_ann(location)
        if not next_ann:
            return Failure(
                context=context,
                parser=self,
                location=location,
                message=&#34;No annotation left&#34;,
            )
        # try to match it
        if self._matcher(next_ann, doc=context.doc):
            newlocation = context.inc_location(location, by_index=1)
            if self.name is not None:
                data = dict(
                    span=Span(next_ann),
                    location=location,
                    ann=next_ann,
                    name=self.name,
                )
            else:
                data = None
            span = Span(next_ann.start, next_ann.end)
            return Success(Result(data=data, span=span, location=newlocation), context)
        else:
            return Failure(location=location, context=context, parser=self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gatenlp.pam.pampac._AnnBase</li>
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Ann.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to match the given annotation at the current context location. If we succeed,</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>the location of where to parse next</dd>
<dt><strong><code>context</code></strong></dt>
<dd>parser context</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Success or Failure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    &#34;&#34;&#34;
    Try to match the given annotation at the current context location. If we succeed,

    Args:
        location: the location of where to parse next
        context: parser context

    Returns:
        Success or Failure
    &#34;&#34;&#34;
    if self.useoffset:
        location = context.update_location_byoffset(location)
    next_ann = context.get_ann(location)
    if not next_ann:
        return Failure(
            context=context,
            parser=self,
            location=location,
            message=&#34;No annotation left&#34;,
        )
    # try to match it
    if self._matcher(next_ann, doc=context.doc):
        newlocation = context.inc_location(location, by_index=1)
        if self.name is not None:
            data = dict(
                span=Span(next_ann),
                location=location,
                ann=next_ann,
                name=self.name,
            )
        else:
            data = None
        span = Span(next_ann.start, next_ann.end)
        return Success(Result(data=data, span=span, location=newlocation), context)
    else:
        return Failure(location=location, context=context, parser=self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.AnnAt"><code class="flex name class">
<span>class <span class="ident">AnnAt</span></span>
<span>(</span><span>type=None, features=None, features_eq=None, text=None, matchtype='first', name=None, useoffset=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Parser for matching the first or all annotations at the offset for the next annotation in the list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnAt(_AnnBase):
    &#34;&#34;&#34;
    Parser for matching the first or all annotations at the offset for the next annotation in the list.
    &#34;&#34;&#34;

    def __init__(
        self,
        type=None,
        features=None,
        features_eq=None,
        text=None,
        matchtype=&#34;first&#34;,
        name=None,
        useoffset=True,
    ):
        self.type = type
        self.features = features
        self.features_eq = features_eq
        self.text = text
        self.name = name
        self._matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        self.matchtype = matchtype
        self.useoffset = useoffset

    def parse(self, location, context):
        if self.useoffset:
            location = context.update_location_byoffset(location)
        next_ann = context.get_ann(location)
        if not next_ann:
            return Failure(
                context=context,
                location=location,
                parser=self,
                message=&#34;No annotation left&#34;,
            )
        results = []
        start = next_ann.start
        matched = False
        while True:
            if self._matcher(next_ann):
                matched = True
                matchlocation = Location(
                    text_location=start, ann_location=location.ann_location
                )
                if self.name is None:
                    data = None
                else:
                    data = dict(
                        span=Span(next_ann),
                        location=matchlocation,
                        ann=next_ann,
                        name=self.name,
                    )
                # update location
                location = context.inc_location(location, by_index=1)
                result = Result(
                    data=data, location=location, span=Span(next_ann.start, next_ann.end)
                )
                if self.matchtype == &#34;first&#34;:
                    return Success(result, context)
                results.append(result)
                next_ann = context.get_ann(location)
                if not next_ann or next_ann.start != start:
                    break
            else:
                location = context.inc_location(location, by_index=1)
                next_ann = context.get_ann(location)
                if not next_ann or next_ann.start != start:
                    break
        if not matched:
            return Failure(
                context=context,
                parser=self,
                location=location,
                message=&#34;No matching annotation&#34;,
            )
        else:
            res = Success.select_result(results, matchtype=self.matchtype)
            return Success(res, context)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gatenlp.pam.pampac._AnnBase</li>
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.AnnAt.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    if self.useoffset:
        location = context.update_location_byoffset(location)
    next_ann = context.get_ann(location)
    if not next_ann:
        return Failure(
            context=context,
            location=location,
            parser=self,
            message=&#34;No annotation left&#34;,
        )
    results = []
    start = next_ann.start
    matched = False
    while True:
        if self._matcher(next_ann):
            matched = True
            matchlocation = Location(
                text_location=start, ann_location=location.ann_location
            )
            if self.name is None:
                data = None
            else:
                data = dict(
                    span=Span(next_ann),
                    location=matchlocation,
                    ann=next_ann,
                    name=self.name,
                )
            # update location
            location = context.inc_location(location, by_index=1)
            result = Result(
                data=data, location=location, span=Span(next_ann.start, next_ann.end)
            )
            if self.matchtype == &#34;first&#34;:
                return Success(result, context)
            results.append(result)
            next_ann = context.get_ann(location)
            if not next_ann or next_ann.start != start:
                break
        else:
            location = context.inc_location(location, by_index=1)
            next_ann = context.get_ann(location)
            if not next_ann or next_ann.start != start:
                break
    if not matched:
        return Failure(
            context=context,
            parser=self,
            location=location,
            message=&#34;No matching annotation&#34;,
        )
    else:
        res = Success.select_result(results, matchtype=self.matchtype)
        return Success(res, context)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.Call"><code class="flex name class">
<span>class <span class="ident">Call</span></span>
<span>(</span><span>parser, func, onfailure=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Pampac parser, something that takes a context and returns a result.
This can be used to decorate a function that should be used as the parser,
or for subclassing specific parsers.</p>
<p>When subclassing, the parse(location, context) method must be overriden!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Call(PampacParser):
    def __init__(self, parser, func, onfailure=None):
        self.parser = parser
        self.func = func
        self.onfailure = onfailure

    def parse(self, location, context):
        ret = self.parser.parse(location, context)
        if ret.issuccess():
            self.func(ret,
                      context=context,
                      location=location,
                      name=self.parser.name,
                      parser=self.parser.__class__.__name__)
        else:
            if self.onfailure:
                self.onfailure(
                    ret,
                    context=context,
                    location=location,
                    name=self.parser.name,
                    parser=self.parser.__class__.__name__
                )
        return ret</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Call.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    ret = self.parser.parse(location, context)
    if ret.issuccess():
        self.func(ret,
                  context=context,
                  location=location,
                  name=self.parser.name,
                  parser=self.parser.__class__.__name__)
    else:
        if self.onfailure:
            self.onfailure(
                ret,
                context=context,
                location=location,
                name=self.parser.name,
                parser=self.parser.__class__.__name__
            )
    return ret</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.Context"><code class="flex name class">
<span>class <span class="ident">Context</span></span>
<span>(</span><span>doc, anns, start=None, end=None, outset=None, memoize=False, max_recusion=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Context contains data and refers to data for carrying out the parse.</p>
<p>Initialize a parse context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>doc</code></strong></dt>
<dd>the document which should get parsed</dd>
<dt><strong><code>anns</code></strong></dt>
<dd>an iterable of annotations to use for the parsing</dd>
<dt><strong><code>start</code></strong></dt>
<dd>the starting text offset for the parse</dd>
<dt><strong><code>end</code></strong></dt>
<dd>the ending text offset for the parse</dd>
<dt><strong><code>outset</code></strong></dt>
<dd>an annotation set for where to add any new annotations in an action</dd>
<dt><strong><code>memoize</code></strong></dt>
<dd>If memoization should be used (NOT YET IMPLEMENTED)</dd>
<dt><strong><code>max_recusion</code></strong></dt>
<dd>the maximum recursion depth for recursive parse rules (NOT YET IMPLEMENTED)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Context:
    &#34;&#34;&#34;
    Context contains data and refers to data for carrying out the parse.
    &#34;&#34;&#34;

    def __init__(
        self, doc, anns, start=None, end=None, outset=None, memoize=False, max_recusion=None
    ):
        &#34;&#34;&#34;
        Initialize a parse context.

        Args:
            doc: the document which should get parsed
            anns: an iterable of annotations to use for the parsing
            start: the starting text offset for the parse
            end: the ending text offset for the parse
            outset: an annotation set for where to add any new annotations in an action
            memoize: If memoization should be used (NOT YET IMPLEMENTED)
            max_recusion: the maximum recursion depth for recursive parse rules (NOT YET IMPLEMENTED)
        &#34;&#34;&#34;
        self._memotable = {}
        self.max_recursion = max_recusion
        self.doc = doc
        self.outset = outset
        self._annset = None    # cache for the annotations as a detached immutable set, if needed
        # make sure the start and end offsets are plausible or set the default to start/end of document
        if start is None:
            self.start = 0
        else:
            if start &gt;= len(doc.text) or start &lt; 0:
                raise Exception(
                    &#34;Invalid start offset: {start}, document length is {len(doc.text}&#34;
                )
            self.start = start
        if end is None:
            self.end = len(doc.text)  # offset after the last text character!
        else:
            if end &lt;= start or end &gt; len(doc.text):
                raise Exception(&#34;Invalid end offset: {end}, start is {self.start}&#34;)
            self.end = end
        # make sure all the anns are within the given offset range
        anns = [a for a in anns if a.start &gt;= self.start and a.end &lt;= self.end]
        self.anns = anns
        self.memoize = memoize

    @property
    def annset(self):
        &#34;&#34;&#34;
        Return the annotations as a set.

        Returns:
            annotations as a detached immutable AnnotationSet

        &#34;&#34;&#34;
        if self._annset is None:
            self._annset = AnnotationSet.from_anns(self.anns)
        return self._annset

    def get_ann(self, location):
        &#34;&#34;&#34;
        Return the ann at the given location, or None if there is none (mainly for the end-of-anns index).

        Returns:
            annotation or None
        &#34;&#34;&#34;
        if location.ann_location &gt;= len(self.anns):
            return None
        return self.anns[location.ann_location]

    def nextidx4offset(self, location, offset, next_ann=False):
        &#34;&#34;&#34;
        Return the index of the next annotation that starts at or after the given text offset.
        If no such annotation exists the end of annotations index (equal to length of annotations) is returned.

        Args:
            location: current location, the annotation is searched from the annotation index following the one in the
               current location
            offset: offset to look for
            next_ann: if True, always finds the NEXT annotation after the one pointed at with the current location.
               If false keeps the current one if it is still the next one.

        Returns:
            annotation index
        &#34;&#34;&#34;
        idx = location.ann_location
        if next_ann:
            idx += 1
        while True:
            if idx &gt;= len(self.anns):
                return len(self.anns)
            ann = self.anns[idx]
            if ann.start &gt;= offset:
                return idx
            idx += 1

    def inc_location(self, location, by_offset=None, by_index=None):
        &#34;&#34;&#34;
        Return a new location which represents the given location incremented by either the given number of index
        count (usually 1), or by the given offset length. Only one of the by parameters should be specified.

        If the update occurs by offset, then the annotation index is updated to that of the next index with
        a start offset equal or larger than the updated text offset.  This may be the end of annotations index.
        If the text offset hits the end of text offset, the annotation index is set to the end of annotations index.

        If the update occurs by index, then the text offset is updated to the offset corresponding to the end offset
        of the annotation, if there is one.


        Args:
            location:
            by_offset: the number of text characters to increment the text offset by
            by_index:  the number of annotations to increment the index by

        Returns:
            new location
        &#34;&#34;&#34;
        newloc = Location(
            text_location=location.text_location, ann_location=location.ann_location
        )
        if by_index is not None:
            # get the annotation before the one we want to point at next, so we get the end offset of the
            # last annotation consumed
            newloc.ann_location += by_index - 1
            ann = self.get_ann(location)
            # if we already are at the end of the annotations, just leave everything as it is
            if not ann:
                return location
            newloc.text_location = ann.end
            # this is now the index of the next ann or the end of anns index
            newloc.ann_location += 1
        else:
            # update by text offset
            if newloc.text_location + by_offset &gt;= self.end:
                # if we reach the end of the text, update the annotation index to end of annotations as well
                newloc.text_location = self.end
                newloc.ann_location = len(self.anns)
            else:
                # otherwise try to find the next matching annotation
                newloc.text_location += by_offset
                newloc.ann_location = self.nextidx4offset(
                    location, newloc.text_location
                )
                # if we got end of annotations index, we do NOT update the text to end of text!
                # we could still want to match something in the text after the last annotation.
        return newloc

    def update_location_byoffset(self, location):
        &#34;&#34;&#34;
        Update the passed location so that the annotation index is updated by the text offset: all annotations are
        skipped until the start offset of the annotation is at or past the text offset.

        Args:
            location: the location to update

        Returns:
            a new location with the annotation index updated
        &#34;&#34;&#34;
        for i in range(location.ann_location, len(self.anns)):
            if self.anns[i].start &gt;= location.text_location:
                return Location(location.text_location, i)
        return Location(location.text_location, len(self.anns))

    def update_location_byindex(self, location):
        &#34;&#34;&#34;
        Update the passed location from the annotation index and make sure it points to the end of the current
        annotation or the end of the document.

        Args:
            location: the location to update

        Returns:
            a new location with the text offset updated
        &#34;&#34;&#34;
        if location.ann_location == len(self.anns):
            return Location(len(self.doc.text), location.ann_location)
        else:
            return Location(
                location.text_location, self.anns[location.ann_location].end
            )

    def at_endoftext(self, location):
        &#34;&#34;&#34;
        Returns true if the location represents the end of text location

        Args:
            location: location

        Returns:
            True if we are at end of text
        &#34;&#34;&#34;
        return location.text_location &gt;= self.end

    def at_endofanns(self, location):
        &#34;&#34;&#34;
        Returns true if the location represents the end of anns location

        Args:
            location: location

        Returns:
            True if we are at end of anns
        &#34;&#34;&#34;
        return location.ann_location &gt;= len(self.anns)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="gatenlp.pam.pampac.Context.annset"><code class="name">property/get <span class="ident">annset</span></code></dt>
<dd>
<div class="desc"><p>Return the annotations as a set.</p>
<h2 id="returns">Returns</h2>
<p>annotations as a detached immutable AnnotationSet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def annset(self):
    &#34;&#34;&#34;
    Return the annotations as a set.

    Returns:
        annotations as a detached immutable AnnotationSet

    &#34;&#34;&#34;
    if self._annset is None:
        self._annset = AnnotationSet.from_anns(self.anns)
    return self._annset</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Context.at_endofanns"><code class="name flex">
<span>def <span class="ident">at_endofanns</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the location represents the end of anns location</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>location</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if we are at end of anns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at_endofanns(self, location):
    &#34;&#34;&#34;
    Returns true if the location represents the end of anns location

    Args:
        location: location

    Returns:
        True if we are at end of anns
    &#34;&#34;&#34;
    return location.ann_location &gt;= len(self.anns)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Context.at_endoftext"><code class="name flex">
<span>def <span class="ident">at_endoftext</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the location represents the end of text location</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>location</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if we are at end of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at_endoftext(self, location):
    &#34;&#34;&#34;
    Returns true if the location represents the end of text location

    Args:
        location: location

    Returns:
        True if we are at end of text
    &#34;&#34;&#34;
    return location.text_location &gt;= self.end</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Context.get_ann"><code class="name flex">
<span>def <span class="ident">get_ann</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the ann at the given location, or None if there is none (mainly for the end-of-anns index).</p>
<h2 id="returns">Returns</h2>
<p>annotation or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ann(self, location):
    &#34;&#34;&#34;
    Return the ann at the given location, or None if there is none (mainly for the end-of-anns index).

    Returns:
        annotation or None
    &#34;&#34;&#34;
    if location.ann_location &gt;= len(self.anns):
        return None
    return self.anns[location.ann_location]</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Context.inc_location"><code class="name flex">
<span>def <span class="ident">inc_location</span></span>(<span>self, location, by_offset=None, by_index=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new location which represents the given location incremented by either the given number of index
count (usually 1), or by the given offset length. Only one of the by parameters should be specified.</p>
<p>If the update occurs by offset, then the annotation index is updated to that of the next index with
a start offset equal or larger than the updated text offset.
This may be the end of annotations index.
If the text offset hits the end of text offset, the annotation index is set to the end of annotations index.</p>
<p>If the update occurs by index, then the text offset is updated to the offset corresponding to the end offset
of the annotation, if there is one.</p>
<h2 id="args">Args</h2>
<dl>
<dt>location:</dt>
<dt><strong><code>by_offset</code></strong></dt>
<dd>the number of text characters to increment the text offset by</dd>
<dt><strong><code>by_index</code></strong></dt>
<dd>the number of annotations to increment the index by</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>new location</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inc_location(self, location, by_offset=None, by_index=None):
    &#34;&#34;&#34;
    Return a new location which represents the given location incremented by either the given number of index
    count (usually 1), or by the given offset length. Only one of the by parameters should be specified.

    If the update occurs by offset, then the annotation index is updated to that of the next index with
    a start offset equal or larger than the updated text offset.  This may be the end of annotations index.
    If the text offset hits the end of text offset, the annotation index is set to the end of annotations index.

    If the update occurs by index, then the text offset is updated to the offset corresponding to the end offset
    of the annotation, if there is one.


    Args:
        location:
        by_offset: the number of text characters to increment the text offset by
        by_index:  the number of annotations to increment the index by

    Returns:
        new location
    &#34;&#34;&#34;
    newloc = Location(
        text_location=location.text_location, ann_location=location.ann_location
    )
    if by_index is not None:
        # get the annotation before the one we want to point at next, so we get the end offset of the
        # last annotation consumed
        newloc.ann_location += by_index - 1
        ann = self.get_ann(location)
        # if we already are at the end of the annotations, just leave everything as it is
        if not ann:
            return location
        newloc.text_location = ann.end
        # this is now the index of the next ann or the end of anns index
        newloc.ann_location += 1
    else:
        # update by text offset
        if newloc.text_location + by_offset &gt;= self.end:
            # if we reach the end of the text, update the annotation index to end of annotations as well
            newloc.text_location = self.end
            newloc.ann_location = len(self.anns)
        else:
            # otherwise try to find the next matching annotation
            newloc.text_location += by_offset
            newloc.ann_location = self.nextidx4offset(
                location, newloc.text_location
            )
            # if we got end of annotations index, we do NOT update the text to end of text!
            # we could still want to match something in the text after the last annotation.
    return newloc</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Context.nextidx4offset"><code class="name flex">
<span>def <span class="ident">nextidx4offset</span></span>(<span>self, location, offset, next_ann=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the index of the next annotation that starts at or after the given text offset.
If no such annotation exists the end of annotations index (equal to length of annotations) is returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>current location, the annotation is searched from the annotation index following the one in the
current location</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>offset to look for</dd>
<dt><strong><code>next_ann</code></strong></dt>
<dd>if True, always finds the NEXT annotation after the one pointed at with the current location.
If false keeps the current one if it is still the next one.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>annotation index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nextidx4offset(self, location, offset, next_ann=False):
    &#34;&#34;&#34;
    Return the index of the next annotation that starts at or after the given text offset.
    If no such annotation exists the end of annotations index (equal to length of annotations) is returned.

    Args:
        location: current location, the annotation is searched from the annotation index following the one in the
           current location
        offset: offset to look for
        next_ann: if True, always finds the NEXT annotation after the one pointed at with the current location.
           If false keeps the current one if it is still the next one.

    Returns:
        annotation index
    &#34;&#34;&#34;
    idx = location.ann_location
    if next_ann:
        idx += 1
    while True:
        if idx &gt;= len(self.anns):
            return len(self.anns)
        ann = self.anns[idx]
        if ann.start &gt;= offset:
            return idx
        idx += 1</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Context.update_location_byindex"><code class="name flex">
<span>def <span class="ident">update_location_byindex</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the passed location from the annotation index and make sure it points to the end of the current
annotation or the end of the document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>the location to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a new location with the text offset updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_location_byindex(self, location):
    &#34;&#34;&#34;
    Update the passed location from the annotation index and make sure it points to the end of the current
    annotation or the end of the document.

    Args:
        location: the location to update

    Returns:
        a new location with the text offset updated
    &#34;&#34;&#34;
    if location.ann_location == len(self.anns):
        return Location(len(self.doc.text), location.ann_location)
    else:
        return Location(
            location.text_location, self.anns[location.ann_location].end
        )</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Context.update_location_byoffset"><code class="name flex">
<span>def <span class="ident">update_location_byoffset</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the passed location so that the annotation index is updated by the text offset: all annotations are
skipped until the start offset of the annotation is at or past the text offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>the location to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a new location with the annotation index updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_location_byoffset(self, location):
    &#34;&#34;&#34;
    Update the passed location so that the annotation index is updated by the text offset: all annotations are
    skipped until the start offset of the annotation is at or past the text offset.

    Args:
        location: the location to update

    Returns:
        a new location with the annotation index updated
    &#34;&#34;&#34;
    for i in range(location.ann_location, len(self.anns)):
        if self.anns[i].start &gt;= location.text_location:
            return Location(location.text_location, i)
    return Location(location.text_location, len(self.anns))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.pam.pampac.Failure"><code class="flex name class">
<span>class <span class="ident">Failure</span></span>
<span>(</span><span>message=None, parser=None, location=None, causes=None, context=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a parse failure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Failure:
    &#34;&#34;&#34;
    Represents a parse failure.
    &#34;&#34;&#34;

    def __init__(
        self,
        message=None,
        parser=None,
        location=None,
        causes=None,
        context=None,
    ):
        self.context = context
        self._parser = parser
        if not message:
            message = &#34;Parser Error&#34;
        self.message = message
        if location:
            self._cur_text = location.text_location
            self._cur_ann = location.ann_location
        else:
            self._cur_text = &#34;?&#34;
            self._cur_ann = &#34;?&#34;
        if isinstance(causes, Failure):
            self._causes = [causes]
        else:
            self._causes = causes

    def issuccess(self):
        return False

    def _get_causes(self):
        for cause in self._causes:
            if not cause._causes:
                # The root cause since there&#39;s no further failures.
                yield cause
            else:
                yield from cause._get_causes()

    def describe(self, indent=4, level=0):
        lead = &#34; &#34; * indent * level
        desc = (
            f&#34;{lead}{self._parser} at {self._cur_text}/{self._cur_ann}: &#34;
            f&#34;{self.message}&#34;
        )
        tail = &#34;&#34;
        if self._causes:
            tail = f&#34;\n{lead}Caused by:\n&#34; + &#34;\n&#34;.join(
                x.describe(indent, level + 1) for x in self._get_causes()
            )
        return desc + tail

    def __str__(self):
        return self.describe()

    def __repr__(self):
        return (
            f&#34;{self.__class__.__name__}({self.message!r}, &#34;
            f&#34;{self._cur_text!r}/{self._cur_ann}, {self._causes!r})&#34;
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Failure.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self, indent=4, level=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self, indent=4, level=0):
    lead = &#34; &#34; * indent * level
    desc = (
        f&#34;{lead}{self._parser} at {self._cur_text}/{self._cur_ann}: &#34;
        f&#34;{self.message}&#34;
    )
    tail = &#34;&#34;
    if self._causes:
        tail = f&#34;\n{lead}Caused by:\n&#34; + &#34;\n&#34;.join(
            x.describe(indent, level + 1) for x in self._get_causes()
        )
    return desc + tail</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Failure.issuccess"><code class="name flex">
<span>def <span class="ident">issuccess</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def issuccess(self):
    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.pam.pampac.Filter"><code class="flex name class">
<span>class <span class="ident">Filter</span></span>
<span>(</span><span>parser, predicate, take_if=True, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"><p>Select only some of the results returned by a parser success, call the predicate function on each to check.
This can also be used to check a single result and decide if it should be a success or failure.</p>
<p>Invoke predicate with each result of a successful parse of parser and return success with the remaining
list. If the remaining list is empty, return Failure.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parser</code></strong></dt>
<dd>the parser to use</dd>
<dt><strong><code>predicate</code></strong></dt>
<dd>the function to call for each result of the parser success</dd>
<dt><strong><code>take_if</code></strong></dt>
<dd>if True takes if predicate returns True, otherwise if predicate returns false</dd>
<dt><strong><code>matchtype</code></strong></dt>
<dd>how to choose among all the selected results</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Filter(PampacParser):
    &#34;&#34;&#34;
    Select only some of the results returned by a parser success, call the predicate function on each to check.
    This can also be used to check a single result and decide if it should be a success or failure.
    &#34;&#34;&#34;

    def __init__(self, parser, predicate, take_if=True, matchtype=&#34;first&#34;):
        &#34;&#34;&#34;
        Invoke predicate with each result of a successful parse of parser and return success with the remaining
        list. If the remaining list is empty, return Failure.

        Args:
            parser: the parser to use
            predicate: the function to call for each result of the parser success
            take_if: if True takes if predicate returns True, otherwise if predicate returns false
            matchtype: how to choose among all the selected results
        &#34;&#34;&#34;
        self.parser = parser
        self.predicate = predicate
        self.take_if = take_if
        self.matchtype = matchtype

    def parse(self, location, context):
        ret = self.parser.parse(location, context)
        if ret.issuccess():
            res = []
            for r in ret:
                if self.predicate(r, context=context, location=location) == self.take_if:
                    res.append(r)
            if len(r) == 0:
                return Failure(
                    context=context,
                    location=location,
                    message=&#34;No result satisfies predicate&#34;,
                )
            else:
                return Success(res)
        else:
            return ret</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Filter.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    ret = self.parser.parse(location, context)
    if ret.issuccess():
        res = []
        for r in ret:
            if self.predicate(r, context=context, location=location) == self.take_if:
                res.append(r)
        if len(r) == 0:
            return Failure(
                context=context,
                location=location,
                message=&#34;No result satisfies predicate&#34;,
            )
        else:
            return Success(res)
    else:
        return ret</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.Find"><code class="flex name class">
<span>class <span class="ident">Find</span></span>
<span>(</span><span>parser, by_anns=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A parser that tries another parser until it matches.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parser</code></strong></dt>
<dd>the parser to use for finding the match</dd>
<dt><strong><code>by_anns</code></strong></dt>
<dd>if True, tries at each annotation index and the corresponding text offset, otherwise tries
at each text offset and the corresponding ann index.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Find(PampacParser):
    &#34;&#34;&#34;
    A parser that tries another parser until it matches.
    &#34;&#34;&#34;

    def __init__(self, parser, by_anns=True):
        &#34;&#34;&#34;

        Args:
            parser: the parser to use for finding the match
            by_anns: if True, tries at each annotation index and the corresponding text offset, otherwise tries
               at each text offset and the corresponding ann index.
        &#34;&#34;&#34;
        self.parser = parser
        self.by_anns = by_anns

    def parse(self, location, context):
        while True:
            ret = self.parser.parse(location, context)
            if ret.issuccess():
                return ret
            else:
                if self.by_anns:
                    location = context.inc_location(location, by_index=1)
                    if context.at_endofanns(location):
                        return Failure(
                            context=context,
                            message=&#34;Not found via anns&#34;,
                            location=location,
                        )
                else:
                    location = context.inc_location(location, by_offset=1)
                    if context.at_endoftext(location):
                        return Failure(
                            context=context,
                            message=&#34;Not found via text&#34;,
                            location=location,
                        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Find.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    while True:
        ret = self.parser.parse(location, context)
        if ret.issuccess():
            return ret
        else:
            if self.by_anns:
                location = context.inc_location(location, by_index=1)
                if context.at_endofanns(location):
                    return Failure(
                        context=context,
                        message=&#34;Not found via anns&#34;,
                        location=location,
                    )
            else:
                location = context.inc_location(location, by_offset=1)
                if context.at_endoftext(location):
                    return Failure(
                        context=context,
                        message=&#34;Not found via text&#34;,
                        location=location,
                    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.GetAnn"><code class="flex name class">
<span>class <span class="ident">GetAnn</span></span>
<span>(</span><span>name, resultidx=0, dataidx=0, silent_fail=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetAnn:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        ann = data.get(&#34;ann&#34;)
        if ann is None:
            if not self.silent_fail:
                raise Exception(f&#34;No annotation found for name {self.name}, {self.resultidx}, {self.dataidx}&#34;)
        return ann</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.GetEnd"><code class="flex name class">
<span>class <span class="ident">GetEnd</span></span>
<span>(</span><span>name, resultidx=0, dataidx=0, silent_fail=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetEnd:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        span = data[&#34;span&#34;]
        return span.end</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.GetFeature"><code class="flex name class">
<span>class <span class="ident">GetFeature</span></span>
<span>(</span><span>name, featurename, resultidx=0, dataidx=0, silent_fail=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetFeature:
    def __init__(self, name, featurename, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail
        self.featurename = featurename

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        ann = data.get(&#34;ann&#34;)
        if ann is None:
            if not self.silent_fail:
                raise Exception(f&#34;No annotation found for name {self.name}, {self.resultidx}, {self.dataidx}&#34;)
        return ann.features.get(self.featurename)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.GetFeatures"><code class="flex name class">
<span>class <span class="ident">GetFeatures</span></span>
<span>(</span><span>name, resultidx=0, dataidx=0, silent_fail=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetFeatures:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        ann = data.get(&#34;ann&#34;)
        if ann is None:
            if not self.silent_fail:
                raise Exception(f&#34;No annotation found for name {self.name}, {self.resultidx}, {self.dataidx}&#34;)
        return ann.features</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.GetRegexGroup"><code class="flex name class">
<span>class <span class="ident">GetRegexGroup</span></span>
<span>(</span><span>name, group=0, resultidx=0, dataidx=0, silent_fail=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetRegexGroup:
    def __init__(self, name, group=0, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.group = group
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        groups = data.get(&#34;groups&#34;)
        if groups:
            return groups[self.group]
        else:
            if self.silent_fail:
                return
            else:
                raise Exception(&#34;Could not find regexp groups for data&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.GetStart"><code class="flex name class">
<span>class <span class="ident">GetStart</span></span>
<span>(</span><span>name, resultidx=0, dataidx=0, silent_fail=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetStart:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        span = data[&#34;span&#34;]
        return span.start</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.GetText"><code class="flex name class">
<span>class <span class="ident">GetText</span></span>
<span>(</span><span>name, resultidx=0, dataidx=0, silent_fail=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetText:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        span = data.get(&#34;span&#34;)
        if span:
            return context.doc[span]
        else:
            if self.silent_fail:
                return
            else:
                raise Exception(&#34;Could not find a span for data&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.GetType"><code class="flex name class">
<span>class <span class="ident">GetType</span></span>
<span>(</span><span>name, resultidx=0, dataidx=0, silent_fail=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetType:
    def __init__(self, name, resultidx=0, dataidx=0, silent_fail=False):
        self.name = name
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        data = _get_data(succ, self.name, self.resultidx, self.dataidx, self.silent_fail)
        ann = data.get(&#34;ann&#34;)
        if ann is None:
            if not self.silent_fail:
                raise Exception(f&#34;No annotation found for name {self.name}, {self.resultidx}, {self.dataidx}&#34;)
        return ann.type</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Location"><code class="flex name class">
<span>class <span class="ident">Location</span></span>
<span>(</span><span>text_location=0, ann_location=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A ParseLocation represents the next location in the text and annotation list where a parser will try to
match, i.e. the location after everything that has been consumed by the parser so far.</p>
<p>The text offset equal to the length of the text represent the EndOfText condition and the annotation index
equal to the length of the annotation list represents the EndOfAnns condition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Location:
    &#34;&#34;&#34;
    A ParseLocation represents the next location in the text and annotation list where a parser will try to
    match, i.e. the location after everything that has been consumed by the parser so far.

    The text offset equal to the length of the text represent the EndOfText condition and the annotation index
    equal to the length of the annotation list represents the EndOfAnns condition.
    &#34;&#34;&#34;

    def __init__(self, text_location=0, ann_location=0):
        self.text_location = text_location
        self.ann_location = ann_location

    def __str__(self):
        return f&#34;Location({self.text_location},{self.ann_location})&#34;

    def __repr__(self):
        return f&#34;Location({self.text_location},{self.ann_location})&#34;

    def __eq__(self, other):
        if not isinstance(other, Location):
            return False
        return (
            self.text_location == other.text_location
            and self.ann_location == other.ann_location
        )</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Lookahead"><code class="flex name class">
<span>class <span class="ident">Lookahead</span></span>
<span>(</span><span>parser, laparser)</span>
</code></dt>
<dd>
<div class="desc"><p>A Pampac parser, something that takes a context and returns a result.
This can be used to decorate a function that should be used as the parser,
or for subclassing specific parsers.</p>
<p>When subclassing, the parse(location, context) method must be overriden!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lookahead(PampacParser):
    def __init__(self, parser, laparser):
        self.parser = parser
        self.laparser = laparser

    def parse(self, location, context):
        if context.parse(location, context).issuccess():
            return self.parser.parse(location, context)
        else:
            return Failure(
                context=context, message=&#34;Lookahead failed&#34;, location=location
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Lookahead.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    if context.parse(location, context).issuccess():
        return self.parser.parse(location, context)
    else:
        return Failure(
            context=context, message=&#34;Lookahead failed&#34;, location=location
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.N"><code class="flex name class">
<span>class <span class="ident">N</span></span>
<span>(</span><span>parser, min=1, max=1, matchtype='first', select='first', until=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A parser that represents a sequence of k to l matching parsers, greedy.</p>
<p>Return a parser that matches min to max matches of parser in sequence. If until is specified, that
parser is tried to match before each iteration and as soon as it matched, the parser succeeds.
If after ming to max matches of the parser, until does not match, the parser fails.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parser</code></strong></dt>
<dd>the parser that should match min to max times</dd>
<dt><strong><code>min</code></strong></dt>
<dd>minimum number of times to match for a success</dd>
<dt><strong><code>max</code></strong></dt>
<dd>maximum number of times to match for a success</dd>
<dt><strong><code>matchtype</code></strong></dt>
<dd>which results to include in a successful match, one of first, longest, shortest, all</dd>
<dt><strong><code>until</code></strong></dt>
<dd>parser that terminates the repetition</dd>
<dt><strong><code>name</code></strong></dt>
<dd>if not None, adds an additional data element to the result which contains the
and span of the whole sequence.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class N(PampacParser):
    &#34;&#34;&#34;
    A parser that represents a sequence of k to l matching parsers, greedy.
    &#34;&#34;&#34;

    def __init__(
        self, parser, min=1, max=1, matchtype=&#34;first&#34;, select=&#34;first&#34;, until=None, name=None
    ):
        &#34;&#34;&#34;
        Return a parser that matches min to max matches of parser in sequence. If until is specified, that
        parser is tried to match before each iteration and as soon as it matched, the parser succeeds.
        If after ming to max matches of the parser, until does not match, the parser fails.

        Args:
            parser: the parser that should match min to max times
            min: minimum number of times to match for a success
            max: maximum number of times to match for a success
            matchtype: which results to include in a successful match, one of first, longest, shortest, all
            until: parser that terminates the repetition
            name: if not None, adds an additional data element to the result which contains the
              and span of the whole sequence.
        &#34;&#34;&#34;
        self.parser = parser
        self.min = min
        self.max = max
        self.matchtype = matchtype
        self.until = until
        self.select = select
        self.name = name

    def parse(self, location, context):
        start = location.text_location
        end = start
        if self.select != &#34;all&#34;:
            datas = []
            i = 0
            first = True
            # location is the location where we try to match
            while True:
                if self.until and i &gt;= self.min:
                    ret = self.until.parse(location, context)
                    if ret.issuccess():
                        res = ret.result(self.select)
                        data = res.data
                        for d in data:
                            datas.append(d)
                        loc = res.location
                        end = res.span.end
                        if self.name:
                            datas.append(dict(span=Span(start,end),
                                              location=loc,
                                              name=self.name))
                        return Success(
                            Result(datas, location=loc, span=Span(start, end)), context
                        )
                ret = self.parser.parse(location, context)
                if not ret.issuccess():
                    if i &lt; self.min:
                        return Failure(
                            context=context,
                            location=location,
                            message=f&#34;Not at least {self.min} matches&#34;,
                        )
                    else:
                        if self.name:
                            datas.append(dict(span=Span(start,end),
                                              location=location,
                                              name=self.name))
                        return Success(
                            Result(data=datas, location=location, span=Span(start, end)),
                            context,
                        )
                else:
                    result = ret.result(self.select)
                    if first:
                        first = False
                        start = result.span.start
                    end = result.span.end
                    data = result.data
                    for d in data:
                        datas.append(d)
                    location = result.location
                    i += 1
                    if i == self.max:
                        break
            if self.until:
                ret = self.until.parse(location, context)
                if ret.issuccess():
                    res = ret.result(self.select)
                    data = res.data
                    loc = res.location
                    end = res.span.end
                    for d in data:
                        datas.append(d)
                    if self.name:
                        datas.append(dict(span=Span(start, end),
                                          location=loc,
                                          name=self.name))
                    return Success(
                        Result(datas, location=loc, span=Span(start, end)), context
                    )
                else:
                    return Failure(
                        context=context,
                        location=location,
                        message=&#34;Until parser not successful&#34;,
                    )
            if self.name:
                datas.append(dict(span=Span(start, end),
                                  location=location,
                                  name=self.name))
            return Success(
                Result(data=datas, location=location, span=Span(start, end)), context
            )
        else:
            # This does a depth-first enumeration of all matches: each successive parser gets tried
            # for each result of the previous one.
            def depthfirst(lvl, result):
                # if we already have min matches and we can terminate early, do it
                if self.until and lvl &gt;= self.min:
                    ret = self.until.parse(result.location, context)
                    if ret.issuccess():
                        for res in ret:
                            data = result.data.copy()
                            for dtmp in res.data:
                                data.append(dtmp)
                            loc = res.location
                            end = res.span.end
                            if self.name:
                                data.append(dict(span=Span(start, end),
                                                 location=location,
                                                 name=self.name))
                            yield Result(data, location=loc, span=Span(start, end))
                            return
                # if we got here after the max number of matches, and self.until is set, then
                # the parse we did above did not succeed, so we end without a result
                if self.until and lvl &gt; self.max:
                    return
                # if we got here after the max number of matches and self.util is not set, we
                # can yield the current result as we found max matches
                if lvl &gt;= self.max:
                    yield result
                    return
                # lvl is still smaller than max, so we try to match more
                ret = self.parser.parse(result.location, context)
                if ret.issuccess():
                    # for each of the results, try to continue matching
                    for res in ret:
                        datas = result.data.copy()
                        for d in res.data:
                            datas.append(d)
                        loc = res.location
                        span = Span(location.text_location, res.location.text_location)
                        newresult = Result(datas, location=loc, span=span)
                        yield from depthfirst(lvl + 1, newresult)
                else:
                    if lvl &lt;= self.min:
                        return
                    else:
                        # we already have at least min matches: if we have no until, we can yield the result
                        if not self.until:
                            data = result.data
                            end = result.span.end
                            if self.name:
                                data.append(dict(span=Span(start, end),
                                                 location=result.location,
                                                 name=self.name))
                            yield result
                        else:
                            # if we have until, then the until above did not match so neither the normal parser
                            # nor the until did match so we do not have a success
                            return

            gen = depthfirst(0, Result(data=[], location=location, span=(None, None)))
            all = []
            best = None
            for idx, result in enumerate(gen):
                if self.matchtype == &#34;first&#34; and idx == 0:
                    return Success(result, context)
                if self.matchtype == &#34;all&#34;:
                    all.append(result)
                elif self.matchtype == &#34;longest&#34;:
                    if best is None:
                        best = result
                    elif result.span.end &gt; best.span.end:
                        best = result
                elif self.matchtype == &#34;shortest&#34;:
                    if best is None:
                        best = result
                    elif result.span.end &lt; best.span.end:
                        best = result
            if self.matchtype == &#34;all&#34;:
                if len(all) &gt; 0:
                    return Success(all, context)
                else:
                    return Failure(context=context, location=location)
            else:
                if best is not None:
                    return Success(best, context)
                else:
                    return Failure(context=context, location=location)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.N.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    start = location.text_location
    end = start
    if self.select != &#34;all&#34;:
        datas = []
        i = 0
        first = True
        # location is the location where we try to match
        while True:
            if self.until and i &gt;= self.min:
                ret = self.until.parse(location, context)
                if ret.issuccess():
                    res = ret.result(self.select)
                    data = res.data
                    for d in data:
                        datas.append(d)
                    loc = res.location
                    end = res.span.end
                    if self.name:
                        datas.append(dict(span=Span(start,end),
                                          location=loc,
                                          name=self.name))
                    return Success(
                        Result(datas, location=loc, span=Span(start, end)), context
                    )
            ret = self.parser.parse(location, context)
            if not ret.issuccess():
                if i &lt; self.min:
                    return Failure(
                        context=context,
                        location=location,
                        message=f&#34;Not at least {self.min} matches&#34;,
                    )
                else:
                    if self.name:
                        datas.append(dict(span=Span(start,end),
                                          location=location,
                                          name=self.name))
                    return Success(
                        Result(data=datas, location=location, span=Span(start, end)),
                        context,
                    )
            else:
                result = ret.result(self.select)
                if first:
                    first = False
                    start = result.span.start
                end = result.span.end
                data = result.data
                for d in data:
                    datas.append(d)
                location = result.location
                i += 1
                if i == self.max:
                    break
        if self.until:
            ret = self.until.parse(location, context)
            if ret.issuccess():
                res = ret.result(self.select)
                data = res.data
                loc = res.location
                end = res.span.end
                for d in data:
                    datas.append(d)
                if self.name:
                    datas.append(dict(span=Span(start, end),
                                      location=loc,
                                      name=self.name))
                return Success(
                    Result(datas, location=loc, span=Span(start, end)), context
                )
            else:
                return Failure(
                    context=context,
                    location=location,
                    message=&#34;Until parser not successful&#34;,
                )
        if self.name:
            datas.append(dict(span=Span(start, end),
                              location=location,
                              name=self.name))
        return Success(
            Result(data=datas, location=location, span=Span(start, end)), context
        )
    else:
        # This does a depth-first enumeration of all matches: each successive parser gets tried
        # for each result of the previous one.
        def depthfirst(lvl, result):
            # if we already have min matches and we can terminate early, do it
            if self.until and lvl &gt;= self.min:
                ret = self.until.parse(result.location, context)
                if ret.issuccess():
                    for res in ret:
                        data = result.data.copy()
                        for dtmp in res.data:
                            data.append(dtmp)
                        loc = res.location
                        end = res.span.end
                        if self.name:
                            data.append(dict(span=Span(start, end),
                                             location=location,
                                             name=self.name))
                        yield Result(data, location=loc, span=Span(start, end))
                        return
            # if we got here after the max number of matches, and self.until is set, then
            # the parse we did above did not succeed, so we end without a result
            if self.until and lvl &gt; self.max:
                return
            # if we got here after the max number of matches and self.util is not set, we
            # can yield the current result as we found max matches
            if lvl &gt;= self.max:
                yield result
                return
            # lvl is still smaller than max, so we try to match more
            ret = self.parser.parse(result.location, context)
            if ret.issuccess():
                # for each of the results, try to continue matching
                for res in ret:
                    datas = result.data.copy()
                    for d in res.data:
                        datas.append(d)
                    loc = res.location
                    span = Span(location.text_location, res.location.text_location)
                    newresult = Result(datas, location=loc, span=span)
                    yield from depthfirst(lvl + 1, newresult)
            else:
                if lvl &lt;= self.min:
                    return
                else:
                    # we already have at least min matches: if we have no until, we can yield the result
                    if not self.until:
                        data = result.data
                        end = result.span.end
                        if self.name:
                            data.append(dict(span=Span(start, end),
                                             location=result.location,
                                             name=self.name))
                        yield result
                    else:
                        # if we have until, then the until above did not match so neither the normal parser
                        # nor the until did match so we do not have a success
                        return

        gen = depthfirst(0, Result(data=[], location=location, span=(None, None)))
        all = []
        best = None
        for idx, result in enumerate(gen):
            if self.matchtype == &#34;first&#34; and idx == 0:
                return Success(result, context)
            if self.matchtype == &#34;all&#34;:
                all.append(result)
            elif self.matchtype == &#34;longest&#34;:
                if best is None:
                    best = result
                elif result.span.end &gt; best.span.end:
                    best = result
            elif self.matchtype == &#34;shortest&#34;:
                if best is None:
                    best = result
                elif result.span.end &lt; best.span.end:
                    best = result
        if self.matchtype == &#34;all&#34;:
            if len(all) &gt; 0:
                return Success(all, context)
            else:
                return Failure(context=context, location=location)
        else:
            if best is not None:
                return Success(best, context)
            else:
                return Failure(context=context, location=location)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.Or"><code class="flex name class">
<span>class <span class="ident">Or</span></span>
<span>(</span><span>*parsers, matchtype='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a parser that accepts the first of all the parsers specified.</p>
<p>Creates a parser that tries each of the given parsers in order and uses the first
one that finds a successful match only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*parsers</code></strong></dt>
<dd>two or more parsers to each try in sequence</dd>
<dt><strong><code>matchtype</code></strong></dt>
<dd>which of the results from the successful parser to return.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Or(PampacParser):
    &#34;&#34;&#34;
    Create a parser that accepts the first of all the parsers specified.
    &#34;&#34;&#34;

    def __init__(self, *parsers, matchtype=&#34;all&#34;):
        &#34;&#34;&#34;
        Creates a parser that tries each of the given parsers in order and uses the first
        one that finds a successful match only.

        Args:
            *parsers: two or more parsers to each try in sequence
            matchtype: which of the results from the successful parser to return.
        &#34;&#34;&#34;
        assert len(parsers) &gt; 0
        self.parsers = parsers
        self.matchtype = matchtype

    def parse(self, location, context):
        for p in self.parsers:
            ret = p.parse(location, context)
            if ret.issuccess():
                if self.matchtype == &#34;all&#34;:
                    return ret
                result = ret.result(self.matchtype)
                newloc = result.location
                return Success(
                    Result(result.data, location=newloc, span=result.span), context
                )
        return Failure(
            context=context, location=location, message=&#34;None of the choices match&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Or.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    for p in self.parsers:
        ret = p.parse(location, context)
        if ret.issuccess():
            if self.matchtype == &#34;all&#34;:
                return ret
            result = ret.result(self.matchtype)
            newloc = result.location
            return Success(
                Result(result.data, location=newloc, span=result.span), context
            )
    return Failure(
        context=context, location=location, message=&#34;None of the choices match&#34;
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.Pampac"><code class="flex name class">
<span>class <span class="ident">Pampac</span></span>
<span>(</span><span>*rules, skip='longest', select='first')</span>
</code></dt>
<dd>
<div class="desc"><p>A class for applying a sequence of rules to a document.</p>
<p>Initialize Pampac.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*rules</code></strong></dt>
<dd>one or more rules</dd>
<dt><strong><code>skip</code></strong></dt>
<dd>how proceed after something has been matched at a position. One of: "longest" to proceed
at the next text offset after the end of the longest match. "next" to use a location with the highest
text and annotation index over all matches. "one" to increment the text offset by one and adjust
the annotation index to point to the next annotation at or after the new text offset.
"once": do not advance after the first location where a rule matches. NOTE: if skipping depends on
on the match(es), only those matches for which a rule fires are considered.</dd>
<dt><strong><code>select</code></strong></dt>
<dd>which of those rules that match to actually apply, i.e. call the action part of the rule.
One of: "first": try all rules in sequence and call only the first one that matches. "highest": try
all rules and only call the rules which has the highest priority, if there is more than one, the first
of those.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pampac:
    &#34;&#34;&#34;
    A class for applying a sequence of rules to a document.

    &#34;&#34;&#34;
    def __init__(self, *rules, skip=&#34;longest&#34;, select=&#34;first&#34;):
        &#34;&#34;&#34;
        Initialize Pampac.

        Args:
            *rules: one or more rules
            skip:  how proceed after something has been matched at a position. One of: &#34;longest&#34; to proceed
              at the next text offset after the end of the longest match. &#34;next&#34; to use a location with the highest
              text and annotation index over all matches. &#34;one&#34; to increment the text offset by one and adjust
              the annotation index to point to the next annotation at or after the new text offset.
              &#34;once&#34;: do not advance after the first location where a rule matches. NOTE: if skipping depends on
              on the match(es), only those matches for which a rule fires are considered.
            select: which of those rules that match to actually apply, i.e. call the action part of the rule.
              One of: &#34;first&#34;: try all rules in sequence and call only the first one that matches. &#34;highest&#34;: try
              all rules and only call the rules which has the highest priority, if there is more than one, the first
              of those.
        &#34;&#34;&#34;
        assert len(rules) &gt; 0
        assert skip in [&#34;one&#34;, &#34;longest&#34;, &#34;next&#34;, &#34;once&#34;]
        assert select in [&#34;first&#34;, &#34;highest&#34;, &#34;all&#34;]
        for r in rules:
            assert isinstance(r, Rule)
        self.rules = rules
        self.priorities = [r.priority for r in self.rules]
        self.max_priority = max(self.priorities)
        for idx, r in enumerate(rules):
            if r.priority == self.max_priority:
                self.hp_rule = r
                self.hp_rule_idx = idx
                break
        self.skip = skip
        self.select = select

    def set_skip(self, val):
        &#34;&#34;&#34;
        Different way to set the skip parameter.
        &#34;&#34;&#34;
        self.skip = val
        return self

    def set_select(self, val):
        &#34;&#34;&#34;
        Different way to set the select parameter.
        &#34;&#34;&#34;
        self.select = val
        return self

    def run(self, doc, annotations, outset=None, start=None, end=None, debug=False):
        &#34;&#34;&#34;
        Run the rules from location start to location end (default: full document), using the annotation set or list.

        Args:
            doc: the document to run on
            annotations: the annotation set or iterable to use
            outset: the output annotation set.
            start: the text offset where to start matching
            end: the text offset where to end matching

        Returns:
            a list of tuples (offset, actionreturnvals) for each location where one or more matches occurred
        &#34;&#34;&#34;
        logger = init_logger(debug=debug)
        ctx = Context(doc=doc, anns=annotations, outset=outset, start=start, end=end)
        returntuples = []
        location = Location(ctx.start, 0)
        while True:
            # try the rules at the current position
            cur_offset = location.text_location
            frets = []
            rets = dict()
            for idx, r in enumerate(self.rules):
                logger.debug(f&#34;Trying rule {idx} at location {location}&#34;)
                ret = r.parse(location, ctx)
                if ret.issuccess():
                    rets[idx] = ret
                    logger.debug(f&#34;Success for rule {idx}, {len(ret)} results&#34;)
                    if self.select == &#34;first&#34;:
                        break
            # we now got all the matching results in rets
            # if we have at least one matching ...
            if len(rets) &gt; 0:
                fired_rets = []
                # choose the rules to fire and call the actions
                if self.select == &#34;first&#34;:
                    idx, ret = list(rets.items())[0]
                    logger.debug(f&#34;Firing rule {idx} at {location}&#34;)
                    fret = self.rules[idx].action(ret, context=ctx, location=location)
                    frets.append(fret)
                    fired_rets.append(ret)
                elif self.select == &#34;all&#34;:
                    for idx, ret in rets.items():
                        logger.debug(f&#34;Firing rule {idx} at {location}&#34;)
                        fret = self.rules[idx].action(ret, context=ctx, location=location)
                        frets.append(fret)
                        fired_rets.append(ret)
                elif self.select == &#34;highest&#34;:
                    for idx, ret in rets.items():
                        if idx == self.hp_rule_idx:
                            logger.debug(f&#34;Firing rule {idx} at {location}&#34;)
                            fret = self.rules[idx].action(ret, context=ctx, location=location)
                            frets.append(fret)
                            fired_rets.append(ret)
                # now that we have fired rules, find out how to advance to the next position
                if self.skip == &#34;once&#34;:
                    return frets
                elif self.skip == &#34;once&#34;:
                    location = ctx.inc_location(location, by_offset=1)
                elif self.skip == &#34;longest&#34;:
                    longest = 0
                    for ret in fired_rets:
                        for res in ret:
                            if res.location.text_location &gt; longest:
                                longest = res.location.text_location
                    location.text_location = longest
                    location = ctx.update_location_byoffset(location)
                elif self.skip == &#34;next&#34;:
                    for ret in fired_rets:
                        for res in ret:
                            if res.location.text_location &gt; location.text_location:
                                location.text_location = res.location.text_location
                                location.ann_location = res.location.ann_location
                            elif res.location.text_location == location.text_location and \
                                    res.location.ann_location &gt; location.ann_location:
                                location.ann_location = res.location.ann_location
                returntuples.append((cur_offset, frets))
            else:
                # we had no match, just continue from the next offset
                location = ctx.inc_location(location, by_offset=1)
            if ctx.at_endofanns(location) or ctx.at_endoftext(location):
                break
        return returntuples

    __call__ = run</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Pampac.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, doc, annotations, outset=None, start=None, end=None, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the rules from location start to location end (default: full document), using the annotation set or list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>doc</code></strong></dt>
<dd>the document to run on</dd>
<dt><strong><code>annotations</code></strong></dt>
<dd>the annotation set or iterable to use</dd>
<dt><strong><code>outset</code></strong></dt>
<dd>the output annotation set.</dd>
<dt><strong><code>start</code></strong></dt>
<dd>the text offset where to start matching</dd>
<dt><strong><code>end</code></strong></dt>
<dd>the text offset where to end matching</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a list of tuples (offset, actionreturnvals) for each location where one or more matches occurred</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, doc, annotations, outset=None, start=None, end=None, debug=False):
    &#34;&#34;&#34;
    Run the rules from location start to location end (default: full document), using the annotation set or list.

    Args:
        doc: the document to run on
        annotations: the annotation set or iterable to use
        outset: the output annotation set.
        start: the text offset where to start matching
        end: the text offset where to end matching

    Returns:
        a list of tuples (offset, actionreturnvals) for each location where one or more matches occurred
    &#34;&#34;&#34;
    logger = init_logger(debug=debug)
    ctx = Context(doc=doc, anns=annotations, outset=outset, start=start, end=end)
    returntuples = []
    location = Location(ctx.start, 0)
    while True:
        # try the rules at the current position
        cur_offset = location.text_location
        frets = []
        rets = dict()
        for idx, r in enumerate(self.rules):
            logger.debug(f&#34;Trying rule {idx} at location {location}&#34;)
            ret = r.parse(location, ctx)
            if ret.issuccess():
                rets[idx] = ret
                logger.debug(f&#34;Success for rule {idx}, {len(ret)} results&#34;)
                if self.select == &#34;first&#34;:
                    break
        # we now got all the matching results in rets
        # if we have at least one matching ...
        if len(rets) &gt; 0:
            fired_rets = []
            # choose the rules to fire and call the actions
            if self.select == &#34;first&#34;:
                idx, ret = list(rets.items())[0]
                logger.debug(f&#34;Firing rule {idx} at {location}&#34;)
                fret = self.rules[idx].action(ret, context=ctx, location=location)
                frets.append(fret)
                fired_rets.append(ret)
            elif self.select == &#34;all&#34;:
                for idx, ret in rets.items():
                    logger.debug(f&#34;Firing rule {idx} at {location}&#34;)
                    fret = self.rules[idx].action(ret, context=ctx, location=location)
                    frets.append(fret)
                    fired_rets.append(ret)
            elif self.select == &#34;highest&#34;:
                for idx, ret in rets.items():
                    if idx == self.hp_rule_idx:
                        logger.debug(f&#34;Firing rule {idx} at {location}&#34;)
                        fret = self.rules[idx].action(ret, context=ctx, location=location)
                        frets.append(fret)
                        fired_rets.append(ret)
            # now that we have fired rules, find out how to advance to the next position
            if self.skip == &#34;once&#34;:
                return frets
            elif self.skip == &#34;once&#34;:
                location = ctx.inc_location(location, by_offset=1)
            elif self.skip == &#34;longest&#34;:
                longest = 0
                for ret in fired_rets:
                    for res in ret:
                        if res.location.text_location &gt; longest:
                            longest = res.location.text_location
                location.text_location = longest
                location = ctx.update_location_byoffset(location)
            elif self.skip == &#34;next&#34;:
                for ret in fired_rets:
                    for res in ret:
                        if res.location.text_location &gt; location.text_location:
                            location.text_location = res.location.text_location
                            location.ann_location = res.location.ann_location
                        elif res.location.text_location == location.text_location and \
                                res.location.ann_location &gt; location.ann_location:
                            location.ann_location = res.location.ann_location
            returntuples.append((cur_offset, frets))
        else:
            # we had no match, just continue from the next offset
            location = ctx.inc_location(location, by_offset=1)
        if ctx.at_endofanns(location) or ctx.at_endoftext(location):
            break
    return returntuples</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Pampac.set_select"><code class="name flex">
<span>def <span class="ident">set_select</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Different way to set the select parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_select(self, val):
    &#34;&#34;&#34;
    Different way to set the select parameter.
    &#34;&#34;&#34;
    self.select = val
    return self</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Pampac.set_skip"><code class="name flex">
<span>def <span class="ident">set_skip</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Different way to set the skip parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_skip(self, val):
    &#34;&#34;&#34;
    Different way to set the skip parameter.
    &#34;&#34;&#34;
    self.skip = val
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser"><code class="flex name class">
<span>class <span class="ident">PampacParser</span></span>
<span>(</span><span>parser_function)</span>
</code></dt>
<dd>
<div class="desc"><p>A Pampac parser, something that takes a context and returns a result.
This can be used to decorate a function that should be used as the parser,
or for subclassing specific parsers.</p>
<p>When subclassing, the parse(location, context) method must be overriden!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PampacParser:
    &#34;&#34;&#34;
    A Pampac parser, something that takes a context and returns a result.
    This can be used to decorate a function that should be used as the parser,
    or for subclassing specific parsers.

    When subclassing, the parse(location, context) method must be overriden!
    &#34;&#34;&#34;

    def __init__(self, parser_function):
        self.name = None
        self._parser_function = parser_function
        self.name = parser_function.__name__
        functools.update_wrapper(self, parser_function)

    def parse(self, location, context):
        return self._parser_function(location, context)

    def match(self, doc, anns=None, start=None, end=None, location=None):
        &#34;&#34;&#34;
        Runs the matcher on the given document and the given annotations. Annotations may be empty in which
        case only matching on text makes sense.

        Args:
            doc: the document to run matching on.
            anns: (default: None) a set or Iterable of annotations. If this is a list or Iterable, the annotations
               will get matched in the order given. If it is a set the &#34;natural&#34; order of annotations used
               by the annotation set iterator will be used.
            start:  the minimum text offset of a range where to look for matches. No annotations that start before
               that offset are included.
            end: the maximum text offset of a range where to look for matches. No annotation that ends after that
               offset and not text that ends after that offset should get included in the result.

        Returns:
            Either Success or Failure

        &#34;&#34;&#34;
        if anns is None:
            anns = []
        else:
            anns = list(anns)
        ctx = Context(doc, anns, start=start, end=end)
        if location is None:
            location = Location(ctx.start, 0)
        return self.parse(location, ctx)

    __call__ = match

    def call(self, func, onfailure=None):
        &#34;&#34;&#34;
        Returns a parser that is equivalent to this parser, but also calls the given function if there is success.

        Args:
            func: the function to call on the success. Should take the success object and arbitrary kwargs.
                context and location are kwargs that get passed.
            onfailure: the function to call on failure. Should take the failure object and arbitrary kwargs.
                context and location are kwargs that get passed.

        Returns:

        &#34;&#34;&#34;
        return Call(self, func, onfailure=onfailure)

    def __or__(self, other):
        return Or(self, other)

    def __rshift__(self, other):
        return Seq(self, other)

    def __and__(self, other):
        return And(self, other)

    def __xor__(self, other):
        &#34;&#34;&#34;
        Return a parser that succeeds if this or the other parser succeeds and return the union of all results.
        Fails if both parsers fail.

        NOTE: `a ^ b ^ c` is NOT the same as All(a,b,c) as the first will fail if b fails but the second will
        still return `a ^ c`

        Args:
            other:

        Returns:

        &#34;&#34;&#34;
        return All(self, other)

    def where(self, predicate, take_if=True):
        return Filter(self, predicate, take_if=take_if)

    def repeat(self, min=1, max=1):
        return N(self, min=min, max=max)

    def __mul__(self, n):
        if isinstance(n, int):
            return N(self, min=n, max=n)
        elif isinstance(n, tuple) and len(n) == 2:
            return N(self, min=n[0], max=n[1])
        elif isinstance(n, list) and len(n) == 2:
            return N(self, min=n[0], max=n[1])
        else:
            raise Exception(&#34;Not an integer or tuple or list of two integers&#34;)

    def _make_constraint_predicate(self, matcher, matchtype, constraint):
        &#34;&#34;&#34;
        Create predicate that can be used to filter results according to one of the
        annotation-based constraints like .within, .coextensive.

        Args:
            matcher: the annotation matcher
            matchtype: the matchtype for the filter
            constraint: the constraint to use on the annotation set

        Returns:
            predicate function

        &#34;&#34;&#34;
        def _predicate(result, context=None, **kwargs):
            anns = set()
            for d in result.data:
                ann = d.get(&#34;ann&#34;)
                if ann:
                    anns.add(ann)
            annset = context.annset
            # TODO: !!!!!!!  CHECK IF THIS IS CORRECT
            tocall = getattr(annset, constraint)
            annstocheck = tocall(result.span)
            for anntocheck in annstocheck:
                if matcher(anntocheck, context.doc):
                    if anntocheck in anns:
                        continue
                    return True
            return False
        return _predicate

    def _make_notconstraint_predicate(self, matcher, matchtype, constraint):
        &#34;&#34;&#34;
        Create predicate that can be used to filter results according to one of the
        annotation-based negated constraints like .notwithin, .notcoextensive.

        Args:
            matcher: the annotation matcher
            matchtype: the matchtype for the filter
            constraint: the constraint to use on the annotation set

        Returns:
            predicate function

        &#34;&#34;&#34;
        def _predicate(result, context=None, **kwargs):
            anns = set()
            for d in result.data:
                ann = d.get(&#34;ann&#34;)
                if ann:
                    anns.add(ann)
            annset = context.annset
            # TODO: !!!!!!!!!!!!! CHECK IF CORRECT, SPAN CORRECT?
            tocall = getattr(annset, constraint)
            annstocheck = tocall(result.span)
            matched = False
            for anntocheck in annstocheck:
                if matcher(anntocheck, context.doc):
                    if anntocheck in anns:
                        continue
                    matched = True
            return not matched
        return _predicate

    def within(self, type=None, features=None, features_eq=None, text=None, matchtype=&#34;first&#34;):
        &#34;&#34;&#34;
        Parser that succeeds if there is a success for the current parser that is within any annotation
        that matches the given properties and is different from that annotation.

        Args:
            type:
            features:
            features_eq:
            text:
            matchtype: return matches of all that are within the span according to the given strategy

        Returns:
            Parser modified to only match within a matching annotation
        &#34;&#34;&#34;
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_constraint_predicate(matcher, matchtype, &#34;covering&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def notwithin(self, type=None, features=None, features_eq=None, text=None, matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;covering&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def coextensive(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_constraint_predicate(matcher, matchtype, &#34;coextensive&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def notcoextensive(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;coextensive&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def overlapping(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_constraint_predicate(matcher, matchtype, &#34;overlapping&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def notoverlapping(self,type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;overlapping&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def covering(self, type=None, features=None, features_eq=None, text=None, matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_constraint_predicate(matcher, matchtype, &#34;within&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def notcovering(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;within&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def at(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_constraint_predicate(matcher, matchtype, &#34;start_eq&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def noat(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )
        pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;start_eq&#34;)
        return Filter(self, pred, matchtype=matchtype)

    def before(self, type=None, features=None, features_eq=None, text=None, immediately=False, matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )

        # predicate for this needs to check if there are matching annotations that start at or after
        # the END of the result
        def _predicate(result, context=None, **kwargs):
            anns = set()
            for d in result.data:
                ann = d.get(&#34;ann&#34;)
                if ann:
                    anns.add(ann)
            annset = context.annset
            if immediately:
                annstocheck = annset.start_eq(result.span.end)
            else:
                annstocheck = annset.start_ge(result.span.end)
            for anntocheck in annstocheck:
                if matcher(anntocheck, context.doc):
                    if anntocheck in anns:
                        continue
                    return True
            return False
        return Filter(self, _predicate, matchtype=matchtype)

    @support_annotation_or_set
    def notbefore(self,  type=None, features=None, features_eq=None, text=None, immediately=False, matchtype=&#34;first&#34;):
        matcher = AnnMatcher(
            type=type, features=features, features_eq=features_eq, text=text
        )

        def _predicate(result, context=None, **kwargs):
            anns = set()
            for d in result.data:
                ann = d.get(&#34;ann&#34;)
                if ann:
                    anns.add(ann)
            annset = context.annset
            if immediately:
                annstocheck = annset.start_eq(result.span.end)
            else:
                annstocheck = annset.start_ge(result.span.end)
            matched = False
            for anntocheck in annstocheck:
                if matcher(anntocheck, context.doc):
                    if anntocheck in anns:
                        continue
                    matched = True
            return not matched
        return Filter(self, _predicate, matchtype=matchtype)

    def lookahead(self, parser):
        &#34;&#34;&#34;
        Return a parser that makes sure the given parser has at least one match before returning success.

        Args:
            parser:

        Returns:

        &#34;&#34;&#34;
        return Lookahead(self, parser)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.All" href="#gatenlp.pam.pampac.All">All</a></li>
<li><a title="gatenlp.pam.pampac.And" href="#gatenlp.pam.pampac.And">And</a></li>
<li><a title="gatenlp.pam.pampac.Call" href="#gatenlp.pam.pampac.Call">Call</a></li>
<li><a title="gatenlp.pam.pampac.Filter" href="#gatenlp.pam.pampac.Filter">Filter</a></li>
<li><a title="gatenlp.pam.pampac.Find" href="#gatenlp.pam.pampac.Find">Find</a></li>
<li><a title="gatenlp.pam.pampac.Lookahead" href="#gatenlp.pam.pampac.Lookahead">Lookahead</a></li>
<li><a title="gatenlp.pam.pampac.N" href="#gatenlp.pam.pampac.N">N</a></li>
<li><a title="gatenlp.pam.pampac.Or" href="#gatenlp.pam.pampac.Or">Or</a></li>
<li><a title="gatenlp.pam.pampac.Rule" href="#gatenlp.pam.pampac.Rule">Rule</a></li>
<li><a title="gatenlp.pam.pampac.Seq" href="#gatenlp.pam.pampac.Seq">Seq</a></li>
<li><a title="gatenlp.pam.pampac.Text" href="#gatenlp.pam.pampac.Text">Text</a></li>
<li>gatenlp.pam.pampac._AnnBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.PampacParser.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )
    pred = self._make_constraint_predicate(matcher, matchtype, &#34;start_eq&#34;)
    return Filter(self, pred, matchtype=matchtype)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.before"><code class="name flex">
<span>def <span class="ident">before</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, immediately=False, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def before(self, type=None, features=None, features_eq=None, text=None, immediately=False, matchtype=&#34;first&#34;):
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )

    # predicate for this needs to check if there are matching annotations that start at or after
    # the END of the result
    def _predicate(result, context=None, **kwargs):
        anns = set()
        for d in result.data:
            ann = d.get(&#34;ann&#34;)
            if ann:
                anns.add(ann)
        annset = context.annset
        if immediately:
            annstocheck = annset.start_eq(result.span.end)
        else:
            annstocheck = annset.start_ge(result.span.end)
        for anntocheck in annstocheck:
            if matcher(anntocheck, context.doc):
                if anntocheck in anns:
                    continue
                return True
        return False
    return Filter(self, _predicate, matchtype=matchtype)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, func, onfailure=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a parser that is equivalent to this parser, but also calls the given function if there is success.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong></dt>
<dd>the function to call on the success. Should take the success object and arbitrary kwargs.
context and location are kwargs that get passed.</dd>
<dt><strong><code>onfailure</code></strong></dt>
<dd>the function to call on failure. Should take the failure object and arbitrary kwargs.
context and location are kwargs that get passed.</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, func, onfailure=None):
    &#34;&#34;&#34;
    Returns a parser that is equivalent to this parser, but also calls the given function if there is success.

    Args:
        func: the function to call on the success. Should take the success object and arbitrary kwargs.
            context and location are kwargs that get passed.
        onfailure: the function to call on failure. Should take the failure object and arbitrary kwargs.
            context and location are kwargs that get passed.

    Returns:

    &#34;&#34;&#34;
    return Call(self, func, onfailure=onfailure)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.coextensive"><code class="name flex">
<span>def <span class="ident">coextensive</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coextensive(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )
    pred = self._make_constraint_predicate(matcher, matchtype, &#34;coextensive&#34;)
    return Filter(self, pred, matchtype=matchtype)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.covering"><code class="name flex">
<span>def <span class="ident">covering</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def covering(self, type=None, features=None, features_eq=None, text=None, matchtype=&#34;first&#34;):
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )
    pred = self._make_constraint_predicate(matcher, matchtype, &#34;within&#34;)
    return Filter(self, pred, matchtype=matchtype)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.lookahead"><code class="name flex">
<span>def <span class="ident">lookahead</span></span>(<span>self, parser)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a parser that makes sure the given parser has at least one match before returning success.</p>
<h2 id="args">Args</h2>
<p>parser:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lookahead(self, parser):
    &#34;&#34;&#34;
    Return a parser that makes sure the given parser has at least one match before returning success.

    Args:
        parser:

    Returns:

    &#34;&#34;&#34;
    return Lookahead(self, parser)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, doc, anns=None, start=None, end=None, location=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the matcher on the given document and the given annotations. Annotations may be empty in which
case only matching on text makes sense.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>doc</code></strong></dt>
<dd>the document to run matching on.</dd>
<dt><strong><code>anns</code></strong></dt>
<dd>(default: None) a set or Iterable of annotations. If this is a list or Iterable, the annotations
will get matched in the order given. If it is a set the "natural" order of annotations used
by the annotation set iterator will be used.</dd>
<dt><strong><code>start</code></strong></dt>
<dd>the minimum text offset of a range where to look for matches. No annotations that start before
that offset are included.</dd>
<dt><strong><code>end</code></strong></dt>
<dd>the maximum text offset of a range where to look for matches. No annotation that ends after that
offset and not text that ends after that offset should get included in the result.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Either Success or Failure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, doc, anns=None, start=None, end=None, location=None):
    &#34;&#34;&#34;
    Runs the matcher on the given document and the given annotations. Annotations may be empty in which
    case only matching on text makes sense.

    Args:
        doc: the document to run matching on.
        anns: (default: None) a set or Iterable of annotations. If this is a list or Iterable, the annotations
           will get matched in the order given. If it is a set the &#34;natural&#34; order of annotations used
           by the annotation set iterator will be used.
        start:  the minimum text offset of a range where to look for matches. No annotations that start before
           that offset are included.
        end: the maximum text offset of a range where to look for matches. No annotation that ends after that
           offset and not text that ends after that offset should get included in the result.

    Returns:
        Either Success or Failure

    &#34;&#34;&#34;
    if anns is None:
        anns = []
    else:
        anns = list(anns)
    ctx = Context(doc, anns, start=start, end=end)
    if location is None:
        location = Location(ctx.start, 0)
    return self.parse(location, ctx)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.noat"><code class="name flex">
<span>def <span class="ident">noat</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def noat(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )
    pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;start_eq&#34;)
    return Filter(self, pred, matchtype=matchtype)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.notbefore"><code class="name flex">
<span>def <span class="ident">notbefore</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, immediately=False, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def notbefore(self,  type=None, features=None, features_eq=None, text=None, immediately=False, matchtype=&#34;first&#34;):
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )

    def _predicate(result, context=None, **kwargs):
        anns = set()
        for d in result.data:
            ann = d.get(&#34;ann&#34;)
            if ann:
                anns.add(ann)
        annset = context.annset
        if immediately:
            annstocheck = annset.start_eq(result.span.end)
        else:
            annstocheck = annset.start_ge(result.span.end)
        matched = False
        for anntocheck in annstocheck:
            if matcher(anntocheck, context.doc):
                if anntocheck in anns:
                    continue
                matched = True
        return not matched
    return Filter(self, _predicate, matchtype=matchtype)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.notcoextensive"><code class="name flex">
<span>def <span class="ident">notcoextensive</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notcoextensive(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )
    pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;coextensive&#34;)
    return Filter(self, pred, matchtype=matchtype)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.notcovering"><code class="name flex">
<span>def <span class="ident">notcovering</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notcovering(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )
    pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;within&#34;)
    return Filter(self, pred, matchtype=matchtype)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.notoverlapping"><code class="name flex">
<span>def <span class="ident">notoverlapping</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notoverlapping(self,type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )
    pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;overlapping&#34;)
    return Filter(self, pred, matchtype=matchtype)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.notwithin"><code class="name flex">
<span>def <span class="ident">notwithin</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notwithin(self, type=None, features=None, features_eq=None, text=None, matchtype=&#34;first&#34;):
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )
    pred = self._make_notconstraint_predicate(matcher, matchtype, &#34;covering&#34;)
    return Filter(self, pred, matchtype=matchtype)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.overlapping"><code class="name flex">
<span>def <span class="ident">overlapping</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlapping(self, type=None, features=None, features_eq=None, text=None,  matchtype=&#34;first&#34;):
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )
    pred = self._make_constraint_predicate(matcher, matchtype, &#34;overlapping&#34;)
    return Filter(self, pred, matchtype=matchtype)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    return self._parser_function(location, context)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.repeat"><code class="name flex">
<span>def <span class="ident">repeat</span></span>(<span>self, min=1, max=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat(self, min=1, max=1):
    return N(self, min=min, max=max)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>self, predicate, take_if=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(self, predicate, take_if=True):
    return Filter(self, predicate, take_if=take_if)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.PampacParser.within"><code class="name flex">
<span>def <span class="ident">within</span></span>(<span>self, type=None, features=None, features_eq=None, text=None, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"><p>Parser that succeeds if there is a success for the current parser that is within any annotation
that matches the given properties and is different from that annotation.</p>
<h2 id="args">Args</h2>
<dl>
<dt>type:</dt>
<dt>features:</dt>
<dt>features_eq:</dt>
<dt>text:</dt>
<dt><strong><code>matchtype</code></strong></dt>
<dd>return matches of all that are within the span according to the given strategy</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Parser modified to only match within a matching annotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def within(self, type=None, features=None, features_eq=None, text=None, matchtype=&#34;first&#34;):
    &#34;&#34;&#34;
    Parser that succeeds if there is a success for the current parser that is within any annotation
    that matches the given properties and is different from that annotation.

    Args:
        type:
        features:
        features_eq:
        text:
        matchtype: return matches of all that are within the span according to the given strategy

    Returns:
        Parser modified to only match within a matching annotation
    &#34;&#34;&#34;
    matcher = AnnMatcher(
        type=type, features=features, features_eq=features_eq, text=text
    )
    pred = self._make_constraint_predicate(matcher, matchtype, &#34;covering&#34;)
    return Filter(self, pred, matchtype=matchtype)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.pam.pampac.Pattern"><code class="flex name class">
<span>class <span class="ident">CLASS_REGEX_PATTERN</span></span>
</code></dt>
<dd>
<div class="desc"><p>Compiled regex object</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="gatenlp.pam.pampac.Pattern.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><p>The regex matching flags.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.groupindex"><code class="name">var <span class="ident">groupindex</span></code></dt>
<dd>
<div class="desc"><p>A dictionary mapping group names to group numbers.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.groups"><code class="name">var <span class="ident">groups</span></code></dt>
<dd>
<div class="desc"><p>The number of capturing groups in the pattern.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.named_lists"><code class="name">var <span class="ident">named_lists</span></code></dt>
<dd>
<div class="desc"><p>The named lists used by the regex.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.pattern"><code class="name">var <span class="ident">pattern</span></code></dt>
<dd>
<div class="desc"><p>The pattern string from which the regex object was compiled.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Pattern.findall"><code class="name flex">
<span>def <span class="ident">findall</span></span>(<span>string, pos=None, endpos=None, overlapped=False, concurrent=None, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>findall(string, pos=None, endpos=None, overlapped=False, concurrent=None, timeout=None) &ndash;&gt; list.
Return a list of all matches of pattern in string.
The matches may be
overlapped if overlapped is True.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.finditer"><code class="name flex">
<span>def <span class="ident">finditer</span></span>(<span>string, pos=None, endpos=None, overlapped=False, concurrent=None, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>finditer(string, pos=None, endpos=None, overlapped=False, concurrent=None, timeout=None) &ndash;&gt; iterator.
Return an iterator over all matches for the RE pattern in string.
The
matches may be overlapped if overlapped is True.
For each match, the
iterator returns a MatchObject.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.fullmatch"><code class="name flex">
<span>def <span class="ident">fullmatch</span></span>(<span>string, pos=None, endpos=None, concurrent=None, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>fullmatch(string, pos=None, endpos=None, concurrent=None, timeout=None) &ndash;&gt; MatchObject or None.
Match zero or more characters against all of the string.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>string, pos=None, endpos=None, concurrent=None, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>match(string, pos=None, endpos=None, concurrent=None, timeout=None) &ndash;&gt; MatchObject or None.
Match zero or more characters at the beginning of the string.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.scanner"><code class="name flex">
<span>def <span class="ident">scanner</span></span>(<span>string, pos=None, endpos=None, overlapped=False, concurrent=None, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>scanner(string, pos=None, endpos=None, overlapped=False, concurrent=None, timeout=None) &ndash;&gt; scanner.
Return an scanner for the RE pattern in string.
The matches may be overlapped
if overlapped is True.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>string, pos=None, endpos=None, concurrent=None, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>search(string, pos=None, endpos=None, concurrent=None, timeout=None) &ndash;&gt; MatchObject or None.
Search through string looking for a match, and return a corresponding
match object instance.
Return None if no match is found.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>split(string, string, maxsplit=0, concurrent=None, timeout=None) &ndash;&gt; list.
Split string by the occurrences of pattern.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.splititer"><code class="name flex">
<span>def <span class="ident">splititer</span></span>(<span>string, maxsplit=0, concurrent=None, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>splititer(string, maxsplit=0, concurrent=None, timeout=None) &ndash;&gt; iterator.
Return an iterator yielding the parts of a split string.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.sub"><code class="name flex">
<span>def <span class="ident">sub</span></span>(<span>repl, string, count=0, flags=0, pos=None, endpos=None, concurrent=None, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>sub(repl, string, count=0, flags=0, pos=None, endpos=None, concurrent=None, timeout=None) &ndash;&gt; newstring
Return the string obtained by replacing the leftmost (or rightmost with a
reverse pattern) non-overlapping occurrences of pattern in string by the
replacement repl.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.subf"><code class="name flex">
<span>def <span class="ident">subf</span></span>(<span>format, string, count=0, flags=0, pos=None, endpos=None, concurrent=None, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>subf(format, string, count=0, flags=0, pos=None, endpos=None, concurrent=None, timeout=None) &ndash;&gt; newstring
Return the string obtained by replacing the leftmost (or rightmost with a
reverse pattern) non-overlapping occurrences of pattern in string by the
replacement format.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.subfn"><code class="name flex">
<span>def <span class="ident">subfn</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>subfn(format, string, count=0, flags=0, pos=None, endpos=None, concurrent=None, timeout=None) &ndash;&gt; (newstring, number of subs)
Return the tuple (new_string, number_of_subs_made) found by replacing the
leftmost (or rightmost with a reverse pattern) non-overlapping occurrences
of pattern with the replacement format.</p></div>
</dd>
<dt id="gatenlp.pam.pampac.Pattern.subn"><code class="name flex">
<span>def <span class="ident">subn</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>subn(repl, string, count=0, flags=0, pos=None, endpos=None, concurrent=None, timeout=None) &ndash;&gt; (newstring, number of subs)
Return the tuple (new_string, number_of_subs_made) found by replacing the
leftmost (or rightmost with a reverse pattern) non-overlapping occurrences
of pattern with the replacement repl.</p></div>
</dd>
</dl>
</dd>
<dt id="gatenlp.pam.pampac.Result"><code class="flex name class">
<span>class <span class="ident">Result</span></span>
<span>(</span><span>data=None, location=None, span=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an individual parser result. A successful parse can have any number of parser results which
are alternate ways of how the parser can match the document.</p>
<p>Creata parser result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>the data associated with the result, this should be a dictionary or None.</dd>
<dt><strong><code>location</code></strong></dt>
<dd>the location where the result was matched, i.e. the location <em>before</em> matching was done.</dd>
<dt><strong><code>span</code></strong></dt>
<dd>the span representing the start and end text offset for the match</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Result:
    &#34;&#34;&#34;
    Represents an individual parser result. A successful parse can have any number of parser results which
    are alternate ways of how the parser can match the document.
    &#34;&#34;&#34;
    def __init__(self, data=None, location=None, span=None):
        &#34;&#34;&#34;
        Creata parser result.

        Args:
            data: the data associated with the result, this should be a dictionary or None.
            location: the location where the result was matched, i.e. the location *before* matching was done.
            span: the span representing the start and end text offset for the match
        &#34;&#34;&#34;
        assert location is not None
        assert span is not None
        if data is not None:
            if isinstance(data, dict):
                self.data = [data]
            elif isinstance(data, Iterable):
                self.data = list(data)
            else:
                self.data = [data]
        else:
            self.data = []
        self.location = location
        self.span = span

    def data4name(self, name):
        &#34;&#34;&#34;
        Return a list of data dictionaries with the given name.
        &#34;&#34;&#34;
        return [d for d in self.data if d.get(&#34;name&#34;) == name]

    def __str__(self):
        return f&#34;Result(loc={self.location},span=({self.span.start},{self.span.end}),ndata={len(self.data)})&#34;

    def __repr__(self):
        return f&#34;Result(loc={self.location},span=({self.span.start},{self.span.end}),data={self.data})&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Result.data4name"><code class="name flex">
<span>def <span class="ident">data4name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of data dictionaries with the given name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data4name(self, name):
    &#34;&#34;&#34;
    Return a list of data dictionaries with the given name.
    &#34;&#34;&#34;
    return [d for d in self.data if d.get(&#34;name&#34;) == name]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.pam.pampac.Rule"><code class="flex name class">
<span>class <span class="ident">Rule</span></span>
<span>(</span><span>parser, action, priority=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A matching rule: this defines the parser and some action (a function) to carry out if the rule matches
as it is tried as one of many rules with a Pampac instance. Depending on select setting for pampac
the action only fires under certain circumstances (e.g. the rule is the first that matches at a location).
Rule is thus different from pattern.call() or Call(pattern, func) as these always call the function if
there is a successful match.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rule(PampacParser):
    &#34;&#34;&#34;
    A matching rule: this defines the parser and some action (a function) to carry out if the rule matches
    as it is tried as one of many rules with a Pampac instance. Depending on select setting for pampac
    the action only fires under certain circumstances (e.g. the rule is the first that matches at a location).
    Rule is thus different from pattern.call() or Call(pattern, func) as these always call the function if
    there is a successful match.
    &#34;&#34;&#34;

    def __init__(self, parser, action, priority=0):
        self.parser = parser
        self.action = action
        self.priority = priority

    def set_priority(self, val):
        &#34;&#34;&#34;
        Different way of setting the priority.
        &#34;&#34;&#34;
        self.priority = val
        return self

    def parse(self, location, context):
        &#34;&#34;&#34;
        Return the parse result. This does NOT automatically invoke the action if the parse result is a success.
        The invoking Pampac instance decides, based on its setting, for which matching rules the action is
        actually carried out.

        Returns:
            Success or failure of the parser

        &#34;&#34;&#34;
        return self.parser.parse(location, context)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Rule.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the parse result. This does NOT automatically invoke the action if the parse result is a success.
The invoking Pampac instance decides, based on its setting, for which matching rules the action is
actually carried out.</p>
<h2 id="returns">Returns</h2>
<p>Success or failure of the parser</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    &#34;&#34;&#34;
    Return the parse result. This does NOT automatically invoke the action if the parse result is a success.
    The invoking Pampac instance decides, based on its setting, for which matching rules the action is
    actually carried out.

    Returns:
        Success or failure of the parser

    &#34;&#34;&#34;
    return self.parser.parse(location, context)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Rule.set_priority"><code class="name flex">
<span>def <span class="ident">set_priority</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Different way of setting the priority.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_priority(self, val):
    &#34;&#34;&#34;
    Different way of setting the priority.
    &#34;&#34;&#34;
    self.priority = val
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.Seq"><code class="flex name class">
<span>class <span class="ident">Seq</span></span>
<span>(</span><span>*parsers, matchtype='first', select='first', name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A parser that represents a sequence of matching parsers. Each result of this parser combines
all the data from the sequence element parsers. For matchtype all and select all, all paths
through all the possible ways to match the sequence get combined into separate results of
a successful parse.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*parsers</code></strong></dt>
<dd>one or more parsers</dd>
<dt><strong><code>matchtype</code></strong></dt>
<dd>(default "first") one of "first", "longest", "shortest", "all": which match to return.
Note that even if a matchtype for a single match is specified, the parser may still need to
generate an exponential number of combinations for all the results to select from.</dd>
<dt><strong><code>select</code></strong></dt>
<dd>(default "first") one of "first", "longest", "shortest", "all": which match to choose from each
of the parsers. Only if "all" is used will more than one result be generated.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>if not None, a separate data element is added to the result with that name and
a span that represents the span of the result.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Seq(PampacParser):
    &#34;&#34;&#34;
    A parser that represents a sequence of matching parsers. Each result of this parser combines
    all the data from the sequence element parsers. For matchtype all and select all, all paths
    through all the possible ways to match the sequence get combined into separate results of
    a successful parse.
    &#34;&#34;&#34;

    def __init__(self, *parsers, matchtype=&#34;first&#34;, select=&#34;first&#34;, name=None):
        &#34;&#34;&#34;

        Args:
            *parsers: one or more parsers
            matchtype: (default &#34;first&#34;) one of &#34;first&#34;, &#34;longest&#34;, &#34;shortest&#34;, &#34;all&#34;: which match to return.
              Note that even if a matchtype for a single match is specified, the parser may still need to
              generate an exponential number of combinations for all the results to select from.
            select: (default &#34;first&#34;) one of &#34;first&#34;, &#34;longest&#34;, &#34;shortest&#34;, &#34;all&#34;: which match to choose from each
              of the parsers. Only if &#34;all&#34; is used will more than one result be generated.
            name: if not None, a separate data element is added to the result with that name and
              a span that represents the span of the result.
        &#34;&#34;&#34;
        assert len(parsers) &gt; 0
        self.parsers = parsers
        if matchtype is None:
            matchtype = &#34;first&#34;
        assert matchtype in [&#34;first&#34;, &#34;longest&#34;, &#34;shortest&#34;, &#34;all&#34;]
        self.select = select
        self.matchtype = matchtype
        self.name = name

    def parse(self, location, context):
        if self.select != &#34;all&#34;:
            datas = []
            first = True
            start = None
            end = None
            for parser in self.parsers:
                ret = parser.parse(location, context)
                if ret.issuccess():
                    result = ret.result(self.select)
                    for d in result.data:
                        datas.append(d)
                    location = result.location
                    if first:
                        first = False
                        start = result.span.start
                    end = result.span.end
                else:
                    return Failure(
                        context=context, location=location, message=&#34;Mismatch in Seq&#34;
                    )
            if self.name:
                datas.append(dict(span=Span(start,end), name=self.name, location=location))
            return Success(
                Result(data=datas, location=location, span=Span(start, end)), context
            )
        else:
            # This does a depth-first enumeration of all matches: each successive parser gets tried
            # for each result of the previous one.

            def depthfirst(lvl, result):
                parser = self.parsers[lvl]
                ret = parser.parse(result.location, context)
                if ret.issuccess():
                    for res in ret:
                        datas = result.data.copy()
                        for d in res.data:
                            datas.append(d)
                        loc = res.location
                        span = Span(location.text_location, res.location.text_location)
                        if lvl == len(self.parsers) - 1:
                            if self.name:
                                datas.append(dict(span=Span(start, end),
                                                  location=loc,
                                                  name=self.name))
                            newresult = Result(datas, location=loc, span=span)
                            yield newresult
                        else:
                            newresult = Result(datas, location=loc, span=span)
                            yield from depthfirst(lvl + 1, newresult)

            gen = depthfirst(0, Result(data=[], location=location, span=Span(None, None)))
            all = []
            best = None
            for idx, result in enumerate(gen):
                if self.matchtype == &#34;first&#34; and idx == 0:
                    return Success(result, context)
                if self.matchtype == &#34;all&#34;:
                    all.append(result)
                elif self.matchtype == &#34;longest&#34;:
                    if best is None:
                        best = result
                    elif result.span.end&gt; best.span.end:
                        best = result
                elif self.matchtype == &#34;shortest&#34;:
                    if best is None:
                        best = result
                    elif result.span.end &lt; best.span.end:
                        best = result
            if self.matchtype == &#34;all&#34;:
                if len(all) &gt; 0:
                    return Success(all, context)
                else:
                    return Failure(context=context, location=location)
            else:
                if best is not None:
                    return Success(best, context)
                else:
                    return Failure(context=context, location=location)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Seq.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    if self.select != &#34;all&#34;:
        datas = []
        first = True
        start = None
        end = None
        for parser in self.parsers:
            ret = parser.parse(location, context)
            if ret.issuccess():
                result = ret.result(self.select)
                for d in result.data:
                    datas.append(d)
                location = result.location
                if first:
                    first = False
                    start = result.span.start
                end = result.span.end
            else:
                return Failure(
                    context=context, location=location, message=&#34;Mismatch in Seq&#34;
                )
        if self.name:
            datas.append(dict(span=Span(start,end), name=self.name, location=location))
        return Success(
            Result(data=datas, location=location, span=Span(start, end)), context
        )
    else:
        # This does a depth-first enumeration of all matches: each successive parser gets tried
        # for each result of the previous one.

        def depthfirst(lvl, result):
            parser = self.parsers[lvl]
            ret = parser.parse(result.location, context)
            if ret.issuccess():
                for res in ret:
                    datas = result.data.copy()
                    for d in res.data:
                        datas.append(d)
                    loc = res.location
                    span = Span(location.text_location, res.location.text_location)
                    if lvl == len(self.parsers) - 1:
                        if self.name:
                            datas.append(dict(span=Span(start, end),
                                              location=loc,
                                              name=self.name))
                        newresult = Result(datas, location=loc, span=span)
                        yield newresult
                    else:
                        newresult = Result(datas, location=loc, span=span)
                        yield from depthfirst(lvl + 1, newresult)

        gen = depthfirst(0, Result(data=[], location=location, span=Span(None, None)))
        all = []
        best = None
        for idx, result in enumerate(gen):
            if self.matchtype == &#34;first&#34; and idx == 0:
                return Success(result, context)
            if self.matchtype == &#34;all&#34;:
                all.append(result)
            elif self.matchtype == &#34;longest&#34;:
                if best is None:
                    best = result
                elif result.span.end&gt; best.span.end:
                    best = result
            elif self.matchtype == &#34;shortest&#34;:
                if best is None:
                    best = result
                elif result.span.end &lt; best.span.end:
                    best = result
        if self.matchtype == &#34;all&#34;:
            if len(all) &gt; 0:
                return Success(all, context)
            else:
                return Failure(context=context, location=location)
        else:
            if best is not None:
                return Success(best, context)
            else:
                return Failure(context=context, location=location)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.Success"><code class="flex name class">
<span>class <span class="ident">Success</span></span>
<span>(</span><span>results, context)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a parse success as a possibly empty list of result elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Success(Iterable, Sized):
    &#34;&#34;&#34;
    Represents a parse success as a possibly empty list of result elements.
    &#34;&#34;&#34;

    def __init__(self, results, context):
        if results is None:
            self._results = []
        elif isinstance(results, Iterable):
            self._results = list(results)
        else:
            self._results = [results]
        self.context = context

    def issuccess(self):
        return True

    def add(self, result, ifnew=False):
        # TODO: not sure if the ifnew parameter and treatment makes sense: do we ever not want
        # to add a result if it is already there (meaning, the same match and the same remaining text/anns).
        if isinstance(result, Iterable):
            for re in result:
                self.add(re, ifnew=ifnew)
        else:
            if ifnew:
                if result not in self._results:
                    self._results.append(result)
            else:
                self._results.append(result)
        return self

    def pprint(self, file=None):
        for idx, res in enumerate(self._results):
            if file:
                print(f&#34;Result {idx}, location={res.location}:&#34;, file=file)
            else:
                print(f&#34;Result {idx}, location={res.location}:&#34;, file=file)
            for jdx, d in enumerate(res.data):
                if file:
                    print(f&#34;  {jdx}: {d}&#34;, file)
                else:
                    print(f&#34;  {jdx}: {d}&#34;, file)

    @staticmethod
    def select_result(results, matchtype=&#34;first&#34;):
        &#34;&#34;&#34;
        Return the result described by parameter matchtype. If &#34;all&#34; returns the whole list of matches.

        Args:
            results: list of results to select from
            matchtype: one of  &#34;first&#34;, &#34;shortest&#34;, &#34;longest&#34;, &#34;all&#34;. If there is more than one longest or shortest
               result, the first one of those in the list is returned.

        Returns:
            the filtered match or matches
        &#34;&#34;&#34;
        if matchtype == None:
            matchtype = &#34;first&#34;
        if matchtype == &#34;all&#34;:
            return results
        elif matchtype == &#34;first&#34;:
            return results[0]
        elif matchtype == &#34;longest&#34;:
            result = results[0]
            loc = result.location
            for res in results:
                if res.location.text_location &gt; loc.text_location:
                    loc = res.location
                    result = res
            return result
        elif matchtype == &#34;shortest&#34;:
            result = results[0]
            loc = result.location
            for res in results:
                if res.location.text_location &lt; loc.text_location:
                    loc = res.location
                    result = res
            return result
        else:
            raise Exception(f&#34;Not a valid value for matchtype: {matchtype}&#34;)

    def result(self, matchtype=&#34;first&#34;):
        &#34;&#34;&#34;
        Return the result described by parameter matchtype. If &#34;all&#34; returns the whole list of matches.

        Args:
            matchtype: one of  &#34;first&#34;, &#34;shortest&#34;, &#34;longest&#34;, &#34;all&#34;. If there is more than one longest or shortest
               result, the first one of those in the list is returned.

        Returns:
            the filtered match or matches
        &#34;&#34;&#34;
        return Success.select_result(self._results, matchtype)

    def __iter__(self):
        return iter(self._results)

    def __len__(self):
        return len(self._results)

    def __eq__(self, other):
        if not isinstance(other, Success):
            return False
        return self._results == other._results

    def __str__(self):
        return str(self._results)

    def __getitem__(self, item):
        return self._results[item]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Iterable</li>
<li>collections.abc.Sized</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Success.select_result"><code class="name flex">
<span>def <span class="ident">select_result</span></span>(<span>results, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"><p>Return the result described by parameter matchtype. If "all" returns the whole list of matches.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results</code></strong></dt>
<dd>list of results to select from</dd>
<dt><strong><code>matchtype</code></strong></dt>
<dd>one of
"first", "shortest", "longest", "all". If there is more than one longest or shortest
result, the first one of those in the list is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the filtered match or matches</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def select_result(results, matchtype=&#34;first&#34;):
    &#34;&#34;&#34;
    Return the result described by parameter matchtype. If &#34;all&#34; returns the whole list of matches.

    Args:
        results: list of results to select from
        matchtype: one of  &#34;first&#34;, &#34;shortest&#34;, &#34;longest&#34;, &#34;all&#34;. If there is more than one longest or shortest
           result, the first one of those in the list is returned.

    Returns:
        the filtered match or matches
    &#34;&#34;&#34;
    if matchtype == None:
        matchtype = &#34;first&#34;
    if matchtype == &#34;all&#34;:
        return results
    elif matchtype == &#34;first&#34;:
        return results[0]
    elif matchtype == &#34;longest&#34;:
        result = results[0]
        loc = result.location
        for res in results:
            if res.location.text_location &gt; loc.text_location:
                loc = res.location
                result = res
        return result
    elif matchtype == &#34;shortest&#34;:
        result = results[0]
        loc = result.location
        for res in results:
            if res.location.text_location &lt; loc.text_location:
                loc = res.location
                result = res
        return result
    else:
        raise Exception(f&#34;Not a valid value for matchtype: {matchtype}&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Success.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, result, ifnew=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, result, ifnew=False):
    # TODO: not sure if the ifnew parameter and treatment makes sense: do we ever not want
    # to add a result if it is already there (meaning, the same match and the same remaining text/anns).
    if isinstance(result, Iterable):
        for re in result:
            self.add(re, ifnew=ifnew)
    else:
        if ifnew:
            if result not in self._results:
                self._results.append(result)
        else:
            self._results.append(result)
    return self</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Success.issuccess"><code class="name flex">
<span>def <span class="ident">issuccess</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def issuccess(self):
    return True</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Success.pprint"><code class="name flex">
<span>def <span class="ident">pprint</span></span>(<span>self, file=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pprint(self, file=None):
    for idx, res in enumerate(self._results):
        if file:
            print(f&#34;Result {idx}, location={res.location}:&#34;, file=file)
        else:
            print(f&#34;Result {idx}, location={res.location}:&#34;, file=file)
        for jdx, d in enumerate(res.data):
            if file:
                print(f&#34;  {jdx}: {d}&#34;, file)
            else:
                print(f&#34;  {jdx}: {d}&#34;, file)</code></pre>
</details>
</dd>
<dt id="gatenlp.pam.pampac.Success.result"><code class="name flex">
<span>def <span class="ident">result</span></span>(<span>self, matchtype='first')</span>
</code></dt>
<dd>
<div class="desc"><p>Return the result described by parameter matchtype. If "all" returns the whole list of matches.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matchtype</code></strong></dt>
<dd>one of
"first", "shortest", "longest", "all". If there is more than one longest or shortest
result, the first one of those in the list is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the filtered match or matches</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def result(self, matchtype=&#34;first&#34;):
    &#34;&#34;&#34;
    Return the result described by parameter matchtype. If &#34;all&#34; returns the whole list of matches.

    Args:
        matchtype: one of  &#34;first&#34;, &#34;shortest&#34;, &#34;longest&#34;, &#34;all&#34;. If there is more than one longest or shortest
           result, the first one of those in the list is returned.

    Returns:
        the filtered match or matches
    &#34;&#34;&#34;
    return Success.select_result(self._results, matchtype)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.pam.pampac.Text"><code class="flex name class">
<span>class <span class="ident">Text</span></span>
<span>(</span><span>text, name=None, matchcase=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A parser that matches some text or regular expression</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>either text or a compiled regular expression</dd>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the matcher, if None, no data is stored</dd>
<dt><strong><code>matchcase</code></strong></dt>
<dd>if text is actual text, whether the match should be case sensitive or not</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Text(PampacParser):
    &#34;&#34;&#34;
    A parser that matches some text or regular expression
    &#34;&#34;&#34;

    def __init__(self, text, name=None, matchcase=True):
        &#34;&#34;&#34;

        Args:
            text: either text or a compiled regular expression
            name:  the name of the matcher, if None, no data is stored
            matchcase: if text is actual text, whether the match should be case sensitive or not
        &#34;&#34;&#34;
        self.text = text
        if isinstance(self.text, str) and not matchcase:
            self.text = self.text.upper()
        self.name = name
        self.matchcase = matchcase

    def parse(self, location, context):
        location = context.update_location_byindex(location)
        txt = context.doc.text[location.text_location :]
        if isinstance(self.text, CLASS_RE_PATTERN) or isinstance(
            self.text, CLASS_REGEX_PATTERN
        ):
            m = self.text.match(txt)
            if m:
                l = len(m.group())
                newlocation = context.inc_location(location, by_offset=l)
                if self.name:
                    data = dict(
                        location=location,
                        span=Span(location.text_location, location.text_location+len(m.group())),
                        text=m.group(),
                        groups=m.groups(),
                        name=self.name,
                    )
                else:
                    data = None
                span = Span(location.text_location, location.text_location + len(m.group()))
                return Success(
                    Result(data=data, location=newlocation, span=span), context
                )
            else:
                return Failure(context=context)
        else:
            if not self.matchcase:
                txt = txt.upper()
            if txt.startswith(self.text):
                if self.name:
                    data = dict(
                        span=Span(location.text_location, location.text_location+len(self.text)),
                        location=location,
                        text=self.text,
                        name=self.name,
                    )
                else:
                    data = None
                newlocation = context.inc_location(location, by_offset=len(self.text))
                span = Span(location.text_location, location.text_location + len(self.text))
                return Success(
                    Result(data=data, location=newlocation, span=span), context
                )
            else:
                return Failure(context=context)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.pam.pampac.Text.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, location, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, location, context):
    location = context.update_location_byindex(location)
    txt = context.doc.text[location.text_location :]
    if isinstance(self.text, CLASS_RE_PATTERN) or isinstance(
        self.text, CLASS_REGEX_PATTERN
    ):
        m = self.text.match(txt)
        if m:
            l = len(m.group())
            newlocation = context.inc_location(location, by_offset=l)
            if self.name:
                data = dict(
                    location=location,
                    span=Span(location.text_location, location.text_location+len(m.group())),
                    text=m.group(),
                    groups=m.groups(),
                    name=self.name,
                )
            else:
                data = None
            span = Span(location.text_location, location.text_location + len(m.group()))
            return Success(
                Result(data=data, location=newlocation, span=span), context
            )
        else:
            return Failure(context=context)
    else:
        if not self.matchcase:
            txt = txt.upper()
        if txt.startswith(self.text):
            if self.name:
                data = dict(
                    span=Span(location.text_location, location.text_location+len(self.text)),
                    location=location,
                    text=self.text,
                    name=self.name,
                )
            else:
                data = None
            newlocation = context.inc_location(location, by_offset=len(self.text))
            span = Span(location.text_location, location.text_location + len(self.text))
            return Success(
                Result(data=data, location=newlocation, span=span), context
            )
        else:
            return Failure(context=context)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.pam.pampac.UpdateAnnFeatures"><code class="flex name class">
<span>class <span class="ident">UpdateAnnFeatures</span></span>
<span>(</span><span>name, ann=None, features=None, replace=False, resultidx=0, dataidx=0, silent_fail=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UpdateAnnFeatures:
    def __init__(self, name,
                 ann=None,  # ann to update
                 features=None,
                 replace=False,  # replace existing features rather than updating
                 resultidx=0, dataidx=0,
                 silent_fail=False,
                 ):
        # span is either a span, the index of data to take the span from, or a callable that will return the
        # span at firing time
        assert isinstance(ann, GetAnn)
        assert features is not None
        self.name = name
        self.ann = ann
        self.replace = replace
        self.features = features
        self.resultidx = resultidx
        self.dataidx = dataidx
        self.silent_fail = silent_fail

    def __call__(self, succ, context=None, location=None):
        ann = self.ann(succ)
        if ann is None:
            if self.silent_fail:
                return
            else:
                raise Exception(&#34;No matching annotation found&#34;)
        if callable(self.features):
            features = self.features(succ, context=context, location=location)
        else:
            features = self.features
        if self.replace:
            ann.features.clear()
        ann.features.update(features)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.pam" href="index.html">gatenlp.pam</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.pam.pampac.AddAnn" href="#gatenlp.pam.pampac.AddAnn">AddAnn</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.All" href="#gatenlp.pam.pampac.All">All</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.All.parse" href="#gatenlp.pam.pampac.All.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.And" href="#gatenlp.pam.pampac.And">And</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.And.parse" href="#gatenlp.pam.pampac.And.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Ann" href="#gatenlp.pam.pampac.Ann">Ann</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Ann.parse" href="#gatenlp.pam.pampac.Ann.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.AnnAt" href="#gatenlp.pam.pampac.AnnAt">AnnAt</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.AnnAt.parse" href="#gatenlp.pam.pampac.AnnAt.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Call" href="#gatenlp.pam.pampac.Call">Call</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Call.parse" href="#gatenlp.pam.pampac.Call.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Context" href="#gatenlp.pam.pampac.Context">Context</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Context.annset" href="#gatenlp.pam.pampac.Context.annset">annset</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Context.at_endofanns" href="#gatenlp.pam.pampac.Context.at_endofanns">at_endofanns</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Context.at_endoftext" href="#gatenlp.pam.pampac.Context.at_endoftext">at_endoftext</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Context.get_ann" href="#gatenlp.pam.pampac.Context.get_ann">get_ann</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Context.inc_location" href="#gatenlp.pam.pampac.Context.inc_location">inc_location</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Context.nextidx4offset" href="#gatenlp.pam.pampac.Context.nextidx4offset">nextidx4offset</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Context.update_location_byindex" href="#gatenlp.pam.pampac.Context.update_location_byindex">update_location_byindex</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Context.update_location_byoffset" href="#gatenlp.pam.pampac.Context.update_location_byoffset">update_location_byoffset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Failure" href="#gatenlp.pam.pampac.Failure">Failure</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Failure.describe" href="#gatenlp.pam.pampac.Failure.describe">describe</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Failure.issuccess" href="#gatenlp.pam.pampac.Failure.issuccess">issuccess</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Filter" href="#gatenlp.pam.pampac.Filter">Filter</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Filter.parse" href="#gatenlp.pam.pampac.Filter.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Find" href="#gatenlp.pam.pampac.Find">Find</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Find.parse" href="#gatenlp.pam.pampac.Find.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.GetAnn" href="#gatenlp.pam.pampac.GetAnn">GetAnn</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.GetEnd" href="#gatenlp.pam.pampac.GetEnd">GetEnd</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.GetFeature" href="#gatenlp.pam.pampac.GetFeature">GetFeature</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.GetFeatures" href="#gatenlp.pam.pampac.GetFeatures">GetFeatures</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.GetRegexGroup" href="#gatenlp.pam.pampac.GetRegexGroup">GetRegexGroup</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.GetStart" href="#gatenlp.pam.pampac.GetStart">GetStart</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.GetText" href="#gatenlp.pam.pampac.GetText">GetText</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.GetType" href="#gatenlp.pam.pampac.GetType">GetType</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Location" href="#gatenlp.pam.pampac.Location">Location</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Lookahead" href="#gatenlp.pam.pampac.Lookahead">Lookahead</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Lookahead.parse" href="#gatenlp.pam.pampac.Lookahead.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.N" href="#gatenlp.pam.pampac.N">N</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.N.parse" href="#gatenlp.pam.pampac.N.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Or" href="#gatenlp.pam.pampac.Or">Or</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Or.parse" href="#gatenlp.pam.pampac.Or.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Pampac" href="#gatenlp.pam.pampac.Pampac">Pampac</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Pampac.run" href="#gatenlp.pam.pampac.Pampac.run">run</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pampac.set_select" href="#gatenlp.pam.pampac.Pampac.set_select">set_select</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pampac.set_skip" href="#gatenlp.pam.pampac.Pampac.set_skip">set_skip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.PampacParser" href="#gatenlp.pam.pampac.PampacParser">PampacParser</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.pam.pampac.PampacParser.at" href="#gatenlp.pam.pampac.PampacParser.at">at</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.before" href="#gatenlp.pam.pampac.PampacParser.before">before</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.call" href="#gatenlp.pam.pampac.PampacParser.call">call</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.coextensive" href="#gatenlp.pam.pampac.PampacParser.coextensive">coextensive</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.covering" href="#gatenlp.pam.pampac.PampacParser.covering">covering</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.lookahead" href="#gatenlp.pam.pampac.PampacParser.lookahead">lookahead</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.match" href="#gatenlp.pam.pampac.PampacParser.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.noat" href="#gatenlp.pam.pampac.PampacParser.noat">noat</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.notbefore" href="#gatenlp.pam.pampac.PampacParser.notbefore">notbefore</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.notcoextensive" href="#gatenlp.pam.pampac.PampacParser.notcoextensive">notcoextensive</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.notcovering" href="#gatenlp.pam.pampac.PampacParser.notcovering">notcovering</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.notoverlapping" href="#gatenlp.pam.pampac.PampacParser.notoverlapping">notoverlapping</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.notwithin" href="#gatenlp.pam.pampac.PampacParser.notwithin">notwithin</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.overlapping" href="#gatenlp.pam.pampac.PampacParser.overlapping">overlapping</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.parse" href="#gatenlp.pam.pampac.PampacParser.parse">parse</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.repeat" href="#gatenlp.pam.pampac.PampacParser.repeat">repeat</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.where" href="#gatenlp.pam.pampac.PampacParser.where">where</a></code></li>
<li><code><a title="gatenlp.pam.pampac.PampacParser.within" href="#gatenlp.pam.pampac.PampacParser.within">within</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Pattern" href="#gatenlp.pam.pampac.Pattern">Pattern</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.pam.pampac.Pattern.findall" href="#gatenlp.pam.pampac.Pattern.findall">findall</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.finditer" href="#gatenlp.pam.pampac.Pattern.finditer">finditer</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.flags" href="#gatenlp.pam.pampac.Pattern.flags">flags</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.fullmatch" href="#gatenlp.pam.pampac.Pattern.fullmatch">fullmatch</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.groupindex" href="#gatenlp.pam.pampac.Pattern.groupindex">groupindex</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.groups" href="#gatenlp.pam.pampac.Pattern.groups">groups</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.match" href="#gatenlp.pam.pampac.Pattern.match">match</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.named_lists" href="#gatenlp.pam.pampac.Pattern.named_lists">named_lists</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.pattern" href="#gatenlp.pam.pampac.Pattern.pattern">pattern</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.scanner" href="#gatenlp.pam.pampac.Pattern.scanner">scanner</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.search" href="#gatenlp.pam.pampac.Pattern.search">search</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.split" href="#gatenlp.pam.pampac.Pattern.split">split</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.splititer" href="#gatenlp.pam.pampac.Pattern.splititer">splititer</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.sub" href="#gatenlp.pam.pampac.Pattern.sub">sub</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.subf" href="#gatenlp.pam.pampac.Pattern.subf">subf</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.subfn" href="#gatenlp.pam.pampac.Pattern.subfn">subfn</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Pattern.subn" href="#gatenlp.pam.pampac.Pattern.subn">subn</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Result" href="#gatenlp.pam.pampac.Result">Result</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Result.data4name" href="#gatenlp.pam.pampac.Result.data4name">data4name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Rule" href="#gatenlp.pam.pampac.Rule">Rule</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Rule.parse" href="#gatenlp.pam.pampac.Rule.parse">parse</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Rule.set_priority" href="#gatenlp.pam.pampac.Rule.set_priority">set_priority</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Seq" href="#gatenlp.pam.pampac.Seq">Seq</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Seq.parse" href="#gatenlp.pam.pampac.Seq.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Success" href="#gatenlp.pam.pampac.Success">Success</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Success.add" href="#gatenlp.pam.pampac.Success.add">add</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Success.issuccess" href="#gatenlp.pam.pampac.Success.issuccess">issuccess</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Success.pprint" href="#gatenlp.pam.pampac.Success.pprint">pprint</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Success.result" href="#gatenlp.pam.pampac.Success.result">result</a></code></li>
<li><code><a title="gatenlp.pam.pampac.Success.select_result" href="#gatenlp.pam.pampac.Success.select_result">select_result</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.Text" href="#gatenlp.pam.pampac.Text">Text</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.pam.pampac.Text.parse" href="#gatenlp.pam.pampac.Text.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.pam.pampac.UpdateAnnFeatures" href="#gatenlp.pam.pampac.UpdateAnnFeatures">UpdateAnnFeatures</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev16+g8c2bb0d.d20201028</a>.</p>
</footer>
</body>
</html>