<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gatenlp.processing.client.perspective API documentation</title>
<meta name="description" content="Perspective client." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.processing.client.perspective</code></h1>
</header>
<section id="section-intro">
<p>Perspective client.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Perspective client.
&#34;&#34;&#34;
import time

from typing import Optional, Union, List, Dict
from gatenlp.processing.annotator import Annotator
from gatenlp.utils import init_logger


class PerspectiveAnnotator(Annotator):
    &#34;&#34;&#34;
    An annotator that sends text to the Perspective classification service
    (see https://perspectiveapi.com/)
    and uses the result to set either document or annotation features.
    &#34;&#34;&#34;

    def __init__(
        self,
        url: Optional[str] = &#34;https://commentanalyzer.googleapis.com/$discovery/rest?version=v1alpha1&#34;,
        auth_token: str = &#34;&#34;,
        requested_attributes: Optional[List[str]] = None,
        requested_attributes_feature: Optional[str] = None,
        do_not_store: bool = True,
        langs: Optional[Union[str, List[str]]] = None,
        langs_feature: Optional[str] = None,
        annset_name: Optional[str] = &#34;&#34;,
        ann_type: Optional[str] = None,
        ann_feature: Optional[str] = None,
        attr2feature: Optional[Dict[str, str]] = None,
        min_delay_ms: int = 1000,
    ):
        &#34;&#34;&#34;
        Create a Perspective annotator.

        Args:
            url: the annotation service endpoint, if None, the default endpoint URL
            auth_token: (required) the authentication token needed to use the service
            requested_attributes: (required) a list of attributes to return. Note that not all attributes are
                available for all languages!
            requested_attributes_feature: if specified, get the requested attributes list from that doc/ann feature
                if it exists (fall back to requested_attributes)
            do_not_store: if True, do not allow the text to get stored (default: True)
            langs: None indiciates auto-detect, otherwise the language code or a list of language codes.
            langs_feature: if the text is taken from an annotation, the feature of that annotation that contains
                the language code or list of language codes. If the feature does not exist or is empty, falls back
                to langs. If the text is taken from the document, a document feature that contains the language code
                or list of language codes. 
            annset_name: if an annotation type is specified, the name of the annotation set to use
            ann_type: if this is specified, the text of those annoations is getting classified and
                the result is stored as annotaiton features. Otherwise, the whole document is classified
                and the result is stored as document features.
            ann_feature: if ann_type is specified, and this is also specified, the text is taken from
                that feature instead of the underlying document text.
            attr2feature: a dictionary mapping attribute names to feature names. Note that each attribute name is
                made of the actual attribute (e.g. &#34;TOXICITY&#34;) with the score type appended after an underscore,
                e.g. &#34;_PROBABILITY&#34;, giving &#34;TOXICITY_PROBABILITY&#34;. Only the summary scores are used.
            min_delay_ms: minimum time in ms to wait between requests to the server (1000)
        &#34;&#34;&#34;
        try:
            from googleapiclient import discovery
        except Exception as ex:
            raise Exception(f&#34;Package google-api-python-client not installed?&#34;, ex)
        assert auth_token
        assert requested_attributes
        self.auth_token = auth_token
        self.url = url
        self.min_delay_s = min_delay_ms / 1000.0
        self.logger = init_logger()
        # self.logger.setLevel(logging.DEBUG)
        self._last_call_time = 0
        self.ann_type = ann_type
        self.ann_feature = ann_feature
        self.langs = langs
        self.langs_feature = langs_feature
        self.attr2feature = attr2feature
        self.annset_name = annset_name
        self.do_not_store = do_not_store
        self.requested_attributes = requested_attributes
        self.requested_attributes_feature = requested_attributes_feature
        self.client = discovery.build(
            &#34;commentanalyzer&#34;,
            &#34;v1alpha1&#34;,
            developerKey=self.auth_token,
            discoveryServiceUrl=self.url,
            static_discovery=False,
        )

    def _call_api(self, text, langs=None, requested_attributes=None, attr2feature=None):
        &#34;&#34;&#34;Send text to API respecting min delay and get back dict&#34;&#34;&#34;
        delay = time.time() - self._last_call_time
        if delay &lt; self.min_delay_s:
            time.sleep(self.min_delay_s - delay)
        request = {
            &#34;comment&#34;: {&#34;text&#34;: text},
            &#34;requestedAttributes&#34;: {n: {} for n in requested_attributes},
            &#34;doNotStore&#34;: self.do_not_store,
        }
        if langs is not None:
            if isinstance(langs, str):
                langs = [langs]
            request[&#34;languages&#34;] = langs
        response = self.client.comments().analyze(body=request).execute()
        ret = {}
        scoredata = response[&#34;attributeScores&#34;]
        for name, data in scoredata.items():
            val = data[&#34;summaryScore&#34;][&#34;value&#34;]
            typ = data[&#34;summaryScore&#34;][&#34;type&#34;]
            if attr2feature is not None:
                name = attr2feature.get(name, name)
            ret[name+&#34;_&#34;+typ] = val
        name = &#34;languages&#34;
        if attr2feature is not None:
            name = attr2feature(name, name)
        ret[name] = response[&#34;languages&#34;]
        return ret

    def __call__(self, doc, **kwargs):
        if self.ann_type is not None:
            annset = doc.annset(self.annset_name).with_type(self.ann_type)
            for ann in annset:
                if self.ann_feature:
                    txt = ann.features.get(self.ann_feature, &#34;&#34;)
                else:
                    txt = doc[ann]
                langs = self.langs
                if self.langs_feature:
                    langs = ann.features.get(self.langs_feature, langs)
                requested_attributes = self.requested_attributes
                if self.requested_attributes_feature:
                    requested_attributes = ann.features.get(self.requested_attributes_feature, requested_attributes)
                ret = self._call_api(txt, langs=langs,
                                     attr2feature=self.attr2feature, requested_attributes=requested_attributes)
                if isinstance(ret, dict):
                    ann.features.update(ret)
        else:
            langs = self.langs
            if self.langs_feature:
                langs = doc.features.get(self.langs_feature, langs)
            requested_attributes = self.requested_attributes
            if self.requested_attributes_feature:
                requested_attributes = doc.features.get(self.requested_attributes_feature, requested_attributes)
            ret = self._call_api(doc.text, langs=langs,
                                 attr2feature=self.attr2feature, requested_attributes=requested_attributes)
            if isinstance(ret, dict):
                doc.features.update(ret)
        return doc</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.processing.client.perspective.PerspectiveAnnotator"><code class="flex name class">
<span>class <span class="ident">PerspectiveAnnotator</span></span>
<span>(</span><span>url: Optional[str] = 'https://commentanalyzer.googleapis.com/$discovery/rest?version=v1alpha1', auth_token: str = '', requested_attributes: Optional[List[str]] = None, requested_attributes_feature: Optional[str] = None, do_not_store: bool = True, langs: Union[str, List[str], None] = None, langs_feature: Optional[str] = None, annset_name: Optional[str] = '', ann_type: Optional[str] = None, ann_feature: Optional[str] = None, attr2feature: Optional[Dict[str, str]] = None, min_delay_ms: int = 1000)</span>
</code></dt>
<dd>
<div class="desc"><p>An annotator that sends text to the Perspective classification service
(see <a href="https://perspectiveapi.com/">https://perspectiveapi.com/</a>)
and uses the result to set either document or annotation features.</p>
<p>Create a Perspective annotator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong></dt>
<dd>the annotation service endpoint, if None, the default endpoint URL</dd>
<dt><strong><code>auth_token</code></strong></dt>
<dd>(required) the authentication token needed to use the service</dd>
<dt><strong><code>requested_attributes</code></strong></dt>
<dd>(required) a list of attributes to return. Note that not all attributes are
available for all languages!</dd>
<dt><strong><code>requested_attributes_feature</code></strong></dt>
<dd>if specified, get the requested attributes list from that doc/ann feature
if it exists (fall back to requested_attributes)</dd>
<dt><strong><code>do_not_store</code></strong></dt>
<dd>if True, do not allow the text to get stored (default: True)</dd>
<dt><strong><code>langs</code></strong></dt>
<dd>None indiciates auto-detect, otherwise the language code or a list of language codes.</dd>
<dt><strong><code>langs_feature</code></strong></dt>
<dd>if the text is taken from an annotation, the feature of that annotation that contains
the language code or list of language codes. If the feature does not exist or is empty, falls back
to langs. If the text is taken from the document, a document feature that contains the language code
or list of language codes. </dd>
<dt><strong><code>annset_name</code></strong></dt>
<dd>if an annotation type is specified, the name of the annotation set to use</dd>
<dt><strong><code>ann_type</code></strong></dt>
<dd>if this is specified, the text of those annoations is getting classified and
the result is stored as annotaiton features. Otherwise, the whole document is classified
and the result is stored as document features.</dd>
<dt><strong><code>ann_feature</code></strong></dt>
<dd>if ann_type is specified, and this is also specified, the text is taken from
that feature instead of the underlying document text.</dd>
<dt><strong><code>attr2feature</code></strong></dt>
<dd>a dictionary mapping attribute names to feature names. Note that each attribute name is
made of the actual attribute (e.g. "TOXICITY") with the score type appended after an underscore,
e.g. "_PROBABILITY", giving "TOXICITY_PROBABILITY". Only the summary scores are used.</dd>
<dt><strong><code>min_delay_ms</code></strong></dt>
<dd>minimum time in ms to wait between requests to the server (1000)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PerspectiveAnnotator(Annotator):
    &#34;&#34;&#34;
    An annotator that sends text to the Perspective classification service
    (see https://perspectiveapi.com/)
    and uses the result to set either document or annotation features.
    &#34;&#34;&#34;

    def __init__(
        self,
        url: Optional[str] = &#34;https://commentanalyzer.googleapis.com/$discovery/rest?version=v1alpha1&#34;,
        auth_token: str = &#34;&#34;,
        requested_attributes: Optional[List[str]] = None,
        requested_attributes_feature: Optional[str] = None,
        do_not_store: bool = True,
        langs: Optional[Union[str, List[str]]] = None,
        langs_feature: Optional[str] = None,
        annset_name: Optional[str] = &#34;&#34;,
        ann_type: Optional[str] = None,
        ann_feature: Optional[str] = None,
        attr2feature: Optional[Dict[str, str]] = None,
        min_delay_ms: int = 1000,
    ):
        &#34;&#34;&#34;
        Create a Perspective annotator.

        Args:
            url: the annotation service endpoint, if None, the default endpoint URL
            auth_token: (required) the authentication token needed to use the service
            requested_attributes: (required) a list of attributes to return. Note that not all attributes are
                available for all languages!
            requested_attributes_feature: if specified, get the requested attributes list from that doc/ann feature
                if it exists (fall back to requested_attributes)
            do_not_store: if True, do not allow the text to get stored (default: True)
            langs: None indiciates auto-detect, otherwise the language code or a list of language codes.
            langs_feature: if the text is taken from an annotation, the feature of that annotation that contains
                the language code or list of language codes. If the feature does not exist or is empty, falls back
                to langs. If the text is taken from the document, a document feature that contains the language code
                or list of language codes. 
            annset_name: if an annotation type is specified, the name of the annotation set to use
            ann_type: if this is specified, the text of those annoations is getting classified and
                the result is stored as annotaiton features. Otherwise, the whole document is classified
                and the result is stored as document features.
            ann_feature: if ann_type is specified, and this is also specified, the text is taken from
                that feature instead of the underlying document text.
            attr2feature: a dictionary mapping attribute names to feature names. Note that each attribute name is
                made of the actual attribute (e.g. &#34;TOXICITY&#34;) with the score type appended after an underscore,
                e.g. &#34;_PROBABILITY&#34;, giving &#34;TOXICITY_PROBABILITY&#34;. Only the summary scores are used.
            min_delay_ms: minimum time in ms to wait between requests to the server (1000)
        &#34;&#34;&#34;
        try:
            from googleapiclient import discovery
        except Exception as ex:
            raise Exception(f&#34;Package google-api-python-client not installed?&#34;, ex)
        assert auth_token
        assert requested_attributes
        self.auth_token = auth_token
        self.url = url
        self.min_delay_s = min_delay_ms / 1000.0
        self.logger = init_logger()
        # self.logger.setLevel(logging.DEBUG)
        self._last_call_time = 0
        self.ann_type = ann_type
        self.ann_feature = ann_feature
        self.langs = langs
        self.langs_feature = langs_feature
        self.attr2feature = attr2feature
        self.annset_name = annset_name
        self.do_not_store = do_not_store
        self.requested_attributes = requested_attributes
        self.requested_attributes_feature = requested_attributes_feature
        self.client = discovery.build(
            &#34;commentanalyzer&#34;,
            &#34;v1alpha1&#34;,
            developerKey=self.auth_token,
            discoveryServiceUrl=self.url,
            static_discovery=False,
        )

    def _call_api(self, text, langs=None, requested_attributes=None, attr2feature=None):
        &#34;&#34;&#34;Send text to API respecting min delay and get back dict&#34;&#34;&#34;
        delay = time.time() - self._last_call_time
        if delay &lt; self.min_delay_s:
            time.sleep(self.min_delay_s - delay)
        request = {
            &#34;comment&#34;: {&#34;text&#34;: text},
            &#34;requestedAttributes&#34;: {n: {} for n in requested_attributes},
            &#34;doNotStore&#34;: self.do_not_store,
        }
        if langs is not None:
            if isinstance(langs, str):
                langs = [langs]
            request[&#34;languages&#34;] = langs
        response = self.client.comments().analyze(body=request).execute()
        ret = {}
        scoredata = response[&#34;attributeScores&#34;]
        for name, data in scoredata.items():
            val = data[&#34;summaryScore&#34;][&#34;value&#34;]
            typ = data[&#34;summaryScore&#34;][&#34;type&#34;]
            if attr2feature is not None:
                name = attr2feature.get(name, name)
            ret[name+&#34;_&#34;+typ] = val
        name = &#34;languages&#34;
        if attr2feature is not None:
            name = attr2feature(name, name)
        ret[name] = response[&#34;languages&#34;]
        return ret

    def __call__(self, doc, **kwargs):
        if self.ann_type is not None:
            annset = doc.annset(self.annset_name).with_type(self.ann_type)
            for ann in annset:
                if self.ann_feature:
                    txt = ann.features.get(self.ann_feature, &#34;&#34;)
                else:
                    txt = doc[ann]
                langs = self.langs
                if self.langs_feature:
                    langs = ann.features.get(self.langs_feature, langs)
                requested_attributes = self.requested_attributes
                if self.requested_attributes_feature:
                    requested_attributes = ann.features.get(self.requested_attributes_feature, requested_attributes)
                ret = self._call_api(txt, langs=langs,
                                     attr2feature=self.attr2feature, requested_attributes=requested_attributes)
                if isinstance(ret, dict):
                    ann.features.update(ret)
        else:
            langs = self.langs
            if self.langs_feature:
                langs = doc.features.get(self.langs_feature, langs)
            requested_attributes = self.requested_attributes
            if self.requested_attributes_feature:
                requested_attributes = doc.features.get(self.requested_attributes_feature, requested_attributes)
            ret = self._call_api(doc.text, langs=langs,
                                 attr2feature=self.attr2feature, requested_attributes=requested_attributes)
            if isinstance(ret, dict):
                doc.features.update(ret)
        return doc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.processing.annotator.Annotator" href="../annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.processing.annotator.Annotator" href="../annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.processing.annotator.Annotator.__call__" href="../annotator.html#gatenlp.processing.annotator.Annotator.__call__">__call__</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.finish" href="../annotator.html#gatenlp.processing.annotator.Annotator.finish">finish</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.pipe" href="../annotator.html#gatenlp.processing.annotator.Annotator.pipe">pipe</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.reduce" href="../annotator.html#gatenlp.processing.annotator.Annotator.reduce">reduce</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.start" href="../annotator.html#gatenlp.processing.annotator.Annotator.start">start</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.processing.client" href="index.html">gatenlp.processing.client</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.processing.client.perspective.PerspectiveAnnotator" href="#gatenlp.processing.client.perspective.PerspectiveAnnotator">PerspectiveAnnotator</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>