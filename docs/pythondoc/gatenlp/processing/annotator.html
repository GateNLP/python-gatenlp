<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev16+g8c2bb0d.d20201028" />
<title>gatenlp.processing.annotator API documentation</title>
<meta name="description" content="Module with the base class and supporting functions for all annotators.
Any callable that can be called by passing a document can be used as an â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.processing.annotator</code></h1>
</header>
<section id="section-intro">
<p>Module with the base class and supporting functions for all annotators.
Any callable that can be called by passing a document can be used as an annotator,
but the base class "Annotator" defined in here is designed to allow for a more
flexible approach to do things.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module with the base class and supporting functions for all annotators.
Any callable that can be called by passing a document can be used as an annotator,
but the base class &#34;Annotator&#34; defined in here is designed to allow for a more
flexible approach to do things.
&#34;&#34;&#34;
from abc import ABC, abstractmethod

__pdoc__ = {&#34;Annotator.__call__&#34;: True}


class Annotator(ABC):
    @abstractmethod
    def __call__(self, doc, **kwargs):
        &#34;&#34;&#34;
        This method must get implemented in a concrete subclass to do the actual processing
        and annotation. It must accept a document and return a document which may be
        the same that got passed.

        If it returns a list of documents, all of them are used as processing results, if
        the list is empty, the processing does not yield a result.

        The method must accept arbitrary keyword arguments which will be used for handling
        non-standard situations.

        Args:
          doc: the document to process
          kwargs: return: a document or a list of documents

        Returns:
            a document or a list of documents
        &#34;&#34;&#34;
        raise Exception(&#34;This method must be implemented!&#34;)

    def start(self):
        &#34;&#34;&#34;
        A method that gets called when processing starts, e.g. before the first document in
        corpus gets processed. This is invoked by an executor to initialize processing a batch
        of documents.

        This is different from initializing the Annotator: initializing may load large data which
        can be reused even if the same annotator instance is run several times over documents.
        &#34;&#34;&#34;
        pass

    def finish(self):
        &#34;&#34;&#34;
        A method that gets called when processing ends, e.g. when all documents of a corpus
        have been processed. It should return some result for processing the whole batch of documents
        it has seen - that result may be None.

        Returns:
            The overall result of processing all documents or None
        &#34;&#34;&#34;
        pass

    def reduce(self, results):
        &#34;&#34;&#34;
        A method that should know how to combine the results passed on in some collection into a
        single result. This method should behave like a static method, i.e. not make use of any
        data that is specific to the concrete instance.

        This can be used to combine corpus results obtained from several processes running on
        different parts of a corpus.

        This gets invoked by the executor if more than one instance of the annotator was run
        over separate sets of documents. If only a single instance was used, the result returned
        from finish is used directly.

        Args:
          results: an iterable of individual results over some documents each or None if no results are available.
             If no results have been passed back from the finish method of any of the processes, the executor should
             not call reduce, but if it does, reduce should accept None or an iterator of all None and return None.

        Returns:
            The combined overall result or None if there are no individual results
        &#34;&#34;&#34;
        return results</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.processing.annotator.Annotator"><code class="flex name class">
<span>class <span class="ident">Annotator</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Annotator(ABC):
    @abstractmethod
    def __call__(self, doc, **kwargs):
        &#34;&#34;&#34;
        This method must get implemented in a concrete subclass to do the actual processing
        and annotation. It must accept a document and return a document which may be
        the same that got passed.

        If it returns a list of documents, all of them are used as processing results, if
        the list is empty, the processing does not yield a result.

        The method must accept arbitrary keyword arguments which will be used for handling
        non-standard situations.

        Args:
          doc: the document to process
          kwargs: return: a document or a list of documents

        Returns:
            a document or a list of documents
        &#34;&#34;&#34;
        raise Exception(&#34;This method must be implemented!&#34;)

    def start(self):
        &#34;&#34;&#34;
        A method that gets called when processing starts, e.g. before the first document in
        corpus gets processed. This is invoked by an executor to initialize processing a batch
        of documents.

        This is different from initializing the Annotator: initializing may load large data which
        can be reused even if the same annotator instance is run several times over documents.
        &#34;&#34;&#34;
        pass

    def finish(self):
        &#34;&#34;&#34;
        A method that gets called when processing ends, e.g. when all documents of a corpus
        have been processed. It should return some result for processing the whole batch of documents
        it has seen - that result may be None.

        Returns:
            The overall result of processing all documents or None
        &#34;&#34;&#34;
        pass

    def reduce(self, results):
        &#34;&#34;&#34;
        A method that should know how to combine the results passed on in some collection into a
        single result. This method should behave like a static method, i.e. not make use of any
        data that is specific to the concrete instance.

        This can be used to combine corpus results obtained from several processes running on
        different parts of a corpus.

        This gets invoked by the executor if more than one instance of the annotator was run
        over separate sets of documents. If only a single instance was used, the result returned
        from finish is used directly.

        Args:
          results: an iterable of individual results over some documents each or None if no results are available.
             If no results have been passed back from the finish method of any of the processes, the executor should
             not call reduce, but if it does, reduce should accept None or an iterator of all None and return None.

        Returns:
            The combined overall result or None if there are no individual results
        &#34;&#34;&#34;
        return results</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gatenlp.gateslave.GateSlaveAnnotator" href="../gateslave.html#gatenlp.gateslave.GateSlaveAnnotator">GateSlaveAnnotator</a></li>
<li><a title="gatenlp.lib_spacy.AnnSpacy" href="../lib_spacy.html#gatenlp.lib_spacy.AnnSpacy">AnnSpacy</a></li>
<li><a title="gatenlp.lib_stanza.AnnStanza" href="../lib_stanza.html#gatenlp.lib_stanza.AnnStanza">AnnStanza</a></li>
<li><a title="gatenlp.processing.client.ElgTextAnnotator" href="client.html#gatenlp.processing.client.ElgTextAnnotator">ElgTextAnnotator</a></li>
<li><a title="gatenlp.processing.client.GateCloudAnnotator" href="client.html#gatenlp.processing.client.GateCloudAnnotator">GateCloudAnnotator</a></li>
<li><a title="gatenlp.processing.client.TagMeAnnotator" href="client.html#gatenlp.processing.client.TagMeAnnotator">TagMeAnnotator</a></li>
<li><a title="gatenlp.processing.client.TextRazorTextAnnotator" href="client.html#gatenlp.processing.client.TextRazorTextAnnotator">TextRazorTextAnnotator</a></li>
<li><a title="gatenlp.processing.gazetteer.Gazetteer" href="gazetteer.html#gatenlp.processing.gazetteer.Gazetteer">Gazetteer</a></li>
<li><a title="gatenlp.processing.normalizer.Normalizer" href="normalizer.html#gatenlp.processing.normalizer.Normalizer">Normalizer</a></li>
<li><a title="gatenlp.processing.pipeline.Pipeline" href="pipeline.html#gatenlp.processing.pipeline.Pipeline">Pipeline</a></li>
<li><a title="gatenlp.processing.tokenizer.Tokenizer" href="tokenizer.html#gatenlp.processing.tokenizer.Tokenizer">Tokenizer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.processing.annotator.Annotator.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, doc, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This method must get implemented in a concrete subclass to do the actual processing
and annotation. It must accept a document and return a document which may be
the same that got passed.</p>
<p>If it returns a list of documents, all of them are used as processing results, if
the list is empty, the processing does not yield a result.</p>
<p>The method must accept arbitrary keyword arguments which will be used for handling
non-standard situations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>doc</code></strong></dt>
<dd>the document to process</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>return: a document or a list of documents</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a document or a list of documents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def __call__(self, doc, **kwargs):
    &#34;&#34;&#34;
    This method must get implemented in a concrete subclass to do the actual processing
    and annotation. It must accept a document and return a document which may be
    the same that got passed.

    If it returns a list of documents, all of them are used as processing results, if
    the list is empty, the processing does not yield a result.

    The method must accept arbitrary keyword arguments which will be used for handling
    non-standard situations.

    Args:
      doc: the document to process
      kwargs: return: a document or a list of documents

    Returns:
        a document or a list of documents
    &#34;&#34;&#34;
    raise Exception(&#34;This method must be implemented!&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.annotator.Annotator.finish"><code class="name flex">
<span>def <span class="ident">finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A method that gets called when processing ends, e.g. when all documents of a corpus
have been processed. It should return some result for processing the whole batch of documents
it has seen - that result may be None.</p>
<h2 id="returns">Returns</h2>
<p>The overall result of processing all documents or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish(self):
    &#34;&#34;&#34;
    A method that gets called when processing ends, e.g. when all documents of a corpus
    have been processed. It should return some result for processing the whole batch of documents
    it has seen - that result may be None.

    Returns:
        The overall result of processing all documents or None
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.annotator.Annotator.reduce"><code class="name flex">
<span>def <span class="ident">reduce</span></span>(<span>self, results)</span>
</code></dt>
<dd>
<div class="desc"><p>A method that should know how to combine the results passed on in some collection into a
single result. This method should behave like a static method, i.e. not make use of any
data that is specific to the concrete instance.</p>
<p>This can be used to combine corpus results obtained from several processes running on
different parts of a corpus.</p>
<p>This gets invoked by the executor if more than one instance of the annotator was run
over separate sets of documents. If only a single instance was used, the result returned
from finish is used directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results</code></strong></dt>
<dd>an iterable of individual results over some documents each or None if no results are available.
If no results have been passed back from the finish method of any of the processes, the executor should
not call reduce, but if it does, reduce should accept None or an iterator of all None and return None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The combined overall result or None if there are no individual results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce(self, results):
    &#34;&#34;&#34;
    A method that should know how to combine the results passed on in some collection into a
    single result. This method should behave like a static method, i.e. not make use of any
    data that is specific to the concrete instance.

    This can be used to combine corpus results obtained from several processes running on
    different parts of a corpus.

    This gets invoked by the executor if more than one instance of the annotator was run
    over separate sets of documents. If only a single instance was used, the result returned
    from finish is used directly.

    Args:
      results: an iterable of individual results over some documents each or None if no results are available.
         If no results have been passed back from the finish method of any of the processes, the executor should
         not call reduce, but if it does, reduce should accept None or an iterator of all None and return None.

    Returns:
        The combined overall result or None if there are no individual results
    &#34;&#34;&#34;
    return results</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.annotator.Annotator.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A method that gets called when processing starts, e.g. before the first document in
corpus gets processed. This is invoked by an executor to initialize processing a batch
of documents.</p>
<p>This is different from initializing the Annotator: initializing may load large data which
can be reused even if the same annotator instance is run several times over documents.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;
    A method that gets called when processing starts, e.g. before the first document in
    corpus gets processed. This is invoked by an executor to initialize processing a batch
    of documents.

    This is different from initializing the Annotator: initializing may load large data which
    can be reused even if the same annotator instance is run several times over documents.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.processing" href="index.html">gatenlp.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.processing.annotator.Annotator" href="#gatenlp.processing.annotator.Annotator">Annotator</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.processing.annotator.Annotator.__call__" href="#gatenlp.processing.annotator.Annotator.__call__">__call__</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.finish" href="#gatenlp.processing.annotator.Annotator.finish">finish</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.reduce" href="#gatenlp.processing.annotator.Annotator.reduce">reduce</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.start" href="#gatenlp.processing.annotator.Annotator.start">start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev16+g8c2bb0d.d20201028</a>.</p>
</footer>
</body>
</html>