<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gatenlp.processing.annotator API documentation</title>
<meta name="description" content="Module with the base class and supporting functions for all annotators.
Any callable that can be called by passing a document can be used as an …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.processing.annotator</code></h1>
</header>
<section id="section-intro">
<p>Module with the base class and supporting functions for all annotators.
Any callable that can be called by passing a document can be used as an annotator,
but the base class "Annotator" defined in here is designed to allow for a more
flexible approach to do things.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module with the base class and supporting functions for all annotators.
Any callable that can be called by passing a document can be used as an annotator,
but the base class &#34;Annotator&#34; defined in here is designed to allow for a more
flexible approach to do things.
&#34;&#34;&#34;
from typing import Union, List, Iterable, Any, Callable
from abc import ABC, abstractmethod
from gatenlp import Document

__pdoc__ = {&#34;Annotator.__call__&#34;: True}


class Annotator(ABC):
    @abstractmethod
    def __call__(self, doc: Document, **kwargs) -&gt; Union[Document, List[Document], None]:
        &#34;&#34;&#34;
        This method MUST get implemented in a concrete subclass to do the actual processing
        and annotation. It must accept a document and arbitrary keyword arguments and it must
        return either a document which may be the same or a different object than the document passed,
        or None or an empty list or a list of one or more documents. The method also may raise an
        exception.

        The semantics of returning None or an empty list are not strictly defined: this may be used to
        handle processing errors where documents which cannot be processed are quietly ignored or
        filtering.

        The method must accept arbitrary keyword arguments which will be passed on to sub-annotators and
        may be used to configure or parametrize processing.

        NOTE: some annotators may set or use special document features in order to handle
        document context or the document id when processing a corpus or streams where a document id
        is important.

        Args:
          doc: the document to process
          kwargs: any arguments to pass to the annotator or sub-annotators called by this annotator

        Returns:
            a document, None, or a possibly empty list of documents
        &#34;&#34;&#34;
        raise Exception(&#34;This method must be implemented!&#34;)

    def pipe(self, documents: Iterable[Document], **kwargs):
        &#34;&#34;&#34;
        If this method gets overridden, it should take an iterable of documents and yield processed documents.
        This allows for batching, caching, and other optimizations over streams of documents.
        If with_context is True, then the documents parameter should be an iterable over tuples (document, context).

        Args:
            documents: an iterable over documents
            **kwargs: arbitrary other keyword arguments must be accepted

        Yields:
            processed documents
        &#34;&#34;&#34;
        for document in documents:
            if document is not None:
                docordocs = self.__call__(document, **kwargs)
                if docordocs is not None:
                    if isinstance(docordocs, list):
                        for doc in docordocs:
                            if doc is not None:
                                yield doc
                    else:
                        yield docordocs

    def start(self) -&gt; None:
        &#34;&#34;&#34;
        A method that gets called when processing starts, e.g. before the first document in
        corpus gets processed. This is invoked by an executor to initialize processing a batch
        of documents.

        This is different from initializing the Annotator: initializing may load large data which
        can be reused even if the same annotator instance is run several times over documents.
        &#34;&#34;&#34;
        pass

    def finish(self) -&gt; Any:
        &#34;&#34;&#34;
        A method that gets called when processing ends, e.g. when all documents of a corpus
        have been processed. It should return some result for processing the whole batch of documents
        it has seen - that result may be None.

        Returns:
            The overall result of processing all documents or None
        &#34;&#34;&#34;
        pass

    def reduce(self, results: Iterable[Any]) -&gt; Any:
        &#34;&#34;&#34;
        A method that should know how to combine the results passed on in some collection into a
        single result. This method should behave like a static method, i.e. not make use of any
        data that is specific to the concrete instance.

        This can be used to combine corpus results obtained from several processes running on
        different parts of a corpus.

        This gets invoked by the executor if more than one instance of the annotator was run
        over separate sets of documents. If only a single instance was used, the result returned
        from finish is used directly.

        Args:
          results: an iterable of individual results over some documents each or None if no results are available.
             If no results have been passed back from the finish method of any of the processes, the executor should
             not call reduce, but if it does, reduce should accept None or an iterator of all None and return None.

        Returns:
            The combined overall result or None if there are no individual results
        &#34;&#34;&#34;
        return results


class AnnotatorFunction(Annotator):
    def __init__(self, funct: Callable):
        self.funct = funct

    def __call__(self, doc: Document, **kwargs) -&gt; Union[Document, List[Document], None]:
        return self.funct(doc, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.processing.annotator.Annotator"><code class="flex name class">
<span>class <span class="ident">Annotator</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Annotator(ABC):
    @abstractmethod
    def __call__(self, doc: Document, **kwargs) -&gt; Union[Document, List[Document], None]:
        &#34;&#34;&#34;
        This method MUST get implemented in a concrete subclass to do the actual processing
        and annotation. It must accept a document and arbitrary keyword arguments and it must
        return either a document which may be the same or a different object than the document passed,
        or None or an empty list or a list of one or more documents. The method also may raise an
        exception.

        The semantics of returning None or an empty list are not strictly defined: this may be used to
        handle processing errors where documents which cannot be processed are quietly ignored or
        filtering.

        The method must accept arbitrary keyword arguments which will be passed on to sub-annotators and
        may be used to configure or parametrize processing.

        NOTE: some annotators may set or use special document features in order to handle
        document context or the document id when processing a corpus or streams where a document id
        is important.

        Args:
          doc: the document to process
          kwargs: any arguments to pass to the annotator or sub-annotators called by this annotator

        Returns:
            a document, None, or a possibly empty list of documents
        &#34;&#34;&#34;
        raise Exception(&#34;This method must be implemented!&#34;)

    def pipe(self, documents: Iterable[Document], **kwargs):
        &#34;&#34;&#34;
        If this method gets overridden, it should take an iterable of documents and yield processed documents.
        This allows for batching, caching, and other optimizations over streams of documents.
        If with_context is True, then the documents parameter should be an iterable over tuples (document, context).

        Args:
            documents: an iterable over documents
            **kwargs: arbitrary other keyword arguments must be accepted

        Yields:
            processed documents
        &#34;&#34;&#34;
        for document in documents:
            if document is not None:
                docordocs = self.__call__(document, **kwargs)
                if docordocs is not None:
                    if isinstance(docordocs, list):
                        for doc in docordocs:
                            if doc is not None:
                                yield doc
                    else:
                        yield docordocs

    def start(self) -&gt; None:
        &#34;&#34;&#34;
        A method that gets called when processing starts, e.g. before the first document in
        corpus gets processed. This is invoked by an executor to initialize processing a batch
        of documents.

        This is different from initializing the Annotator: initializing may load large data which
        can be reused even if the same annotator instance is run several times over documents.
        &#34;&#34;&#34;
        pass

    def finish(self) -&gt; Any:
        &#34;&#34;&#34;
        A method that gets called when processing ends, e.g. when all documents of a corpus
        have been processed. It should return some result for processing the whole batch of documents
        it has seen - that result may be None.

        Returns:
            The overall result of processing all documents or None
        &#34;&#34;&#34;
        pass

    def reduce(self, results: Iterable[Any]) -&gt; Any:
        &#34;&#34;&#34;
        A method that should know how to combine the results passed on in some collection into a
        single result. This method should behave like a static method, i.e. not make use of any
        data that is specific to the concrete instance.

        This can be used to combine corpus results obtained from several processes running on
        different parts of a corpus.

        This gets invoked by the executor if more than one instance of the annotator was run
        over separate sets of documents. If only a single instance was used, the result returned
        from finish is used directly.

        Args:
          results: an iterable of individual results over some documents each or None if no results are available.
             If no results have been passed back from the finish method of any of the processes, the executor should
             not call reduce, but if it does, reduce should accept None or an iterator of all None and return None.

        Returns:
            The combined overall result or None if there are no individual results
        &#34;&#34;&#34;
        return results</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gatenlp.gateworker.gateworkerannotator.GateWorkerAnnotator" href="../gateworker/gateworkerannotator.html#gatenlp.gateworker.gateworkerannotator.GateWorkerAnnotator">GateWorkerAnnotator</a></li>
<li><a title="gatenlp.lib_spacy.AnnSpacy" href="../lib_spacy.html#gatenlp.lib_spacy.AnnSpacy">AnnSpacy</a></li>
<li><a title="gatenlp.lib_stanza.AnnStanza" href="../lib_stanza.html#gatenlp.lib_stanza.AnnStanza">AnnStanza</a></li>
<li><a title="gatenlp.pam.pampac.pampac.PampacAnnotator" href="../pam/pampac/pampac.html#gatenlp.pam.pampac.pampac.PampacAnnotator">PampacAnnotator</a></li>
<li><a title="gatenlp.processing.annotator.AnnotatorFunction" href="#gatenlp.processing.annotator.AnnotatorFunction">AnnotatorFunction</a></li>
<li><a title="gatenlp.processing.client.ElgTextAnnotator" href="client.html#gatenlp.processing.client.ElgTextAnnotator">ElgTextAnnotator</a></li>
<li><a title="gatenlp.processing.client.GateCloudAnnotator" href="client.html#gatenlp.processing.client.GateCloudAnnotator">GateCloudAnnotator</a></li>
<li><a title="gatenlp.processing.client.TagMeAnnotator" href="client.html#gatenlp.processing.client.TagMeAnnotator">TagMeAnnotator</a></li>
<li><a title="gatenlp.processing.client.TextRazorTextAnnotator" href="client.html#gatenlp.processing.client.TextRazorTextAnnotator">TextRazorTextAnnotator</a></li>
<li><a title="gatenlp.processing.gazetteer.base.GazetteerBase" href="gazetteer/base.html#gatenlp.processing.gazetteer.base.GazetteerBase">GazetteerBase</a></li>
<li><a title="gatenlp.processing.gazetteer.featuregazetteer.FeatureGazetteer" href="gazetteer/featuregazetteer.html#gatenlp.processing.gazetteer.featuregazetteer.FeatureGazetteer">FeatureGazetteer</a></li>
<li><a title="gatenlp.processing.normalizer.Normalizer" href="normalizer.html#gatenlp.processing.normalizer.Normalizer">Normalizer</a></li>
<li><a title="gatenlp.processing.pipeline.Pipeline" href="pipeline.html#gatenlp.processing.pipeline.Pipeline">Pipeline</a></li>
<li><a title="gatenlp.processing.tokenizer.Tokenizer" href="tokenizer.html#gatenlp.processing.tokenizer.Tokenizer">Tokenizer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.processing.annotator.Annotator.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, doc: <a title="gatenlp.document.Document" href="../document.html#gatenlp.document.Document">Document</a>, **kwargs) ‑> Union[<a title="gatenlp.document.Document" href="../document.html#gatenlp.document.Document">Document</a>, List[<a title="gatenlp.document.Document" href="../document.html#gatenlp.document.Document">Document</a>], None]</span>
</code></dt>
<dd>
<div class="desc"><p>This method MUST get implemented in a concrete subclass to do the actual processing
and annotation. It must accept a document and arbitrary keyword arguments and it must
return either a document which may be the same or a different object than the document passed,
or None or an empty list or a list of one or more documents. The method also may raise an
exception.</p>
<p>The semantics of returning None or an empty list are not strictly defined: this may be used to
handle processing errors where documents which cannot be processed are quietly ignored or
filtering.</p>
<p>The method must accept arbitrary keyword arguments which will be passed on to sub-annotators and
may be used to configure or parametrize processing.</p>
<p>NOTE: some annotators may set or use special document features in order to handle
document context or the document id when processing a corpus or streams where a document id
is important.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>doc</code></strong></dt>
<dd>the document to process</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>any arguments to pass to the annotator or sub-annotators called by this annotator</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a document, None, or a possibly empty list of documents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def __call__(self, doc: Document, **kwargs) -&gt; Union[Document, List[Document], None]:
    &#34;&#34;&#34;
    This method MUST get implemented in a concrete subclass to do the actual processing
    and annotation. It must accept a document and arbitrary keyword arguments and it must
    return either a document which may be the same or a different object than the document passed,
    or None or an empty list or a list of one or more documents. The method also may raise an
    exception.

    The semantics of returning None or an empty list are not strictly defined: this may be used to
    handle processing errors where documents which cannot be processed are quietly ignored or
    filtering.

    The method must accept arbitrary keyword arguments which will be passed on to sub-annotators and
    may be used to configure or parametrize processing.

    NOTE: some annotators may set or use special document features in order to handle
    document context or the document id when processing a corpus or streams where a document id
    is important.

    Args:
      doc: the document to process
      kwargs: any arguments to pass to the annotator or sub-annotators called by this annotator

    Returns:
        a document, None, or a possibly empty list of documents
    &#34;&#34;&#34;
    raise Exception(&#34;This method must be implemented!&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.annotator.Annotator.finish"><code class="name flex">
<span>def <span class="ident">finish</span></span>(<span>self) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>A method that gets called when processing ends, e.g. when all documents of a corpus
have been processed. It should return some result for processing the whole batch of documents
it has seen - that result may be None.</p>
<h2 id="returns">Returns</h2>
<p>The overall result of processing all documents or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish(self) -&gt; Any:
    &#34;&#34;&#34;
    A method that gets called when processing ends, e.g. when all documents of a corpus
    have been processed. It should return some result for processing the whole batch of documents
    it has seen - that result may be None.

    Returns:
        The overall result of processing all documents or None
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.annotator.Annotator.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, documents: Iterable[<a title="gatenlp.document.Document" href="../document.html#gatenlp.document.Document">Document</a>], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>If this method gets overridden, it should take an iterable of documents and yield processed documents.
This allows for batching, caching, and other optimizations over streams of documents.
If with_context is True, then the documents parameter should be an iterable over tuples (document, context).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>documents</code></strong></dt>
<dd>an iterable over documents</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>arbitrary other keyword arguments must be accepted</dd>
</dl>
<h2 id="yields">Yields</h2>
<p>processed documents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, documents: Iterable[Document], **kwargs):
    &#34;&#34;&#34;
    If this method gets overridden, it should take an iterable of documents and yield processed documents.
    This allows for batching, caching, and other optimizations over streams of documents.
    If with_context is True, then the documents parameter should be an iterable over tuples (document, context).

    Args:
        documents: an iterable over documents
        **kwargs: arbitrary other keyword arguments must be accepted

    Yields:
        processed documents
    &#34;&#34;&#34;
    for document in documents:
        if document is not None:
            docordocs = self.__call__(document, **kwargs)
            if docordocs is not None:
                if isinstance(docordocs, list):
                    for doc in docordocs:
                        if doc is not None:
                            yield doc
                else:
                    yield docordocs</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.annotator.Annotator.reduce"><code class="name flex">
<span>def <span class="ident">reduce</span></span>(<span>self, results: Iterable[Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>A method that should know how to combine the results passed on in some collection into a
single result. This method should behave like a static method, i.e. not make use of any
data that is specific to the concrete instance.</p>
<p>This can be used to combine corpus results obtained from several processes running on
different parts of a corpus.</p>
<p>This gets invoked by the executor if more than one instance of the annotator was run
over separate sets of documents. If only a single instance was used, the result returned
from finish is used directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results</code></strong></dt>
<dd>an iterable of individual results over some documents each or None if no results are available.
If no results have been passed back from the finish method of any of the processes, the executor should
not call reduce, but if it does, reduce should accept None or an iterator of all None and return None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The combined overall result or None if there are no individual results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce(self, results: Iterable[Any]) -&gt; Any:
    &#34;&#34;&#34;
    A method that should know how to combine the results passed on in some collection into a
    single result. This method should behave like a static method, i.e. not make use of any
    data that is specific to the concrete instance.

    This can be used to combine corpus results obtained from several processes running on
    different parts of a corpus.

    This gets invoked by the executor if more than one instance of the annotator was run
    over separate sets of documents. If only a single instance was used, the result returned
    from finish is used directly.

    Args:
      results: an iterable of individual results over some documents each or None if no results are available.
         If no results have been passed back from the finish method of any of the processes, the executor should
         not call reduce, but if it does, reduce should accept None or an iterator of all None and return None.

    Returns:
        The combined overall result or None if there are no individual results
    &#34;&#34;&#34;
    return results</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.annotator.Annotator.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>A method that gets called when processing starts, e.g. before the first document in
corpus gets processed. This is invoked by an executor to initialize processing a batch
of documents.</p>
<p>This is different from initializing the Annotator: initializing may load large data which
can be reused even if the same annotator instance is run several times over documents.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self) -&gt; None:
    &#34;&#34;&#34;
    A method that gets called when processing starts, e.g. before the first document in
    corpus gets processed. This is invoked by an executor to initialize processing a batch
    of documents.

    This is different from initializing the Annotator: initializing may load large data which
    can be reused even if the same annotator instance is run several times over documents.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.processing.annotator.AnnotatorFunction"><code class="flex name class">
<span>class <span class="ident">AnnotatorFunction</span></span>
<span>(</span><span>funct: Callable)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnotatorFunction(Annotator):
    def __init__(self, funct: Callable):
        self.funct = funct

    def __call__(self, doc: Document, **kwargs) -&gt; Union[Document, List[Document], None]:
        return self.funct(doc, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.processing.annotator.Annotator" href="#gatenlp.processing.annotator.Annotator">Annotator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.processing.annotator.Annotator" href="#gatenlp.processing.annotator.Annotator">Annotator</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.processing.annotator.Annotator.__call__" href="#gatenlp.processing.annotator.Annotator.__call__">__call__</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.finish" href="#gatenlp.processing.annotator.Annotator.finish">finish</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.pipe" href="#gatenlp.processing.annotator.Annotator.pipe">pipe</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.reduce" href="#gatenlp.processing.annotator.Annotator.reduce">reduce</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.start" href="#gatenlp.processing.annotator.Annotator.start">start</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.processing" href="index.html">gatenlp.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.processing.annotator.Annotator" href="#gatenlp.processing.annotator.Annotator">Annotator</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.processing.annotator.Annotator.__call__" href="#gatenlp.processing.annotator.Annotator.__call__">__call__</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.finish" href="#gatenlp.processing.annotator.Annotator.finish">finish</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.pipe" href="#gatenlp.processing.annotator.Annotator.pipe">pipe</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.reduce" href="#gatenlp.processing.annotator.Annotator.reduce">reduce</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.start" href="#gatenlp.processing.annotator.Annotator.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.processing.annotator.AnnotatorFunction" href="#gatenlp.processing.annotator.AnnotatorFunction">AnnotatorFunction</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>