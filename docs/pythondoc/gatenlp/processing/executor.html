<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>gatenlp.processing.executor API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.processing.executor</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from gatenlp.processing.pipeline import _has_method

__pdoc__ = {
    &#34;Annotator.__call__&#34;: True
}


class SerialCorpusExecutor:
    &#34;&#34;&#34;
    Runs a pipeline on an iterable of documents and creates another iterable of documents.
    If inplace=True, the original iterable must be an object that can be enumerated and where
    each element can be accessed and replaced by its enumeration number: `doc=corpus[i]`
    `corpus[i] = doc`.
    &#34;&#34;&#34;
    def __init__(self,
                 input_corpus,
                 annotator,
                 output_corpus=None,
                 inplace=False,
                 ):
        &#34;&#34;&#34;
        Creates an Executor to run an annotator on an iterator of documents. If an output corpus is
        specified, the returned documents are added to the output corpus and the inplace parameter is ignored.

        If no output corpus is specified, then if inplace is True, the processing result is stored back into
        the input corpus which mast support setting an element by id. If the annotator returns a list of documents
        or None, that is also stored back to where the original document was. In most cases, if documents should get
        stored back, the Annotator should return the original document.

        If no output corpus is specified and
        inplace is False, the documents are processed, but the returned documents are discarded (this can be
        useful if the annotator is really just something that is called for a side-effect like sending or storing).

        If an output corpus is specified, the returned document(s) are added one by one to it using the
        `append` or `add` method of the corpus.

        Args:
            input_corpus: the source of documents to iterate over. If inplace is True and not output corpus is
              specified this must all to assign the processing result back to the corpus, e.g. `corpus[i]=result`.
            annotator: the callable to run on each document. If this is an instance of Annotator, the additional
              methods start, finish, and reduce are called as appropriate
            output_corpus: if specified the result documents are added to this one by one, if an annotator returns
              a list, then the list elements are added. If the corpus has the method &#34;append&#34; it is used, otherwise
              the method &#34;add&#34; is expected.
            inplace: if no output corpus is specified and this is True, then results are assigned back to the
              input corpus.
        &#34;&#34;&#34;
        self.input_corpus = input_corpus
        # check how we can add to the output corps
        if output_corpus:
            adder = getattr(output_corpus, &#34;append&#34;, None)
            if adder is None:
                adder = getattr(output_corpus, &#34;add&#34;, None)
            if adder is None or not callable(adder):
                raise Exception(&#34;Output corpus does not have a callable &#39;append&#39; or &#39;add&#39; method&#34;)
            self.corpus_adder = adder
        elif inplace:
            adder = getattr(input_corpus, &#34;__setitem__&#34;, None)
            if adder is None or not callable(adder):
                raise Exception(&#34;Input corpus cannot be assigned to&#34;)
        self.corpus_adder = adder
        if output_corpus is None and inplace:
            self.output_corpus = input_corpus
        else:
            self.output_corpus = output_corpus
            self.inplace = False
        self.annotator = annotator

    def __call__(self, **kwargs):
        if _has_method(self.annotator, &#34;start&#34;):
            self.annotator.init()
        for idx, doc in enumerate(self.input_corpus):
            ret = self.annotator(doc, **kwargs)
            if self.inplace:   # we need to assign the result as it is back to the corpus
                self.input_corpus[idx] = ret
            elif self.output_corpus:
                if ret is not None:
                    for d in ret:
                        self.output_corpus.append(d)
        if _has_method(self.annotator, &#34;finish&#34;):
            rets = self.annotator.init()
            return rets
        else:
            return None
        # NOTE: since this is single-threaded, no reduce call is necessary!</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.processing.executor.SerialCorpusExecutor"><code class="flex name class">
<span>class <span class="ident">SerialCorpusExecutor</span></span>
<span>(</span><span>input_corpus, annotator, output_corpus=None, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs a pipeline on an iterable of documents and creates another iterable of documents.
If inplace=True, the original iterable must be an object that can be enumerated and where
each element can be accessed and replaced by its enumeration number: <code>doc=corpus[i]</code>
<code>corpus[i] = doc</code>.</p>
<p>Creates an Executor to run an annotator on an iterator of documents. If an output corpus is
specified, the returned documents are added to the output corpus and the inplace parameter is ignored.</p>
<p>If no output corpus is specified, then if inplace is True, the processing result is stored back into
the input corpus which mast support setting an element by id. If the annotator returns a list of documents
or None, that is also stored back to where the original document was. In most cases, if documents should get
stored back, the Annotator should return the original document.</p>
<p>If no output corpus is specified and
inplace is False, the documents are processed, but the returned documents are discarded (this can be
useful if the annotator is really just something that is called for a side-effect like sending or storing).</p>
<p>If an output corpus is specified, the returned document(s) are added one by one to it using the
<code>append</code> or <code>add</code> method of the corpus.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_corpus</code></strong></dt>
<dd>the source of documents to iterate over. If inplace is True and not output corpus is
specified this must all to assign the processing result back to the corpus, e.g. <code>corpus[i]=result</code>.</dd>
<dt><strong><code>annotator</code></strong></dt>
<dd>the callable to run on each document. If this is an instance of Annotator, the additional
methods start, finish, and reduce are called as appropriate</dd>
<dt><strong><code>output_corpus</code></strong></dt>
<dd>if specified the result documents are added to this one by one, if an annotator returns
a list, then the list elements are added. If the corpus has the method "append" it is used, otherwise
the method "add" is expected.</dd>
<dt><strong><code>inplace</code></strong></dt>
<dd>if no output corpus is specified and this is True, then results are assigned back to the
input corpus.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerialCorpusExecutor:
    &#34;&#34;&#34;
    Runs a pipeline on an iterable of documents and creates another iterable of documents.
    If inplace=True, the original iterable must be an object that can be enumerated and where
    each element can be accessed and replaced by its enumeration number: `doc=corpus[i]`
    `corpus[i] = doc`.
    &#34;&#34;&#34;
    def __init__(self,
                 input_corpus,
                 annotator,
                 output_corpus=None,
                 inplace=False,
                 ):
        &#34;&#34;&#34;
        Creates an Executor to run an annotator on an iterator of documents. If an output corpus is
        specified, the returned documents are added to the output corpus and the inplace parameter is ignored.

        If no output corpus is specified, then if inplace is True, the processing result is stored back into
        the input corpus which mast support setting an element by id. If the annotator returns a list of documents
        or None, that is also stored back to where the original document was. In most cases, if documents should get
        stored back, the Annotator should return the original document.

        If no output corpus is specified and
        inplace is False, the documents are processed, but the returned documents are discarded (this can be
        useful if the annotator is really just something that is called for a side-effect like sending or storing).

        If an output corpus is specified, the returned document(s) are added one by one to it using the
        `append` or `add` method of the corpus.

        Args:
            input_corpus: the source of documents to iterate over. If inplace is True and not output corpus is
              specified this must all to assign the processing result back to the corpus, e.g. `corpus[i]=result`.
            annotator: the callable to run on each document. If this is an instance of Annotator, the additional
              methods start, finish, and reduce are called as appropriate
            output_corpus: if specified the result documents are added to this one by one, if an annotator returns
              a list, then the list elements are added. If the corpus has the method &#34;append&#34; it is used, otherwise
              the method &#34;add&#34; is expected.
            inplace: if no output corpus is specified and this is True, then results are assigned back to the
              input corpus.
        &#34;&#34;&#34;
        self.input_corpus = input_corpus
        # check how we can add to the output corps
        if output_corpus:
            adder = getattr(output_corpus, &#34;append&#34;, None)
            if adder is None:
                adder = getattr(output_corpus, &#34;add&#34;, None)
            if adder is None or not callable(adder):
                raise Exception(&#34;Output corpus does not have a callable &#39;append&#39; or &#39;add&#39; method&#34;)
            self.corpus_adder = adder
        elif inplace:
            adder = getattr(input_corpus, &#34;__setitem__&#34;, None)
            if adder is None or not callable(adder):
                raise Exception(&#34;Input corpus cannot be assigned to&#34;)
        self.corpus_adder = adder
        if output_corpus is None and inplace:
            self.output_corpus = input_corpus
        else:
            self.output_corpus = output_corpus
            self.inplace = False
        self.annotator = annotator

    def __call__(self, **kwargs):
        if _has_method(self.annotator, &#34;start&#34;):
            self.annotator.init()
        for idx, doc in enumerate(self.input_corpus):
            ret = self.annotator(doc, **kwargs)
            if self.inplace:   # we need to assign the result as it is back to the corpus
                self.input_corpus[idx] = ret
            elif self.output_corpus:
                if ret is not None:
                    for d in ret:
                        self.output_corpus.append(d)
        if _has_method(self.annotator, &#34;finish&#34;):
            rets = self.annotator.init()
            return rets
        else:
            return None</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.processing" href="index.html">gatenlp.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.processing.executor.SerialCorpusExecutor" href="#gatenlp.processing.executor.SerialCorpusExecutor">SerialCorpusExecutor</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>