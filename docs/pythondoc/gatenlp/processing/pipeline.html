<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev16+g8c2bb0d.d20201028" />
<title>gatenlp.processing.pipeline API documentation</title>
<meta name="description" content="Module that provides the Pipeline class. A Pipeline is an annotator which is configured to contain several annotators
which get executed in sequence â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.processing.pipeline</code></h1>
</header>
<section id="section-intro">
<p>Module that provides the Pipeline class. A Pipeline is an annotator which is configured to contain several annotators
which get executed in sequence. The result of each annotator is passed on to the next anotator.
Each annotator can return a single document, None, or list of documents. If no document is returned, subsequent
annotators are not called and None is returned from the pipeline. If several documents are areturned, subsequent
annotators are invoked for each of those documents and the list of final return documents is returned by the pipeline.</p>
<p>Whenever a single document is returned it is returned as the document and NOT as a list with a single document as
the only element.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that provides the Pipeline class. A Pipeline is an annotator which is configured to contain several annotators
which get executed in sequence. The result of each annotator is passed on to the next anotator.
Each annotator can return a single document, None, or list of documents. If no document is returned, subsequent
annotators are not called and None is returned from the pipeline. If several documents are areturned, subsequent
annotators are invoked for each of those documents and the list of final return documents is returned by the pipeline.

Whenever a single document is returned it is returned as the document and NOT as a list with a single document as
the only element.
&#34;&#34;&#34;

from collections.abc import Iterable
import inspect
from gatenlp.processing.annotator import Annotator
from gatenlp.utils import init_logger


def _check_and_ret_callable(a, **kwargs):
    &#34;&#34;&#34;
    Make sure a is either a callable or a class that can be instatiated to a callable.

    Args:
      a: a class or instantiated callable
      kwargs: arguments to pass on to the initializer
      **kwargs: 

    Returns:
        an instantiated callable or throws an exception if not a callable

    &#34;&#34;&#34;
    if inspect.isclass(a):
        a = a(**kwargs)
    if not callable(a):
        raise Exception(f&#34;Not a callable: {a}&#34;)
    return a


def _has_method(obj, name):
    &#34;&#34;&#34;
    Check if the object has a method with that name

    Args:
      obj: the object
      name: the name of the method

    Returns:
        True if the object has a callable method with that name, otherwise False

    &#34;&#34;&#34;
    mth = getattr(obj, name, None)
    if mth is None:
        return False
    elif callable(mth):
        return True
    else:
        return False


class Pipeline(Annotator):
    &#34;&#34;&#34;
    A pipeline is an annotator which runs several other annotators in sequence on a document
    and returns the result. Since annotators can return no or more than one result document
    in a list, the pipeline can return no or more than one document for each input document
    as well.

    When the start/finish/reduce method of the pipeline is invoked, all start/finish/reduce methods of
    all annotators are invoked in sequence. The finish method returns the list of all return values of
    all the finish methods of the annotators (if a finish method returns None, this is added to the list).

    The reduce method expects a list with as many return value lists as there are annotators and returns
    the overall result for each annotator (again, including None if there is none).
    &#34;&#34;&#34;

    def __init__(self, *annotators, **kwargs):
        &#34;&#34;&#34;
        Creates a pipeline annotator.

        Args:
            annotators: each parameter can be an annotator or callable, if it is an iterable,
                it is assumed to be an iterable of callables or lists. If it is not an iterable, it can
                be either a class or an already initialized instance of a class which must be a callable
                or some other callable.
            **kwargs: these arguments are passed to the constructor of any class in the annotators list
        &#34;&#34;&#34;
        self.annotators = []
        self.logger = init_logger(__name__)
        for ann in annotators:
            if isinstance(ann, Iterable):
                for a in ann:
                    a = _check_and_ret_callable(a)
                    self.annotators.append(a)
            else:
                a = _check_and_ret_callable(a, **kwargs)
                self.annotators.append(ann)
        if len(self.annotators) == 0:
            self.logger.warn(&#34;Pipeline is a do-nothing pipeline: no annotators&#34;)

    def __call__(self, doc, **kwargs):
        &#34;&#34;&#34;
        Calls each annotator in sequence and passes the result or results to the next.

        Args:
            doc: the document to process
            **kwargs: any kwargs will be passed to all annotators

        Returns:
            a document or a list of documents
        &#34;&#34;&#34;
        toprocess = [doc]
        results = []
        for annotator in self.annotators:
            results = []
            for d in toprocess:
                ret = annotator(doc, **kwargs)
                if isinstance(ret, list):
                    results.extend(ret)
                else:
                    if ret is not None:
                        results.append(ret)
            toprocess = results
        if len(results) == 1:
            return results[0]
        else:
            return results

    def start(self):
        &#34;&#34;&#34;
        Invokes start on all annotators.
        &#34;&#34;&#34;
        for annotator in self.annotators:
            if _has_method(annotator, &#34;start&#34;):
                annotator.start()

    def finish(self):
        &#34;&#34;&#34;
        Invokes finish on all annotators and return their results as a list with as many
        elements as there are annotators (annotators which did not return anything have None).

        Returns:
            list of annotator results
        &#34;&#34;&#34;
        results = []
        for annotator in self.annotators:
            if _has_method(annotator, &#34;finish&#34;):
                results.append(annotator.finish())
            else:
                results.append(None)
        return results

    def reduce(self, results):
        &#34;&#34;&#34;
        Invokes reduce on all annotators using the list of result lists. `results` is a list with
        as many elements as there are annotators. Each element is a list of results from different
        processes or different batches.
        
        Returns a list with as many elements as there are annotators, each element the combined result.

        Args:
            results: a list of result lists

        Returns:
            a list of combined results
        &#34;&#34;&#34;
        results = []
        assert len(results) == len(self.annotators)
        for reslist, annotator in zip(results, self.annotators):
            if _has_method(annotator, &#34;reduce&#34;):
                results.append(annotator.reduce(reslist))
            else:
                results.append(reslist)
        return results</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.processing.pipeline.Pipeline"><code class="flex name class">
<span>class <span class="ident">Pipeline</span></span>
<span>(</span><span>*annotators, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A pipeline is an annotator which runs several other annotators in sequence on a document
and returns the result. Since annotators can return no or more than one result document
in a list, the pipeline can return no or more than one document for each input document
as well.</p>
<p>When the start/finish/reduce method of the pipeline is invoked, all start/finish/reduce methods of
all annotators are invoked in sequence. The finish method returns the list of all return values of
all the finish methods of the annotators (if a finish method returns None, this is added to the list).</p>
<p>The reduce method expects a list with as many return value lists as there are annotators and returns
the overall result for each annotator (again, including None if there is none).</p>
<p>Creates a pipeline annotator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annotators</code></strong></dt>
<dd>each parameter can be an annotator or callable, if it is an iterable,
it is assumed to be an iterable of callables or lists. If it is not an iterable, it can
be either a class or an already initialized instance of a class which must be a callable
or some other callable.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>these arguments are passed to the constructor of any class in the annotators list</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pipeline(Annotator):
    &#34;&#34;&#34;
    A pipeline is an annotator which runs several other annotators in sequence on a document
    and returns the result. Since annotators can return no or more than one result document
    in a list, the pipeline can return no or more than one document for each input document
    as well.

    When the start/finish/reduce method of the pipeline is invoked, all start/finish/reduce methods of
    all annotators are invoked in sequence. The finish method returns the list of all return values of
    all the finish methods of the annotators (if a finish method returns None, this is added to the list).

    The reduce method expects a list with as many return value lists as there are annotators and returns
    the overall result for each annotator (again, including None if there is none).
    &#34;&#34;&#34;

    def __init__(self, *annotators, **kwargs):
        &#34;&#34;&#34;
        Creates a pipeline annotator.

        Args:
            annotators: each parameter can be an annotator or callable, if it is an iterable,
                it is assumed to be an iterable of callables or lists. If it is not an iterable, it can
                be either a class or an already initialized instance of a class which must be a callable
                or some other callable.
            **kwargs: these arguments are passed to the constructor of any class in the annotators list
        &#34;&#34;&#34;
        self.annotators = []
        self.logger = init_logger(__name__)
        for ann in annotators:
            if isinstance(ann, Iterable):
                for a in ann:
                    a = _check_and_ret_callable(a)
                    self.annotators.append(a)
            else:
                a = _check_and_ret_callable(a, **kwargs)
                self.annotators.append(ann)
        if len(self.annotators) == 0:
            self.logger.warn(&#34;Pipeline is a do-nothing pipeline: no annotators&#34;)

    def __call__(self, doc, **kwargs):
        &#34;&#34;&#34;
        Calls each annotator in sequence and passes the result or results to the next.

        Args:
            doc: the document to process
            **kwargs: any kwargs will be passed to all annotators

        Returns:
            a document or a list of documents
        &#34;&#34;&#34;
        toprocess = [doc]
        results = []
        for annotator in self.annotators:
            results = []
            for d in toprocess:
                ret = annotator(doc, **kwargs)
                if isinstance(ret, list):
                    results.extend(ret)
                else:
                    if ret is not None:
                        results.append(ret)
            toprocess = results
        if len(results) == 1:
            return results[0]
        else:
            return results

    def start(self):
        &#34;&#34;&#34;
        Invokes start on all annotators.
        &#34;&#34;&#34;
        for annotator in self.annotators:
            if _has_method(annotator, &#34;start&#34;):
                annotator.start()

    def finish(self):
        &#34;&#34;&#34;
        Invokes finish on all annotators and return their results as a list with as many
        elements as there are annotators (annotators which did not return anything have None).

        Returns:
            list of annotator results
        &#34;&#34;&#34;
        results = []
        for annotator in self.annotators:
            if _has_method(annotator, &#34;finish&#34;):
                results.append(annotator.finish())
            else:
                results.append(None)
        return results

    def reduce(self, results):
        &#34;&#34;&#34;
        Invokes reduce on all annotators using the list of result lists. `results` is a list with
        as many elements as there are annotators. Each element is a list of results from different
        processes or different batches.
        
        Returns a list with as many elements as there are annotators, each element the combined result.

        Args:
            results: a list of result lists

        Returns:
            a list of combined results
        &#34;&#34;&#34;
        results = []
        assert len(results) == len(self.annotators)
        for reslist, annotator in zip(results, self.annotators):
            if _has_method(annotator, &#34;reduce&#34;):
                results.append(annotator.reduce(reslist))
            else:
                results.append(reslist)
        return results</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.processing.pipeline.Pipeline.finish"><code class="name flex">
<span>def <span class="ident">finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invokes finish on all annotators and return their results as a list with as many
elements as there are annotators (annotators which did not return anything have None).</p>
<h2 id="returns">Returns</h2>
<p>list of annotator results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish(self):
    &#34;&#34;&#34;
    Invokes finish on all annotators and return their results as a list with as many
    elements as there are annotators (annotators which did not return anything have None).

    Returns:
        list of annotator results
    &#34;&#34;&#34;
    results = []
    for annotator in self.annotators:
        if _has_method(annotator, &#34;finish&#34;):
            results.append(annotator.finish())
        else:
            results.append(None)
    return results</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.pipeline.Pipeline.reduce"><code class="name flex">
<span>def <span class="ident">reduce</span></span>(<span>self, results)</span>
</code></dt>
<dd>
<div class="desc"><p>Invokes reduce on all annotators using the list of result lists. <code>results</code> is a list with
as many elements as there are annotators. Each element is a list of results from different
processes or different batches.</p>
<p>Returns a list with as many elements as there are annotators, each element the combined result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results</code></strong></dt>
<dd>a list of result lists</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a list of combined results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce(self, results):
    &#34;&#34;&#34;
    Invokes reduce on all annotators using the list of result lists. `results` is a list with
    as many elements as there are annotators. Each element is a list of results from different
    processes or different batches.
    
    Returns a list with as many elements as there are annotators, each element the combined result.

    Args:
        results: a list of result lists

    Returns:
        a list of combined results
    &#34;&#34;&#34;
    results = []
    assert len(results) == len(self.annotators)
    for reslist, annotator in zip(results, self.annotators):
        if _has_method(annotator, &#34;reduce&#34;):
            results.append(annotator.reduce(reslist))
        else:
            results.append(reslist)
    return results</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.pipeline.Pipeline.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invokes start on all annotators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;
    Invokes start on all annotators.
    &#34;&#34;&#34;
    for annotator in self.annotators:
        if _has_method(annotator, &#34;start&#34;):
            annotator.start()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.processing.annotator.Annotator.__call__" href="annotator.html#gatenlp.processing.annotator.Annotator.__call__">__call__</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.processing" href="index.html">gatenlp.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.processing.pipeline.Pipeline" href="#gatenlp.processing.pipeline.Pipeline">Pipeline</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.processing.pipeline.Pipeline.finish" href="#gatenlp.processing.pipeline.Pipeline.finish">finish</a></code></li>
<li><code><a title="gatenlp.processing.pipeline.Pipeline.reduce" href="#gatenlp.processing.pipeline.Pipeline.reduce">reduce</a></code></li>
<li><code><a title="gatenlp.processing.pipeline.Pipeline.start" href="#gatenlp.processing.pipeline.Pipeline.start">start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev16+g8c2bb0d.d20201028</a>.</p>
</footer>
</body>
</html>