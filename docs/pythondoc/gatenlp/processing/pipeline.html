<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gatenlp.processing.pipeline API documentation</title>
<meta name="description" content="Module that provides the Pipeline class. A Pipeline is an annotator which is configured to contain several annotators
which get executed in sequence â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.processing.pipeline</code></h1>
</header>
<section id="section-intro">
<p>Module that provides the Pipeline class. A Pipeline is an annotator which is configured to contain several annotators
which get executed in sequence. The result of each annotator is passed on to the next anotator.
Each annotator can return a single document, None, or list of documents. If no document is returned, subsequent
annotators are not called and None is returned from the pipeline. If several documents are areturned, subsequent
annotators are invoked for each of those documents and the list of final return documents is returned by the pipeline.</p>
<p>Whenever a single document is returned it is returned as the document and NOT as a list with a single document as
the only element.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that provides the Pipeline class. A Pipeline is an annotator which is configured to contain several annotators
which get executed in sequence. The result of each annotator is passed on to the next anotator.
Each annotator can return a single document, None, or list of documents. If no document is returned, subsequent
annotators are not called and None is returned from the pipeline. If several documents are areturned, subsequent
annotators are invoked for each of those documents and the list of final return documents is returned by the pipeline.

Whenever a single document is returned it is returned as the document and NOT as a list with a single document as
the only element.
&#34;&#34;&#34;

from collections.abc import Iterable
import inspect
from gatenlp.processing.annotator import Annotator
from gatenlp.utils import init_logger


def _check_and_ret_callable(a, **kwargs):
    &#34;&#34;&#34;
    Make sure a is either a callable or a class that can be instatiated to a callable.

    Args:
      a: a class or instantiated callable
      kwargs: arguments to pass on to the initializer
      **kwargs:

    Returns:
        an instantiated callable or throws an exception if not a callable

    &#34;&#34;&#34;
    if inspect.isclass(a):
        a = a(**kwargs)
    if not callable(a):
        raise Exception(f&#34;Not a callable: {a}&#34;)
    return a


def _has_method(obj, name):
    &#34;&#34;&#34;
    Check if the object has a method with that name

    Args:
      obj: the object
      name: the name of the method

    Returns:
        True if the object has a callable method with that name, otherwise False

    &#34;&#34;&#34;
    mth = getattr(obj, name, None)
    if mth is None:
        return False
    elif callable(mth):
        return True
    else:
        return False


class Pipeline(Annotator):
    &#34;&#34;&#34;
    A pipeline is an annotator which runs several other annotators in sequence on a document
    and returns the result. Since annotators can return no or more than one result document
    in a list, the pipeline can return no or more than one document for each input document
    as well.

    When the start/finish/reduce method of the pipeline is invoked, all start/finish/reduce methods of
    all annotators are invoked in sequence. The finish method returns the list of all return values of
    all the finish methods of the annotators (if a finish method returns None, this is added to the list).

    The reduce method expects a list with as many return value lists as there are annotators and returns
    the overall result for each annotator (again, including None if there is none).
    &#34;&#34;&#34;

    def __init__(self, *annotators, **kwargs):
        &#34;&#34;&#34;
        Creates a pipeline annotator. Individual annotators can be added at a later time to the front or back
        using the add method.

        Note: each annotator can be assigned a name in a pipeline, either when using the add method or
        by passing a tuple (annotator, name) instead of just the annotator.

        Args:
            annotators: each parameter can be an annotator, a callable, a tuple where the first item is
                an annotator or callable and the second a string(name), or a list of these things.
                An annotator can be given as an instance or class, if it is a class, the kwargs are used
                to construct an instance. If no annotators are specified at construction, they can still
                be added later and incrementally using the `add` method.
            **kwargs: these arguments are passed to the constructor of any class in the annotators list
        &#34;&#34;&#34;
        self.annotators = []
        self.names = []
        self.names2annotators = dict()
        self.logger = init_logger(&#34;Pipeline&#34;)
        for ann in annotators:
            if not isinstance(ann, list):
                anns = [ann]
            for a in anns:
                if isinstance(a, tuple) and len(a) == 2:
                    a, name = a
                else:
                    name = f&#34;{len(self.annotators)}&#34;
                a = _check_and_ret_callable(a)
                if name in self.names2annotators:
                    raise Exception(f&#34;Duplicate name: {name}&#34;)
                self.names2annotators[name] = a
                self.annotators.append(a)
                self.names.append(name)
        # if len(self.annotators) == 0:
        #     self.logger.warning(&#34;Pipeline is a do-nothing pipeline: no annotators&#34;)

    def copy(self):
        &#34;&#34;&#34;
        Return a shallow copy of the pipeline: the annotators and the annotator data is identical, but
        the pipeline data itself is copied, so that an existing pipeline can be modified or extendet.

        Returns:
            a shallow copy of this pipeline
        &#34;&#34;&#34;
        new = Pipeline([(name, ann) for name, ann in self.names2annotators.items()])
        return new

    def add(self, annotator, name=None, tofront=False):
        &#34;&#34;&#34;
        Add an annotator to list of annotators for this pipeline. The annotator must be an initialized instance,
        not a class.

        Args:
            annotator: the annotator to add
            name: an optional name of the annotator, if None, uses a string representation of the
                number of the annotator as added (not the index in the pipeline!)
            tofront: if True adds to the front of the list instead of appending to the end
        &#34;&#34;&#34;
        a = _check_and_ret_callable(annotator)
        if name is None:
            name = f&#34;{len(self.annotators)}&#34;
        if name in self.names2annotators:
            raise Exception(f&#34;Duplicate name: {name}&#34;)
        if tofront:
            self.annotators.insert(0, a)
            self.names.insert(0, name)
        else:
            self.annotators.append(a)
            self.names.append(name)
        self.names2annotators[name] = a

    def __getitem__(self, item):
        if isinstance(item, str):
            return self.names2annotators[item]
        else:
            return self.annotators[item]

    def __call__(self, doc, **kwargs):
        &#34;&#34;&#34;
        Calls each annotator in sequence and passes the result or results to the next.

        Args:
            doc: the document to process
            **kwargs: any kwargs will be passed to all annotators

        Returns:
            a document or a list of documents
        &#34;&#34;&#34;
        toprocess = [doc]
        results = []
        for annotator in self.annotators:
            results = []
            for d in toprocess:
                ret = annotator(doc, **kwargs)
                if isinstance(ret, list):
                    results.extend(ret)
                else:
                    if ret is not None:
                        results.append(ret)
            toprocess = results
        if len(results) == 1:
            return results[0]
        else:
            return results

    def pipe(self, documents, **kwargs):
        &#34;&#34;&#34;
        Iterate over each of the documents process them by all the annotators in the pipeline
        and yield all the final  non-None result documents. Documents are processed by in turn
        invoking their `pipe` method on the generator created by the previous step.

        Args:
            documents: an iterable of documents or None (None values are ignored)
            **kwargs: arguments to be passed to each of the annotators

        Yields:
            documents for which processing did not return None

        &#34;&#34;&#34;
        gen = documents
        for antr in self.annotators:
            gen = antr.pipe(gen, **kwargs)
        return gen

    def start(self):
        &#34;&#34;&#34;
        Invokes start on all annotators.
        &#34;&#34;&#34;
        for annotator in self.annotators:
            if _has_method(annotator, &#34;start&#34;):
                annotator.start()

    def finish(self):
        &#34;&#34;&#34;
        Invokes finish on all annotators and return their results as a list with as many
        elements as there are annotators (annotators which did not return anything have None).

        Returns:
            list of annotator results
        &#34;&#34;&#34;
        results = []
        for annotator in self.annotators:
            if _has_method(annotator, &#34;finish&#34;):
                results.append(annotator.finish())
            else:
                results.append(None)
        return results

    def reduce(self, results):
        &#34;&#34;&#34;
        Invokes reduce on all annotators using the list of result lists. `results` is a list with
        as many elements as there are annotators. Each element is a list of results from different
        processes or different batches.

        Returns a list with as many elements as there are annotators, each element the combined result.

        Args:
            results: a list of result lists

        Returns:
            a list of combined results
        &#34;&#34;&#34;
        results = []
        assert len(results) == len(self.annotators)
        for reslist, annotator in zip(results, self.annotators):
            if _has_method(annotator, &#34;reduce&#34;):
                results.append(annotator.reduce(reslist))
            else:
                results.append(reslist)
        return results

    def __repr__(self):
        reprs = []
        for name, ann in zip(self.names, self.annotators):
            if hasattr(ann, &#34;__name__&#34;):
                arepr = ann.__name__
            else:
                arepr = ann.__class__.__name__
            repr = name + &#34;:&#34; + arepr
            reprs.append(repr)
        reprs = &#34;,&#34;.join(reprs)
        return f&#34;Pipeline({reprs})&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.processing.pipeline.Pipeline"><code class="flex name class">
<span>class <span class="ident">Pipeline</span></span>
<span>(</span><span>*annotators, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A pipeline is an annotator which runs several other annotators in sequence on a document
and returns the result. Since annotators can return no or more than one result document
in a list, the pipeline can return no or more than one document for each input document
as well.</p>
<p>When the start/finish/reduce method of the pipeline is invoked, all start/finish/reduce methods of
all annotators are invoked in sequence. The finish method returns the list of all return values of
all the finish methods of the annotators (if a finish method returns None, this is added to the list).</p>
<p>The reduce method expects a list with as many return value lists as there are annotators and returns
the overall result for each annotator (again, including None if there is none).</p>
<p>Creates a pipeline annotator. Individual annotators can be added at a later time to the front or back
using the add method.</p>
<p>Note: each annotator can be assigned a name in a pipeline, either when using the add method or
by passing a tuple (annotator, name) instead of just the annotator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annotators</code></strong></dt>
<dd>each parameter can be an annotator, a callable, a tuple where the first item is
an annotator or callable and the second a string(name), or a list of these things.
An annotator can be given as an instance or class, if it is a class, the kwargs are used
to construct an instance. If no annotators are specified at construction, they can still
be added later and incrementally using the <code>add</code> method.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>these arguments are passed to the constructor of any class in the annotators list</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pipeline(Annotator):
    &#34;&#34;&#34;
    A pipeline is an annotator which runs several other annotators in sequence on a document
    and returns the result. Since annotators can return no or more than one result document
    in a list, the pipeline can return no or more than one document for each input document
    as well.

    When the start/finish/reduce method of the pipeline is invoked, all start/finish/reduce methods of
    all annotators are invoked in sequence. The finish method returns the list of all return values of
    all the finish methods of the annotators (if a finish method returns None, this is added to the list).

    The reduce method expects a list with as many return value lists as there are annotators and returns
    the overall result for each annotator (again, including None if there is none).
    &#34;&#34;&#34;

    def __init__(self, *annotators, **kwargs):
        &#34;&#34;&#34;
        Creates a pipeline annotator. Individual annotators can be added at a later time to the front or back
        using the add method.

        Note: each annotator can be assigned a name in a pipeline, either when using the add method or
        by passing a tuple (annotator, name) instead of just the annotator.

        Args:
            annotators: each parameter can be an annotator, a callable, a tuple where the first item is
                an annotator or callable and the second a string(name), or a list of these things.
                An annotator can be given as an instance or class, if it is a class, the kwargs are used
                to construct an instance. If no annotators are specified at construction, they can still
                be added later and incrementally using the `add` method.
            **kwargs: these arguments are passed to the constructor of any class in the annotators list
        &#34;&#34;&#34;
        self.annotators = []
        self.names = []
        self.names2annotators = dict()
        self.logger = init_logger(&#34;Pipeline&#34;)
        for ann in annotators:
            if not isinstance(ann, list):
                anns = [ann]
            for a in anns:
                if isinstance(a, tuple) and len(a) == 2:
                    a, name = a
                else:
                    name = f&#34;{len(self.annotators)}&#34;
                a = _check_and_ret_callable(a)
                if name in self.names2annotators:
                    raise Exception(f&#34;Duplicate name: {name}&#34;)
                self.names2annotators[name] = a
                self.annotators.append(a)
                self.names.append(name)
        # if len(self.annotators) == 0:
        #     self.logger.warning(&#34;Pipeline is a do-nothing pipeline: no annotators&#34;)

    def copy(self):
        &#34;&#34;&#34;
        Return a shallow copy of the pipeline: the annotators and the annotator data is identical, but
        the pipeline data itself is copied, so that an existing pipeline can be modified or extendet.

        Returns:
            a shallow copy of this pipeline
        &#34;&#34;&#34;
        new = Pipeline([(name, ann) for name, ann in self.names2annotators.items()])
        return new

    def add(self, annotator, name=None, tofront=False):
        &#34;&#34;&#34;
        Add an annotator to list of annotators for this pipeline. The annotator must be an initialized instance,
        not a class.

        Args:
            annotator: the annotator to add
            name: an optional name of the annotator, if None, uses a string representation of the
                number of the annotator as added (not the index in the pipeline!)
            tofront: if True adds to the front of the list instead of appending to the end
        &#34;&#34;&#34;
        a = _check_and_ret_callable(annotator)
        if name is None:
            name = f&#34;{len(self.annotators)}&#34;
        if name in self.names2annotators:
            raise Exception(f&#34;Duplicate name: {name}&#34;)
        if tofront:
            self.annotators.insert(0, a)
            self.names.insert(0, name)
        else:
            self.annotators.append(a)
            self.names.append(name)
        self.names2annotators[name] = a

    def __getitem__(self, item):
        if isinstance(item, str):
            return self.names2annotators[item]
        else:
            return self.annotators[item]

    def __call__(self, doc, **kwargs):
        &#34;&#34;&#34;
        Calls each annotator in sequence and passes the result or results to the next.

        Args:
            doc: the document to process
            **kwargs: any kwargs will be passed to all annotators

        Returns:
            a document or a list of documents
        &#34;&#34;&#34;
        toprocess = [doc]
        results = []
        for annotator in self.annotators:
            results = []
            for d in toprocess:
                ret = annotator(doc, **kwargs)
                if isinstance(ret, list):
                    results.extend(ret)
                else:
                    if ret is not None:
                        results.append(ret)
            toprocess = results
        if len(results) == 1:
            return results[0]
        else:
            return results

    def pipe(self, documents, **kwargs):
        &#34;&#34;&#34;
        Iterate over each of the documents process them by all the annotators in the pipeline
        and yield all the final  non-None result documents. Documents are processed by in turn
        invoking their `pipe` method on the generator created by the previous step.

        Args:
            documents: an iterable of documents or None (None values are ignored)
            **kwargs: arguments to be passed to each of the annotators

        Yields:
            documents for which processing did not return None

        &#34;&#34;&#34;
        gen = documents
        for antr in self.annotators:
            gen = antr.pipe(gen, **kwargs)
        return gen

    def start(self):
        &#34;&#34;&#34;
        Invokes start on all annotators.
        &#34;&#34;&#34;
        for annotator in self.annotators:
            if _has_method(annotator, &#34;start&#34;):
                annotator.start()

    def finish(self):
        &#34;&#34;&#34;
        Invokes finish on all annotators and return their results as a list with as many
        elements as there are annotators (annotators which did not return anything have None).

        Returns:
            list of annotator results
        &#34;&#34;&#34;
        results = []
        for annotator in self.annotators:
            if _has_method(annotator, &#34;finish&#34;):
                results.append(annotator.finish())
            else:
                results.append(None)
        return results

    def reduce(self, results):
        &#34;&#34;&#34;
        Invokes reduce on all annotators using the list of result lists. `results` is a list with
        as many elements as there are annotators. Each element is a list of results from different
        processes or different batches.

        Returns a list with as many elements as there are annotators, each element the combined result.

        Args:
            results: a list of result lists

        Returns:
            a list of combined results
        &#34;&#34;&#34;
        results = []
        assert len(results) == len(self.annotators)
        for reslist, annotator in zip(results, self.annotators):
            if _has_method(annotator, &#34;reduce&#34;):
                results.append(annotator.reduce(reslist))
            else:
                results.append(reslist)
        return results

    def __repr__(self):
        reprs = []
        for name, ann in zip(self.names, self.annotators):
            if hasattr(ann, &#34;__name__&#34;):
                arepr = ann.__name__
            else:
                arepr = ann.__class__.__name__
            repr = name + &#34;:&#34; + arepr
            reprs.append(repr)
        reprs = &#34;,&#34;.join(reprs)
        return f&#34;Pipeline({reprs})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.processing.pipeline.Pipeline.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, annotator, name=None, tofront=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an annotator to list of annotators for this pipeline. The annotator must be an initialized instance,
not a class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annotator</code></strong></dt>
<dd>the annotator to add</dd>
<dt><strong><code>name</code></strong></dt>
<dd>an optional name of the annotator, if None, uses a string representation of the
number of the annotator as added (not the index in the pipeline!)</dd>
<dt><strong><code>tofront</code></strong></dt>
<dd>if True adds to the front of the list instead of appending to the end</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, annotator, name=None, tofront=False):
    &#34;&#34;&#34;
    Add an annotator to list of annotators for this pipeline. The annotator must be an initialized instance,
    not a class.

    Args:
        annotator: the annotator to add
        name: an optional name of the annotator, if None, uses a string representation of the
            number of the annotator as added (not the index in the pipeline!)
        tofront: if True adds to the front of the list instead of appending to the end
    &#34;&#34;&#34;
    a = _check_and_ret_callable(annotator)
    if name is None:
        name = f&#34;{len(self.annotators)}&#34;
    if name in self.names2annotators:
        raise Exception(f&#34;Duplicate name: {name}&#34;)
    if tofront:
        self.annotators.insert(0, a)
        self.names.insert(0, name)
    else:
        self.annotators.append(a)
        self.names.append(name)
    self.names2annotators[name] = a</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.pipeline.Pipeline.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a shallow copy of the pipeline: the annotators and the annotator data is identical, but
the pipeline data itself is copied, so that an existing pipeline can be modified or extendet.</p>
<h2 id="returns">Returns</h2>
<p>a shallow copy of this pipeline</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    Return a shallow copy of the pipeline: the annotators and the annotator data is identical, but
    the pipeline data itself is copied, so that an existing pipeline can be modified or extendet.

    Returns:
        a shallow copy of this pipeline
    &#34;&#34;&#34;
    new = Pipeline([(name, ann) for name, ann in self.names2annotators.items()])
    return new</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.pipeline.Pipeline.finish"><code class="name flex">
<span>def <span class="ident">finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invokes finish on all annotators and return their results as a list with as many
elements as there are annotators (annotators which did not return anything have None).</p>
<h2 id="returns">Returns</h2>
<p>list of annotator results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish(self):
    &#34;&#34;&#34;
    Invokes finish on all annotators and return their results as a list with as many
    elements as there are annotators (annotators which did not return anything have None).

    Returns:
        list of annotator results
    &#34;&#34;&#34;
    results = []
    for annotator in self.annotators:
        if _has_method(annotator, &#34;finish&#34;):
            results.append(annotator.finish())
        else:
            results.append(None)
    return results</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.pipeline.Pipeline.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, documents, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over each of the documents process them by all the annotators in the pipeline
and yield all the final
non-None result documents. Documents are processed by in turn
invoking their <code>pipe</code> method on the generator created by the previous step.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>documents</code></strong></dt>
<dd>an iterable of documents or None (None values are ignored)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>arguments to be passed to each of the annotators</dd>
</dl>
<h2 id="yields">Yields</h2>
<p>documents for which processing did not return None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, documents, **kwargs):
    &#34;&#34;&#34;
    Iterate over each of the documents process them by all the annotators in the pipeline
    and yield all the final  non-None result documents. Documents are processed by in turn
    invoking their `pipe` method on the generator created by the previous step.

    Args:
        documents: an iterable of documents or None (None values are ignored)
        **kwargs: arguments to be passed to each of the annotators

    Yields:
        documents for which processing did not return None

    &#34;&#34;&#34;
    gen = documents
    for antr in self.annotators:
        gen = antr.pipe(gen, **kwargs)
    return gen</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.pipeline.Pipeline.reduce"><code class="name flex">
<span>def <span class="ident">reduce</span></span>(<span>self, results)</span>
</code></dt>
<dd>
<div class="desc"><p>Invokes reduce on all annotators using the list of result lists. <code>results</code> is a list with
as many elements as there are annotators. Each element is a list of results from different
processes or different batches.</p>
<p>Returns a list with as many elements as there are annotators, each element the combined result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results</code></strong></dt>
<dd>a list of result lists</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a list of combined results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce(self, results):
    &#34;&#34;&#34;
    Invokes reduce on all annotators using the list of result lists. `results` is a list with
    as many elements as there are annotators. Each element is a list of results from different
    processes or different batches.

    Returns a list with as many elements as there are annotators, each element the combined result.

    Args:
        results: a list of result lists

    Returns:
        a list of combined results
    &#34;&#34;&#34;
    results = []
    assert len(results) == len(self.annotators)
    for reslist, annotator in zip(results, self.annotators):
        if _has_method(annotator, &#34;reduce&#34;):
            results.append(annotator.reduce(reslist))
        else:
            results.append(reslist)
    return results</code></pre>
</details>
</dd>
<dt id="gatenlp.processing.pipeline.Pipeline.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invokes start on all annotators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;
    Invokes start on all annotators.
    &#34;&#34;&#34;
    for annotator in self.annotators:
        if _has_method(annotator, &#34;start&#34;):
            annotator.start()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.processing.annotator.Annotator.__call__" href="annotator.html#gatenlp.processing.annotator.Annotator.__call__">__call__</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.processing" href="index.html">gatenlp.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.processing.pipeline.Pipeline" href="#gatenlp.processing.pipeline.Pipeline">Pipeline</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.processing.pipeline.Pipeline.add" href="#gatenlp.processing.pipeline.Pipeline.add">add</a></code></li>
<li><code><a title="gatenlp.processing.pipeline.Pipeline.copy" href="#gatenlp.processing.pipeline.Pipeline.copy">copy</a></code></li>
<li><code><a title="gatenlp.processing.pipeline.Pipeline.finish" href="#gatenlp.processing.pipeline.Pipeline.finish">finish</a></code></li>
<li><code><a title="gatenlp.processing.pipeline.Pipeline.pipe" href="#gatenlp.processing.pipeline.Pipeline.pipe">pipe</a></code></li>
<li><code><a title="gatenlp.processing.pipeline.Pipeline.reduce" href="#gatenlp.processing.pipeline.Pipeline.reduce">reduce</a></code></li>
<li><code><a title="gatenlp.processing.pipeline.Pipeline.start" href="#gatenlp.processing.pipeline.Pipeline.start">start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>