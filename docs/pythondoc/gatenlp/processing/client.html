<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev16+g8c2bb0d.d20201028" />
<title>gatenlp.processing.client API documentation</title>
<meta name="description" content="Module that provides various Annotators which act as clients to REST annotation services." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.processing.client</code></h1>
</header>
<section id="section-intro">
<p>Module that provides various Annotators which act as clients to REST annotation services.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that provides various Annotators which act as clients to REST annotation services.
&#34;&#34;&#34;

import logging
import json
from gatenlp.processing.annotator import Annotator
import requests
from requests.auth import HTTPBasicAuth
from gatenlp.utils import init_logger
import time
from gatenlp.offsetmapper import OffsetMapper

# TODO:
# * support compression send/receive
# * send GATE XML for existing annotations (requires GATE XML serialization writer)
# * send raw HTML or other formats support by the endpoint instead &#34;doc&#34; (which so far is just text)
# * maybe support the 100-continue protocol so far we dont
# * ERROR HANDLING: raise exception vs return None?
class GateCloudAnnotator(Annotator):
    &#34;&#34;&#34;
    This annotator sends the text of a document to a GATE Cloud (https://cloud.gate.ac.uk/) endpoint and uses the
    returned result to create annotations.
    &#34;&#34;&#34;

    def __init__(
        self,
        api_key=None,
        api_password=None,
        url=None,
        ann_types=None,
        map_types=None,
        out_annset=&#34;&#34;,
        min_delay_ms=501,
    ):
        &#34;&#34;&#34;
        Create a GateCloudAnnotator.

        Args:
            api_key: API key needed to authenticate. Some services can be used in a limited way without
               authentication.
            api_password: API password needed to authenticale.
            url:  the URL of the annotation service endpoint, shown on the GATE Cloud page for the service
            ann_types: this can be used to let the service annotate fewer or more than the default list of annotation
               types. The default list and all possible annotations are shown on the GATE Cloud page for the service.
               Either a string with comma separated annotation types preceded by a colon (e.g. &#34;:Person,:Location&#34;)
               or a python list with those type names (e.g. [&#34;:Person&#34;, &#34;:Location&#34;]). If the list contains type names
               without a leading colon, the colon is added.
            map_types: a dict which maps the annotation types from the service to arbitrary new annotation types,
               any type name not in the map will remain unchanged.
            out_annset: the annotation set in which to store the annotations
            min_delay_ms: minimum time in milliseconds between two subsequent requests to the server
        &#34;&#34;&#34;
        self.api_key = api_key
        self.api_password = api_password
        self.url = url
        self.map_types = map_types
        self.min_delay_s = min_delay_ms / 1000.0
        self.out_annset = out_annset
        if ann_types:
            if isinstance(ann_types, str):
                self.ann_types = ann_types
            elif isinstance(ann_types, list):
                self.ann_types = &#34;,&#34;.join(
                    [at if at.startswith(&#34;:&#34;) else &#34;:&#34; + at for at in ann_types]
                )
            else:
                raise Exception(
                    &#34;ann_types mist be a string of types like &#39;:Person,:Location&#39; or a list of types&#34;
                )
        else:
            self.ann_types = None
        self.logger = init_logger()
        self.logger.setLevel(logging.DEBUG)
        self._last_call_time = 0

    def __call__(self, doc, **kwargs):
        delay = time.time() - self._last_call_time
        if delay &lt; self.min_delay_s:
            time.sleep(self.min_delay_s - delay)
        if &#34;url&#34; in kwargs:
            url = kwargs[&#34;url&#34;]
        else:
            url = self.url
        text = doc.text
        hdrs = {
            &#34;Content-Type&#34;: &#34;text/plain; charset=UTF-8&#34;,
            &#34;Accept&#34;: &#34;application/gate+json&#34;,
        }
        params = {}
        if self.ann_types:
            params[&#34;annotations&#34;] = self.ann_types
        # NOTE: not sure when this is needed, for now, disabled
        # next_annid = doc.annset(self.out_annset)._next_annid
        # params[&#34;nextAnnotationId&#34;] = str(next_annid)
        # self.logger.debug(f&#34;Sending text={text}, params={params}&#34;)
        if self.api_key:
            response = requests.post(
                url,
                data=text.encode(&#34;utf-8&#34;),
                headers=hdrs,
                params=params,
                auth=HTTPBasicAuth(self.api_key, self.api_password),
            )
        else:
            response = requests.post(
                url, data=text.encode(&#34;utf-8&#34;), headers=hdrs, params=params
            )
        scode = response.status_code
        if scode != 200:
            raise Exception(f&#34;Something went wrong, received status code {scode}&#34;)
        json = response.json()
        ents = json.get(&#34;entities&#34;, {})
        annset = doc.annset(self.out_annset)
        for typename, anns in ents.items():
            for anndata in anns:
                feats = {}
                start, end = (
                    None,
                    None,
                )  # cause an exception if the return data does not have indices
                for fname, fval in anndata.items():
                    if fname == &#34;indices&#34;:
                        start, end = fval[0], fval[1]
                    else:
                        feats[fname] = fval
                if self.map_types:
                    typename = self.map_types.get(typename, typename)
                # self.logger.debug(f&#34;Adding annotation {start},{start},{typename},{feats}&#34;)
                annset.add(start, end, typename, features=feats)
        return doc


class TagMeAnnotator(Annotator):
    &#34;&#34;&#34;
    An annotator that sends text to the TagMe Annotation service (https://sobigdata.d4science.org/group/tagme/tagme)
    and uses the result to annotate the document.
    &#34;&#34;&#34;

    def __init__(
        self,
        lang=&#34;en&#34;,
        ann_type=&#34;Mention&#34;,
        auth_token=None,
        url=None,
        task=&#34;tag&#34;,  # or spot
        out_annset=&#34;&#34;,
        min_delay_ms=501,
        tweet=False,
        include_all_spots=False,
        long_text=None,
        epsilon=None,
        link_pattern=&#34;https://{0}.wikipedia.org/wiki/{1}&#34;,
    ):
        &#34;&#34;&#34;
        Create a TagMeAnnotator.

        Args:
            lang: the language of the text, one of &#39;de&#39;, &#39;en&#39; (default), &#39;it&#39;
            ann_type: the annotation type for the new annotations, default is &#34;Mention&#34;
            auth_token: the authentication token needed to use the service
            url: the annotation service endpoint, is None, the default endpoint for the task (spot or tag) is used
            task: one of &#34;spot&#34; (only find mentions) or &#34;tag&#34; (find mentions and link), default is &#34;tag&#34;
            out_annset: the annotationset to put the new annotations in
            min_delay_ms: minimum time in ms to wait between requests to the server
            tweet: if True, TagMe expects a Tweet (default is False)
            include_all_spots: if True, include spots that cannot be linked (default is False)
            long_text: if not None, the context length to use (default: None)
            epsilon: if not None, the epsilong value (float) to use (default: None)
            link_pattern: the URL pattern to use to turn the &#34;title&#34; returned from TagMe into an actual link. The
               default is &#34;https://{0}.wikipedia.org/wiki/{1}&#34; where {0} gets replaced with the language code and
               {1} gets replaced with the title.
        &#34;&#34;&#34;
        if url is None:
            if task == &#34;tag&#34;:
                url = &#34;https://tagme.d4science.org/tagme/tag&#34;
            elif task == &#34;spot&#34;:
                url = &#34;https://tagme.d4science.org/tagme/spot&#34;
            else:
                raise Exception(&#34;task must be &#39;tag&#39; or &#39;spot&#39;&#34;)
        assert lang in [&#34;en&#34;, &#34;de&#34;, &#34;it&#34;]
        if long_text is not None:
            assert isinstance(long_text, int)
        if epsilon is not None:
            assert isinstance(epsilon, float)
        self.long_text = long_text
        self.epsilon = epsilon
        self.lang = lang
        self.auth_token = auth_token
        self.url = url
        self.tweet = tweet
        self.include_all_spots = include_all_spots
        self.out_annset = out_annset
        self.min_delay_s = min_delay_ms / 1000.0
        self.logger = init_logger()
        # self.logger.setLevel(logging.DEBUG)
        self._last_call_time = 0
        self.ann_type = ann_type
        self.link_pattern = link_pattern

    def __call__(self, doc, **kwargs):
        if &#34;tweet&#34; in kwargs:
            tweet = kwargs[&#34;tweet&#34;]
        else:
            tweet = self.tweet
        delay = time.time() - self._last_call_time
        if delay &lt; self.min_delay_s:
            time.sleep(self.min_delay_s - delay)
        text = doc.text
        hdrs = {
            &#34;Content-Type&#34;: &#34;text/plain; charset=UTF-8&#34;,
            &#34;Accept&#34;: &#34;application/gate+json&#34;,
        }
        params = {
            &#34;text&#34;: text,
            &#34;gcube-token&#34;: self.auth_token,
            &#34;lang&#34;: self.lang,
        }
        if self.include_all_spots:
            params[&#34;include_all_spots&#34;] = &#34;true&#34;
        if tweet:
            params[&#34;tweet&#34;] = &#34;true&#34;
        if self.long_text is not None:
            params[&#34;long_text&#34;] = self.long_text
        if self.epsilon is not None:
            params[&#34;epsilon&#34;] = self.epsilon
        response = requests.post(self.url, params=params, headers=hdrs)
        scode = response.status_code
        if scode != 200:
            raise Exception(f&#34;Something went wrong, received status code {scode}&#34;)
        json = response.json()
        # self.logger.debug(f&#34;Response JSON: {json}&#34;)
        ents = json.get(&#34;annotations&#34;, {})
        annset = doc.annset(self.out_annset)
        om = OffsetMapper(text)
        for ent in ents:
            start = ent[&#34;start&#34;]
            end = ent[&#34;end&#34;]
            start, end = om.convert_to_python([start, end])
            feats = {}
            title = ent.get(&#34;title&#34;)
            if title is not None:
                if self.link_pattern:
                    feats[&#34;url&#34;] = self.link_pattern.format(self.lang, title)
                else:
                    feats[&#34;title&#34;] = title
            for fname in [&#34;id&#34;, &#34;rho&#34;, &#34;link_probability&#34;, &#34;lp&#34;]:
                fval = ent.get(fname)
                if fval is not None:
                    feats[fname] = fval
            # self.logger.debug(f&#34;Adding annotation {start},{end},{feats}&#34;)
            annset.add(start, end, self.ann_type, features=feats)
        return doc


class TextRazorTextAnnotator(Annotator):
    &#34;&#34;&#34;
    An annotator that sends document text to the TextRazor Annotation service (https://www.textrazor.com/)
    and uses the result to annotate the document.

    NOTE: this annotator and how it can get parametrized will still change!
    &#34;&#34;&#34;

    def __init__(
        self,
        lang=None,  # if None/not specified, TextRazor auto-detects
        auth_token=None,
        url=None,  # use default
        extractors=None,
        out_annset=&#34;&#34;,
        min_delay_ms=501,
    ):
        &#34;&#34;&#34;
        Create a TextRazorTextAnnotator.

        Args:
            lang: if specified, override the auto-detected language of the text
            auth_token: the authentication token needed to use the service
            url: the annotation service endpoint, is None, the default endpoint  https://api.textrazor.com is used
            extractors: a list of extractor names or a string with comma-separated extractor names to add to the
               minimum extractors (words, sentences). If None uses words, sentences, entities.
               NOTE: currently only words, sentences, entities is supported.!
            out_annset: the annotationset to put the new annotations in
            min_delay_ms: minimum time in ms to wait between requests to the server
        &#34;&#34;&#34;
        if url is None:
            url = &#34;https://api.textrazor.com&#34;
        self.url = url
        self.lang = lang
        self.out_annset = out_annset
        self.auth_token = auth_token
        self.min_delay_s = min_delay_ms / 1000.0
        self.logger = init_logger()
        self.logger.setLevel(logging.DEBUG)
        self._last_call_time = 0
        if extractors is not None:
            if isinstance(extractors, str):
                extractors = extractors.split(&#34;,&#34;)
            if isinstance(extractors, list):
                allextrs = set()
                allextrs.update(extractors)
                allextrs.update([&#34;words&#34;, &#34;sentences&#34;])
                self.extractors = &#34;,&#34;.join(list(allextrs))
            else:
                raise Exception(&#34;Odd extractors, must be list of strings or string&#34;)
        else:
            self.extractors = &#34;words,sentences,entities&#34;

    def __call__(self, doc, **kwargs):
        delay = time.time() - self._last_call_time
        if delay &lt; self.min_delay_s:
            time.sleep(self.min_delay_s - delay)
        text = doc.text
        hdrs = {
            # &#39;Content-Type&#39;: &#39;text/plain; charset=UTF-8&#39;,
            # &#39;Accept-encoding&#39;: &#39;gzip&#39;  # TODO: to enable compressed responses
            # &#39;Content-encoding&#39;: &#39;gzip&#39;  # TODO: to enable compressed requests
            &#34;X-TextRazor-Key&#34;: self.auth_token
        }
        data = {&#34;text&#34;: text.encode(&#34;UTF-8&#34;)}
        if self.extractors:
            data[&#34;extractors&#34;] = self.extractors
        if self.lang:
            data[&#34;languageOverride&#34;] = self.lang
        self.logger.debug(f&#34;Sending request to {self.url}, data={data}, headers={hdrs}&#34;)
        response = requests.post(
            self.url,
            # params=params,
            data=data,
            headers=hdrs,
        )
        scode = response.status_code
        if scode != 200:
            raise Exception(f&#34;Something went wrong, received status code {scode}&#34;)
        json = response.json()
        ok = json.get(&#34;ok&#34;, False)
        if not ok:
            raise Exception(f&#34;Something went wrong, did not get OK, json: {json}&#34;)
        self.logger.debug(f&#34;Response JSON: {json}&#34;)
        resp = json.get(&#34;response&#34;, {})
        entities = resp.get(&#34;entities&#34;, [])
        sentences = resp.get(&#34;sentences&#34;, [])
        categories = resp.get(&#34;categories&#34;, [])
        topics = resp.get(&#34;topics&#34;, [])
        entailments = resp.get(&#34;entailments&#34;, [])
        relations = resp.get(&#34;relations&#34;, [])
        properties = resp.get(&#34;properties&#34;, [])
        nounphrases = resp.get(&#34;nounPhrases&#34;, [])
        language = resp.get(&#34;language&#34;)
        languageIsReliable = resp.get(&#34;languageIsReliable&#34;)
        tok2off = {}  # maps token idxs to tuples (start,end)
        annset = doc.annset(self.out_annset)
        for s in sentences:
            sentstart = None
            sentend = None
            words = s.get(&#34;words&#34;, [])
            end = None
            for word in words:
                start = word[&#34;startingPos&#34;]
                end = word[&#34;endingPos&#34;]
                if sentstart is None:
                    sentstart = start
                tokidx = word[&#34;position&#34;]
                feats = {}
                feats[&#34;partOfSpeech&#34;] = word[&#34;partOfSpeech&#34;]
                feats[&#34;lemma&#34;] = word[&#34;lemma&#34;]
                if word.get(&#34;stem&#34;):
                    feats[&#34;stem&#34;] = word[&#34;stem&#34;]
                annset.add(start, end, &#34;Token&#34;, features=feats)
                tok2off[tokidx] = (start, end)
            if end is not None:
                sentend = end
            if sentstart is not None and sentend is not None:
                annset.add(sentstart, sentend, &#34;Sentence&#34;)
        for ent in entities:
            feats = {}
            for fname in [
                &#34;wikiLink&#34;,
                &#34;entityEnglishId&#34;,
                &#34;wikidataId&#34;,
                &#34;relevanceScore&#34;,
                &#34;confidenceScore&#34;,
                &#34;type&#34;,
                &#34;freebaseId&#34;,
                &#34;entityId&#34;,
                &#34;freebaseTypes&#34;,
            ]:
                if fname in ent:
                    feats[fname] = ent[fname]
            annset.add(ent[&#34;startingPos&#34;], ent[&#34;endingPos&#34;], &#34;Entity&#34;, feats)
        return doc


class ElgTextAnnotator(Annotator):
    &#34;&#34;&#34;
    An annotator that sends text to one of the services registered with the European Language Grid
    (https://live.european-language-grid.eu/) and uses the result to create annotations.

    NOTE: This is maybe not properly implemented and not properly tested yet!
    &#34;&#34;&#34;

    def __init__(
        self,
        auth_token=None,
        url=None,
        out_annset=&#34;&#34;,
        min_delay_ms=501,
        anntypes_map=None,
    ):
        &#34;&#34;&#34;
        Create an ElgTextAnnotator.

        Args:
            auth_token: the authentication token from ELG
            url:  the annotation service URL to use
            out_annset: the name of the annotation set where to create the annotations (default: &#34;&#34;)
            min_delay_ms: the minimum delay time between requests in milliseconds (default: 501 ms)
            anntypes_map: a map for renaming the annotation type names from the service to the ones to use in
               the annotated document.
        &#34;&#34;&#34;
        assert url is not None
        self.auth_token = auth_token
        self.url = url
        self.min_delay_s = min_delay_ms / 1000.0
        self.anntypes_map = anntypes_map
        self.out_annset = out_annset
        self.logger = init_logger(__name__)
        # self.logger.setLevel(logging.DEBUG)
        self._last_call_time = 0

    def __call__(self, doc, **kwargs):
        delay = time.time() - self._last_call_time
        if delay &lt; self.min_delay_s:
            time.sleep(self.min_delay_s - delay)
        om = OffsetMapper(doc.text)
        request_json = json.dumps(
            {&#34;type&#34;: &#34;text&#34;, &#34;content&#34;: doc.text, &#34;mimeType&#34;: &#34;text/plain&#34;}
        )
        hdrs = {&#34;Content-Type&#34;: &#34;application/json&#34;}
        if self.auth_token:
            hdrs[&#34;Authorization&#34;] = f&#34;Bearer {self.auth_token}&#34;
        response = requests.post(self.url, data=request_json, headers=hdrs)
        scode = response.status_code
        if scode != 200:
            raise Exception(
                f&#34;Something went wrong, received status code/text {scode} / {response.text}&#34;
            )
        response_json = response.json()
        # self.logger.debug(f&#34;Response JSON: {json}&#34;)
        # TODO: check that we have got
        # - a map
        # - which has the &#34;response&#34; key
        # - response value is a map which has &#34;type&#34;= &#34;annotations&#34; and
        # - &#34;annotations&#34; is a map with keys being the annotation types and values arrays of annoations
        ents = response_json.get(&#34;response&#34;, {}).get(&#34;annotations&#34;, {})
        annset = doc.annset(self.out_annset)
        for ret_anntype, ret_anns in ents.items():
            if self.anntypes_map:
                anntype = self.anntypes_map.get(ret_anntype, ret_anntype)
            else:
                anntype = ret_anntype
            for ret_ann in ret_anns:
                start = ret_ann[&#34;start&#34;]
                end = ret_ann[&#34;end&#34;]
                feats = ret_ann.get(&#34;features&#34;, {})
                start, end = om.convert_to_python([start, end])
                annset.add(start, end, anntype, features=feats)
        return doc</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.processing.client.ElgTextAnnotator"><code class="flex name class">
<span>class <span class="ident">ElgTextAnnotator</span></span>
<span>(</span><span>auth_token=None, url=None, out_annset='', min_delay_ms=501, anntypes_map=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An annotator that sends text to one of the services registered with the European Language Grid
(<a href="https://live.european-language-grid.eu/">https://live.european-language-grid.eu/</a>) and uses the result to create annotations.</p>
<p>NOTE: This is maybe not properly implemented and not properly tested yet!</p>
<p>Create an ElgTextAnnotator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>auth_token</code></strong></dt>
<dd>the authentication token from ELG</dd>
<dt><strong><code>url</code></strong></dt>
<dd>the annotation service URL to use</dd>
<dt><strong><code>out_annset</code></strong></dt>
<dd>the name of the annotation set where to create the annotations (default: "")</dd>
<dt><strong><code>min_delay_ms</code></strong></dt>
<dd>the minimum delay time between requests in milliseconds (default: 501 ms)</dd>
<dt><strong><code>anntypes_map</code></strong></dt>
<dd>a map for renaming the annotation type names from the service to the ones to use in
the annotated document.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ElgTextAnnotator(Annotator):
    &#34;&#34;&#34;
    An annotator that sends text to one of the services registered with the European Language Grid
    (https://live.european-language-grid.eu/) and uses the result to create annotations.

    NOTE: This is maybe not properly implemented and not properly tested yet!
    &#34;&#34;&#34;

    def __init__(
        self,
        auth_token=None,
        url=None,
        out_annset=&#34;&#34;,
        min_delay_ms=501,
        anntypes_map=None,
    ):
        &#34;&#34;&#34;
        Create an ElgTextAnnotator.

        Args:
            auth_token: the authentication token from ELG
            url:  the annotation service URL to use
            out_annset: the name of the annotation set where to create the annotations (default: &#34;&#34;)
            min_delay_ms: the minimum delay time between requests in milliseconds (default: 501 ms)
            anntypes_map: a map for renaming the annotation type names from the service to the ones to use in
               the annotated document.
        &#34;&#34;&#34;
        assert url is not None
        self.auth_token = auth_token
        self.url = url
        self.min_delay_s = min_delay_ms / 1000.0
        self.anntypes_map = anntypes_map
        self.out_annset = out_annset
        self.logger = init_logger(__name__)
        # self.logger.setLevel(logging.DEBUG)
        self._last_call_time = 0

    def __call__(self, doc, **kwargs):
        delay = time.time() - self._last_call_time
        if delay &lt; self.min_delay_s:
            time.sleep(self.min_delay_s - delay)
        om = OffsetMapper(doc.text)
        request_json = json.dumps(
            {&#34;type&#34;: &#34;text&#34;, &#34;content&#34;: doc.text, &#34;mimeType&#34;: &#34;text/plain&#34;}
        )
        hdrs = {&#34;Content-Type&#34;: &#34;application/json&#34;}
        if self.auth_token:
            hdrs[&#34;Authorization&#34;] = f&#34;Bearer {self.auth_token}&#34;
        response = requests.post(self.url, data=request_json, headers=hdrs)
        scode = response.status_code
        if scode != 200:
            raise Exception(
                f&#34;Something went wrong, received status code/text {scode} / {response.text}&#34;
            )
        response_json = response.json()
        # self.logger.debug(f&#34;Response JSON: {json}&#34;)
        # TODO: check that we have got
        # - a map
        # - which has the &#34;response&#34; key
        # - response value is a map which has &#34;type&#34;= &#34;annotations&#34; and
        # - &#34;annotations&#34; is a map with keys being the annotation types and values arrays of annoations
        ents = response_json.get(&#34;response&#34;, {}).get(&#34;annotations&#34;, {})
        annset = doc.annset(self.out_annset)
        for ret_anntype, ret_anns in ents.items():
            if self.anntypes_map:
                anntype = self.anntypes_map.get(ret_anntype, ret_anntype)
            else:
                anntype = ret_anntype
            for ret_ann in ret_anns:
                start = ret_ann[&#34;start&#34;]
                end = ret_ann[&#34;end&#34;]
                feats = ret_ann.get(&#34;features&#34;, {})
                start, end = om.convert_to_python([start, end])
                annset.add(start, end, anntype, features=feats)
        return doc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.processing.annotator.Annotator.__call__" href="annotator.html#gatenlp.processing.annotator.Annotator.__call__">__call__</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.finish" href="annotator.html#gatenlp.processing.annotator.Annotator.finish">finish</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.reduce" href="annotator.html#gatenlp.processing.annotator.Annotator.reduce">reduce</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.start" href="annotator.html#gatenlp.processing.annotator.Annotator.start">start</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.processing.client.GateCloudAnnotator"><code class="flex name class">
<span>class <span class="ident">GateCloudAnnotator</span></span>
<span>(</span><span>api_key=None, api_password=None, url=None, ann_types=None, map_types=None, out_annset='', min_delay_ms=501)</span>
</code></dt>
<dd>
<div class="desc"><p>This annotator sends the text of a document to a GATE Cloud (<a href="https://cloud.gate.ac.uk/">https://cloud.gate.ac.uk/</a>) endpoint and uses the
returned result to create annotations.</p>
<p>Create a GateCloudAnnotator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api_key</code></strong></dt>
<dd>API key needed to authenticate. Some services can be used in a limited way without
authentication.</dd>
<dt><strong><code>api_password</code></strong></dt>
<dd>API password needed to authenticale.</dd>
<dt><strong><code>url</code></strong></dt>
<dd>the URL of the annotation service endpoint, shown on the GATE Cloud page for the service</dd>
<dt><strong><code>ann_types</code></strong></dt>
<dd>this can be used to let the service annotate fewer or more than the default list of annotation
types. The default list and all possible annotations are shown on the GATE Cloud page for the service.
Either a string with comma separated annotation types preceded by a colon (e.g. ":Person,:Location")
or a python list with those type names (e.g. [":Person", ":Location"]). If the list contains type names
without a leading colon, the colon is added.</dd>
<dt><strong><code>map_types</code></strong></dt>
<dd>a dict which maps the annotation types from the service to arbitrary new annotation types,
any type name not in the map will remain unchanged.</dd>
<dt><strong><code>out_annset</code></strong></dt>
<dd>the annotation set in which to store the annotations</dd>
<dt><strong><code>min_delay_ms</code></strong></dt>
<dd>minimum time in milliseconds between two subsequent requests to the server</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GateCloudAnnotator(Annotator):
    &#34;&#34;&#34;
    This annotator sends the text of a document to a GATE Cloud (https://cloud.gate.ac.uk/) endpoint and uses the
    returned result to create annotations.
    &#34;&#34;&#34;

    def __init__(
        self,
        api_key=None,
        api_password=None,
        url=None,
        ann_types=None,
        map_types=None,
        out_annset=&#34;&#34;,
        min_delay_ms=501,
    ):
        &#34;&#34;&#34;
        Create a GateCloudAnnotator.

        Args:
            api_key: API key needed to authenticate. Some services can be used in a limited way without
               authentication.
            api_password: API password needed to authenticale.
            url:  the URL of the annotation service endpoint, shown on the GATE Cloud page for the service
            ann_types: this can be used to let the service annotate fewer or more than the default list of annotation
               types. The default list and all possible annotations are shown on the GATE Cloud page for the service.
               Either a string with comma separated annotation types preceded by a colon (e.g. &#34;:Person,:Location&#34;)
               or a python list with those type names (e.g. [&#34;:Person&#34;, &#34;:Location&#34;]). If the list contains type names
               without a leading colon, the colon is added.
            map_types: a dict which maps the annotation types from the service to arbitrary new annotation types,
               any type name not in the map will remain unchanged.
            out_annset: the annotation set in which to store the annotations
            min_delay_ms: minimum time in milliseconds between two subsequent requests to the server
        &#34;&#34;&#34;
        self.api_key = api_key
        self.api_password = api_password
        self.url = url
        self.map_types = map_types
        self.min_delay_s = min_delay_ms / 1000.0
        self.out_annset = out_annset
        if ann_types:
            if isinstance(ann_types, str):
                self.ann_types = ann_types
            elif isinstance(ann_types, list):
                self.ann_types = &#34;,&#34;.join(
                    [at if at.startswith(&#34;:&#34;) else &#34;:&#34; + at for at in ann_types]
                )
            else:
                raise Exception(
                    &#34;ann_types mist be a string of types like &#39;:Person,:Location&#39; or a list of types&#34;
                )
        else:
            self.ann_types = None
        self.logger = init_logger()
        self.logger.setLevel(logging.DEBUG)
        self._last_call_time = 0

    def __call__(self, doc, **kwargs):
        delay = time.time() - self._last_call_time
        if delay &lt; self.min_delay_s:
            time.sleep(self.min_delay_s - delay)
        if &#34;url&#34; in kwargs:
            url = kwargs[&#34;url&#34;]
        else:
            url = self.url
        text = doc.text
        hdrs = {
            &#34;Content-Type&#34;: &#34;text/plain; charset=UTF-8&#34;,
            &#34;Accept&#34;: &#34;application/gate+json&#34;,
        }
        params = {}
        if self.ann_types:
            params[&#34;annotations&#34;] = self.ann_types
        # NOTE: not sure when this is needed, for now, disabled
        # next_annid = doc.annset(self.out_annset)._next_annid
        # params[&#34;nextAnnotationId&#34;] = str(next_annid)
        # self.logger.debug(f&#34;Sending text={text}, params={params}&#34;)
        if self.api_key:
            response = requests.post(
                url,
                data=text.encode(&#34;utf-8&#34;),
                headers=hdrs,
                params=params,
                auth=HTTPBasicAuth(self.api_key, self.api_password),
            )
        else:
            response = requests.post(
                url, data=text.encode(&#34;utf-8&#34;), headers=hdrs, params=params
            )
        scode = response.status_code
        if scode != 200:
            raise Exception(f&#34;Something went wrong, received status code {scode}&#34;)
        json = response.json()
        ents = json.get(&#34;entities&#34;, {})
        annset = doc.annset(self.out_annset)
        for typename, anns in ents.items():
            for anndata in anns:
                feats = {}
                start, end = (
                    None,
                    None,
                )  # cause an exception if the return data does not have indices
                for fname, fval in anndata.items():
                    if fname == &#34;indices&#34;:
                        start, end = fval[0], fval[1]
                    else:
                        feats[fname] = fval
                if self.map_types:
                    typename = self.map_types.get(typename, typename)
                # self.logger.debug(f&#34;Adding annotation {start},{start},{typename},{feats}&#34;)
                annset.add(start, end, typename, features=feats)
        return doc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.processing.annotator.Annotator.__call__" href="annotator.html#gatenlp.processing.annotator.Annotator.__call__">__call__</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.finish" href="annotator.html#gatenlp.processing.annotator.Annotator.finish">finish</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.reduce" href="annotator.html#gatenlp.processing.annotator.Annotator.reduce">reduce</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.start" href="annotator.html#gatenlp.processing.annotator.Annotator.start">start</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.processing.client.TagMeAnnotator"><code class="flex name class">
<span>class <span class="ident">TagMeAnnotator</span></span>
<span>(</span><span>lang='en', ann_type='Mention', auth_token=None, url=None, task='tag', out_annset='', min_delay_ms=501, tweet=False, include_all_spots=False, long_text=None, epsilon=None, link_pattern='https://{0}.wikipedia.org/wiki/{1}')</span>
</code></dt>
<dd>
<div class="desc"><p>An annotator that sends text to the TagMe Annotation service (<a href="https://sobigdata.d4science.org/group/tagme/tagme">https://sobigdata.d4science.org/group/tagme/tagme</a>)
and uses the result to annotate the document.</p>
<p>Create a TagMeAnnotator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd>the language of the text, one of 'de', 'en' (default), 'it'</dd>
<dt><strong><code>ann_type</code></strong></dt>
<dd>the annotation type for the new annotations, default is "Mention"</dd>
<dt><strong><code>auth_token</code></strong></dt>
<dd>the authentication token needed to use the service</dd>
<dt><strong><code>url</code></strong></dt>
<dd>the annotation service endpoint, is None, the default endpoint for the task (spot or tag) is used</dd>
<dt><strong><code>task</code></strong></dt>
<dd>one of "spot" (only find mentions) or "tag" (find mentions and link), default is "tag"</dd>
<dt><strong><code>out_annset</code></strong></dt>
<dd>the annotationset to put the new annotations in</dd>
<dt><strong><code>min_delay_ms</code></strong></dt>
<dd>minimum time in ms to wait between requests to the server</dd>
<dt><strong><code>tweet</code></strong></dt>
<dd>if True, TagMe expects a Tweet (default is False)</dd>
<dt><strong><code>include_all_spots</code></strong></dt>
<dd>if True, include spots that cannot be linked (default is False)</dd>
<dt><strong><code>long_text</code></strong></dt>
<dd>if not None, the context length to use (default: None)</dd>
<dt><strong><code>epsilon</code></strong></dt>
<dd>if not None, the epsilong value (float) to use (default: None)</dd>
<dt><strong><code>link_pattern</code></strong></dt>
<dd>the URL pattern to use to turn the "title" returned from TagMe into an actual link. The
default is "https://{0}.wikipedia.org/wiki/{1}" where {0} gets replaced with the language code and
{1} gets replaced with the title.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TagMeAnnotator(Annotator):
    &#34;&#34;&#34;
    An annotator that sends text to the TagMe Annotation service (https://sobigdata.d4science.org/group/tagme/tagme)
    and uses the result to annotate the document.
    &#34;&#34;&#34;

    def __init__(
        self,
        lang=&#34;en&#34;,
        ann_type=&#34;Mention&#34;,
        auth_token=None,
        url=None,
        task=&#34;tag&#34;,  # or spot
        out_annset=&#34;&#34;,
        min_delay_ms=501,
        tweet=False,
        include_all_spots=False,
        long_text=None,
        epsilon=None,
        link_pattern=&#34;https://{0}.wikipedia.org/wiki/{1}&#34;,
    ):
        &#34;&#34;&#34;
        Create a TagMeAnnotator.

        Args:
            lang: the language of the text, one of &#39;de&#39;, &#39;en&#39; (default), &#39;it&#39;
            ann_type: the annotation type for the new annotations, default is &#34;Mention&#34;
            auth_token: the authentication token needed to use the service
            url: the annotation service endpoint, is None, the default endpoint for the task (spot or tag) is used
            task: one of &#34;spot&#34; (only find mentions) or &#34;tag&#34; (find mentions and link), default is &#34;tag&#34;
            out_annset: the annotationset to put the new annotations in
            min_delay_ms: minimum time in ms to wait between requests to the server
            tweet: if True, TagMe expects a Tweet (default is False)
            include_all_spots: if True, include spots that cannot be linked (default is False)
            long_text: if not None, the context length to use (default: None)
            epsilon: if not None, the epsilong value (float) to use (default: None)
            link_pattern: the URL pattern to use to turn the &#34;title&#34; returned from TagMe into an actual link. The
               default is &#34;https://{0}.wikipedia.org/wiki/{1}&#34; where {0} gets replaced with the language code and
               {1} gets replaced with the title.
        &#34;&#34;&#34;
        if url is None:
            if task == &#34;tag&#34;:
                url = &#34;https://tagme.d4science.org/tagme/tag&#34;
            elif task == &#34;spot&#34;:
                url = &#34;https://tagme.d4science.org/tagme/spot&#34;
            else:
                raise Exception(&#34;task must be &#39;tag&#39; or &#39;spot&#39;&#34;)
        assert lang in [&#34;en&#34;, &#34;de&#34;, &#34;it&#34;]
        if long_text is not None:
            assert isinstance(long_text, int)
        if epsilon is not None:
            assert isinstance(epsilon, float)
        self.long_text = long_text
        self.epsilon = epsilon
        self.lang = lang
        self.auth_token = auth_token
        self.url = url
        self.tweet = tweet
        self.include_all_spots = include_all_spots
        self.out_annset = out_annset
        self.min_delay_s = min_delay_ms / 1000.0
        self.logger = init_logger()
        # self.logger.setLevel(logging.DEBUG)
        self._last_call_time = 0
        self.ann_type = ann_type
        self.link_pattern = link_pattern

    def __call__(self, doc, **kwargs):
        if &#34;tweet&#34; in kwargs:
            tweet = kwargs[&#34;tweet&#34;]
        else:
            tweet = self.tweet
        delay = time.time() - self._last_call_time
        if delay &lt; self.min_delay_s:
            time.sleep(self.min_delay_s - delay)
        text = doc.text
        hdrs = {
            &#34;Content-Type&#34;: &#34;text/plain; charset=UTF-8&#34;,
            &#34;Accept&#34;: &#34;application/gate+json&#34;,
        }
        params = {
            &#34;text&#34;: text,
            &#34;gcube-token&#34;: self.auth_token,
            &#34;lang&#34;: self.lang,
        }
        if self.include_all_spots:
            params[&#34;include_all_spots&#34;] = &#34;true&#34;
        if tweet:
            params[&#34;tweet&#34;] = &#34;true&#34;
        if self.long_text is not None:
            params[&#34;long_text&#34;] = self.long_text
        if self.epsilon is not None:
            params[&#34;epsilon&#34;] = self.epsilon
        response = requests.post(self.url, params=params, headers=hdrs)
        scode = response.status_code
        if scode != 200:
            raise Exception(f&#34;Something went wrong, received status code {scode}&#34;)
        json = response.json()
        # self.logger.debug(f&#34;Response JSON: {json}&#34;)
        ents = json.get(&#34;annotations&#34;, {})
        annset = doc.annset(self.out_annset)
        om = OffsetMapper(text)
        for ent in ents:
            start = ent[&#34;start&#34;]
            end = ent[&#34;end&#34;]
            start, end = om.convert_to_python([start, end])
            feats = {}
            title = ent.get(&#34;title&#34;)
            if title is not None:
                if self.link_pattern:
                    feats[&#34;url&#34;] = self.link_pattern.format(self.lang, title)
                else:
                    feats[&#34;title&#34;] = title
            for fname in [&#34;id&#34;, &#34;rho&#34;, &#34;link_probability&#34;, &#34;lp&#34;]:
                fval = ent.get(fname)
                if fval is not None:
                    feats[fname] = fval
            # self.logger.debug(f&#34;Adding annotation {start},{end},{feats}&#34;)
            annset.add(start, end, self.ann_type, features=feats)
        return doc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.processing.annotator.Annotator.__call__" href="annotator.html#gatenlp.processing.annotator.Annotator.__call__">__call__</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.finish" href="annotator.html#gatenlp.processing.annotator.Annotator.finish">finish</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.reduce" href="annotator.html#gatenlp.processing.annotator.Annotator.reduce">reduce</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.start" href="annotator.html#gatenlp.processing.annotator.Annotator.start">start</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gatenlp.processing.client.TextRazorTextAnnotator"><code class="flex name class">
<span>class <span class="ident">TextRazorTextAnnotator</span></span>
<span>(</span><span>lang=None, auth_token=None, url=None, extractors=None, out_annset='', min_delay_ms=501)</span>
</code></dt>
<dd>
<div class="desc"><p>An annotator that sends document text to the TextRazor Annotation service (<a href="https://www.textrazor.com/">https://www.textrazor.com/</a>)
and uses the result to annotate the document.</p>
<p>NOTE: this annotator and how it can get parametrized will still change!</p>
<p>Create a TextRazorTextAnnotator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd>if specified, override the auto-detected language of the text</dd>
<dt><strong><code>auth_token</code></strong></dt>
<dd>the authentication token needed to use the service</dd>
<dt><strong><code>url</code></strong></dt>
<dd>the annotation service endpoint, is None, the default endpoint
<a href="https://api.textrazor.com">https://api.textrazor.com</a> is used</dd>
<dt><strong><code>extractors</code></strong></dt>
<dd>a list of extractor names or a string with comma-separated extractor names to add to the
minimum extractors (words, sentences). If None uses words, sentences, entities.
NOTE: currently only words, sentences, entities is supported.!</dd>
<dt><strong><code>out_annset</code></strong></dt>
<dd>the annotationset to put the new annotations in</dd>
<dt><strong><code>min_delay_ms</code></strong></dt>
<dd>minimum time in ms to wait between requests to the server</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextRazorTextAnnotator(Annotator):
    &#34;&#34;&#34;
    An annotator that sends document text to the TextRazor Annotation service (https://www.textrazor.com/)
    and uses the result to annotate the document.

    NOTE: this annotator and how it can get parametrized will still change!
    &#34;&#34;&#34;

    def __init__(
        self,
        lang=None,  # if None/not specified, TextRazor auto-detects
        auth_token=None,
        url=None,  # use default
        extractors=None,
        out_annset=&#34;&#34;,
        min_delay_ms=501,
    ):
        &#34;&#34;&#34;
        Create a TextRazorTextAnnotator.

        Args:
            lang: if specified, override the auto-detected language of the text
            auth_token: the authentication token needed to use the service
            url: the annotation service endpoint, is None, the default endpoint  https://api.textrazor.com is used
            extractors: a list of extractor names or a string with comma-separated extractor names to add to the
               minimum extractors (words, sentences). If None uses words, sentences, entities.
               NOTE: currently only words, sentences, entities is supported.!
            out_annset: the annotationset to put the new annotations in
            min_delay_ms: minimum time in ms to wait between requests to the server
        &#34;&#34;&#34;
        if url is None:
            url = &#34;https://api.textrazor.com&#34;
        self.url = url
        self.lang = lang
        self.out_annset = out_annset
        self.auth_token = auth_token
        self.min_delay_s = min_delay_ms / 1000.0
        self.logger = init_logger()
        self.logger.setLevel(logging.DEBUG)
        self._last_call_time = 0
        if extractors is not None:
            if isinstance(extractors, str):
                extractors = extractors.split(&#34;,&#34;)
            if isinstance(extractors, list):
                allextrs = set()
                allextrs.update(extractors)
                allextrs.update([&#34;words&#34;, &#34;sentences&#34;])
                self.extractors = &#34;,&#34;.join(list(allextrs))
            else:
                raise Exception(&#34;Odd extractors, must be list of strings or string&#34;)
        else:
            self.extractors = &#34;words,sentences,entities&#34;

    def __call__(self, doc, **kwargs):
        delay = time.time() - self._last_call_time
        if delay &lt; self.min_delay_s:
            time.sleep(self.min_delay_s - delay)
        text = doc.text
        hdrs = {
            # &#39;Content-Type&#39;: &#39;text/plain; charset=UTF-8&#39;,
            # &#39;Accept-encoding&#39;: &#39;gzip&#39;  # TODO: to enable compressed responses
            # &#39;Content-encoding&#39;: &#39;gzip&#39;  # TODO: to enable compressed requests
            &#34;X-TextRazor-Key&#34;: self.auth_token
        }
        data = {&#34;text&#34;: text.encode(&#34;UTF-8&#34;)}
        if self.extractors:
            data[&#34;extractors&#34;] = self.extractors
        if self.lang:
            data[&#34;languageOverride&#34;] = self.lang
        self.logger.debug(f&#34;Sending request to {self.url}, data={data}, headers={hdrs}&#34;)
        response = requests.post(
            self.url,
            # params=params,
            data=data,
            headers=hdrs,
        )
        scode = response.status_code
        if scode != 200:
            raise Exception(f&#34;Something went wrong, received status code {scode}&#34;)
        json = response.json()
        ok = json.get(&#34;ok&#34;, False)
        if not ok:
            raise Exception(f&#34;Something went wrong, did not get OK, json: {json}&#34;)
        self.logger.debug(f&#34;Response JSON: {json}&#34;)
        resp = json.get(&#34;response&#34;, {})
        entities = resp.get(&#34;entities&#34;, [])
        sentences = resp.get(&#34;sentences&#34;, [])
        categories = resp.get(&#34;categories&#34;, [])
        topics = resp.get(&#34;topics&#34;, [])
        entailments = resp.get(&#34;entailments&#34;, [])
        relations = resp.get(&#34;relations&#34;, [])
        properties = resp.get(&#34;properties&#34;, [])
        nounphrases = resp.get(&#34;nounPhrases&#34;, [])
        language = resp.get(&#34;language&#34;)
        languageIsReliable = resp.get(&#34;languageIsReliable&#34;)
        tok2off = {}  # maps token idxs to tuples (start,end)
        annset = doc.annset(self.out_annset)
        for s in sentences:
            sentstart = None
            sentend = None
            words = s.get(&#34;words&#34;, [])
            end = None
            for word in words:
                start = word[&#34;startingPos&#34;]
                end = word[&#34;endingPos&#34;]
                if sentstart is None:
                    sentstart = start
                tokidx = word[&#34;position&#34;]
                feats = {}
                feats[&#34;partOfSpeech&#34;] = word[&#34;partOfSpeech&#34;]
                feats[&#34;lemma&#34;] = word[&#34;lemma&#34;]
                if word.get(&#34;stem&#34;):
                    feats[&#34;stem&#34;] = word[&#34;stem&#34;]
                annset.add(start, end, &#34;Token&#34;, features=feats)
                tok2off[tokidx] = (start, end)
            if end is not None:
                sentend = end
            if sentstart is not None and sentend is not None:
                annset.add(sentstart, sentend, &#34;Sentence&#34;)
        for ent in entities:
            feats = {}
            for fname in [
                &#34;wikiLink&#34;,
                &#34;entityEnglishId&#34;,
                &#34;wikidataId&#34;,
                &#34;relevanceScore&#34;,
                &#34;confidenceScore&#34;,
                &#34;type&#34;,
                &#34;freebaseId&#34;,
                &#34;entityId&#34;,
                &#34;freebaseTypes&#34;,
            ]:
                if fname in ent:
                    feats[fname] = ent[fname]
            annset.add(ent[&#34;startingPos&#34;], ent[&#34;endingPos&#34;], &#34;Entity&#34;, feats)
        return doc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.processing.annotator.Annotator" href="annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.processing.annotator.Annotator.__call__" href="annotator.html#gatenlp.processing.annotator.Annotator.__call__">__call__</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.finish" href="annotator.html#gatenlp.processing.annotator.Annotator.finish">finish</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.reduce" href="annotator.html#gatenlp.processing.annotator.Annotator.reduce">reduce</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.start" href="annotator.html#gatenlp.processing.annotator.Annotator.start">start</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.processing" href="index.html">gatenlp.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.processing.client.ElgTextAnnotator" href="#gatenlp.processing.client.ElgTextAnnotator">ElgTextAnnotator</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.processing.client.GateCloudAnnotator" href="#gatenlp.processing.client.GateCloudAnnotator">GateCloudAnnotator</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.processing.client.TagMeAnnotator" href="#gatenlp.processing.client.TagMeAnnotator">TagMeAnnotator</a></code></h4>
</li>
<li>
<h4><code><a title="gatenlp.processing.client.TextRazorTextAnnotator" href="#gatenlp.processing.client.TextRazorTextAnnotator">TextRazorTextAnnotator</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev16+g8c2bb0d.d20201028</a>.</p>
</footer>
</body>
</html>