<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev22+gf4251dd" />
<title>gatenlp.processing.gazetteer.stringgazetteer API documentation</title>
<meta name="description" content="This module provides Gazetteer classes which allow matching the text or the tokens of documents against
gazetteer lists, lists of interesting texts or â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.processing.gazetteer.stringgazetteer</code></h1>
</header>
<section id="section-intro">
<p>This module provides Gazetteer classes which allow matching the text or the tokens of documents against
gazetteer lists, lists of interesting texts or token sequences and annotate the matches with features from the
gazetteer lists.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides Gazetteer classes which allow matching the text or the tokens of documents against
gazetteer lists, lists of interesting texts or token sequences and annotate the matches with features from the
gazetteer lists.
&#34;&#34;&#34;

from recordclass import structclass
from gatenlp.utils import init_logger
from gatenlp.processing.gazetteer.base import GazetteerAnnotator


# TODO: Implement the StringGazetteer!!!!!!!!!!!!!!!!!!!!!!

# NOTE: Match was a dataclass originally
Match = structclass(&#34;Match&#34;, (&#34;start&#34;, &#34;end&#34;, &#34;match&#34;, &#34;entrydata&#34;, &#34;matcherdata&#34;))


_NOVALUE = object()

import sys


class _Node:
    &#34;&#34;&#34;
    Trie Node: represents the value and the children.
    &#34;&#34;&#34;

    __slots__ = (&#34;children&#34;, &#34;value&#34;)

    def __init__(self):
        self.children = dict()
        self.value = _NOVALUE

    # Will get removed or replaced with a proper pretty-printer!
    def debug_print_node(self, file=sys.stderr):
        if self.value == _NOVALUE:
            print(&#34;Node(val=,children=[&#34;, end=&#34;&#34;, file=file)
        else:
            print(f&#34;Node(val={self.value},children=[&#34;, end=&#34;&#34;, file=file)
        for c, n in self.children.items():
            print(f&#34;{c}:&#34;, end=&#34;&#34;, file=file)
            n.print_node()
        print(&#34;])&#34;, end=&#34;&#34;, file=file)


class StringGazetteer(GazetteerAnnotator):
    def __init__(
        self, ignorefunc=None, mapfunc=None, matcherdata=None, defaultdata=None
    ):
        &#34;&#34;&#34;
        NOTE: NOT YET IMPLEMENTED! (code copied from Matcher package, mostly unchanges)

        Create a String Gazetteer.

        Args:
            ignorefunc: a predicate that returns True for any token that should be ignored.
            mapfunc: a function that returns the string to use for each token.
            matcherdata: data to add to all matches in the matcherdata field
            defaultdata: data to add to matches when the entry data is None
        &#34;&#34;&#34;
        # TODO: need to figure out how to handle word boundaries
        # TODO: need to figure out how to handle matching spaces vs. different spaces / no spaces!
        # self.nodes = defaultdict(Node)
        self.ignorefunc = ignorefunc
        self.mapfunc = mapfunc
        self.defaultdata = defaultdata
        self.matcherdata = matcherdata
        self._root = _Node()
        self.logger = init_logger(__name__)
        raise Exception(&#34;Not yet implemented&#34;)

    def add(self, entry, data=None, listdata=None, append=False):
        &#34;&#34;&#34;
        Add a gazetteer entry or several entries if &#34;entry&#34; is iterable and not a string and store its data.
        Note that data has to be a non-None value to indicate that this entry is in the tree (e.g. True).

        If an entry already exists, the data is replaced with the new data unless append is True
        in which case the data is appended to the list of data already there.

        If all elements of the entry are ignored, nothing is done.

        :param entry: a string
        :param data: the data to add for that gazetteer entry.
        :param listdata: the list data to add for that gazeteer entry.
        :param append: if true and data is not None, store data in a list and append any new data
        :return:
        &#34;&#34;&#34;
        if isinstance(entry, str):
            entry = [entry]
        for e in entry:
            node = self._get_node(e, create=True)
            if node == self._root:
                # empty string not allowed
                continue
            if node.value == _NOVALUE:
                if append:
                    node.value = [data]
                else:
                    node.value = data
            else:
                if append:
                    node.value.append(data)
                else:
                    node.value = data

    def find(
        self, text, all=False, skip=True, fromidx=None, toidx=None, matchmaker=None
    ):
        &#34;&#34;&#34;
        Find gazetteer entries in text.
        ignored.
        :param text: string to search
        :param all: return all matches, if False only return longest match
        :param skip: skip forward over longest match (do not return contained/overlapping matches)
        :param fromidx: index where to start finding in tokens
        :param toidx: index where to stop finding in tokens (this is the last index actually used)
        :return: an iterable of Match. The start/end fields of each Match are the character offsets if
        text is a string, otherwise are the token offsets.
        &#34;&#34;&#34;
        matches = []
        lentext = len(text)
        if fromidx is None:
            fromidx = 0
        if toidx is None:
            toidx = lentext - 1
        if fromidx &gt;= lentext:
            return matches
        if toidx &gt;= lentext:
            toidx = lentext - 1
        if fromidx &gt; toidx:
            return matches
        i = fromidx
        self.logger.debug(f&#34;From index {i} to index {toidx} for {text}&#34;)
        while i &lt; toidx:
            chr = text[i]
            if self.ignorefunc and self.ignorefunc(chr):
                i += 1
                continue
            if self.mapfunc:
                chr = self.mapfunc(chr)
            longest_len = 0
            longest_match = None
            node = self._root
            node = node.children.get(chr)
            k = 0
            while node is not None:
                if node.value != _NOVALUE:
                    # we found a match
                    cur_len = k + 1
                    if matchmaker:
                        match = matchmaker(
                            i,
                            i + k + 1,
                            text[i: i + k + 1],
                            node.value,
                            self.matcherdata,
                        )
                    else:
                        match = Match(
                            i,
                            i + k + 1,
                            text[i: i + k + 1],
                            node.value,
                            self.matcherdata,
                        )
                    if all:
                        matches.append(match)
                    else:
                        # NOTE: only one longest match is possible, but it can have a list of data if append=True
                        if cur_len &gt; longest_len:
                            longest_len = cur_len
                            longest_match = match
                while True:
                    k += 1
                    if i + k &gt;= len(text):
                        break
                    chr = text[i + k]
                    if self.ignorefunc and self.ignorefunc(chr):
                        continue
                    if self.mapfunc:
                        chr = self.mapfunc(chr)
                    node = node.children.get(chr)
                    break
                if i + k &gt;= len(text):
                    break
            if not all and longest_match is not None:
                matches.append(longest_match)
            if skip:
                i += max(k, 1)
            else:
                i += 1
        return matches

    def __setitem__(self, key, value):
        node = self._get_node(key, create=True)
        node.value = value

    def __getitem__(self, item):
        node = self._get_node(item, create=False, raise_error=True)
        if node.value == _NOVALUE:
            raise KeyError(item)
        return node.value

    def get(self, item, default=None):
        node = self._get_node(item, create=False, raise_error=False)
        if node is None:
            return default
        if node.value == _NOVALUE:
            return default
        return node.value

    def _get_node(self, item, create=False, raise_error=True):
        &#34;&#34;&#34;
        Returns the node corresponding to the last character in key or raises a KeyError if create is False
        and the node does not exist. If create is True, inserts the node.

        :param item: the key for which to find a node
        :param create: if True, insert all necessary nodes
        :param raise_error: if True and create is False, raises an error if not found, if False, returns None
        :return: the node corresponding to the key or None if no node found and raise_error is False
        &#34;&#34;&#34;
        node = self._root
        for el in item:
            if self.ignorefunc and self.ignorefunc(el):
                continue
            if self.mapfunc:
                el = self.mapfunc(el)
            if create:
                node = node.children.setdefault(el, _Node())
            else:
                node = node.children.get(el)
                if not node:
                    if raise_error:
                        raise KeyError(item)
                    else:
                        return None
        return node</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.processing.gazetteer.stringgazetteer.Match"><code class="flex name class">
<span>class <span class="ident">Match</span></span>
<span>(</span><span>start, end, match, entrydata, matcherdata)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="matchstart-end-match-entrydata-matcherdata">Match(start, end, match, entrydata, matcherdata)</h2>
<p>Create class instance</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>recordclass.datatype.dataobject</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gatenlp.processing.gazetteer.stringgazetteer.Match.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gatenlp.processing.gazetteer.stringgazetteer.Match.entrydata"><code class="name">var <span class="ident">entrydata</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gatenlp.processing.gazetteer.stringgazetteer.Match.match"><code class="name">var <span class="ident">match</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gatenlp.processing.gazetteer.stringgazetteer.Match.matcherdata"><code class="name">var <span class="ident">matcherdata</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gatenlp.processing.gazetteer.stringgazetteer.Match.start"><code class="name">var <span class="ident">start</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer"><code class="flex name class">
<span>class <span class="ident">StringGazetteer</span></span>
<span>(</span><span>ignorefunc=None, mapfunc=None, matcherdata=None, defaultdata=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>NOTE: NOT YET IMPLEMENTED! (code copied from Matcher package, mostly unchanges)</p>
<p>Create a String Gazetteer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ignorefunc</code></strong></dt>
<dd>a predicate that returns True for any token that should be ignored.</dd>
<dt><strong><code>mapfunc</code></strong></dt>
<dd>a function that returns the string to use for each token.</dd>
<dt><strong><code>matcherdata</code></strong></dt>
<dd>data to add to all matches in the matcherdata field</dd>
<dt><strong><code>defaultdata</code></strong></dt>
<dd>data to add to matches when the entry data is None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringGazetteer(GazetteerAnnotator):
    def __init__(
        self, ignorefunc=None, mapfunc=None, matcherdata=None, defaultdata=None
    ):
        &#34;&#34;&#34;
        NOTE: NOT YET IMPLEMENTED! (code copied from Matcher package, mostly unchanges)

        Create a String Gazetteer.

        Args:
            ignorefunc: a predicate that returns True for any token that should be ignored.
            mapfunc: a function that returns the string to use for each token.
            matcherdata: data to add to all matches in the matcherdata field
            defaultdata: data to add to matches when the entry data is None
        &#34;&#34;&#34;
        # TODO: need to figure out how to handle word boundaries
        # TODO: need to figure out how to handle matching spaces vs. different spaces / no spaces!
        # self.nodes = defaultdict(Node)
        self.ignorefunc = ignorefunc
        self.mapfunc = mapfunc
        self.defaultdata = defaultdata
        self.matcherdata = matcherdata
        self._root = _Node()
        self.logger = init_logger(__name__)
        raise Exception(&#34;Not yet implemented&#34;)

    def add(self, entry, data=None, listdata=None, append=False):
        &#34;&#34;&#34;
        Add a gazetteer entry or several entries if &#34;entry&#34; is iterable and not a string and store its data.
        Note that data has to be a non-None value to indicate that this entry is in the tree (e.g. True).

        If an entry already exists, the data is replaced with the new data unless append is True
        in which case the data is appended to the list of data already there.

        If all elements of the entry are ignored, nothing is done.

        :param entry: a string
        :param data: the data to add for that gazetteer entry.
        :param listdata: the list data to add for that gazeteer entry.
        :param append: if true and data is not None, store data in a list and append any new data
        :return:
        &#34;&#34;&#34;
        if isinstance(entry, str):
            entry = [entry]
        for e in entry:
            node = self._get_node(e, create=True)
            if node == self._root:
                # empty string not allowed
                continue
            if node.value == _NOVALUE:
                if append:
                    node.value = [data]
                else:
                    node.value = data
            else:
                if append:
                    node.value.append(data)
                else:
                    node.value = data

    def find(
        self, text, all=False, skip=True, fromidx=None, toidx=None, matchmaker=None
    ):
        &#34;&#34;&#34;
        Find gazetteer entries in text.
        ignored.
        :param text: string to search
        :param all: return all matches, if False only return longest match
        :param skip: skip forward over longest match (do not return contained/overlapping matches)
        :param fromidx: index where to start finding in tokens
        :param toidx: index where to stop finding in tokens (this is the last index actually used)
        :return: an iterable of Match. The start/end fields of each Match are the character offsets if
        text is a string, otherwise are the token offsets.
        &#34;&#34;&#34;
        matches = []
        lentext = len(text)
        if fromidx is None:
            fromidx = 0
        if toidx is None:
            toidx = lentext - 1
        if fromidx &gt;= lentext:
            return matches
        if toidx &gt;= lentext:
            toidx = lentext - 1
        if fromidx &gt; toidx:
            return matches
        i = fromidx
        self.logger.debug(f&#34;From index {i} to index {toidx} for {text}&#34;)
        while i &lt; toidx:
            chr = text[i]
            if self.ignorefunc and self.ignorefunc(chr):
                i += 1
                continue
            if self.mapfunc:
                chr = self.mapfunc(chr)
            longest_len = 0
            longest_match = None
            node = self._root
            node = node.children.get(chr)
            k = 0
            while node is not None:
                if node.value != _NOVALUE:
                    # we found a match
                    cur_len = k + 1
                    if matchmaker:
                        match = matchmaker(
                            i,
                            i + k + 1,
                            text[i: i + k + 1],
                            node.value,
                            self.matcherdata,
                        )
                    else:
                        match = Match(
                            i,
                            i + k + 1,
                            text[i: i + k + 1],
                            node.value,
                            self.matcherdata,
                        )
                    if all:
                        matches.append(match)
                    else:
                        # NOTE: only one longest match is possible, but it can have a list of data if append=True
                        if cur_len &gt; longest_len:
                            longest_len = cur_len
                            longest_match = match
                while True:
                    k += 1
                    if i + k &gt;= len(text):
                        break
                    chr = text[i + k]
                    if self.ignorefunc and self.ignorefunc(chr):
                        continue
                    if self.mapfunc:
                        chr = self.mapfunc(chr)
                    node = node.children.get(chr)
                    break
                if i + k &gt;= len(text):
                    break
            if not all and longest_match is not None:
                matches.append(longest_match)
            if skip:
                i += max(k, 1)
            else:
                i += 1
        return matches

    def __setitem__(self, key, value):
        node = self._get_node(key, create=True)
        node.value = value

    def __getitem__(self, item):
        node = self._get_node(item, create=False, raise_error=True)
        if node.value == _NOVALUE:
            raise KeyError(item)
        return node.value

    def get(self, item, default=None):
        node = self._get_node(item, create=False, raise_error=False)
        if node is None:
            return default
        if node.value == _NOVALUE:
            return default
        return node.value

    def _get_node(self, item, create=False, raise_error=True):
        &#34;&#34;&#34;
        Returns the node corresponding to the last character in key or raises a KeyError if create is False
        and the node does not exist. If create is True, inserts the node.

        :param item: the key for which to find a node
        :param create: if True, insert all necessary nodes
        :param raise_error: if True and create is False, raises an error if not found, if False, returns None
        :return: the node corresponding to the key or None if no node found and raise_error is False
        &#34;&#34;&#34;
        node = self._root
        for el in item:
            if self.ignorefunc and self.ignorefunc(el):
                continue
            if self.mapfunc:
                el = self.mapfunc(el)
            if create:
                node = node.children.setdefault(el, _Node())
            else:
                node = node.children.get(el)
                if not node:
                    if raise_error:
                        raise KeyError(item)
                    else:
                        return None
        return node</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.processing.gazetteer.base.GazetteerAnnotator" href="base.html#gatenlp.processing.gazetteer.base.GazetteerAnnotator">GazetteerAnnotator</a></li>
<li><a title="gatenlp.processing.annotator.Annotator" href="../annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, entry, data=None, listdata=None, append=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a gazetteer entry or several entries if "entry" is iterable and not a string and store its data.
Note that data has to be a non-None value to indicate that this entry is in the tree (e.g. True).</p>
<p>If an entry already exists, the data is replaced with the new data unless append is True
in which case the data is appended to the list of data already there.</p>
<p>If all elements of the entry are ignored, nothing is done.</p>
<p>:param entry: a string
:param data: the data to add for that gazetteer entry.
:param listdata: the list data to add for that gazeteer entry.
:param append: if true and data is not None, store data in a list and append any new data
:return:</p></div>
</dd>
<dt id="gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, text, all=False, skip=True, fromidx=None, toidx=None, matchmaker=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Find gazetteer entries in text.
ignored.
:param text: string to search
:param all: return all matches, if False only return longest match
:param skip: skip forward over longest match (do not return contained/overlapping matches)
:param fromidx: index where to start finding in tokens
:param toidx: index where to stop finding in tokens (this is the last index actually used)
:return: an iterable of Match. The start/end fields of each Match are the character offsets if
text is a string, otherwise are the token offsets.</p></div>
</dd>
<dt id="gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, item, default=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.processing.gazetteer.base.GazetteerAnnotator" href="base.html#gatenlp.processing.gazetteer.base.GazetteerAnnotator">GazetteerAnnotator</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.processing.gazetteer.base.GazetteerAnnotator.__call__" href="../annotator.html#gatenlp.processing.annotator.Annotator.__call__">__call__</a></code></li>
<li><code><a title="gatenlp.processing.gazetteer.base.GazetteerAnnotator.finish" href="../annotator.html#gatenlp.processing.annotator.Annotator.finish">finish</a></code></li>
<li><code><a title="gatenlp.processing.gazetteer.base.GazetteerAnnotator.pipe" href="../annotator.html#gatenlp.processing.annotator.Annotator.pipe">pipe</a></code></li>
<li><code><a title="gatenlp.processing.gazetteer.base.GazetteerAnnotator.reduce" href="../annotator.html#gatenlp.processing.annotator.Annotator.reduce">reduce</a></code></li>
<li><code><a title="gatenlp.processing.gazetteer.base.GazetteerAnnotator.start" href="../annotator.html#gatenlp.processing.annotator.Annotator.start">start</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.processing.gazetteer" href="index.html">gatenlp.processing.gazetteer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.processing.gazetteer.stringgazetteer.Match" href="#gatenlp.processing.gazetteer.stringgazetteer.Match">Match</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.processing.gazetteer.stringgazetteer.Match.end" href="#gatenlp.processing.gazetteer.stringgazetteer.Match.end">end</a></code></li>
<li><code><a title="gatenlp.processing.gazetteer.stringgazetteer.Match.entrydata" href="#gatenlp.processing.gazetteer.stringgazetteer.Match.entrydata">entrydata</a></code></li>
<li><code><a title="gatenlp.processing.gazetteer.stringgazetteer.Match.match" href="#gatenlp.processing.gazetteer.stringgazetteer.Match.match">match</a></code></li>
<li><code><a title="gatenlp.processing.gazetteer.stringgazetteer.Match.matcherdata" href="#gatenlp.processing.gazetteer.stringgazetteer.Match.matcherdata">matcherdata</a></code></li>
<li><code><a title="gatenlp.processing.gazetteer.stringgazetteer.Match.start" href="#gatenlp.processing.gazetteer.stringgazetteer.Match.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer" href="#gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer">StringGazetteer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer.add" href="#gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer.add">add</a></code></li>
<li><code><a title="gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer.find" href="#gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer.find">find</a></code></li>
<li><code><a title="gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer.get" href="#gatenlp.processing.gazetteer.stringgazetteer.StringGazetteer.get">get</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev22+gf4251dd</a>.</p>
</footer>
</body>
</html>