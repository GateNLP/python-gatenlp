<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev16+g8c2bb0d.d20201028" />
<title>gatenlp.serialization.default API documentation</title>
<meta name="description" content="Module that implements the various ways of how to save and load documents and change logs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.serialization.default</code></h1>
</header>
<section id="section-intro">
<p>Module that implements the various ways of how to save and load documents and change logs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that implements the various ways of how to save and load documents and change logs.
&#34;&#34;&#34;
import io
import os
import sys
import json
import yaml
from random import choice
from string import ascii_uppercase
from msgpack import pack, Unpacker
from gatenlp.document import Document
from gatenlp.annotation_set import AnnotationSet
from gatenlp.annotation import Annotation
from gatenlp.changelog import ChangeLog
from gatenlp.features import Features
from gzip import open as gopen, compress, decompress
from pathlib import Path
from urllib.parse import ParseResult
from urllib.request import urlopen
import requests
from bs4 import BeautifulSoup
from gatenlp.gatenlpconfig import gatenlpconfig
import bs4
from bs4 import GuessedAtParserWarning
import warnings

warnings.filterwarnings(&#39;ignore&#39;, category=GuessedAtParserWarning)

# TODO: when loading from a URL, allow for deciding on the format based on the mime type!
# So if we do not have the format, we should get the header for the file, check the mime type and see
# if  we have a loder registered for that and then let the loader do the rest of the work. This may
# need loaders to be able to use an already open stream. 


def is_url(ext):
    &#34;&#34;&#34;
    Returns a tuple (True, urlstring) if ext should be interpreted as a (HTTP(s)) URL, otherwise false, pathstring
    If ext is None, returns None, None.

    Args:
      ext: something that represents an external resource: string, url parse, pathlib path object ...

    Returns:
        a tuple (True, urlstring)  or (False,pathstring)

    &#34;&#34;&#34;
    if ext is None:
        return None, None
    if isinstance(ext, str):
        if ext.startswith(&#34;http://&#34;) or ext.startswith(&#34;https://&#34;):
            return True, ext
        else:
            return False, ext
    elif isinstance(ext, Path):
        return False, str(ext)
    elif isinstance(ext, ParseResult):
        return True, ext.geturl()
    else:
        raise Exception(f&#34;Odd type: {ext}&#34;)


def get_str_from_url(url, encoding=None):
    &#34;&#34;&#34;Read a string from the URL.

    Args:
      url: some URL
      encoding: override the encoding that would have determined automatically (Default value = None)

    Returns:
        the string
    &#34;&#34;&#34;
    req = requests.get(url)
    if encoding is not None:
        req.encoding = encoding
    return req.text


def get_bytes_from_url(url):
    &#34;&#34;&#34;
    Reads bytes from url.

    Args:
      url: the URL

    Returns:
        the bytes
    &#34;&#34;&#34;
    req = requests.get(url)
    return req.content


def read_lines_from(url_or_file, encoding=&#34;utf-8&#34;):
    &#34;&#34;&#34;
    Yields lines of text from either a file or an URL

    Args:
        url_or_file: either a file path or URL. If this is a string, then it is interpreted as an URL
        only if it starts with http:// or https://, otherwise it can be a parsed urllib url or a pathlib path
    &#34;&#34;&#34;
    if is_url(url_or_file):
        for line in urlopen(url_or_file):
            line = line.decode(encoding)
            yield line
    else:
        with open(url_or_file, &#34;rt&#34;, encoding=encoding) as infp:
            for line in infp:
                yield line


class JsonSerializer:
    &#34;&#34;&#34;
    This class performs the saving and load of Documents and ChangeLog instances to and from the
    BDOC JSON format files, optionally with gzip compression.
    &#34;&#34;&#34;

    @staticmethod
    def save(clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: the class of the object that gets saved
          inst: the object to get saved
          to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
          to_mem: if True, return a String serialization
          offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
          offset_mapper: the offset mapper to use, only needed if the type needs to get converted
          gzip: if True, the JSON gets gzip compressed
          **kwargs: 
        &#34;&#34;&#34;
        d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, **kwargs)
        if to_mem:
            if gzip:
                compress(json.dumps(d).encode(&#34;UTF-8&#34;))
            else:
                return json.dumps(d)
        else:
            if gzip:
                with gopen(to_ext, &#34;wt&#34;) as outfp:
                    json.dump(d, outfp)
            else:
                with open(to_ext, &#34;wt&#34;) as outfp:
                    json.dump(d, outfp)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;
        Invokes the save method with gzip=True
        &#34;&#34;&#34;
        JsonSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        # print(&#34;RUNNING load with from_ext=&#34;, from_ext, &#34; from_mem=&#34;, from_mem)

        if from_ext is not None and from_mem is not None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)
        if from_ext is None and from_mem is None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)

        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                # print(&#34;DEBUG: we got a URL&#34;)
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
            else:
                # print(&#34;DEBUG: not a URL !!!&#34;)
                pass
        if from_mem is not None:
            if gzip:
                d = json.loads(decompress(from_mem).decode(&#34;UTF-8&#34;))
            else:
                d = json.loads(from_mem)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        else:  # from_ext must have been not None and a path
            if gzip:
                with gopen(extstr, &#34;rt&#34;) as infp:
                    d = json.load(infp)
            else:
                with open(extstr, &#34;rt&#34;) as infp:
                    d = json.load(infp)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        return JsonSerializer.load(clazz, gzip=True, **kwargs)


class PlainTextSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def save(clazz, inst, to_ext=None, to_mem=None,
             offset_type=None, offset_mapper=None,
             encoding=&#34;UTF-8&#34;,
             gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          inst: 
          to_ext: (Default value = None)
          to_mem: (Default value = None)
          offset_type: (Default value = None)
          offset_mapper: (Default value = None)
          encoding: (Default value = &#34;UTF-8&#34;)
          gzip: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        txt = inst.text
        if txt is None:
            txt = &#34;&#34;
        if to_mem:
            if gzip:
                compress(txt.encode(encoding))
            else:
                return txt
        else:
            if gzip:
                with gopen(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                    outfp.write(txt)
            else:
                with open(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                    outfp.write(txt)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          inst: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        PlainTextSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, offset_mapper=None,
             encoding=&#34;UTF-8&#34;,
             gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          encoding: (Default value = &#34;UTF-8&#34;)
          gzip: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=encoding)
        if from_mem is not None:
            if gzip:
                txt = decompress(from_mem).decode(encoding)
            else:
                txt = from_mem
            doc = Document(txt)
        else:
            if gzip:
                with gopen(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                    txt = infp.read()
            else:
                with open(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                    txt = infp.read()
            doc = Document(txt)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        return PlainTextSerializer.load(clazz, gzip=True, **kwargs)


class YamlSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def save(clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          inst: 
          to_ext: (Default value = None)
          to_mem: (Default value = None)
          offset_type: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, **kwargs)
        if to_mem:
            if gzip:
                compress(yaml.dump(d).encode(&#34;UTF-8&#34;))
            else:
                return yaml.dump(d)
        else:
            if gzip:
                with gopen(to_ext, &#34;wt&#34;) as outfp:
                    yaml.dump(d, outfp)
            else:
                with open(to_ext, &#34;wt&#34;) as outfp:
                    yaml.dump(d, outfp)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          inst: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        YamlSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
        if from_mem is not None:
            if gzip:
                d = yaml.load(decompress(from_mem).decode(&#34;UTF-8&#34;), Loader=yaml.FullLoader)
            else:
                d = yaml.load(from_mem, Loader=yaml.FullLoader)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        else:
            if gzip:
                with gopen(extstr, &#34;rt&#34;) as infp:
                    d = yaml.load(infp, Loader=yaml.FullLoader)
            else:
                with open(extstr, &#34;rt&#34;) as infp:
                    d = yaml.load(infp, Loader=yaml.FullLoader)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        return YamlSerializer.load(clazz, gzip=True, **kwargs)


MSGPACK_VERSION_HDR = &#34;sm2&#34;


class MsgPackSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def document2stream(doc: Document, stream):
        &#34;&#34;&#34;

        Args:
          doc: Document:
          stream: 
          doc: Document: 

        Returns:

        &#34;&#34;&#34;
        pack(MSGPACK_VERSION_HDR, stream)
        pack(doc.offset_type, stream)
        pack(doc.text, stream)
        pack(doc.name, stream)
        pack(doc._features.to_dict(), stream)
        pack(len(doc._annotation_sets), stream)
        for name, annset in doc._annotation_sets.items():
            pack(name, stream)
            pack(annset._next_annid, stream)
            pack(len(annset), stream)
            for ann in annset.fast_iter():
                pack(ann.type, stream)
                pack(ann.start, stream)
                pack(ann.end, stream)
                pack(ann.id, stream)
                pack(ann.features.to_dict(), stream)

    @staticmethod
    def stream2document(stream):
        &#34;&#34;&#34;

        Args:
          stream: 

        Returns:

        &#34;&#34;&#34;
        u = Unpacker(stream)
        version = u.unpack()
        if version != MSGPACK_VERSION_HDR:
            raise Exception(&#34;MsgPack data starts with wrong version&#34;)
        doc = Document()
        doc.offset_type = u.unpack()
        doc._text = u.unpack()
        doc.name = u.unpack()
        doc._features = Features(u.unpack())
        nsets = u.unpack()
        setsdict = dict()
        doc.annotation_sets = setsdict
        for iset in range(nsets):
            sname = u.unpack()
            if sname is None:
                sname = &#34;&#34;
            annset = AnnotationSet(name=sname, owner_doc=doc)
            annset._next_annid = u.unpack()
            nanns = u.unpack()
            for iann in range(nanns):
                atype = u.unpack()
                astart = u.unpack()
                aend = u.unpack()
                aid = u.unpack()
                afeatures = u.unpack()
                ann = Annotation(astart, aend, atype, annid=aid, features=afeatures)
                annset._annotations[aid] = ann
            setsdict[sname] = annset
        doc._annotation_sets = setsdict
        return doc

    @staticmethod
    def save(clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          inst: 
          to_ext: (Default value = None)
          to_mem: (Default value = None)
          offset_type: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        if isinstance(inst, Document):
            writer = MsgPackSerializer.document2stream
        elif isinstance(inst, ChangeLog):
            raise Exception(&#34;Not implemented yet&#34;)
        else:
            raise Exception(&#34;Object not supported&#34;)
        if to_mem:
            f = io.BytesIO()
        else:
            f = open(to_ext, &#34;wb&#34;)
        writer(inst, f)
        if to_mem:
            return f.getvalue()
        else:
            f.close()

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        if clazz == Document:
            reader = MsgPackSerializer.stream2document
        elif clazz == ChangeLog:
            raise Exception(&#34;Not implemented yet&#34;)
        else:
            raise Exception(&#34;Object not supported&#34;)

        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                from_mem = get_bytes_from_url(extstr)
        if from_mem:
            f = io.BytesIO(from_mem)
        else:
            f = open(extstr, &#34;rb&#34;)
        doc = reader(f)
        return doc

JS_JQUERY = &#39;&lt;script src=&#34;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js&#34;&gt;&lt;/script&gt;&#39;
JS_GATENLP = &#39;&lt;script src=&#34;https://unpkg.com/gatenlp-ann-viewer@1.0.11/gatenlp-ann-viewer.js&#34;&gt;&lt;/script&gt;&#39;
HTML_TEMPLATE_FILE_NAME = &#34;gatenlp-ann-viewer.html&#34;
JS_GATENLP_FILE_NAME = &#34;gatenlp-ann-viewer-merged.js&#34;

html_ann_viewer_serializer_js_loaded = False


class HtmlAnnViewerSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def save(clazz, inst, to_ext=None, to_mem=None, notebook=False, offline=False,
             htmlid=None, **kwargs):
        &#34;&#34;&#34;Convert a document to HTML for visualizing it.

        Args:
          clazz: param inst:
          to_ext: param to_mem: (Default value = None)
          notebook: param offline: (Default value = False)
          htmlid: the id to use for HTML ids so it is possible to style the output
        from a separate notebook cell. (Default value = None)
          kwargs: return:
          inst: 
          to_mem: (Default value = None)
          offline: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        if not isinstance(inst, Document):
            raise Exception(&#34;Not a document!&#34;)
        doccopy = inst.deepcopy()
        doccopy.to_offset_type(&#34;j&#34;)
        json = doccopy.save_mem(fmt=&#34;json&#34;)
        htmlloc = os.path.join(os.path.dirname(__file__), &#34;_htmlviewer&#34;, HTML_TEMPLATE_FILE_NAME)
        if not os.path.exists(htmlloc):
            raise Exception(&#34;Could not find HTML template, {} does not exist&#34;.format(htmlloc))
        with open(htmlloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
            html = infp.read();
        txtcolor = gatenlpconfig.doc_html_repr_txtcolor
        if notebook:
            str_start = &#34;&lt;!--STARTDIV--&gt;&#34;
            str_end = &#34;&lt;!--ENDDIV--&gt;&#34;
            idx1 = html.find(str_start) + len(str_start)
            idx2 = html.find(str_end)
            if htmlid:
                rndpref = str(htmlid)
            else:
                rndpref = &#34;&#34;.join(choice(ascii_uppercase) for i in range(10))
            html = html[idx1:idx2]
            html = f&#34;&#34;&#34;&lt;div&gt;&lt;style&gt;#{rndpref}-wrapper {{ color: {txtcolor} !important; }}&lt;/style&gt;
&lt;div id=&#34;{rndpref}-wrapper&#34;&gt;
{html}
&lt;/div&gt;&lt;/div&gt;&#34;&#34;&#34;
            # replace the prefix with a random one
            html = html.replace(&#34;GATENLPID&#34;, rndpref)
        if offline:
            global html_ann_viewer_serializer_js_loaded
            if not html_ann_viewer_serializer_js_loaded:
                jsloc = os.path.join(os.path.dirname(__file__), &#34;_htmlviewer&#34;, JS_GATENLP_FILE_NAME)
                if not os.path.exists(jsloc):
                    raise Exception(&#34;Could not find JavsScript file, {} does not exist&#34;.format(jsloc))
                with open(jsloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
                    js = infp.read();
                    js = &#34;&#34;&#34;&lt;script type=&#34;text/javascript&#34;&gt;&#34;&#34;&#34; + js + &#34;&lt;/script&gt;&#34;
                html_ann_viewer_serializer_js_loaded = True
            else:
                js = &#34;&#34;
        else:
            js = JS_JQUERY + JS_GATENLP
        html = html.replace(&#34;$$JAVASCRIPT$$&#34;, js, 1).replace(&#34;$$JSONDATA$$&#34;, json, 1)
        if to_mem:
            return html
        else:
            with open(to_ext, &#34;wt&#34;, encoding=&#34;utf-8&#34;) as outfp:
                outfp.write(html)


class HtmlLoader:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def load_rendered(clazz, from_ext=None, from_mem=None, parser=None, markup_set_name=&#34;Original markups&#34;,
             process_soup=None, offset_mapper=None, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          parser: (Default value = None)
          markup_set_name: (Default value = &#34;Original markups&#34;)
          process_soup: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        raise Exception(&#34;Rendered html parser not yet implemented&#34;)

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, parser=None, markup_set_name=&#34;Original markups&#34;,
             process_soup=None, offset_mapper=None, **kwargs):
        &#34;&#34;&#34;Load a HTML file.

        Args:
          clazz: param from_ext:
          from_mem: param parser: one of &#34;html.parser&#34;, &#34;lxml&#34;, &#34;lxml-xml&#34;, &#34;html5lib&#34; (default is &#34;lxml&#34;)
          markup_set_name: the annotation set name for the set to contain the HTML annotations (Default value = &#34;Original markups&#34;)
          process_soup: a function to run on the parsed HTML soup before converting (Default value = None)
          offset_mapper: param kwargs: (Default value = None)
          from_ext: (Default value = None)
          parser: (Default value = None)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        # NOTE: for now we have a simple heuristic for adding newlines to the text:
        # before and after a block element, a newline is added unless there is already one
        # NOTE: for now we use  multi_valued_attributes=None which prevents attributes of the
        # form &#34;class=&#39;val1 val2&#39;&#34; to get converted into features with a list of values.
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                from_mem = get_str_from_url(extstr)
        if from_mem:
            bs = BeautifulSoup(from_mem, parser,  multi_valued_attributes=None)
        else:
            bs = BeautifulSoup(extstr, parser,  multi_valued_attributes=None)
        # we recursively iterate the tree depth first, going through the children
        # and adding to a list that either contains the text or a dict with the information
        # about annotations we want to add
        nlels = {
            &#34;pre&#34;, &#34;br&#34;, &#34;p&#34;, &#34;div&#34;, &#34;tr&#34;, &#34;h1&#34;, &#34;h2&#34;, &#34;h3&#34;, &#34;h4&#34;, &#34;h5&#34;, &#34;h6&#34;, &#34;li&#34;,
            &#34;address&#34;, &#34;article&#34;, &#34;aside&#34;, &#34;blockquote&#34;, &#34;del&#34;, &#34;figure&#34;, &#34;figcaption&#34;,
            &#34;footer&#34;, &#34;header&#34;, &#34;hr&#34;, &#34;ins&#34;, &#34;main&#34;, &#34;nav&#34;, &#34;section&#34;, &#34;summary&#34;, &#34;input&#34;, &#34;legend&#34;,
            &#34;option&#34;, &#34;textarea&#34;, &#34;bdi&#34;, &#34;bdo&#34;, &#34;center&#34;, &#34;code&#34;, &#34;dfn&#34;, &#34;menu&#34;, &#34;dir&#34;, &#34;caption&#34;,
        }
        ignoreels = {
            &#34;script&#34;, &#34;style&#34;
        }
        docinfo = {&#34;anninfos&#34;: [], &#34;curoffset&#34;: 0, &#34;curid&#34;: 0, &#34;text&#34;: &#34;&#34;}
        def walktree(el):
            &#34;&#34;&#34;

            Args:
              el: 

            Returns:

            &#34;&#34;&#34;
            #print(&#34;DEBUG: type=&#34;, type(el))
            if isinstance(el, bs4.element.Doctype):
                # print(&#34;DEBUG: got doctype&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Comment):
                # print(&#34;DEBUG: got Comment&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Script):
                # print(&#34;DEBUG: got Script&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Tag):
                # print(&#34;DEBUG: got tag: &#34;, type(el), &#34; name=&#34;,el.name)
                # some tags we ignore completely:
                if el.name in ignoreels:
                    return
                # for some tags we insert a new line before, but only if we do not already have one
                if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and \
                        el.name in nlels:
                    docinfo[&#34;text&#34;] += &#34;\n&#34;
                    # print(&#34;DEBUG: adding newline before at &#34;, docinfo[&#34;curoffset&#34;])
                    docinfo[&#34;curoffset&#34;] += 1
                ann = {&#34;type&#34;: el.name, &#34;features&#34;: el.attrs,
                       &#34;id&#34;: docinfo[&#34;curid&#34;], &#34;event&#34;: &#34;start&#34;, &#34;start&#34;: docinfo[&#34;curoffset&#34;]}
                thisid = docinfo[&#34;curid&#34;]
                docinfo[&#34;anninfos&#34;].append(ann)
                docinfo[&#34;curid&#34;] += 1
                for child in el.children:
                    walktree(child)
                # for some tags we insert a new line after
                if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and \
                        el.name in nlels:
                    docinfo[&#34;text&#34;] += &#34;\n&#34;
                    # print(&#34;DEBUG: adding newline after at &#34;, docinfo[&#34;curoffset&#34;])
                    docinfo[&#34;curoffset&#34;] += 1
                docinfo[&#34;anninfos&#34;].append({&#34;event&#34;: &#34;end&#34;, &#34;id&#34;: thisid, &#34;end&#34;: docinfo[&#34;curoffset&#34;]})
            elif isinstance(el, bs4.element.NavigableString):
                # print(&#34;DEBUG: got text: &#34;, el)
                text = str(el)
                if text == &#34;\n&#34; and docinfo[&#34;text&#34;].endswith(&#34;\n&#34;):
                    return
                docinfo[&#34;text&#34;] += text
                docinfo[&#34;curoffset&#34;] += len(el)
            else:
                print(&#34;WARNING: odd element type&#34;, type(el))
        walktree(bs)
        # need to add the end corresponding to bs
        # print(&#34;DEBUG: got docinfo:\n&#34;,docinfo)
        id2anninfo = {}  # from id to anninfo
        nstart = 0
        for anninfo in docinfo[&#34;anninfos&#34;]:
            if anninfo[&#34;event&#34;] == &#34;start&#34;:
                nstart += 1
                id2anninfo[anninfo[&#34;id&#34;]] = anninfo
        nend = 0
        for anninfo in docinfo[&#34;anninfos&#34;]:
            if anninfo[&#34;event&#34;] == &#34;end&#34;:
                nend += 1
                end = anninfo[&#34;end&#34;]
                annid = anninfo[&#34;id&#34;]
                anninfo = id2anninfo[annid]
                anninfo[&#34;end&#34;] = end
        # print(&#34;DEBUG: got nstart/nend&#34;, nstart, nend)
        assert nstart == nend
        # print(&#34;DEBUG: got id2anninfo:\n&#34;, id2anninfo)
        doc = Document(docinfo[&#34;text&#34;])
        annset = doc.annset(markup_set_name)
        for i in range(nstart):
            anninfo = id2anninfo[i]
            annset.add(start=anninfo[&#34;start&#34;], end=anninfo[&#34;end&#34;], anntype=anninfo[&#34;type&#34;],
                       features=anninfo[&#34;features&#34;])
        return doc


class GateXmlLoader:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def value4objectwrapper(text):
        &#34;&#34;&#34;This may one day convert things like lists, maps, shared objects to Python, but for
        now we always throw an exeption.

        Args:
          text: return:

        Returns:

        &#34;&#34;&#34;
        raise Exception(&#34;Cannot load GATE XML which contains gate.corpora.ObjectWrapper data&#34;)

    @staticmethod
    def load(clazz, from_ext=None, ignore_unknown_types=False):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          ignore_unknown_types: (Default value = False)

        Returns:

        &#34;&#34;&#34;
        # TODO: the code below is just an outline and needs work!
        # TODO: make use of the test document created in repo project-python-gatenlp
        import xml.etree.ElementTree as ET
        isurl, extstr = is_url(from_ext)
        if isurl:
            xmlstring = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
            root = ET.fromstring(xmlstring)
        else:
            tree = ET.parse(extstr)
            root = tree.getroot()

        # or: root = ET.fromstring(xmlstring)

        # check we do have a GATE document

        assert root.tag == &#34;GateDocument&#34;
        assert root.attrib == {&#34;version&#34;: &#34;3&#34;}

        def parsefeatures(feats):
            &#34;&#34;&#34;

            Args:
              feats: 

            Returns:

            &#34;&#34;&#34;
            features = {}
            for feat in list(feats):
                name = None
                value = None
                for el in list(feat):
                    if el.tag == &#34;Name&#34;:
                        if el.get(&#34;className&#34;) == &#34;java.lang.String&#34;:
                            name = el.text
                        else:
                            raise Exception(&#34;Odd Feature Name type: &#34; + el.get(&#34;className&#34;))
                    elif el.tag == &#34;Value&#34;:
                        cls_name = el.get(&#34;className&#34;)
                        if cls_name == &#34;java.lang.String&#34;:
                            value = el.text
                        elif cls_name == &#34;java.lang.Integer&#34;:
                            value = int(el.text)
                        elif cls_name == &#34;java.lang.Long&#34;:
                            value = int(el.text)
                        elif cls_name == &#34;java.math.BigDecimal&#34;:
                            value = float(el.text)
                        elif cls_name == &#34;java.lang.Boolean&#34;:
                            value = bool(el.text)
                        #elif cls_name == &#34;gate.corpora.ObjectWrapper&#34;:
                        #    value = GateXmlLoader.value4objectwrapper(el.text)
                        else:
                            if ignore_unknown_types:
                                print(f&#34;Warning: ignoring feature with serialization type: {cls_name}&#34;, file=sys.stderr)
                            else:
                                raise Exception(&#34;Unsupported serialization type: &#34; + el.get(&#34;className&#34;))
                if name is not None and value is not None:
                    features[name] = value
            return features

        # get the document features
        docfeatures = {}
        feats = root.findall(&#34;./GateDocumentFeatures/Feature&#34;)

        docfeatures = parsefeatures(feats)

        textwithnodes = root.findall(&#34;./TextWithNodes&#34;)
        text = &#34;&#34;
        node2offset = {}
        curoff = 0
        for item in textwithnodes:
            if item.text:
                print(&#34;Got item text: &#34;, item.text)
                text += item.text
                # TODO HTML unescape item text
                curoff += len(item.text)
            for node in item:
                nodeid = node.get(&#34;id&#34;)
                node2offset[nodeid] = curoff
                if node.tail:
                    # TODO: unescape item.text?
                    print(&#34;Gote node tail: &#34;, node.tail)
                    text += node.tail
                    curoff += len(node.tail)

        annsets = root.findall(&#34;./AnnotationSet&#34;)

        annotation_sets = {}  # map name - set
        for annset in annsets:
            if annset.get(&#34;Name&#34;):
                setname = annset.get(&#34;Name&#34;)
            else:
                setname = &#34;&#34;
            annots = annset.findall(&#34;./Annotation&#34;)
            annotations = []
            maxannid = 0
            for ann in annots:
                annid = int(ann.attrib[&#34;Id&#34;])
                maxannid = max(maxannid, annid)
                anntype = ann.attrib[&#34;Type&#34;]
                startnode = ann.attrib[&#34;StartNode&#34;]
                endnode = ann.attrib[&#34;EndNode&#34;]
                startoff = node2offset[startnode]
                endoff = node2offset[endnode]
                feats = ann.findall(&#34;./Feature&#34;)
                features = parsefeatures(feats)
                if len(features) == 0:
                    features = None
                annotation = {&#34;id&#34;: annid, &#34;type&#34;: anntype, &#34;start&#34;: startoff, &#34;end&#34;: endoff,
                              &#34;features&#34;: features}
                annotations.append(annotation)
            annset = {&#34;name&#34;: setname, &#34;annotations&#34;: annotations, &#34;next_annid&#34;: maxannid + 1}
            annotation_sets[setname] = annset

        docmap = {&#34;text&#34;: text, &#34;features&#34;: docfeatures, &#34;offset_type&#34;: &#34;p&#34;,
                  &#34;annotation_sets&#34;: annotation_sets}

        doc = Document.from_dict(docmap)
        return doc


def determine_loader(clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      gzip: (Default value = False)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    first = None
    if from_mem:
        first = from_mem[0]
    else:
        with open(from_ext, &#34;rt&#34;) as infp:
            first = infp.read(1)
    if first == &#34;{&#34;:
        return JsonSerializer.load(clazz, from_ext=from_ext, from_mem=from_mem, offset_mapper=offset_mapper,
                            gzip=gzip, **kwargs)
    else:
        return MsgPackSerializer.load(clazz, from_ext=from_ext, from_mem=from_mem, offset_mapper=offset_mapper,
                            gzip=gzip, **kwargs)


DOCUMENT_SAVERS = {
    &#34;text/plain&#34;: PlainTextSerializer.save,
    &#34;text/plain+gzip&#34;: PlainTextSerializer.save_gzip,
    &#34;text&#34;: PlainTextSerializer.save,

    &#34;json&#34;: JsonSerializer.save,
    &#34;jsongz&#34;: JsonSerializer.save_gzip,
    &#34;bdocjs&#34;: JsonSerializer.save,
    &#34;bdocjsgz&#34;: JsonSerializer.save_gzip,
    &#34;text/bdocjs&#34;: JsonSerializer.save,
    &#34;text/bdocjs+gzip&#34;: JsonSerializer.save_gzip,

    &#34;yaml&#34;: YamlSerializer.save,
    &#34;yamlgz&#34;: YamlSerializer.save_gzip,
    &#34;text/bdocym&#34;: YamlSerializer.save,
    &#34;text/bdocym+gzip+&#34;: YamlSerializer.save_gzip,

    &#34;msgpack&#34;: MsgPackSerializer.save,
    &#34;bdocmp&#34;: MsgPackSerializer.save,
    &#34;text/bdocmp&#34;: MsgPackSerializer.save,
    &#34;application/msgpack&#34;: MsgPackSerializer.save,

    &#34;html-ann-viewer&#34;: HtmlAnnViewerSerializer.save,
}
DOCUMENT_LOADERS = {
    &#34;json&#34;: JsonSerializer.load,
    &#34;jsongz&#34;: JsonSerializer.load_gzip,
    &#34;bdocjs&#34;: JsonSerializer.load,
    &#34;bdocjsgz&#34;: JsonSerializer.load_gzip,
    &#34;text/bdocjs&#34;: JsonSerializer.load,
    &#34;text/bdocjs+gzip&#34;: JsonSerializer.load_gzip,

    &#34;yaml&#34;: YamlSerializer.load,
    &#34;yamlgz&#34;: YamlSerializer.load_gzip,
    &#34;bdocym&#34;: YamlSerializer.load,
    &#34;bdocymzg: &#34;: YamlSerializer.load_gzip,
    &#34;text/bdocym&#34;: YamlSerializer.load,
    &#34;text/bdocym+gzip&#34;: YamlSerializer.load_gzip,

    &#34;msgpack&#34;: MsgPackSerializer.load,
    &#34;bdocmp&#34;: MsgPackSerializer.load,
    &#34;application/msgpack&#34;: MsgPackSerializer.load,
    &#34;text/bdocmp&#34;: MsgPackSerializer.load,

    &#34;jsonormsgpack&#34;: determine_loader,
    &#34;text/plain&#34;: PlainTextSerializer.load,
    &#34;text/plain+gzip&#34;: PlainTextSerializer.load_gzip,
    &#34;text&#34;: PlainTextSerializer.load,
    &#34;text/html&#34;: HtmlLoader.load,
    &#34;html&#34;: HtmlLoader.load,
    &#34;html-rendered&#34;: HtmlLoader.load_rendered,
    &#34;gatexml&#34;: GateXmlLoader.load,
}
CHANGELOG_SAVERS = {
    &#34;json&#34;: JsonSerializer.save,
    &#34;text/bdocjs+gzip&#34;: JsonSerializer.save_gzip,
    &#34;text/bdocjs&#34;: JsonSerializer.save,
}
CHANGELOG_LOADERS = {
    &#34;json&#34;: JsonSerializer.load,
    &#34;text/bdocjs+gzip&#34;: JsonSerializer.load_gzip,
    &#34;text/bdocjs&#34;: JsonSerializer.load,
}

# map extensions to document types
EXTENSIONS = {
    &#34;bdocjs&#34;: &#34;json&#34;,
    &#34;bdocym&#34;: &#34;yaml&#34;,
    &#34;bdocym.gz&#34;: &#34;text/bdocym+gzip&#34;,
    &#34;bdoc.gz&#34;: &#34;text/bdocjs+gzip&#34;, # lets assume it is compressed json
    &#34;bdoc&#34;: &#34;jsonormsgpack&#34;,
    &#34;bdocjs.gz&#34;: &#34;text/bdocjs+gzip&#34;,
    &#34;bdocjson&#34;: &#34;json&#34;,
    &#34;bdocmp&#34;: &#34;msgpack&#34;,
    &#34;txt&#34;: &#34;text/plain&#34;,
    &#34;txt.gz&#34;: &#34;text/plain+gzip&#34;,
    &#34;html&#34;: &#34;text/html&#34;,
    &#34;htm&#34;: &#34;text/html&#34;,
}


def get_handler(filespec, fmt, handlers, saveload, what):
    &#34;&#34;&#34;

    Args:
      filespec: 
      fmt: 
      handlers: 
      saveload: 
      what: 

    Returns:

    &#34;&#34;&#34;
    msg = f&#34;Could not determine how to {saveload} {what} for format {fmt} in module gatenlp.serialization.default&#34;
    if fmt:
        handler = handlers.get(fmt)
        if not handler:
            raise Exception(msg)
        return handler
    else:
        if not filespec: # in case of save_mem
            raise Exception(msg)
        if isinstance(filespec, os.PathLike):
            wf = os.fspath(filespec)
        elif isinstance(filespec, str):
            wf = filespec
        else:
            raise Exception(msg)
        name, ext = os.path.splitext(wf)
        if ext == &#34;.gz&#34;:
            ext2 = os.path.splitext(name)[1]
            if ext2:
                ext2 = ext2[1:]
            ext = ext2 + ext
        elif ext:
            ext = ext[1:]
        fmt = EXTENSIONS.get(ext)
        msg = f&#34;Could not determine how to {saveload} {what} for format {fmt} and with extension {ext} in module gatenlp.serialization.default&#34;
        if not fmt:
            raise Exception(msg)
        handler = handlers.get(fmt)
        if not handler:
            raise Exception(msg)
        return handler


def get_document_saver(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec: 
      fmt: 

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, DOCUMENT_SAVERS, &#34;save&#34;, &#34;document&#34;)


def get_document_loader(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec: 
      fmt: 

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, DOCUMENT_LOADERS, &#34;load&#34;, &#34;document&#34;)


def get_changelog_saver(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec: 
      fmt: 

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, CHANGELOG_SAVERS, &#34;save&#34;, &#34;changelog&#34;)


def get_changelog_loader(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec: 
      fmt: 

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, CHANGELOG_LOADERS, &#34;load&#34;, &#34;changelog&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gatenlp.serialization.default.determine_loader"><code class="name flex">
<span>def <span class="ident">determine_loader</span></span>(<span>clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_loader(clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      gzip: (Default value = False)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    first = None
    if from_mem:
        first = from_mem[0]
    else:
        with open(from_ext, &#34;rt&#34;) as infp:
            first = infp.read(1)
    if first == &#34;{&#34;:
        return JsonSerializer.load(clazz, from_ext=from_ext, from_mem=from_mem, offset_mapper=offset_mapper,
                            gzip=gzip, **kwargs)
    else:
        return MsgPackSerializer.load(clazz, from_ext=from_ext, from_mem=from_mem, offset_mapper=offset_mapper,
                            gzip=gzip, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_bytes_from_url"><code class="name flex">
<span>def <span class="ident">get_bytes_from_url</span></span>(<span>url)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads bytes from url.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong></dt>
<dd>the URL</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bytes_from_url(url):
    &#34;&#34;&#34;
    Reads bytes from url.

    Args:
      url: the URL

    Returns:
        the bytes
    &#34;&#34;&#34;
    req = requests.get(url)
    return req.content</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_changelog_loader"><code class="name flex">
<span>def <span class="ident">get_changelog_loader</span></span>(<span>filespec, fmt)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>filespec</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_changelog_loader(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec: 
      fmt: 

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, CHANGELOG_LOADERS, &#34;load&#34;, &#34;changelog&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_changelog_saver"><code class="name flex">
<span>def <span class="ident">get_changelog_saver</span></span>(<span>filespec, fmt)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>filespec</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_changelog_saver(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec: 
      fmt: 

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, CHANGELOG_SAVERS, &#34;save&#34;, &#34;changelog&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_document_loader"><code class="name flex">
<span>def <span class="ident">get_document_loader</span></span>(<span>filespec, fmt)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>filespec</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_document_loader(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec: 
      fmt: 

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, DOCUMENT_LOADERS, &#34;load&#34;, &#34;document&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_document_saver"><code class="name flex">
<span>def <span class="ident">get_document_saver</span></span>(<span>filespec, fmt)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>filespec</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_document_saver(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec: 
      fmt: 

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, DOCUMENT_SAVERS, &#34;save&#34;, &#34;document&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_handler"><code class="name flex">
<span>def <span class="ident">get_handler</span></span>(<span>filespec, fmt, handlers, saveload, what)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>filespec</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>handlers</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>saveload</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>what</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_handler(filespec, fmt, handlers, saveload, what):
    &#34;&#34;&#34;

    Args:
      filespec: 
      fmt: 
      handlers: 
      saveload: 
      what: 

    Returns:

    &#34;&#34;&#34;
    msg = f&#34;Could not determine how to {saveload} {what} for format {fmt} in module gatenlp.serialization.default&#34;
    if fmt:
        handler = handlers.get(fmt)
        if not handler:
            raise Exception(msg)
        return handler
    else:
        if not filespec: # in case of save_mem
            raise Exception(msg)
        if isinstance(filespec, os.PathLike):
            wf = os.fspath(filespec)
        elif isinstance(filespec, str):
            wf = filespec
        else:
            raise Exception(msg)
        name, ext = os.path.splitext(wf)
        if ext == &#34;.gz&#34;:
            ext2 = os.path.splitext(name)[1]
            if ext2:
                ext2 = ext2[1:]
            ext = ext2 + ext
        elif ext:
            ext = ext[1:]
        fmt = EXTENSIONS.get(ext)
        msg = f&#34;Could not determine how to {saveload} {what} for format {fmt} and with extension {ext} in module gatenlp.serialization.default&#34;
        if not fmt:
            raise Exception(msg)
        handler = handlers.get(fmt)
        if not handler:
            raise Exception(msg)
        return handler</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_str_from_url"><code class="name flex">
<span>def <span class="ident">get_str_from_url</span></span>(<span>url, encoding=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a string from the URL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong></dt>
<dd>some URL</dd>
<dt><strong><code>encoding</code></strong></dt>
<dd>override the encoding that would have determined automatically (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_str_from_url(url, encoding=None):
    &#34;&#34;&#34;Read a string from the URL.

    Args:
      url: some URL
      encoding: override the encoding that would have determined automatically (Default value = None)

    Returns:
        the string
    &#34;&#34;&#34;
    req = requests.get(url)
    if encoding is not None:
        req.encoding = encoding
    return req.text</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.is_url"><code class="name flex">
<span>def <span class="ident">is_url</span></span>(<span>ext)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple (True, urlstring) if ext should be interpreted as a (HTTP(s)) URL, otherwise false, pathstring
If ext is None, returns None, None.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ext</code></strong></dt>
<dd>something that represents an external resource: string, url parse, pathlib path object &hellip;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple (True, urlstring)
or (False,pathstring)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_url(ext):
    &#34;&#34;&#34;
    Returns a tuple (True, urlstring) if ext should be interpreted as a (HTTP(s)) URL, otherwise false, pathstring
    If ext is None, returns None, None.

    Args:
      ext: something that represents an external resource: string, url parse, pathlib path object ...

    Returns:
        a tuple (True, urlstring)  or (False,pathstring)

    &#34;&#34;&#34;
    if ext is None:
        return None, None
    if isinstance(ext, str):
        if ext.startswith(&#34;http://&#34;) or ext.startswith(&#34;https://&#34;):
            return True, ext
        else:
            return False, ext
    elif isinstance(ext, Path):
        return False, str(ext)
    elif isinstance(ext, ParseResult):
        return True, ext.geturl()
    else:
        raise Exception(f&#34;Odd type: {ext}&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.read_lines_from"><code class="name flex">
<span>def <span class="ident">read_lines_from</span></span>(<span>url_or_file, encoding='utf-8')</span>
</code></dt>
<dd>
<div class="desc"><p>Yields lines of text from either a file or an URL</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url_or_file</code></strong></dt>
<dd>either a file path or URL. If this is a string, then it is interpreted as an URL</dd>
</dl>
<p>only if it starts with http:// or <a href="https://,">https://,</a> otherwise it can be a parsed urllib url or a pathlib path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_lines_from(url_or_file, encoding=&#34;utf-8&#34;):
    &#34;&#34;&#34;
    Yields lines of text from either a file or an URL

    Args:
        url_or_file: either a file path or URL. If this is a string, then it is interpreted as an URL
        only if it starts with http:// or https://, otherwise it can be a parsed urllib url or a pathlib path
    &#34;&#34;&#34;
    if is_url(url_or_file):
        for line in urlopen(url_or_file):
            line = line.decode(encoding)
            yield line
    else:
        with open(url_or_file, &#34;rt&#34;, encoding=encoding) as infp:
            for line in infp:
                yield line</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.serialization.default.GateXmlLoader"><code class="flex name class">
<span>class <span class="ident">GateXmlLoader</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GateXmlLoader:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def value4objectwrapper(text):
        &#34;&#34;&#34;This may one day convert things like lists, maps, shared objects to Python, but for
        now we always throw an exeption.

        Args:
          text: return:

        Returns:

        &#34;&#34;&#34;
        raise Exception(&#34;Cannot load GATE XML which contains gate.corpora.ObjectWrapper data&#34;)

    @staticmethod
    def load(clazz, from_ext=None, ignore_unknown_types=False):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          ignore_unknown_types: (Default value = False)

        Returns:

        &#34;&#34;&#34;
        # TODO: the code below is just an outline and needs work!
        # TODO: make use of the test document created in repo project-python-gatenlp
        import xml.etree.ElementTree as ET
        isurl, extstr = is_url(from_ext)
        if isurl:
            xmlstring = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
            root = ET.fromstring(xmlstring)
        else:
            tree = ET.parse(extstr)
            root = tree.getroot()

        # or: root = ET.fromstring(xmlstring)

        # check we do have a GATE document

        assert root.tag == &#34;GateDocument&#34;
        assert root.attrib == {&#34;version&#34;: &#34;3&#34;}

        def parsefeatures(feats):
            &#34;&#34;&#34;

            Args:
              feats: 

            Returns:

            &#34;&#34;&#34;
            features = {}
            for feat in list(feats):
                name = None
                value = None
                for el in list(feat):
                    if el.tag == &#34;Name&#34;:
                        if el.get(&#34;className&#34;) == &#34;java.lang.String&#34;:
                            name = el.text
                        else:
                            raise Exception(&#34;Odd Feature Name type: &#34; + el.get(&#34;className&#34;))
                    elif el.tag == &#34;Value&#34;:
                        cls_name = el.get(&#34;className&#34;)
                        if cls_name == &#34;java.lang.String&#34;:
                            value = el.text
                        elif cls_name == &#34;java.lang.Integer&#34;:
                            value = int(el.text)
                        elif cls_name == &#34;java.lang.Long&#34;:
                            value = int(el.text)
                        elif cls_name == &#34;java.math.BigDecimal&#34;:
                            value = float(el.text)
                        elif cls_name == &#34;java.lang.Boolean&#34;:
                            value = bool(el.text)
                        #elif cls_name == &#34;gate.corpora.ObjectWrapper&#34;:
                        #    value = GateXmlLoader.value4objectwrapper(el.text)
                        else:
                            if ignore_unknown_types:
                                print(f&#34;Warning: ignoring feature with serialization type: {cls_name}&#34;, file=sys.stderr)
                            else:
                                raise Exception(&#34;Unsupported serialization type: &#34; + el.get(&#34;className&#34;))
                if name is not None and value is not None:
                    features[name] = value
            return features

        # get the document features
        docfeatures = {}
        feats = root.findall(&#34;./GateDocumentFeatures/Feature&#34;)

        docfeatures = parsefeatures(feats)

        textwithnodes = root.findall(&#34;./TextWithNodes&#34;)
        text = &#34;&#34;
        node2offset = {}
        curoff = 0
        for item in textwithnodes:
            if item.text:
                print(&#34;Got item text: &#34;, item.text)
                text += item.text
                # TODO HTML unescape item text
                curoff += len(item.text)
            for node in item:
                nodeid = node.get(&#34;id&#34;)
                node2offset[nodeid] = curoff
                if node.tail:
                    # TODO: unescape item.text?
                    print(&#34;Gote node tail: &#34;, node.tail)
                    text += node.tail
                    curoff += len(node.tail)

        annsets = root.findall(&#34;./AnnotationSet&#34;)

        annotation_sets = {}  # map name - set
        for annset in annsets:
            if annset.get(&#34;Name&#34;):
                setname = annset.get(&#34;Name&#34;)
            else:
                setname = &#34;&#34;
            annots = annset.findall(&#34;./Annotation&#34;)
            annotations = []
            maxannid = 0
            for ann in annots:
                annid = int(ann.attrib[&#34;Id&#34;])
                maxannid = max(maxannid, annid)
                anntype = ann.attrib[&#34;Type&#34;]
                startnode = ann.attrib[&#34;StartNode&#34;]
                endnode = ann.attrib[&#34;EndNode&#34;]
                startoff = node2offset[startnode]
                endoff = node2offset[endnode]
                feats = ann.findall(&#34;./Feature&#34;)
                features = parsefeatures(feats)
                if len(features) == 0:
                    features = None
                annotation = {&#34;id&#34;: annid, &#34;type&#34;: anntype, &#34;start&#34;: startoff, &#34;end&#34;: endoff,
                              &#34;features&#34;: features}
                annotations.append(annotation)
            annset = {&#34;name&#34;: setname, &#34;annotations&#34;: annotations, &#34;next_annid&#34;: maxannid + 1}
            annotation_sets[setname] = annset

        docmap = {&#34;text&#34;: text, &#34;features&#34;: docfeatures, &#34;offset_type&#34;: &#34;p&#34;,
                  &#34;annotation_sets&#34;: annotation_sets}

        doc = Document.from_dict(docmap)
        return doc</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.GateXmlLoader.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, ignore_unknown_types=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>ignore_unknown_types</code></strong></dt>
<dd>(Default value = False)</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(clazz, from_ext=None, ignore_unknown_types=False):
    &#34;&#34;&#34;

    Args:
      clazz: 
      from_ext: (Default value = None)
      ignore_unknown_types: (Default value = False)

    Returns:

    &#34;&#34;&#34;
    # TODO: the code below is just an outline and needs work!
    # TODO: make use of the test document created in repo project-python-gatenlp
    import xml.etree.ElementTree as ET
    isurl, extstr = is_url(from_ext)
    if isurl:
        xmlstring = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
        root = ET.fromstring(xmlstring)
    else:
        tree = ET.parse(extstr)
        root = tree.getroot()

    # or: root = ET.fromstring(xmlstring)

    # check we do have a GATE document

    assert root.tag == &#34;GateDocument&#34;
    assert root.attrib == {&#34;version&#34;: &#34;3&#34;}

    def parsefeatures(feats):
        &#34;&#34;&#34;

        Args:
          feats: 

        Returns:

        &#34;&#34;&#34;
        features = {}
        for feat in list(feats):
            name = None
            value = None
            for el in list(feat):
                if el.tag == &#34;Name&#34;:
                    if el.get(&#34;className&#34;) == &#34;java.lang.String&#34;:
                        name = el.text
                    else:
                        raise Exception(&#34;Odd Feature Name type: &#34; + el.get(&#34;className&#34;))
                elif el.tag == &#34;Value&#34;:
                    cls_name = el.get(&#34;className&#34;)
                    if cls_name == &#34;java.lang.String&#34;:
                        value = el.text
                    elif cls_name == &#34;java.lang.Integer&#34;:
                        value = int(el.text)
                    elif cls_name == &#34;java.lang.Long&#34;:
                        value = int(el.text)
                    elif cls_name == &#34;java.math.BigDecimal&#34;:
                        value = float(el.text)
                    elif cls_name == &#34;java.lang.Boolean&#34;:
                        value = bool(el.text)
                    #elif cls_name == &#34;gate.corpora.ObjectWrapper&#34;:
                    #    value = GateXmlLoader.value4objectwrapper(el.text)
                    else:
                        if ignore_unknown_types:
                            print(f&#34;Warning: ignoring feature with serialization type: {cls_name}&#34;, file=sys.stderr)
                        else:
                            raise Exception(&#34;Unsupported serialization type: &#34; + el.get(&#34;className&#34;))
            if name is not None and value is not None:
                features[name] = value
        return features

    # get the document features
    docfeatures = {}
    feats = root.findall(&#34;./GateDocumentFeatures/Feature&#34;)

    docfeatures = parsefeatures(feats)

    textwithnodes = root.findall(&#34;./TextWithNodes&#34;)
    text = &#34;&#34;
    node2offset = {}
    curoff = 0
    for item in textwithnodes:
        if item.text:
            print(&#34;Got item text: &#34;, item.text)
            text += item.text
            # TODO HTML unescape item text
            curoff += len(item.text)
        for node in item:
            nodeid = node.get(&#34;id&#34;)
            node2offset[nodeid] = curoff
            if node.tail:
                # TODO: unescape item.text?
                print(&#34;Gote node tail: &#34;, node.tail)
                text += node.tail
                curoff += len(node.tail)

    annsets = root.findall(&#34;./AnnotationSet&#34;)

    annotation_sets = {}  # map name - set
    for annset in annsets:
        if annset.get(&#34;Name&#34;):
            setname = annset.get(&#34;Name&#34;)
        else:
            setname = &#34;&#34;
        annots = annset.findall(&#34;./Annotation&#34;)
        annotations = []
        maxannid = 0
        for ann in annots:
            annid = int(ann.attrib[&#34;Id&#34;])
            maxannid = max(maxannid, annid)
            anntype = ann.attrib[&#34;Type&#34;]
            startnode = ann.attrib[&#34;StartNode&#34;]
            endnode = ann.attrib[&#34;EndNode&#34;]
            startoff = node2offset[startnode]
            endoff = node2offset[endnode]
            feats = ann.findall(&#34;./Feature&#34;)
            features = parsefeatures(feats)
            if len(features) == 0:
                features = None
            annotation = {&#34;id&#34;: annid, &#34;type&#34;: anntype, &#34;start&#34;: startoff, &#34;end&#34;: endoff,
                          &#34;features&#34;: features}
            annotations.append(annotation)
        annset = {&#34;name&#34;: setname, &#34;annotations&#34;: annotations, &#34;next_annid&#34;: maxannid + 1}
        annotation_sets[setname] = annset

    docmap = {&#34;text&#34;: text, &#34;features&#34;: docfeatures, &#34;offset_type&#34;: &#34;p&#34;,
              &#34;annotation_sets&#34;: annotation_sets}

    doc = Document.from_dict(docmap)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.GateXmlLoader.value4objectwrapper"><code class="name flex">
<span>def <span class="ident">value4objectwrapper</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>This may one day convert things like lists, maps, shared objects to Python, but for
now we always throw an exeption.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>return:</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def value4objectwrapper(text):
    &#34;&#34;&#34;This may one day convert things like lists, maps, shared objects to Python, but for
    now we always throw an exeption.

    Args:
      text: return:

    Returns:

    &#34;&#34;&#34;
    raise Exception(&#34;Cannot load GATE XML which contains gate.corpora.ObjectWrapper data&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.HtmlAnnViewerSerializer"><code class="flex name class">
<span>class <span class="ident">HtmlAnnViewerSerializer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HtmlAnnViewerSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def save(clazz, inst, to_ext=None, to_mem=None, notebook=False, offline=False,
             htmlid=None, **kwargs):
        &#34;&#34;&#34;Convert a document to HTML for visualizing it.

        Args:
          clazz: param inst:
          to_ext: param to_mem: (Default value = None)
          notebook: param offline: (Default value = False)
          htmlid: the id to use for HTML ids so it is possible to style the output
        from a separate notebook cell. (Default value = None)
          kwargs: return:
          inst: 
          to_mem: (Default value = None)
          offline: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        if not isinstance(inst, Document):
            raise Exception(&#34;Not a document!&#34;)
        doccopy = inst.deepcopy()
        doccopy.to_offset_type(&#34;j&#34;)
        json = doccopy.save_mem(fmt=&#34;json&#34;)
        htmlloc = os.path.join(os.path.dirname(__file__), &#34;_htmlviewer&#34;, HTML_TEMPLATE_FILE_NAME)
        if not os.path.exists(htmlloc):
            raise Exception(&#34;Could not find HTML template, {} does not exist&#34;.format(htmlloc))
        with open(htmlloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
            html = infp.read();
        txtcolor = gatenlpconfig.doc_html_repr_txtcolor
        if notebook:
            str_start = &#34;&lt;!--STARTDIV--&gt;&#34;
            str_end = &#34;&lt;!--ENDDIV--&gt;&#34;
            idx1 = html.find(str_start) + len(str_start)
            idx2 = html.find(str_end)
            if htmlid:
                rndpref = str(htmlid)
            else:
                rndpref = &#34;&#34;.join(choice(ascii_uppercase) for i in range(10))
            html = html[idx1:idx2]
            html = f&#34;&#34;&#34;&lt;div&gt;&lt;style&gt;#{rndpref}-wrapper {{ color: {txtcolor} !important; }}&lt;/style&gt;
&lt;div id=&#34;{rndpref}-wrapper&#34;&gt;
{html}
&lt;/div&gt;&lt;/div&gt;&#34;&#34;&#34;
            # replace the prefix with a random one
            html = html.replace(&#34;GATENLPID&#34;, rndpref)
        if offline:
            global html_ann_viewer_serializer_js_loaded
            if not html_ann_viewer_serializer_js_loaded:
                jsloc = os.path.join(os.path.dirname(__file__), &#34;_htmlviewer&#34;, JS_GATENLP_FILE_NAME)
                if not os.path.exists(jsloc):
                    raise Exception(&#34;Could not find JavsScript file, {} does not exist&#34;.format(jsloc))
                with open(jsloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
                    js = infp.read();
                    js = &#34;&#34;&#34;&lt;script type=&#34;text/javascript&#34;&gt;&#34;&#34;&#34; + js + &#34;&lt;/script&gt;&#34;
                html_ann_viewer_serializer_js_loaded = True
            else:
                js = &#34;&#34;
        else:
            js = JS_JQUERY + JS_GATENLP
        html = html.replace(&#34;$$JAVASCRIPT$$&#34;, js, 1).replace(&#34;$$JSONDATA$$&#34;, json, 1)
        if to_mem:
            return html
        else:
            with open(to_ext, &#34;wt&#34;, encoding=&#34;utf-8&#34;) as outfp:
                outfp.write(html)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.HtmlAnnViewerSerializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, notebook=False, offline=False, htmlid=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a document to HTML for visualizing it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>param inst:</dd>
<dt><strong><code>to_ext</code></strong></dt>
<dd>param to_mem: (Default value = None)</dd>
<dt><strong><code>notebook</code></strong></dt>
<dd>param offline: (Default value = False)</dd>
<dt><strong><code>htmlid</code></strong></dt>
<dd>the id to use for HTML ids so it is possible to style the output</dd>
</dl>
<p>from a separate notebook cell. (Default value = None)
kwargs: return:
inst:
to_mem: (Default value = None)
offline: (Default value = False)
**kwargs: </p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @staticmethod
    def save(clazz, inst, to_ext=None, to_mem=None, notebook=False, offline=False,
             htmlid=None, **kwargs):
        &#34;&#34;&#34;Convert a document to HTML for visualizing it.

        Args:
          clazz: param inst:
          to_ext: param to_mem: (Default value = None)
          notebook: param offline: (Default value = False)
          htmlid: the id to use for HTML ids so it is possible to style the output
        from a separate notebook cell. (Default value = None)
          kwargs: return:
          inst: 
          to_mem: (Default value = None)
          offline: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        if not isinstance(inst, Document):
            raise Exception(&#34;Not a document!&#34;)
        doccopy = inst.deepcopy()
        doccopy.to_offset_type(&#34;j&#34;)
        json = doccopy.save_mem(fmt=&#34;json&#34;)
        htmlloc = os.path.join(os.path.dirname(__file__), &#34;_htmlviewer&#34;, HTML_TEMPLATE_FILE_NAME)
        if not os.path.exists(htmlloc):
            raise Exception(&#34;Could not find HTML template, {} does not exist&#34;.format(htmlloc))
        with open(htmlloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
            html = infp.read();
        txtcolor = gatenlpconfig.doc_html_repr_txtcolor
        if notebook:
            str_start = &#34;&lt;!--STARTDIV--&gt;&#34;
            str_end = &#34;&lt;!--ENDDIV--&gt;&#34;
            idx1 = html.find(str_start) + len(str_start)
            idx2 = html.find(str_end)
            if htmlid:
                rndpref = str(htmlid)
            else:
                rndpref = &#34;&#34;.join(choice(ascii_uppercase) for i in range(10))
            html = html[idx1:idx2]
            html = f&#34;&#34;&#34;&lt;div&gt;&lt;style&gt;#{rndpref}-wrapper {{ color: {txtcolor} !important; }}&lt;/style&gt;
&lt;div id=&#34;{rndpref}-wrapper&#34;&gt;
{html}
&lt;/div&gt;&lt;/div&gt;&#34;&#34;&#34;
            # replace the prefix with a random one
            html = html.replace(&#34;GATENLPID&#34;, rndpref)
        if offline:
            global html_ann_viewer_serializer_js_loaded
            if not html_ann_viewer_serializer_js_loaded:
                jsloc = os.path.join(os.path.dirname(__file__), &#34;_htmlviewer&#34;, JS_GATENLP_FILE_NAME)
                if not os.path.exists(jsloc):
                    raise Exception(&#34;Could not find JavsScript file, {} does not exist&#34;.format(jsloc))
                with open(jsloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
                    js = infp.read();
                    js = &#34;&#34;&#34;&lt;script type=&#34;text/javascript&#34;&gt;&#34;&#34;&#34; + js + &#34;&lt;/script&gt;&#34;
                html_ann_viewer_serializer_js_loaded = True
            else:
                js = &#34;&#34;
        else:
            js = JS_JQUERY + JS_GATENLP
        html = html.replace(&#34;$$JAVASCRIPT$$&#34;, js, 1).replace(&#34;$$JSONDATA$$&#34;, json, 1)
        if to_mem:
            return html
        else:
            with open(to_ext, &#34;wt&#34;, encoding=&#34;utf-8&#34;) as outfp:
                outfp.write(html)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.HtmlLoader"><code class="flex name class">
<span>class <span class="ident">HtmlLoader</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HtmlLoader:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def load_rendered(clazz, from_ext=None, from_mem=None, parser=None, markup_set_name=&#34;Original markups&#34;,
             process_soup=None, offset_mapper=None, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          parser: (Default value = None)
          markup_set_name: (Default value = &#34;Original markups&#34;)
          process_soup: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        raise Exception(&#34;Rendered html parser not yet implemented&#34;)

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, parser=None, markup_set_name=&#34;Original markups&#34;,
             process_soup=None, offset_mapper=None, **kwargs):
        &#34;&#34;&#34;Load a HTML file.

        Args:
          clazz: param from_ext:
          from_mem: param parser: one of &#34;html.parser&#34;, &#34;lxml&#34;, &#34;lxml-xml&#34;, &#34;html5lib&#34; (default is &#34;lxml&#34;)
          markup_set_name: the annotation set name for the set to contain the HTML annotations (Default value = &#34;Original markups&#34;)
          process_soup: a function to run on the parsed HTML soup before converting (Default value = None)
          offset_mapper: param kwargs: (Default value = None)
          from_ext: (Default value = None)
          parser: (Default value = None)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        # NOTE: for now we have a simple heuristic for adding newlines to the text:
        # before and after a block element, a newline is added unless there is already one
        # NOTE: for now we use  multi_valued_attributes=None which prevents attributes of the
        # form &#34;class=&#39;val1 val2&#39;&#34; to get converted into features with a list of values.
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                from_mem = get_str_from_url(extstr)
        if from_mem:
            bs = BeautifulSoup(from_mem, parser,  multi_valued_attributes=None)
        else:
            bs = BeautifulSoup(extstr, parser,  multi_valued_attributes=None)
        # we recursively iterate the tree depth first, going through the children
        # and adding to a list that either contains the text or a dict with the information
        # about annotations we want to add
        nlels = {
            &#34;pre&#34;, &#34;br&#34;, &#34;p&#34;, &#34;div&#34;, &#34;tr&#34;, &#34;h1&#34;, &#34;h2&#34;, &#34;h3&#34;, &#34;h4&#34;, &#34;h5&#34;, &#34;h6&#34;, &#34;li&#34;,
            &#34;address&#34;, &#34;article&#34;, &#34;aside&#34;, &#34;blockquote&#34;, &#34;del&#34;, &#34;figure&#34;, &#34;figcaption&#34;,
            &#34;footer&#34;, &#34;header&#34;, &#34;hr&#34;, &#34;ins&#34;, &#34;main&#34;, &#34;nav&#34;, &#34;section&#34;, &#34;summary&#34;, &#34;input&#34;, &#34;legend&#34;,
            &#34;option&#34;, &#34;textarea&#34;, &#34;bdi&#34;, &#34;bdo&#34;, &#34;center&#34;, &#34;code&#34;, &#34;dfn&#34;, &#34;menu&#34;, &#34;dir&#34;, &#34;caption&#34;,
        }
        ignoreels = {
            &#34;script&#34;, &#34;style&#34;
        }
        docinfo = {&#34;anninfos&#34;: [], &#34;curoffset&#34;: 0, &#34;curid&#34;: 0, &#34;text&#34;: &#34;&#34;}
        def walktree(el):
            &#34;&#34;&#34;

            Args:
              el: 

            Returns:

            &#34;&#34;&#34;
            #print(&#34;DEBUG: type=&#34;, type(el))
            if isinstance(el, bs4.element.Doctype):
                # print(&#34;DEBUG: got doctype&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Comment):
                # print(&#34;DEBUG: got Comment&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Script):
                # print(&#34;DEBUG: got Script&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Tag):
                # print(&#34;DEBUG: got tag: &#34;, type(el), &#34; name=&#34;,el.name)
                # some tags we ignore completely:
                if el.name in ignoreels:
                    return
                # for some tags we insert a new line before, but only if we do not already have one
                if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and \
                        el.name in nlels:
                    docinfo[&#34;text&#34;] += &#34;\n&#34;
                    # print(&#34;DEBUG: adding newline before at &#34;, docinfo[&#34;curoffset&#34;])
                    docinfo[&#34;curoffset&#34;] += 1
                ann = {&#34;type&#34;: el.name, &#34;features&#34;: el.attrs,
                       &#34;id&#34;: docinfo[&#34;curid&#34;], &#34;event&#34;: &#34;start&#34;, &#34;start&#34;: docinfo[&#34;curoffset&#34;]}
                thisid = docinfo[&#34;curid&#34;]
                docinfo[&#34;anninfos&#34;].append(ann)
                docinfo[&#34;curid&#34;] += 1
                for child in el.children:
                    walktree(child)
                # for some tags we insert a new line after
                if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and \
                        el.name in nlels:
                    docinfo[&#34;text&#34;] += &#34;\n&#34;
                    # print(&#34;DEBUG: adding newline after at &#34;, docinfo[&#34;curoffset&#34;])
                    docinfo[&#34;curoffset&#34;] += 1
                docinfo[&#34;anninfos&#34;].append({&#34;event&#34;: &#34;end&#34;, &#34;id&#34;: thisid, &#34;end&#34;: docinfo[&#34;curoffset&#34;]})
            elif isinstance(el, bs4.element.NavigableString):
                # print(&#34;DEBUG: got text: &#34;, el)
                text = str(el)
                if text == &#34;\n&#34; and docinfo[&#34;text&#34;].endswith(&#34;\n&#34;):
                    return
                docinfo[&#34;text&#34;] += text
                docinfo[&#34;curoffset&#34;] += len(el)
            else:
                print(&#34;WARNING: odd element type&#34;, type(el))
        walktree(bs)
        # need to add the end corresponding to bs
        # print(&#34;DEBUG: got docinfo:\n&#34;,docinfo)
        id2anninfo = {}  # from id to anninfo
        nstart = 0
        for anninfo in docinfo[&#34;anninfos&#34;]:
            if anninfo[&#34;event&#34;] == &#34;start&#34;:
                nstart += 1
                id2anninfo[anninfo[&#34;id&#34;]] = anninfo
        nend = 0
        for anninfo in docinfo[&#34;anninfos&#34;]:
            if anninfo[&#34;event&#34;] == &#34;end&#34;:
                nend += 1
                end = anninfo[&#34;end&#34;]
                annid = anninfo[&#34;id&#34;]
                anninfo = id2anninfo[annid]
                anninfo[&#34;end&#34;] = end
        # print(&#34;DEBUG: got nstart/nend&#34;, nstart, nend)
        assert nstart == nend
        # print(&#34;DEBUG: got id2anninfo:\n&#34;, id2anninfo)
        doc = Document(docinfo[&#34;text&#34;])
        annset = doc.annset(markup_set_name)
        for i in range(nstart):
            anninfo = id2anninfo[i]
            annset.add(start=anninfo[&#34;start&#34;], end=anninfo[&#34;end&#34;], anntype=anninfo[&#34;type&#34;],
                       features=anninfo[&#34;features&#34;])
        return doc</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.HtmlLoader.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, parser=None, markup_set_name='Original markups', process_soup=None, offset_mapper=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a HTML file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>param from_ext:</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>param parser: one of "html.parser", "lxml", "lxml-xml", "html5lib" (default is "lxml")</dd>
<dt><strong><code>markup_set_name</code></strong></dt>
<dd>the annotation set name for the set to contain the HTML annotations (Default value = "Original markups")</dd>
<dt><strong><code>process_soup</code></strong></dt>
<dd>a function to run on the parsed HTML soup before converting (Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>param kwargs: (Default value = None)</dd>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>parser</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(clazz, from_ext=None, from_mem=None, parser=None, markup_set_name=&#34;Original markups&#34;,
         process_soup=None, offset_mapper=None, **kwargs):
    &#34;&#34;&#34;Load a HTML file.

    Args:
      clazz: param from_ext:
      from_mem: param parser: one of &#34;html.parser&#34;, &#34;lxml&#34;, &#34;lxml-xml&#34;, &#34;html5lib&#34; (default is &#34;lxml&#34;)
      markup_set_name: the annotation set name for the set to contain the HTML annotations (Default value = &#34;Original markups&#34;)
      process_soup: a function to run on the parsed HTML soup before converting (Default value = None)
      offset_mapper: param kwargs: (Default value = None)
      from_ext: (Default value = None)
      parser: (Default value = None)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    # NOTE: for now we have a simple heuristic for adding newlines to the text:
    # before and after a block element, a newline is added unless there is already one
    # NOTE: for now we use  multi_valued_attributes=None which prevents attributes of the
    # form &#34;class=&#39;val1 val2&#39;&#34; to get converted into features with a list of values.
    isurl, extstr = is_url(from_ext)
    if from_ext is not None:
        if isurl:
            from_mem = get_str_from_url(extstr)
    if from_mem:
        bs = BeautifulSoup(from_mem, parser,  multi_valued_attributes=None)
    else:
        bs = BeautifulSoup(extstr, parser,  multi_valued_attributes=None)
    # we recursively iterate the tree depth first, going through the children
    # and adding to a list that either contains the text or a dict with the information
    # about annotations we want to add
    nlels = {
        &#34;pre&#34;, &#34;br&#34;, &#34;p&#34;, &#34;div&#34;, &#34;tr&#34;, &#34;h1&#34;, &#34;h2&#34;, &#34;h3&#34;, &#34;h4&#34;, &#34;h5&#34;, &#34;h6&#34;, &#34;li&#34;,
        &#34;address&#34;, &#34;article&#34;, &#34;aside&#34;, &#34;blockquote&#34;, &#34;del&#34;, &#34;figure&#34;, &#34;figcaption&#34;,
        &#34;footer&#34;, &#34;header&#34;, &#34;hr&#34;, &#34;ins&#34;, &#34;main&#34;, &#34;nav&#34;, &#34;section&#34;, &#34;summary&#34;, &#34;input&#34;, &#34;legend&#34;,
        &#34;option&#34;, &#34;textarea&#34;, &#34;bdi&#34;, &#34;bdo&#34;, &#34;center&#34;, &#34;code&#34;, &#34;dfn&#34;, &#34;menu&#34;, &#34;dir&#34;, &#34;caption&#34;,
    }
    ignoreels = {
        &#34;script&#34;, &#34;style&#34;
    }
    docinfo = {&#34;anninfos&#34;: [], &#34;curoffset&#34;: 0, &#34;curid&#34;: 0, &#34;text&#34;: &#34;&#34;}
    def walktree(el):
        &#34;&#34;&#34;

        Args:
          el: 

        Returns:

        &#34;&#34;&#34;
        #print(&#34;DEBUG: type=&#34;, type(el))
        if isinstance(el, bs4.element.Doctype):
            # print(&#34;DEBUG: got doctype&#34;, type(el))
            pass
        elif isinstance(el, bs4.element.Comment):
            # print(&#34;DEBUG: got Comment&#34;, type(el))
            pass
        elif isinstance(el, bs4.element.Script):
            # print(&#34;DEBUG: got Script&#34;, type(el))
            pass
        elif isinstance(el, bs4.element.Tag):
            # print(&#34;DEBUG: got tag: &#34;, type(el), &#34; name=&#34;,el.name)
            # some tags we ignore completely:
            if el.name in ignoreels:
                return
            # for some tags we insert a new line before, but only if we do not already have one
            if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and \
                    el.name in nlels:
                docinfo[&#34;text&#34;] += &#34;\n&#34;
                # print(&#34;DEBUG: adding newline before at &#34;, docinfo[&#34;curoffset&#34;])
                docinfo[&#34;curoffset&#34;] += 1
            ann = {&#34;type&#34;: el.name, &#34;features&#34;: el.attrs,
                   &#34;id&#34;: docinfo[&#34;curid&#34;], &#34;event&#34;: &#34;start&#34;, &#34;start&#34;: docinfo[&#34;curoffset&#34;]}
            thisid = docinfo[&#34;curid&#34;]
            docinfo[&#34;anninfos&#34;].append(ann)
            docinfo[&#34;curid&#34;] += 1
            for child in el.children:
                walktree(child)
            # for some tags we insert a new line after
            if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and \
                    el.name in nlels:
                docinfo[&#34;text&#34;] += &#34;\n&#34;
                # print(&#34;DEBUG: adding newline after at &#34;, docinfo[&#34;curoffset&#34;])
                docinfo[&#34;curoffset&#34;] += 1
            docinfo[&#34;anninfos&#34;].append({&#34;event&#34;: &#34;end&#34;, &#34;id&#34;: thisid, &#34;end&#34;: docinfo[&#34;curoffset&#34;]})
        elif isinstance(el, bs4.element.NavigableString):
            # print(&#34;DEBUG: got text: &#34;, el)
            text = str(el)
            if text == &#34;\n&#34; and docinfo[&#34;text&#34;].endswith(&#34;\n&#34;):
                return
            docinfo[&#34;text&#34;] += text
            docinfo[&#34;curoffset&#34;] += len(el)
        else:
            print(&#34;WARNING: odd element type&#34;, type(el))
    walktree(bs)
    # need to add the end corresponding to bs
    # print(&#34;DEBUG: got docinfo:\n&#34;,docinfo)
    id2anninfo = {}  # from id to anninfo
    nstart = 0
    for anninfo in docinfo[&#34;anninfos&#34;]:
        if anninfo[&#34;event&#34;] == &#34;start&#34;:
            nstart += 1
            id2anninfo[anninfo[&#34;id&#34;]] = anninfo
    nend = 0
    for anninfo in docinfo[&#34;anninfos&#34;]:
        if anninfo[&#34;event&#34;] == &#34;end&#34;:
            nend += 1
            end = anninfo[&#34;end&#34;]
            annid = anninfo[&#34;id&#34;]
            anninfo = id2anninfo[annid]
            anninfo[&#34;end&#34;] = end
    # print(&#34;DEBUG: got nstart/nend&#34;, nstart, nend)
    assert nstart == nend
    # print(&#34;DEBUG: got id2anninfo:\n&#34;, id2anninfo)
    doc = Document(docinfo[&#34;text&#34;])
    annset = doc.annset(markup_set_name)
    for i in range(nstart):
        anninfo = id2anninfo[i]
        annset.add(start=anninfo[&#34;start&#34;], end=anninfo[&#34;end&#34;], anntype=anninfo[&#34;type&#34;],
                   features=anninfo[&#34;features&#34;])
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.HtmlLoader.load_rendered"><code class="name flex">
<span>def <span class="ident">load_rendered</span></span>(<span>clazz, from_ext=None, from_mem=None, parser=None, markup_set_name='Original markups', process_soup=None, offset_mapper=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>parser</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>markup_set_name</code></strong></dt>
<dd>(Default value = "Original markups")</dd>
<dt><strong><code>process_soup</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_rendered(clazz, from_ext=None, from_mem=None, parser=None, markup_set_name=&#34;Original markups&#34;,
         process_soup=None, offset_mapper=None, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      parser: (Default value = None)
      markup_set_name: (Default value = &#34;Original markups&#34;)
      process_soup: (Default value = None)
      offset_mapper: (Default value = None)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    raise Exception(&#34;Rendered html parser not yet implemented&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.JsonSerializer"><code class="flex name class">
<span>class <span class="ident">JsonSerializer</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class performs the saving and load of Documents and ChangeLog instances to and from the
BDOC JSON format files, optionally with gzip compression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JsonSerializer:
    &#34;&#34;&#34;
    This class performs the saving and load of Documents and ChangeLog instances to and from the
    BDOC JSON format files, optionally with gzip compression.
    &#34;&#34;&#34;

    @staticmethod
    def save(clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: the class of the object that gets saved
          inst: the object to get saved
          to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
          to_mem: if True, return a String serialization
          offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
          offset_mapper: the offset mapper to use, only needed if the type needs to get converted
          gzip: if True, the JSON gets gzip compressed
          **kwargs: 
        &#34;&#34;&#34;
        d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, **kwargs)
        if to_mem:
            if gzip:
                compress(json.dumps(d).encode(&#34;UTF-8&#34;))
            else:
                return json.dumps(d)
        else:
            if gzip:
                with gopen(to_ext, &#34;wt&#34;) as outfp:
                    json.dump(d, outfp)
            else:
                with open(to_ext, &#34;wt&#34;) as outfp:
                    json.dump(d, outfp)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;
        Invokes the save method with gzip=True
        &#34;&#34;&#34;
        JsonSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        # print(&#34;RUNNING load with from_ext=&#34;, from_ext, &#34; from_mem=&#34;, from_mem)

        if from_ext is not None and from_mem is not None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)
        if from_ext is None and from_mem is None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)

        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                # print(&#34;DEBUG: we got a URL&#34;)
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
            else:
                # print(&#34;DEBUG: not a URL !!!&#34;)
                pass
        if from_mem is not None:
            if gzip:
                d = json.loads(decompress(from_mem).decode(&#34;UTF-8&#34;))
            else:
                d = json.loads(from_mem)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        else:  # from_ext must have been not None and a path
            if gzip:
                with gopen(extstr, &#34;rt&#34;) as infp:
                    d = json.load(infp)
            else:
                with open(extstr, &#34;rt&#34;) as infp:
                    d = json.load(infp)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        return JsonSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.JsonSerializer.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      gzip: (Default value = False)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    # print(&#34;RUNNING load with from_ext=&#34;, from_ext, &#34; from_mem=&#34;, from_mem)

    if from_ext is not None and from_mem is not None:
        raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)
    if from_ext is None and from_mem is None:
        raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)

    isurl, extstr = is_url(from_ext)
    if from_ext is not None:
        if isurl:
            # print(&#34;DEBUG: we got a URL&#34;)
            if gzip:
                from_mem = get_bytes_from_url(extstr)
            else:
                from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
        else:
            # print(&#34;DEBUG: not a URL !!!&#34;)
            pass
    if from_mem is not None:
        if gzip:
            d = json.loads(decompress(from_mem).decode(&#34;UTF-8&#34;))
        else:
            d = json.loads(from_mem)
        doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
    else:  # from_ext must have been not None and a path
        if gzip:
            with gopen(extstr, &#34;rt&#34;) as infp:
                d = json.load(infp)
        else:
            with open(extstr, &#34;rt&#34;) as infp:
                d = json.load(infp)
        doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.JsonSerializer.load_gzip"><code class="name flex">
<span>def <span class="ident">load_gzip</span></span>(<span>clazz, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_gzip(clazz, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    return JsonSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.JsonSerializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>the class of the object that gets saved</dd>
<dt><strong><code>inst</code></strong></dt>
<dd>the object to get saved</dd>
<dt><strong><code>to_ext</code></strong></dt>
<dd>where to save to, this should be a file path, only one of to_ext and to_mem should be specified</dd>
<dt><strong><code>to_mem</code></strong></dt>
<dd>if True, return a String serialization</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>the offset type to use for saving, if None (default) use "p" (Python)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>the offset mapper to use, only needed if the type needs to get converted</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>if True, the JSON gets gzip compressed</dd>
</dl>
<p>**kwargs:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, gzip=False, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: the class of the object that gets saved
      inst: the object to get saved
      to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
      to_mem: if True, return a String serialization
      offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
      offset_mapper: the offset mapper to use, only needed if the type needs to get converted
      gzip: if True, the JSON gets gzip compressed
      **kwargs: 
    &#34;&#34;&#34;
    d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, **kwargs)
    if to_mem:
        if gzip:
            compress(json.dumps(d).encode(&#34;UTF-8&#34;))
        else:
            return json.dumps(d)
    else:
        if gzip:
            with gopen(to_ext, &#34;wt&#34;) as outfp:
                json.dump(d, outfp)
        else:
            with open(to_ext, &#34;wt&#34;) as outfp:
                json.dump(d, outfp)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.JsonSerializer.save_gzip"><code class="name flex">
<span>def <span class="ident">save_gzip</span></span>(<span>clazz, inst, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Invokes the save method with gzip=True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_gzip(clazz, inst, **kwargs):
    &#34;&#34;&#34;
    Invokes the save method with gzip=True
    &#34;&#34;&#34;
    JsonSerializer.save(clazz, inst, gzip=True, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.MsgPackSerializer"><code class="flex name class">
<span>class <span class="ident">MsgPackSerializer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MsgPackSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def document2stream(doc: Document, stream):
        &#34;&#34;&#34;

        Args:
          doc: Document:
          stream: 
          doc: Document: 

        Returns:

        &#34;&#34;&#34;
        pack(MSGPACK_VERSION_HDR, stream)
        pack(doc.offset_type, stream)
        pack(doc.text, stream)
        pack(doc.name, stream)
        pack(doc._features.to_dict(), stream)
        pack(len(doc._annotation_sets), stream)
        for name, annset in doc._annotation_sets.items():
            pack(name, stream)
            pack(annset._next_annid, stream)
            pack(len(annset), stream)
            for ann in annset.fast_iter():
                pack(ann.type, stream)
                pack(ann.start, stream)
                pack(ann.end, stream)
                pack(ann.id, stream)
                pack(ann.features.to_dict(), stream)

    @staticmethod
    def stream2document(stream):
        &#34;&#34;&#34;

        Args:
          stream: 

        Returns:

        &#34;&#34;&#34;
        u = Unpacker(stream)
        version = u.unpack()
        if version != MSGPACK_VERSION_HDR:
            raise Exception(&#34;MsgPack data starts with wrong version&#34;)
        doc = Document()
        doc.offset_type = u.unpack()
        doc._text = u.unpack()
        doc.name = u.unpack()
        doc._features = Features(u.unpack())
        nsets = u.unpack()
        setsdict = dict()
        doc.annotation_sets = setsdict
        for iset in range(nsets):
            sname = u.unpack()
            if sname is None:
                sname = &#34;&#34;
            annset = AnnotationSet(name=sname, owner_doc=doc)
            annset._next_annid = u.unpack()
            nanns = u.unpack()
            for iann in range(nanns):
                atype = u.unpack()
                astart = u.unpack()
                aend = u.unpack()
                aid = u.unpack()
                afeatures = u.unpack()
                ann = Annotation(astart, aend, atype, annid=aid, features=afeatures)
                annset._annotations[aid] = ann
            setsdict[sname] = annset
        doc._annotation_sets = setsdict
        return doc

    @staticmethod
    def save(clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          inst: 
          to_ext: (Default value = None)
          to_mem: (Default value = None)
          offset_type: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        if isinstance(inst, Document):
            writer = MsgPackSerializer.document2stream
        elif isinstance(inst, ChangeLog):
            raise Exception(&#34;Not implemented yet&#34;)
        else:
            raise Exception(&#34;Object not supported&#34;)
        if to_mem:
            f = io.BytesIO()
        else:
            f = open(to_ext, &#34;wb&#34;)
        writer(inst, f)
        if to_mem:
            return f.getvalue()
        else:
            f.close()

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        if clazz == Document:
            reader = MsgPackSerializer.stream2document
        elif clazz == ChangeLog:
            raise Exception(&#34;Not implemented yet&#34;)
        else:
            raise Exception(&#34;Object not supported&#34;)

        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                from_mem = get_bytes_from_url(extstr)
        if from_mem:
            f = io.BytesIO(from_mem)
        else:
            f = open(extstr, &#34;rb&#34;)
        doc = reader(f)
        return doc</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.MsgPackSerializer.document2stream"><code class="name flex">
<span>def <span class="ident">document2stream</span></span>(<span>doc:<a title="gatenlp.document.Document" href="../document.html#gatenlp.document.Document">Document</a>, stream)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>doc</code></strong></dt>
<dd>Document:</dd>
<dt><strong><code>stream</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>doc</code></strong></dt>
<dd>Document: </dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def document2stream(doc: Document, stream):
    &#34;&#34;&#34;

    Args:
      doc: Document:
      stream: 
      doc: Document: 

    Returns:

    &#34;&#34;&#34;
    pack(MSGPACK_VERSION_HDR, stream)
    pack(doc.offset_type, stream)
    pack(doc.text, stream)
    pack(doc.name, stream)
    pack(doc._features.to_dict(), stream)
    pack(len(doc._annotation_sets), stream)
    for name, annset in doc._annotation_sets.items():
        pack(name, stream)
        pack(annset._next_annid, stream)
        pack(len(annset), stream)
        for ann in annset.fast_iter():
            pack(ann.type, stream)
            pack(ann.start, stream)
            pack(ann.end, stream)
            pack(ann.id, stream)
            pack(ann.features.to_dict(), stream)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.MsgPackSerializer.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, offset_mapper=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    if clazz == Document:
        reader = MsgPackSerializer.stream2document
    elif clazz == ChangeLog:
        raise Exception(&#34;Not implemented yet&#34;)
    else:
        raise Exception(&#34;Object not supported&#34;)

    isurl, extstr = is_url(from_ext)
    if from_ext is not None:
        if isurl:
            from_mem = get_bytes_from_url(extstr)
    if from_mem:
        f = io.BytesIO(from_mem)
    else:
        f = open(extstr, &#34;rb&#34;)
    doc = reader(f)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.MsgPackSerializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>inst</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>to_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>to_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      inst: 
      to_ext: (Default value = None)
      to_mem: (Default value = None)
      offset_type: (Default value = None)
      offset_mapper: (Default value = None)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    if isinstance(inst, Document):
        writer = MsgPackSerializer.document2stream
    elif isinstance(inst, ChangeLog):
        raise Exception(&#34;Not implemented yet&#34;)
    else:
        raise Exception(&#34;Object not supported&#34;)
    if to_mem:
        f = io.BytesIO()
    else:
        f = open(to_ext, &#34;wb&#34;)
    writer(inst, f)
    if to_mem:
        return f.getvalue()
    else:
        f.close()</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.MsgPackSerializer.stream2document"><code class="name flex">
<span>def <span class="ident">stream2document</span></span>(<span>stream)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>stream</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def stream2document(stream):
    &#34;&#34;&#34;

    Args:
      stream: 

    Returns:

    &#34;&#34;&#34;
    u = Unpacker(stream)
    version = u.unpack()
    if version != MSGPACK_VERSION_HDR:
        raise Exception(&#34;MsgPack data starts with wrong version&#34;)
    doc = Document()
    doc.offset_type = u.unpack()
    doc._text = u.unpack()
    doc.name = u.unpack()
    doc._features = Features(u.unpack())
    nsets = u.unpack()
    setsdict = dict()
    doc.annotation_sets = setsdict
    for iset in range(nsets):
        sname = u.unpack()
        if sname is None:
            sname = &#34;&#34;
        annset = AnnotationSet(name=sname, owner_doc=doc)
        annset._next_annid = u.unpack()
        nanns = u.unpack()
        for iann in range(nanns):
            atype = u.unpack()
            astart = u.unpack()
            aend = u.unpack()
            aid = u.unpack()
            afeatures = u.unpack()
            ann = Annotation(astart, aend, atype, annid=aid, features=afeatures)
            annset._annotations[aid] = ann
        setsdict[sname] = annset
    doc._annotation_sets = setsdict
    return doc</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.PlainTextSerializer"><code class="flex name class">
<span>class <span class="ident">PlainTextSerializer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlainTextSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def save(clazz, inst, to_ext=None, to_mem=None,
             offset_type=None, offset_mapper=None,
             encoding=&#34;UTF-8&#34;,
             gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          inst: 
          to_ext: (Default value = None)
          to_mem: (Default value = None)
          offset_type: (Default value = None)
          offset_mapper: (Default value = None)
          encoding: (Default value = &#34;UTF-8&#34;)
          gzip: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        txt = inst.text
        if txt is None:
            txt = &#34;&#34;
        if to_mem:
            if gzip:
                compress(txt.encode(encoding))
            else:
                return txt
        else:
            if gzip:
                with gopen(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                    outfp.write(txt)
            else:
                with open(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                    outfp.write(txt)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          inst: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        PlainTextSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, offset_mapper=None,
             encoding=&#34;UTF-8&#34;,
             gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          encoding: (Default value = &#34;UTF-8&#34;)
          gzip: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=encoding)
        if from_mem is not None:
            if gzip:
                txt = decompress(from_mem).decode(encoding)
            else:
                txt = from_mem
            doc = Document(txt)
        else:
            if gzip:
                with gopen(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                    txt = infp.read()
            else:
                with open(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                    txt = infp.read()
            doc = Document(txt)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        return PlainTextSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.PlainTextSerializer.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, offset_mapper=None, encoding='UTF-8', gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>encoding</code></strong></dt>
<dd>(Default value = "UTF-8")</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(clazz, from_ext=None, from_mem=None, offset_mapper=None,
         encoding=&#34;UTF-8&#34;,
         gzip=False, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      encoding: (Default value = &#34;UTF-8&#34;)
      gzip: (Default value = False)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    isurl, extstr = is_url(from_ext)
    if from_ext is not None:
        if isurl:
            if gzip:
                from_mem = get_bytes_from_url(extstr)
            else:
                from_mem = get_str_from_url(extstr, encoding=encoding)
    if from_mem is not None:
        if gzip:
            txt = decompress(from_mem).decode(encoding)
        else:
            txt = from_mem
        doc = Document(txt)
    else:
        if gzip:
            with gopen(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                txt = infp.read()
        else:
            with open(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                txt = infp.read()
        doc = Document(txt)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.PlainTextSerializer.load_gzip"><code class="name flex">
<span>def <span class="ident">load_gzip</span></span>(<span>clazz, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_gzip(clazz, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    return PlainTextSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.PlainTextSerializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, encoding='UTF-8', gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>inst</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>to_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>to_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>encoding</code></strong></dt>
<dd>(Default value = "UTF-8")</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(clazz, inst, to_ext=None, to_mem=None,
         offset_type=None, offset_mapper=None,
         encoding=&#34;UTF-8&#34;,
         gzip=False, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      inst: 
      to_ext: (Default value = None)
      to_mem: (Default value = None)
      offset_type: (Default value = None)
      offset_mapper: (Default value = None)
      encoding: (Default value = &#34;UTF-8&#34;)
      gzip: (Default value = False)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    txt = inst.text
    if txt is None:
        txt = &#34;&#34;
    if to_mem:
        if gzip:
            compress(txt.encode(encoding))
        else:
            return txt
    else:
        if gzip:
            with gopen(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                outfp.write(txt)
        else:
            with open(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                outfp.write(txt)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.PlainTextSerializer.save_gzip"><code class="name flex">
<span>def <span class="ident">save_gzip</span></span>(<span>clazz, inst, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>inst</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_gzip(clazz, inst, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      inst: 
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    PlainTextSerializer.save(clazz, inst, gzip=True, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.YamlSerializer"><code class="flex name class">
<span>class <span class="ident">YamlSerializer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class YamlSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def save(clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          inst: 
          to_ext: (Default value = None)
          to_mem: (Default value = None)
          offset_type: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, **kwargs)
        if to_mem:
            if gzip:
                compress(yaml.dump(d).encode(&#34;UTF-8&#34;))
            else:
                return yaml.dump(d)
        else:
            if gzip:
                with gopen(to_ext, &#34;wt&#34;) as outfp:
                    yaml.dump(d, outfp)
            else:
                with open(to_ext, &#34;wt&#34;) as outfp:
                    yaml.dump(d, outfp)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          inst: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        YamlSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
        if from_mem is not None:
            if gzip:
                d = yaml.load(decompress(from_mem).decode(&#34;UTF-8&#34;), Loader=yaml.FullLoader)
            else:
                d = yaml.load(from_mem, Loader=yaml.FullLoader)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        else:
            if gzip:
                with gopen(extstr, &#34;rt&#34;) as infp:
                    d = yaml.load(infp, Loader=yaml.FullLoader)
            else:
                with open(extstr, &#34;rt&#34;) as infp:
                    d = yaml.load(infp, Loader=yaml.FullLoader)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        return YamlSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.YamlSerializer.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      gzip: (Default value = False)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    isurl, extstr = is_url(from_ext)
    if from_ext is not None:
        if isurl:
            if gzip:
                from_mem = get_bytes_from_url(extstr)
            else:
                from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
    if from_mem is not None:
        if gzip:
            d = yaml.load(decompress(from_mem).decode(&#34;UTF-8&#34;), Loader=yaml.FullLoader)
        else:
            d = yaml.load(from_mem, Loader=yaml.FullLoader)
        doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
    else:
        if gzip:
            with gopen(extstr, &#34;rt&#34;) as infp:
                d = yaml.load(infp, Loader=yaml.FullLoader)
        else:
            with open(extstr, &#34;rt&#34;) as infp:
                d = yaml.load(infp, Loader=yaml.FullLoader)
        doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.YamlSerializer.load_gzip"><code class="name flex">
<span>def <span class="ident">load_gzip</span></span>(<span>clazz, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_gzip(clazz, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    return YamlSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.YamlSerializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>inst</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>to_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>to_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, gzip=False, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      inst: 
      to_ext: (Default value = None)
      to_mem: (Default value = None)
      offset_type: (Default value = None)
      offset_mapper: (Default value = None)
      gzip: (Default value = False)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, **kwargs)
    if to_mem:
        if gzip:
            compress(yaml.dump(d).encode(&#34;UTF-8&#34;))
        else:
            return yaml.dump(d)
    else:
        if gzip:
            with gopen(to_ext, &#34;wt&#34;) as outfp:
                yaml.dump(d, outfp)
        else:
            with open(to_ext, &#34;wt&#34;) as outfp:
                yaml.dump(d, outfp)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.YamlSerializer.save_gzip"><code class="name flex">
<span>def <span class="ident">save_gzip</span></span>(<span>clazz, inst, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>inst</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_gzip(clazz, inst, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz: 
      inst: 
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    YamlSerializer.save(clazz, inst, gzip=True, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.serialization" href="index.html">gatenlp.serialization</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gatenlp.serialization.default.determine_loader" href="#gatenlp.serialization.default.determine_loader">determine_loader</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_bytes_from_url" href="#gatenlp.serialization.default.get_bytes_from_url">get_bytes_from_url</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_changelog_loader" href="#gatenlp.serialization.default.get_changelog_loader">get_changelog_loader</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_changelog_saver" href="#gatenlp.serialization.default.get_changelog_saver">get_changelog_saver</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_document_loader" href="#gatenlp.serialization.default.get_document_loader">get_document_loader</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_document_saver" href="#gatenlp.serialization.default.get_document_saver">get_document_saver</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_handler" href="#gatenlp.serialization.default.get_handler">get_handler</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_str_from_url" href="#gatenlp.serialization.default.get_str_from_url">get_str_from_url</a></code></li>
<li><code><a title="gatenlp.serialization.default.is_url" href="#gatenlp.serialization.default.is_url">is_url</a></code></li>
<li><code><a title="gatenlp.serialization.default.read_lines_from" href="#gatenlp.serialization.default.read_lines_from">read_lines_from</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.serialization.default.GateXmlLoader" href="#gatenlp.serialization.default.GateXmlLoader">GateXmlLoader</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.GateXmlLoader.load" href="#gatenlp.serialization.default.GateXmlLoader.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.GateXmlLoader.value4objectwrapper" href="#gatenlp.serialization.default.GateXmlLoader.value4objectwrapper">value4objectwrapper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.HtmlAnnViewerSerializer" href="#gatenlp.serialization.default.HtmlAnnViewerSerializer">HtmlAnnViewerSerializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.HtmlAnnViewerSerializer.save" href="#gatenlp.serialization.default.HtmlAnnViewerSerializer.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.HtmlLoader" href="#gatenlp.serialization.default.HtmlLoader">HtmlLoader</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.HtmlLoader.load" href="#gatenlp.serialization.default.HtmlLoader.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.HtmlLoader.load_rendered" href="#gatenlp.serialization.default.HtmlLoader.load_rendered">load_rendered</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.JsonSerializer" href="#gatenlp.serialization.default.JsonSerializer">JsonSerializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.JsonSerializer.load" href="#gatenlp.serialization.default.JsonSerializer.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.JsonSerializer.load_gzip" href="#gatenlp.serialization.default.JsonSerializer.load_gzip">load_gzip</a></code></li>
<li><code><a title="gatenlp.serialization.default.JsonSerializer.save" href="#gatenlp.serialization.default.JsonSerializer.save">save</a></code></li>
<li><code><a title="gatenlp.serialization.default.JsonSerializer.save_gzip" href="#gatenlp.serialization.default.JsonSerializer.save_gzip">save_gzip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.MsgPackSerializer" href="#gatenlp.serialization.default.MsgPackSerializer">MsgPackSerializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.MsgPackSerializer.document2stream" href="#gatenlp.serialization.default.MsgPackSerializer.document2stream">document2stream</a></code></li>
<li><code><a title="gatenlp.serialization.default.MsgPackSerializer.load" href="#gatenlp.serialization.default.MsgPackSerializer.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.MsgPackSerializer.save" href="#gatenlp.serialization.default.MsgPackSerializer.save">save</a></code></li>
<li><code><a title="gatenlp.serialization.default.MsgPackSerializer.stream2document" href="#gatenlp.serialization.default.MsgPackSerializer.stream2document">stream2document</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.PlainTextSerializer" href="#gatenlp.serialization.default.PlainTextSerializer">PlainTextSerializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.PlainTextSerializer.load" href="#gatenlp.serialization.default.PlainTextSerializer.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.PlainTextSerializer.load_gzip" href="#gatenlp.serialization.default.PlainTextSerializer.load_gzip">load_gzip</a></code></li>
<li><code><a title="gatenlp.serialization.default.PlainTextSerializer.save" href="#gatenlp.serialization.default.PlainTextSerializer.save">save</a></code></li>
<li><code><a title="gatenlp.serialization.default.PlainTextSerializer.save_gzip" href="#gatenlp.serialization.default.PlainTextSerializer.save_gzip">save_gzip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.YamlSerializer" href="#gatenlp.serialization.default.YamlSerializer">YamlSerializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.YamlSerializer.load" href="#gatenlp.serialization.default.YamlSerializer.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.YamlSerializer.load_gzip" href="#gatenlp.serialization.default.YamlSerializer.load_gzip">load_gzip</a></code></li>
<li><code><a title="gatenlp.serialization.default.YamlSerializer.save" href="#gatenlp.serialization.default.YamlSerializer.save">save</a></code></li>
<li><code><a title="gatenlp.serialization.default.YamlSerializer.save_gzip" href="#gatenlp.serialization.default.YamlSerializer.save_gzip">save_gzip</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev16+g8c2bb0d.d20201028</a>.</p>
</footer>
</body>
</html>