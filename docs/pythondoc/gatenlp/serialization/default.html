<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gatenlp.serialization.default API documentation</title>
<meta name="description" content="Module that implements the various ways of how to save and load documents and change logs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.serialization.default</code></h1>
</header>
<section id="section-intro">
<p>Module that implements the various ways of how to save and load documents and change logs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that implements the various ways of how to save and load documents and change logs.
&#34;&#34;&#34;
import io
import os
import sys
import yaml
from collections import defaultdict
# import ruyaml as yaml
try:
    from yaml import CFullLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import FullLoader as Loader, Dumper
yaml_loader = yaml.Loader
yaml_dumper = yaml.Dumper
from random import choice
from string import ascii_uppercase
from msgpack import pack, Unpacker
from gatenlp.document import Document
from gatenlp.annotation_set import AnnotationSet
from gatenlp.annotation import Annotation
from gatenlp.changelog import ChangeLog
from gatenlp.features import Features
from gatenlp.utils import get_nested
from gatenlp.urlfileutils import is_url, get_str_from_url, get_bytes_from_url
from gzip import open as gopen, compress, decompress
from bs4 import BeautifulSoup
from gatenlp.gatenlpconfig import gatenlpconfig
import bs4
import warnings
import pickle

try:
    from bs4 import GuessedAtParserWarning
    warnings.filterwarnings(&#34;ignore&#34;, category=GuessedAtParserWarning)
except ImportError as ex:
    pass


# import orjson as usejson
# import json as usejson
# import rapidjson as usejson
# import ujson as usejson
# import hyperjson as usejson
import json

JSON_WRITE = &#34;wt&#34;
JSON_READ = &#34;rt&#34;

# # for replacing json by orjson
# class json:
#     @staticmethod
#     def load(fp):
#         data = fp.read()
#         return usejson.loads(data)
#     @staticmethod
#     def loads(data):
#         return usejson.loads(data)
#     @staticmethod
#     def dump(obj, fp):
#         buf = usejson.dumps(obj)
#         fp.write(buf)
#     @staticmethod
#     def dumps(obj):
#         return usejson.dumps(obj)

# # for replacing json with one of the other implementations
# class json:
#     @staticmethod
#     def load(fp):
#         return usejson.load(fp)
#     @staticmethod
#     def loads(data):
#         return usejson.loads(data)
#     @staticmethod
#     def dump(obj, fp):
#         buf = usejson.dump(obj, fp)
#     @staticmethod
#     def dumps(obj):
#         return usejson.dumps(obj)


# TODO: for ALL save options, allow to filter the annotations that get saved!
# TODO: then use this show only limited set of annotations in the viewer
# TODO: create Document.display(....) to show document in various ways in the current
#   environment, e.g. Jupyter notebook, select anns, configure colour palette, size etc.


# TODO: when loading from a URL, allow for deciding on the format based on the mime type!
# So if we do not have the format, we should get the header for the file, check the mime type and see
# if  we have a loder registered for that and then let the loader do the rest of the work. This may
# need loaders to be able to use an already open stream.

TWITTER_DEFAULT_INCLUDE_FIELDS = [
    &#34;id_str&#34;,
    &#34;user.id_str&#34;,
    &#34;user.screen_name&#34;,
    &#34;user.name&#34; &#34;created_at&#34;,
    &#34;is_quote_status&#34;,
    &#34;quote_count&#34;,
    &#34;retweet_count&#34;,
    &#34;favourite_count&#34;,
    &#34;favourited&#34;,
    &#34;retweeted&#34;,
    &#34;lang&#34;,
    &#34;$is_retweet_status&#34;,
    &#34;retweeted_status.user.screen_name&#34;,
]


class JsonSerializer:
    &#34;&#34;&#34;
    This class performs the saving and load of Documents and ChangeLog instances to and from the
    BDOC JSON format files, optionally with gzip compression.
    &#34;&#34;&#34;

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        offset_type=None,
        offset_mapper=None,
        gzip=False,
        annsets=None,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz: the class of the object that gets saved
          inst: the object to get saved
          to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
          to_mem: if True, return a String serialization
          offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
          offset_mapper: the offset mapper to use, only needed if the type needs to get converted
          gzip: if True, the JSON gets gzip compressed
          annsets: which annotation sets and types to include, list of set names or (setanmes, types) tuples
          **kwargs:
        &#34;&#34;&#34;
        d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, annsets=annsets, **kwargs)
        if to_mem:
            if gzip:
                compress(json.dumps(d).encode(&#34;UTF-8&#34;))
            else:
                return json.dumps(d)
        else:
            if gzip:
                with gopen(to_ext, JSON_WRITE) as outfp:
                    json.dump(d, outfp)
            else:
                with open(to_ext, JSON_WRITE) as outfp:
                    json.dump(d, outfp)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;
        Invokes the save method with gzip=True
        &#34;&#34;&#34;
        JsonSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(
        clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        # print(&#34;RUNNING load with from_ext=&#34;, from_ext, &#34; from_mem=&#34;, from_mem)

        if from_ext is not None and from_mem is not None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)
        if from_ext is None and from_mem is None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)

        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                # print(&#34;DEBUG: we got a URL&#34;)
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
            else:
                # print(&#34;DEBUG: not a URL !!!&#34;)
                pass
        if from_mem is not None:
            if gzip:
                d = json.loads(decompress(from_mem).decode(&#34;UTF-8&#34;))
            else:
                d = json.loads(from_mem)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        else:  # from_ext must have been not None and a path
            if gzip:
                with gopen(extstr, JSON_READ) as infp:
                    d = json.load(infp)
            else:
                with open(extstr, JSON_READ) as infp:
                    d = json.load(infp)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        return JsonSerializer.load(clazz, gzip=True, **kwargs)


class PickleSerializer:
    &#34;&#34;&#34;
    This class performs the saving and load of Documents and ChangeLog instances to and from pickle format.
    &#34;&#34;&#34;

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        offset_type=None,
        offset_mapper=None,
        gzip=False,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz: the class of the object that gets saved
          inst: the object to get saved
          to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
          to_mem: if True, return a String serialization
          offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
          offset_mapper: the offset mapper to use, only needed if the type needs to get converted
          gzip: must be False, gzip is not supported
          **kwargs:
        &#34;&#34;&#34;
        if gzip:
            raise Exception(&#34;Gzip not supported for pickle&#34;)
        if to_mem:
            return pickle.dumps(inst, protocol=-1)
        else:
            with open(to_ext, &#34;wb&#34;) as outfp:
                pickle.dump(inst, outfp, protocol=-1)

    @staticmethod
    def load(
        clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False) must be False, True not supported
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        # print(&#34;RUNNING load with from_ext=&#34;, from_ext, &#34; from_mem=&#34;, from_mem)

        if from_ext is not None and from_mem is not None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)
        if from_ext is None and from_mem is None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)

        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                from_mem = get_bytes_from_url(extstr)
            else:
                # print(&#34;DEBUG: not a URL !!!&#34;)
                pass
        if from_mem is not None:
            doc = pickle.loads(from_mem)
        else:  # from_ext must have been not None and a path
            with open(extstr, &#34;rb&#34;) as infp:
                doc = pickle.load(infp)
        return doc


class PlainTextSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        offset_type=None,
        offset_mapper=None,
        encoding=&#34;UTF-8&#34;,
        gzip=False,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          inst:
          to_ext: (Default value = None)
          to_mem: (Default value = None)
          offset_type: (Default value = None)
          offset_mapper: (Default value = None)
          encoding: (Default value = &#34;UTF-8&#34;)
          gzip: (Default value = False)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        txt = inst.text
        if txt is None:
            txt = &#34;&#34;
        if to_mem:
            if gzip:
                compress(txt.encode(encoding))
            else:
                return txt
        else:
            if gzip:
                with gopen(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                    outfp.write(txt)
            else:
                with open(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                    outfp.write(txt)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          inst:
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        PlainTextSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(
        clazz,
        from_ext=None,
        from_mem=None,
        offset_mapper=None,
        encoding=&#34;UTF-8&#34;,
        gzip=False,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          encoding: (Default value = &#34;UTF-8&#34;)
          gzip: (Default value = False)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=encoding)
        if from_mem is not None:
            if gzip:
                txt = decompress(from_mem).decode(encoding)
            else:
                txt = from_mem
            doc = Document(txt)
        else:
            if gzip:
                with gopen(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                    txt = infp.read()
            else:
                with open(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                    txt = infp.read()
            doc = Document(txt)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        return PlainTextSerializer.load(clazz, gzip=True, **kwargs)


class YamlSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        offset_type=None,
        offset_mapper=None,
        gzip=False,
        annsets=None,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
            clazz:
            inst:
            to_ext: (Default value = None)
            to_mem: (Default value = None)
            offset_type: (Default value = None)
            offset_mapper: (Default value = None)
            gzip: (Default value = False)
            annsets: which annotation sets and types to include, list of set names or (setanmes, types) tuples
            **kwargs:
        &#34;&#34;&#34;
        d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, annsets=annsets, **kwargs)
        if to_mem:
            if gzip:
                compress(yaml.dump(d, Dumper=yaml_dumper).encode(&#34;UTF-8&#34;))
            else:
                return yaml.dump(d, Dumper=yaml_dumper)
        else:
            if gzip:
                with gopen(to_ext, &#34;wt&#34;) as outfp:
                    yaml.dump(d, outfp, Dumper=yaml_dumper)
            else:
                with open(to_ext, &#34;wt&#34;) as outfp:
                    yaml.dump(d, outfp, Dumper=yaml_dumper)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          inst:
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        YamlSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(
        clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
        if from_mem is not None:
            if gzip:
                d = yaml.load(decompress(from_mem).decode(&#34;UTF-8&#34;), Loader=yaml_loader)
            else:
                d = yaml.load(from_mem, Loader=yaml_loader)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        else:
            if gzip:
                with gopen(extstr, &#34;rt&#34;) as infp:
                    d = yaml.load(infp, Loader=yaml_loader)
            else:
                with open(extstr, &#34;rt&#34;) as infp:
                    d = yaml.load(infp, Loader=yaml_loader)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        return YamlSerializer.load(clazz, gzip=True, **kwargs)


MSGPACK_VERSION_HDR = &#34;sm2&#34;


class MsgPackSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def document2stream(doc: Document, stream):
        &#34;&#34;&#34;

        Args:
          doc: Document:
          stream:
          doc: Document:

        Returns:

        &#34;&#34;&#34;
        pack(MSGPACK_VERSION_HDR, stream)
        pack(doc.offset_type, stream)
        pack(doc.text, stream)
        pack(doc.name, stream)
        pack(doc._features.to_dict(), stream)
        pack(len(doc._annotation_sets), stream)
        for name, annset in doc._annotation_sets.items():
            pack(name, stream)
            pack(annset._next_annid, stream)
            pack(len(annset), stream)
            for ann in annset.fast_iter():
                pack(ann.type, stream)
                pack(ann.start, stream)
                pack(ann.end, stream)
                pack(ann.id, stream)
                pack(ann.features.to_dict(), stream)

    @staticmethod
    def stream2document(stream):
        &#34;&#34;&#34;

        Args:
          stream:

        Returns:

        &#34;&#34;&#34;
        u = Unpacker(stream)
        version = u.unpack()
        if version != MSGPACK_VERSION_HDR:
            raise Exception(&#34;MsgPack data starts with wrong version&#34;)
        doc = Document()
        doc.offset_type = u.unpack()
        doc._text = u.unpack()
        doc.name = u.unpack()
        doc._features = Features(u.unpack())
        nsets = u.unpack()
        setsdict = dict()
        doc.annotation_sets = setsdict
        for iset in range(nsets):
            sname = u.unpack()
            if sname is None:
                sname = &#34;&#34;
            annset = AnnotationSet(name=sname, owner_doc=doc)
            annset._next_annid = u.unpack()
            nanns = u.unpack()
            for iann in range(nanns):
                atype = u.unpack()
                astart = u.unpack()
                aend = u.unpack()
                aid = u.unpack()
                afeatures = u.unpack()
                ann = Annotation(astart, aend, atype, annid=aid, features=afeatures)
                annset._annotations[aid] = ann
            setsdict[sname] = annset
        doc._annotation_sets = setsdict
        return doc

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        offset_type=None,
        offset_mapper=None,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          inst:
          to_ext: (Default value = None)
          to_mem: (Default value = None)
          offset_type: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        if isinstance(inst, Document):
            writer = MsgPackSerializer.document2stream
        elif isinstance(inst, ChangeLog):
            raise Exception(&#34;Not implemented yet&#34;)
        else:
            raise Exception(&#34;Object not supported&#34;)
        if to_mem:
            f = io.BytesIO()
        else:
            f = open(to_ext, &#34;wb&#34;)
        writer(inst, f)
        if to_mem:
            return f.getvalue()
        else:
            f.close()

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        if clazz == Document:
            reader = MsgPackSerializer.stream2document
        elif clazz == ChangeLog:
            raise Exception(&#34;Not implemented yet&#34;)
        else:
            raise Exception(&#34;Object not supported&#34;)

        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                from_mem = get_bytes_from_url(extstr)
        if from_mem:
            f = io.BytesIO(from_mem)
        else:
            f = open(extstr, &#34;rb&#34;)
        doc = reader(f)
        return doc

JS_JQUERY_URL = &#34;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js&#34;
JS_GATENLP_URL = &#34;https://unpkg.com/gatenlp-ann-viewer@1.0.14/gatenlp-ann-viewer.js&#34;
JS_JQUERY = f&#34;&lt;script src=\&#34;{JS_JQUERY_URL}\&#34;&gt;&lt;/script&gt;&#34;
JS_GATENLP = f&#34;&lt;script src=\&#34;{JS_GATENLP_URL}\&#34;&gt;&lt;/script&gt;&#34;
HTML_TEMPLATE_FILE_NAME = &#34;gatenlp-ann-viewer.html&#34;
JS_GATENLP_FILE_NAME = &#34;gatenlp-ann-viewer-merged.js&#34;

html_ann_viewer_serializer_js_loaded = False


class HtmlAnnViewerSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def javascript():
        &#34;&#34;&#34;
        Return the Javascript needed for the HTML Annotation viewer.

        Returns: Javascript string.

        &#34;&#34;&#34;
        jsloc = os.path.join(
            os.path.dirname(__file__), &#34;_htmlviewer&#34;, JS_GATENLP_FILE_NAME
        )
        if not os.path.exists(jsloc):
            raise Exception(
                &#34;Could not find JavsScript file, {} does not exist&#34;.format(jsloc)
            )
        with open(jsloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
            js = infp.read()
            js = &#34;&#34;&#34;&lt;script type=&#34;text/javascript&#34;&gt;&#34;&#34;&#34; + js + &#34;&lt;/script&gt;&#34;
        return js

    @staticmethod
    def init_javscript():
        import IPython

        IPython.display.display_html(HtmlAnnViewerSerializer.javascript(), raw=True)

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        notebook=False,
        offline=False,
        add_js=True,
        htmlid=None,
        stretch_height=False,
        annsets=None,
        doc_style=None,
        **kwargs,
    ):
        &#34;&#34;&#34;Convert a document to HTML for visualizing it.

        Args:
            clazz: the class of the object to save
            inst: the instance/object to save
            to_ext:  the destination where to save to unless to_mem is given
            to_mem: if true, ignores to_ext and returns the representation
            notebook: if True only create a div which can be injected into a notebook or other HTML, otherwise
                generate a full HTML document
            offline: if true, include all the Javascript needed in the generated HTML , otherwise load library
                from the internet.
            add_js: if true (default), add the necessary Javascript either directly or by loading a library from
                the internet. If false, assume that the Javascript is already there (only makes sense with
                notebook=True).
            htmlid: the id to use for HTML ids so it is possible to have several independent viewers in the
                same HTML page and to style the output from a separate notebook cell
            max_height1: if this is set, then the maximum height of the first row of the viewer is set to the
                given value (default: 20em). If this is None, then the height is set to
            stretch_height: if False, rows 1 and 2 of the viewer will not have the height set, but only
                min and max height (default min is 10em for row1 and 7em for row2, max is the double of those).
                If True, no max haight is set and instead the height is set to a percentage (default is
                67vh for row 1 and 30vh for row 2). The values used can be changed via gateconfig.
            annsets: if None, include all annotation sets and types, otherwise this should be a list of either
                set names, or tuples, where the first entry is a set name and the second entry is either a type
                name or list of type names to include.
            doc_style: if not None, any additional styling for the document text box, if None, use whatever
                is defined in gatenlpconfig or do not use.
            kwargs: swallow any other kwargs.

        Returns: if to_mem is True, returns the representation, otherwise None.

        &#34;&#34;&#34;
        if not isinstance(inst, Document):
            raise Exception(&#34;Not a document!&#34;)
        # TODO: why are we doing a deepcopy here?
        doccopy = inst.deepcopy(annsets=annsets)
        doccopy.to_offset_type(&#34;j&#34;)
        json = doccopy.save_mem(fmt=&#34;json&#34;, **kwargs)
        htmlloc = os.path.join(
            os.path.dirname(__file__), &#34;_htmlviewer&#34;, HTML_TEMPLATE_FILE_NAME
        )
        if not os.path.exists(htmlloc):
            raise Exception(
                &#34;Could not find HTML template, {} does not exist&#34;.format(htmlloc)
            )
        with open(htmlloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
            html = infp.read()
        txtcolor = gatenlpconfig.doc_html_repr_txtcolor
        if notebook:
            str_start = &#34;&lt;!--STARTDIV--&gt;&#34;
            str_end = &#34;&lt;!--ENDDIV--&gt;&#34;
            idx1 = html.find(str_start) + len(str_start)
            idx2 = html.find(str_end)
            if htmlid:
                rndpref = str(htmlid)
            else:
                rndpref = &#34;&#34;.join(choice(ascii_uppercase) for i in range(10))
            html = html[idx1:idx2]
            html = f&#34;&#34;&#34;&lt;div&gt;&lt;style&gt;#{rndpref}-wrapper {{ color: {txtcolor} !important; }}&lt;/style&gt;
&lt;div id=&#34;{rndpref}-wrapper&#34;&gt;
{html}
&lt;/div&gt;&lt;/div&gt;&#34;&#34;&#34;
            # replace the prefix with a random one
            html = html.replace(&#34;GATENLPID&#34;, rndpref)
        if offline:
            # global html_ann_viewer_serializer_js_loaded
            # if not html_ann_viewer_serializer_js_loaded:
            if add_js:
                jsloc = os.path.join(
                    os.path.dirname(__file__), &#34;_htmlviewer&#34;, JS_GATENLP_FILE_NAME
                )
                if not os.path.exists(jsloc):
                    raise Exception(
                        &#34;Could not find JavsScript file, {} does not exist&#34;.format(
                            jsloc
                        )
                    )
                with open(jsloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
                    js = infp.read()
                    js = &#34;&#34;&#34;&lt;script type=&#34;text/javascript&#34;&gt;&#34;&#34;&#34; + js + &#34;&lt;/script&gt;&#34;
                # html_ann_viewer_serializer_js_loaded = True
            else:
                js = &#34;&#34;
        else:
            js = JS_JQUERY + JS_GATENLP
        if stretch_height:
            height1 = gatenlpconfig.doc_html_repr_height1_stretch
            height2 = gatenlpconfig.doc_html_repr_height2_stretch
        else:
            height1 = gatenlpconfig.doc_html_repr_height1_nostretch
            height2 = gatenlpconfig.doc_html_repr_height2_nostretch
        html = html.replace(&#34;$$JAVASCRIPT$$&#34;, js, 1).replace(&#34;$$JSONDATA$$&#34;, json, 1)
        html = html.replace(&#34;$$HEIGHT1$$&#34;, height1, 1).replace(
            &#34;$$HEIGHT2$$&#34;, height2, 1
        )
        if doc_style is None:
            doc_style = gatenlpconfig.doc_html_repr_doc_style
        if doc_style is None:
            doc_style = &#34;&#34;
        html = html.replace(&#34;$$DOCTEXTSTYLE$$&#34;, doc_style, 1)
        if to_mem:
            return html
        else:
            with open(to_ext, &#34;wt&#34;, encoding=&#34;utf-8&#34;) as outfp:
                outfp.write(html)


class HtmlLoader:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def load_rendered(
        clazz,
        from_ext=None,
        from_mem=None,
        parser=None,
        markup_set_name=&#34;Original markups&#34;,
        process_soup=None,
        offset_mapper=None,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          parser: (Default value = None)
          markup_set_name: (Default value = &#34;Original markups&#34;)
          process_soup: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        raise Exception(&#34;Rendered html parser not yet implemented&#34;)

    @staticmethod
    def load(
        clazz,
        from_ext=None,
        from_mem=None,
        parser=&#34;html.parser&#34;,
        markup_set_name=&#34;Original markups&#34;,
        encoding=None,
        **kwargs,
    ):
        &#34;&#34;&#34;Load a HTML file.

        Args:
            clazz: param from_ext:
            from_ext: file our URL source
            from_mem:  string source
            parser: one of &#34;html.parser&#34;, &#34;lxml&#34;, &#34;lxml-xml&#34;, &#34;html5lib&#34; (default is &#34;html.parser&#34;)
            markup_set_name: the annotation set name for the set to contain the HTML
                annotations (Default value = &#34;Original markups&#34;)
            encoding: the encoding to use for reading the file
        &#34;&#34;&#34;
        # NOTE: for now we have a simple heuristic for adding newlines to the text:
        # before and after a block element, a newline is added unless there is already one
        # NOTE: for now we use  multi_valued_attributes=None which prevents attributes of the
        # form &#34;class=&#39;val1 val2&#39;&#34; to get converted into features with a list of values.
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                from_mem = get_str_from_url(extstr, encoding=encoding)
        if from_mem:
            bs = BeautifulSoup(from_mem, features=parser, multi_valued_attributes=None)
        else:
            with open(extstr, encoding=encoding) as infp:
                bs = BeautifulSoup(infp, features=parser, multi_valued_attributes=None)
        # we recursively iterate the tree depth first, going through the children
        # and adding to a list that either contains the text or a dict with the information
        # about annotations we want to add
        nlels = {
            &#34;pre&#34;,
            &#34;br&#34;,
            &#34;p&#34;,
            &#34;div&#34;,
            &#34;tr&#34;,
            &#34;h1&#34;,
            &#34;h2&#34;,
            &#34;h3&#34;,
            &#34;h4&#34;,
            &#34;h5&#34;,
            &#34;h6&#34;,
            &#34;li&#34;,
            &#34;address&#34;,
            &#34;article&#34;,
            &#34;aside&#34;,
            &#34;blockquote&#34;,
            &#34;del&#34;,
            &#34;figure&#34;,
            &#34;figcaption&#34;,
            &#34;footer&#34;,
            &#34;header&#34;,
            &#34;hr&#34;,
            &#34;ins&#34;,
            &#34;main&#34;,
            &#34;nav&#34;,
            &#34;section&#34;,
            &#34;summary&#34;,
            &#34;input&#34;,
            &#34;legend&#34;,
            &#34;option&#34;,
            &#34;textarea&#34;,
            &#34;bdi&#34;,
            &#34;bdo&#34;,
            &#34;center&#34;,
            &#34;code&#34;,
            &#34;dfn&#34;,
            &#34;menu&#34;,
            &#34;dir&#34;,
            &#34;caption&#34;,
        }
        ignoreels = {&#34;script&#34;, &#34;style&#34;}
        docinfo = {&#34;anninfos&#34;: [], &#34;curoffset&#34;: 0, &#34;curid&#34;: 0, &#34;text&#34;: &#34;&#34;}

        def walktree(el):
            &#34;&#34;&#34;

            Args:
              el:

            Returns:

            &#34;&#34;&#34;
            # print(&#34;DEBUG: type=&#34;, type(el))
            if isinstance(el, bs4.element.Doctype):
                # print(&#34;DEBUG: got doctype&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Comment):
                # print(&#34;DEBUG: got Comment&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Script):
                # print(&#34;DEBUG: got Script&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Tag):
                # print(&#34;DEBUG: got tag: &#34;, type(el), &#34; name=&#34;,el.name)
                # some tags we ignore completely:
                if el.name in ignoreels:
                    return
                # for some tags we insert a new line before, but only if we do not already have one
                if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and el.name in nlels:
                    docinfo[&#34;text&#34;] += &#34;\n&#34;
                    # print(&#34;DEBUG: adding newline before at &#34;, docinfo[&#34;curoffset&#34;])
                    docinfo[&#34;curoffset&#34;] += 1
                ann = {
                    &#34;type&#34;: el.name,
                    &#34;features&#34;: el.attrs,
                    &#34;id&#34;: docinfo[&#34;curid&#34;],
                    &#34;event&#34;: &#34;start&#34;,
                    &#34;start&#34;: docinfo[&#34;curoffset&#34;],
                }
                thisid = docinfo[&#34;curid&#34;]
                docinfo[&#34;anninfos&#34;].append(ann)
                docinfo[&#34;curid&#34;] += 1
                for child in el.children:
                    walktree(child)
                # for some tags we insert a new line after
                if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and el.name in nlels:
                    docinfo[&#34;text&#34;] += &#34;\n&#34;
                    # print(&#34;DEBUG: adding newline after at &#34;, docinfo[&#34;curoffset&#34;])
                    docinfo[&#34;curoffset&#34;] += 1
                docinfo[&#34;anninfos&#34;].append(
                    {&#34;event&#34;: &#34;end&#34;, &#34;id&#34;: thisid, &#34;end&#34;: docinfo[&#34;curoffset&#34;]}
                )
            elif isinstance(el, bs4.element.NavigableString):
                # print(&#34;DEBUG: got text: &#34;, el)
                text = str(el)
                if text == &#34;\n&#34; and docinfo[&#34;text&#34;].endswith(&#34;\n&#34;):
                    return
                docinfo[&#34;text&#34;] += text
                docinfo[&#34;curoffset&#34;] += len(el)
            else:
                print(&#34;WARNING: odd element type&#34;, type(el))

        walktree(bs)
        # need to add the end corresponding to bs
        # print(&#34;DEBUG: got docinfo:\n&#34;,docinfo)
        id2anninfo = {}  # from id to anninfo
        nstart = 0
        for anninfo in docinfo[&#34;anninfos&#34;]:
            if anninfo[&#34;event&#34;] == &#34;start&#34;:
                nstart += 1
                id2anninfo[anninfo[&#34;id&#34;]] = anninfo
        nend = 0
        for anninfo in docinfo[&#34;anninfos&#34;]:
            if anninfo[&#34;event&#34;] == &#34;end&#34;:
                nend += 1
                end = anninfo[&#34;end&#34;]
                annid = anninfo[&#34;id&#34;]
                anninfo = id2anninfo[annid]
                anninfo[&#34;end&#34;] = end
        # print(&#34;DEBUG: got nstart/nend&#34;, nstart, nend)
        assert nstart == nend
        # print(&#34;DEBUG: got id2anninfo:\n&#34;, id2anninfo)
        doc = Document(docinfo[&#34;text&#34;])
        annset = doc.annset(markup_set_name)
        for i in range(nstart):
            anninfo = id2anninfo[i]
            annset.add(
                anninfo[&#34;start&#34;],
                anninfo[&#34;end&#34;],
                anntype=anninfo[&#34;type&#34;],
                features=anninfo[&#34;features&#34;],
            )
        return doc


class TweetV1Serializer:

    @staticmethod
    def doc2twitterv1dict(doc, annsets=None, prefix_sep=None):
        d = doc.to_dict(annsets=annsets)
        ret = {&#34;full_text&#34;: doc.text}
        ents = defaultdict(list)
        for setname, annset in d.get(&#34;annotation_sets&#34;, {}).items():
            for ann in annset.get(&#34;annotations&#34;, []):
                anntype = ann[&#34;type&#34;]
                if prefix_sep is not None and setname != &#34;&#34;:
                    anntype = setname + prefix_sep + anntype
                annlist = ents[anntype]
                twitterann = {
                    &#34;indices&#34;: [ann[&#34;start&#34;], ann[&#34;end&#34;]]
                }
                twitterann.update(ann[&#34;features&#34;])
                annlist.append(twitterann)
        ret[&#34;entities&#34;] = ents
        return ret

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        annsets=None,
        prefix_sep=None,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
            clazz: the class of the object that gets saved
            inst: the object to get saved
            to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
            to_mem: if True, return a String serialization
            offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
            offset_mapper: the offset mapper to use, only needed if the type needs to get converted
            annsets: which annotation sets and types to include, list of set names or (setanmes, types) tuples
            prefix_types: if not None, prefix all types with the name of the annotation set the annotation comes from
                and use the given string as the separator (can be the empty string for no seaparator).
                For annotations from the default set the type stays unchanged.
          **kwargs:
        &#34;&#34;&#34;
        d = TweetV1Serializer.doc2twitterv1dict(inst, annsets=annsets, prefix_sep=prefix_sep)
        if to_mem:
            return json.dumps(d)
        else:
            with open(to_ext, JSON_WRITE) as outfp:
                json.dump(d, outfp)

    @staticmethod
    def load(
        clazz,
        from_ext=None,
        from_mem=None,
        include_fields=None,
        include_entities=True,
        include_quote=False,
        outsetname=&#34;Original markups&#34;,
        tweet_ann=&#34;Tweet&#34;,
    ):
        &#34;&#34;&#34;
        Load a tweet from Twitter JSON format.

        IMPORTANT: this is still very experimental, will change in the future!

        Args:
            clazz: internal use
            from_ext: the file/url to load from
            from_mem: string to load from
            include_fields: a list of fields to include where nested field names are dot-separated, e.g.
               &#34;user.location&#34;. All these fields are included using the nested field name in either the
               features of the tweet annotation with the Type specified, or the features of the document
               if `tweet_ann` is None.
            include_entities: create annotations for the tweet entities in the set with outsetname
            include_quote: if True, add the quoted tweet after an empty line and treat it as a separate
               tweet just like the original tweet.
            outset: the annotation set where to put entity annotations and the tweet annotation(s)
            tweet_ann: the annotation type to use to span the tweet and contain all the features.

        Returns:
            document representing the tweet
        &#34;&#34;&#34;
        if from_ext is not None:
            isurl, extstr = is_url(from_ext)
            if isurl:
                jsonstr = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
                tweet = json.loads(jsonstr)
            else:
                with open(extstr, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
                    tweet = json.load(infp)
        elif from_mem is not None:
            tweet = json.loads(from_mem)
        else:
            raise Exception(&#34;Cannot load from None&#34;)
        if tweet is None:
            raise Exception(&#34;Could not decode Tweet JSON&#34;)
        if tweet.get(&#34;truncated&#34;):
            text = get_nested(tweet, &#34;extended_tweet.full_text&#34;)
        else:
            text = get_nested(tweet, &#34;text&#34;)
        if text is None:
            raise Exception(&#34;No text field found&#34;)
        quoted_status = None
        if include_quote:
            quoted_status = tweet.get(&#34;quoted_status&#34;)
            if quoted_status is not None:
                qtext = quoted_status.get(&#34;text&#34;, &#34;&#34;)
                text += &#34;\n&#34; + qtext
        doc = Document(text)
        anns = doc.annset(outsetname)
        if tweet_ann:
            ann = anns.add(0, len(text), tweet_ann)
            features = ann.features
        else:
            features = doc.features
        if include_fields is None:
            include_fields = TWITTER_DEFAULT_INCLUDE_FIELDS
        for field in include_fields:
            if field.startswith(&#34;$&#34;):
                if field == &#34;$is_retweet_status&#34;:
                    rs = get_nested(tweet, &#34;retweeted_status&#34;, silent=True)
                    if rs is not None:
                        features[field] = True
                continue
            val = get_nested(tweet, field, silent=True)
            if val is not None:
                features[field] = val
        if include_entities:
            if tweet.get(&#34;truncated&#34;):
                entities = get_nested(tweet, &#34;extended_tweet.entities&#34;, default={})
            else:
                entities = get_nested(tweet, &#34;entities&#34;, default={})
        for etype, elist in entities.items():
            for ent in elist:
                start, end = ent[&#34;indices&#34;]
                anns.add(start, end, etype)
        # TODO: if we have a quoted_status, add features and entities from there:
        # Essentially the same processing as for the original tweet, but at document offset
        # len(tweet)+1 (2?)
        return doc


class GateXmlLoader:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def value4objectwrapper(text):
        &#34;&#34;&#34;This may one day convert things like lists, maps, shared objects to Python, but for
        now we always throw an exeption.

        Args:
          text: return:

        Returns:

        &#34;&#34;&#34;
        raise Exception(
            &#34;Cannot load GATE XML which contains gate.corpora.ObjectWrapper data&#34;
        )

    @staticmethod
    def load(clazz, from_ext=None, ignore_unknown_types=False):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          ignore_unknown_types: (Default value = False)

        Returns:

        &#34;&#34;&#34;
        # TODO: the code below is just an outline and needs work!
        # TODO: make use of the test document created in repo project-python-gatenlp
        import xml.etree.ElementTree as ET

        isurl, extstr = is_url(from_ext)
        if isurl:
            xmlstring = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
            root = ET.fromstring(xmlstring)
        else:
            tree = ET.parse(extstr)
            root = tree.getroot()

        # or: root = ET.fromstring(xmlstring)

        # check we do have a GATE document

        assert root.tag == &#34;GateDocument&#34;
        assert root.attrib == {&#34;version&#34;: &#34;3&#34;}

        def parsefeatures(feats):
            &#34;&#34;&#34;

            Args:
              feats:

            Returns:

            &#34;&#34;&#34;
            features = {}
            for feat in list(feats):
                name = None
                value = None
                for el in list(feat):
                    if el.tag == &#34;Name&#34;:
                        if el.get(&#34;className&#34;) == &#34;java.lang.String&#34;:
                            name = el.text
                        else:
                            raise Exception(
                                &#34;Odd Feature Name type: &#34; + el.get(&#34;className&#34;)
                            )
                    elif el.tag == &#34;Value&#34;:
                        cls_name = el.get(&#34;className&#34;)
                        if cls_name == &#34;java.lang.String&#34;:
                            value = el.text
                        elif cls_name == &#34;java.lang.Integer&#34;:
                            value = int(el.text)
                        elif cls_name == &#34;java.lang.Long&#34;:
                            value = int(el.text)
                        elif cls_name == &#34;java.math.BigDecimal&#34;:
                            value = float(el.text)
                        elif cls_name == &#34;java.lang.Boolean&#34;:
                            value = bool(el.text)
                        # elif cls_name == &#34;gate.corpora.ObjectWrapper&#34;:
                        #    value = GateXmlLoader.value4objectwrapper(el.text)
                        else:
                            if ignore_unknown_types:
                                print(
                                    f&#34;Warning: ignoring feature with serialization type: {cls_name}&#34;,
                                    file=sys.stderr,
                                )
                            else:
                                raise Exception(
                                    &#34;Unsupported serialization type: &#34;
                                    + el.get(&#34;className&#34;)
                                )
                if name is not None and value is not None:
                    features[name] = value
            return features

        # get the document features
        docfeatures = {}
        feats = root.findall(&#34;./GateDocumentFeatures/Feature&#34;)

        docfeatures = parsefeatures(feats)

        textwithnodes = root.findall(&#34;./TextWithNodes&#34;)
        text = &#34;&#34;
        node2offset = {}
        curoff = 0
        for item in textwithnodes:
            if item.text:
                print(&#34;Got item text: &#34;, item.text)
                text += item.text
                # TODO HTML unescape item text
                curoff += len(item.text)
            for node in item:
                nodeid = node.get(&#34;id&#34;)
                node2offset[nodeid] = curoff
                if node.tail:
                    # TODO: unescape item.text?
                    print(&#34;Gote node tail: &#34;, node.tail)
                    text += node.tail
                    curoff += len(node.tail)

        annsets = root.findall(&#34;./AnnotationSet&#34;)

        annotation_sets = {}  # map name - set
        for annset in annsets:
            if annset.get(&#34;Name&#34;):
                setname = annset.get(&#34;Name&#34;)
            else:
                setname = &#34;&#34;
            annots = annset.findall(&#34;./Annotation&#34;)
            annotations = []
            maxannid = 0
            for ann in annots:
                annid = int(ann.attrib[&#34;Id&#34;])
                maxannid = max(maxannid, annid)
                anntype = ann.attrib[&#34;Type&#34;]
                startnode = ann.attrib[&#34;StartNode&#34;]
                endnode = ann.attrib[&#34;EndNode&#34;]
                startoff = node2offset[startnode]
                endoff = node2offset[endnode]
                feats = ann.findall(&#34;./Feature&#34;)
                features = parsefeatures(feats)
                if len(features) == 0:
                    features = None
                annotation = {
                    &#34;id&#34;: annid,
                    &#34;type&#34;: anntype,
                    &#34;start&#34;: startoff,
                    &#34;end&#34;: endoff,
                    &#34;features&#34;: features,
                }
                annotations.append(annotation)
            annset = {
                &#34;name&#34;: setname,
                &#34;annotations&#34;: annotations,
                &#34;next_annid&#34;: maxannid + 1,
            }
            annotation_sets[setname] = annset

        docmap = {
            &#34;text&#34;: text,
            &#34;features&#34;: docfeatures,
            &#34;offset_type&#34;: &#34;p&#34;,
            &#34;annotation_sets&#34;: annotation_sets,
        }

        doc = Document.from_dict(docmap)
        return doc


def determine_loader(
    clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs
):
    &#34;&#34;&#34;

    Args:
      clazz:
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      gzip: (Default value = False)
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    first = None
    if from_mem:
        first = from_mem[0]
    else:
        with open(from_ext, &#34;rt&#34;) as infp:
            first = infp.read(1)
    if first == &#34;{&#34;:
        return JsonSerializer.load(
            clazz,
            from_ext=from_ext,
            from_mem=from_mem,
            offset_mapper=offset_mapper,
            gzip=gzip,
            **kwargs,
        )
    else:
        return MsgPackSerializer.load(
            clazz,
            from_ext=from_ext,
            from_mem=from_mem,
            offset_mapper=offset_mapper,
            gzip=gzip,
            **kwargs,
        )


DOCUMENT_SAVERS = {
    &#34;text/plain&#34;: PlainTextSerializer.save,
    &#34;text/plain+gzip&#34;: PlainTextSerializer.save_gzip,
    &#34;text&#34;: PlainTextSerializer.save,
    &#34;json&#34;: JsonSerializer.save,
    &#34;jsongz&#34;: JsonSerializer.save_gzip,
    &#34;bdocjs&#34;: JsonSerializer.save,
    &#34;pickle&#34;: PickleSerializer.save,
    &#34;bdocjsgz&#34;: JsonSerializer.save_gzip,
    &#34;text/bdocjs&#34;: JsonSerializer.save,
    &#34;text/bdocjs+gzip&#34;: JsonSerializer.save_gzip,
    &#34;yaml&#34;: YamlSerializer.save,
    &#34;bdocym&#34;: YamlSerializer.save,
    &#34;yamlgz&#34;: YamlSerializer.save_gzip,
    &#34;text/bdocym&#34;: YamlSerializer.save,
    &#34;text/bdocym+gzip+&#34;: YamlSerializer.save_gzip,
    &#34;msgpack&#34;: MsgPackSerializer.save,
    &#34;bdocmp&#34;: MsgPackSerializer.save,
    &#34;tweet-v1&#34;: TweetV1Serializer.save,
    &#34;text/bdocmp&#34;: MsgPackSerializer.save,
    &#34;application/msgpack&#34;: MsgPackSerializer.save,
    &#34;html-ann-viewer&#34;: HtmlAnnViewerSerializer.save,
}
DOCUMENT_LOADERS = {
    &#34;json&#34;: JsonSerializer.load,
    &#34;jsongz&#34;: JsonSerializer.load_gzip,
    &#34;bdocjs&#34;: JsonSerializer.load,
    &#34;bdocjsgz&#34;: JsonSerializer.load_gzip,
    &#34;text/bdocjs&#34;: JsonSerializer.load,
    &#34;text/bdocjs+gzip&#34;: JsonSerializer.load_gzip,
    &#34;yaml&#34;: YamlSerializer.load,
    &#34;yamlgz&#34;: YamlSerializer.load_gzip,
    &#34;bdocym&#34;: YamlSerializer.load,
    &#34;bdocymzg: &#34;: YamlSerializer.load_gzip,
    &#34;text/bdocym&#34;: YamlSerializer.load,
    &#34;text/bdocym+gzip&#34;: YamlSerializer.load_gzip,
    &#34;msgpack&#34;: MsgPackSerializer.load,
    &#34;bdocmp&#34;: MsgPackSerializer.load,
    &#34;application/msgpack&#34;: MsgPackSerializer.load,
    &#34;text/bdocmp&#34;: MsgPackSerializer.load,
    &#34;jsonormsgpack&#34;: determine_loader,
    &#34;text/plain&#34;: PlainTextSerializer.load,
    &#34;text/plain+gzip&#34;: PlainTextSerializer.load_gzip,
    &#34;text&#34;: PlainTextSerializer.load,
    &#34;text/html&#34;: HtmlLoader.load,
    &#34;html&#34;: HtmlLoader.load,
    &#34;html-rendered&#34;: HtmlLoader.load_rendered,
    &#34;gatexml&#34;: GateXmlLoader.load,
    &#34;tweet-v1&#34;: TweetV1Serializer.load,
    &#34;pickle&#34;: PickleSerializer.load,
}
CHANGELOG_SAVERS = {
    &#34;json&#34;: JsonSerializer.save,
    &#34;text/bdocjs+gzip&#34;: JsonSerializer.save_gzip,
    &#34;text/bdocjs&#34;: JsonSerializer.save,
}
CHANGELOG_LOADERS = {
    &#34;json&#34;: JsonSerializer.load,
    &#34;text/bdocjs+gzip&#34;: JsonSerializer.load_gzip,
    &#34;text/bdocjs&#34;: JsonSerializer.load,
}

# map extensions to document types
EXTENSIONS = {
    &#34;bdocjs&#34;: &#34;json&#34;,
    &#34;bdocym&#34;: &#34;yaml&#34;,
    &#34;bdocym.gz&#34;: &#34;text/bdocym+gzip&#34;,
    &#34;bdoc.gz&#34;: &#34;text/bdocjs+gzip&#34;,  # lets assume it is compressed json
    &#34;bdoc&#34;: &#34;jsonormsgpack&#34;,
    &#34;bdocjs.gz&#34;: &#34;text/bdocjs+gzip&#34;,
    &#34;bdocjson&#34;: &#34;json&#34;,
    &#34;bdocmp&#34;: &#34;msgpack&#34;,
    &#34;txt&#34;: &#34;text/plain&#34;,
    &#34;txt.gz&#34;: &#34;text/plain+gzip&#34;,
    &#34;html&#34;: &#34;text/html&#34;,
    &#34;htm&#34;: &#34;text/html&#34;,
    &#34;pickle&#34;: &#34;pickle&#34;,
}


def get_handler(filespec, fmt, handlers, saveload, what):
    &#34;&#34;&#34;

    Args:
      filespec:
      fmt:
      handlers:
      saveload:
      what:

    Returns:

    &#34;&#34;&#34;
    msg = f&#34;Could not determine how to {saveload} {what} for format {fmt} in module gatenlp.serialization.default&#34;
    if fmt:
        handler = handlers.get(fmt)
        if not handler:
            raise Exception(msg)
        return handler
    else:
        if not filespec:  # in case of save_mem
            raise Exception(msg)
        if isinstance(filespec, os.PathLike):
            wf = os.fspath(filespec)
        elif isinstance(filespec, str):
            wf = filespec
        else:
            raise Exception(msg)
        name, ext = os.path.splitext(wf)
        if ext == &#34;.gz&#34;:
            ext2 = os.path.splitext(name)[1]
            if ext2:
                ext2 = ext2[1:]
            ext = ext2 + ext
        elif ext:
            ext = ext[1:]
        fmt = EXTENSIONS.get(ext)
        msg = f&#34;Could not determine how to {saveload} {what} for format {fmt} and with &#34; \
              &#34;extension {ext} in module gatenlp.serialization.default&#34;
        if not fmt:
            raise Exception(msg)
        handler = handlers.get(fmt)
        if not handler:
            raise Exception(msg)
        return handler


def get_document_saver(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec:
      fmt:

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, DOCUMENT_SAVERS, &#34;save&#34;, &#34;document&#34;)


def get_document_loader(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec:
      fmt:

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, DOCUMENT_LOADERS, &#34;load&#34;, &#34;document&#34;)


def get_changelog_saver(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec:
      fmt:

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, CHANGELOG_SAVERS, &#34;save&#34;, &#34;changelog&#34;)


def get_changelog_loader(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec:
      fmt:

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, CHANGELOG_LOADERS, &#34;load&#34;, &#34;changelog&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gatenlp.serialization.default.determine_loader"><code class="name flex">
<span>def <span class="ident">determine_loader</span></span>(<span>clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt>clazz:</dt>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
</dl>
<p>**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_loader(
    clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs
):
    &#34;&#34;&#34;

    Args:
      clazz:
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      gzip: (Default value = False)
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    first = None
    if from_mem:
        first = from_mem[0]
    else:
        with open(from_ext, &#34;rt&#34;) as infp:
            first = infp.read(1)
    if first == &#34;{&#34;:
        return JsonSerializer.load(
            clazz,
            from_ext=from_ext,
            from_mem=from_mem,
            offset_mapper=offset_mapper,
            gzip=gzip,
            **kwargs,
        )
    else:
        return MsgPackSerializer.load(
            clazz,
            from_ext=from_ext,
            from_mem=from_mem,
            offset_mapper=offset_mapper,
            gzip=gzip,
            **kwargs,
        )</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_changelog_loader"><code class="name flex">
<span>def <span class="ident">get_changelog_loader</span></span>(<span>filespec, fmt)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>filespec:
fmt:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_changelog_loader(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec:
      fmt:

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, CHANGELOG_LOADERS, &#34;load&#34;, &#34;changelog&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_changelog_saver"><code class="name flex">
<span>def <span class="ident">get_changelog_saver</span></span>(<span>filespec, fmt)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>filespec:
fmt:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_changelog_saver(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec:
      fmt:

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, CHANGELOG_SAVERS, &#34;save&#34;, &#34;changelog&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_document_loader"><code class="name flex">
<span>def <span class="ident">get_document_loader</span></span>(<span>filespec, fmt)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>filespec:
fmt:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_document_loader(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec:
      fmt:

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, DOCUMENT_LOADERS, &#34;load&#34;, &#34;document&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_document_saver"><code class="name flex">
<span>def <span class="ident">get_document_saver</span></span>(<span>filespec, fmt)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>filespec:
fmt:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_document_saver(filespec, fmt):
    &#34;&#34;&#34;

    Args:
      filespec:
      fmt:

    Returns:

    &#34;&#34;&#34;
    return get_handler(filespec, fmt, DOCUMENT_SAVERS, &#34;save&#34;, &#34;document&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.get_handler"><code class="name flex">
<span>def <span class="ident">get_handler</span></span>(<span>filespec, fmt, handlers, saveload, what)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>filespec:
fmt:
handlers:
saveload:
what:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_handler(filespec, fmt, handlers, saveload, what):
    &#34;&#34;&#34;

    Args:
      filespec:
      fmt:
      handlers:
      saveload:
      what:

    Returns:

    &#34;&#34;&#34;
    msg = f&#34;Could not determine how to {saveload} {what} for format {fmt} in module gatenlp.serialization.default&#34;
    if fmt:
        handler = handlers.get(fmt)
        if not handler:
            raise Exception(msg)
        return handler
    else:
        if not filespec:  # in case of save_mem
            raise Exception(msg)
        if isinstance(filespec, os.PathLike):
            wf = os.fspath(filespec)
        elif isinstance(filespec, str):
            wf = filespec
        else:
            raise Exception(msg)
        name, ext = os.path.splitext(wf)
        if ext == &#34;.gz&#34;:
            ext2 = os.path.splitext(name)[1]
            if ext2:
                ext2 = ext2[1:]
            ext = ext2 + ext
        elif ext:
            ext = ext[1:]
        fmt = EXTENSIONS.get(ext)
        msg = f&#34;Could not determine how to {saveload} {what} for format {fmt} and with &#34; \
              &#34;extension {ext} in module gatenlp.serialization.default&#34;
        if not fmt:
            raise Exception(msg)
        handler = handlers.get(fmt)
        if not handler:
            raise Exception(msg)
        return handler</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.serialization.default.GateXmlLoader"><code class="flex name class">
<span>class <span class="ident">GateXmlLoader</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GateXmlLoader:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def value4objectwrapper(text):
        &#34;&#34;&#34;This may one day convert things like lists, maps, shared objects to Python, but for
        now we always throw an exeption.

        Args:
          text: return:

        Returns:

        &#34;&#34;&#34;
        raise Exception(
            &#34;Cannot load GATE XML which contains gate.corpora.ObjectWrapper data&#34;
        )

    @staticmethod
    def load(clazz, from_ext=None, ignore_unknown_types=False):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          ignore_unknown_types: (Default value = False)

        Returns:

        &#34;&#34;&#34;
        # TODO: the code below is just an outline and needs work!
        # TODO: make use of the test document created in repo project-python-gatenlp
        import xml.etree.ElementTree as ET

        isurl, extstr = is_url(from_ext)
        if isurl:
            xmlstring = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
            root = ET.fromstring(xmlstring)
        else:
            tree = ET.parse(extstr)
            root = tree.getroot()

        # or: root = ET.fromstring(xmlstring)

        # check we do have a GATE document

        assert root.tag == &#34;GateDocument&#34;
        assert root.attrib == {&#34;version&#34;: &#34;3&#34;}

        def parsefeatures(feats):
            &#34;&#34;&#34;

            Args:
              feats:

            Returns:

            &#34;&#34;&#34;
            features = {}
            for feat in list(feats):
                name = None
                value = None
                for el in list(feat):
                    if el.tag == &#34;Name&#34;:
                        if el.get(&#34;className&#34;) == &#34;java.lang.String&#34;:
                            name = el.text
                        else:
                            raise Exception(
                                &#34;Odd Feature Name type: &#34; + el.get(&#34;className&#34;)
                            )
                    elif el.tag == &#34;Value&#34;:
                        cls_name = el.get(&#34;className&#34;)
                        if cls_name == &#34;java.lang.String&#34;:
                            value = el.text
                        elif cls_name == &#34;java.lang.Integer&#34;:
                            value = int(el.text)
                        elif cls_name == &#34;java.lang.Long&#34;:
                            value = int(el.text)
                        elif cls_name == &#34;java.math.BigDecimal&#34;:
                            value = float(el.text)
                        elif cls_name == &#34;java.lang.Boolean&#34;:
                            value = bool(el.text)
                        # elif cls_name == &#34;gate.corpora.ObjectWrapper&#34;:
                        #    value = GateXmlLoader.value4objectwrapper(el.text)
                        else:
                            if ignore_unknown_types:
                                print(
                                    f&#34;Warning: ignoring feature with serialization type: {cls_name}&#34;,
                                    file=sys.stderr,
                                )
                            else:
                                raise Exception(
                                    &#34;Unsupported serialization type: &#34;
                                    + el.get(&#34;className&#34;)
                                )
                if name is not None and value is not None:
                    features[name] = value
            return features

        # get the document features
        docfeatures = {}
        feats = root.findall(&#34;./GateDocumentFeatures/Feature&#34;)

        docfeatures = parsefeatures(feats)

        textwithnodes = root.findall(&#34;./TextWithNodes&#34;)
        text = &#34;&#34;
        node2offset = {}
        curoff = 0
        for item in textwithnodes:
            if item.text:
                print(&#34;Got item text: &#34;, item.text)
                text += item.text
                # TODO HTML unescape item text
                curoff += len(item.text)
            for node in item:
                nodeid = node.get(&#34;id&#34;)
                node2offset[nodeid] = curoff
                if node.tail:
                    # TODO: unescape item.text?
                    print(&#34;Gote node tail: &#34;, node.tail)
                    text += node.tail
                    curoff += len(node.tail)

        annsets = root.findall(&#34;./AnnotationSet&#34;)

        annotation_sets = {}  # map name - set
        for annset in annsets:
            if annset.get(&#34;Name&#34;):
                setname = annset.get(&#34;Name&#34;)
            else:
                setname = &#34;&#34;
            annots = annset.findall(&#34;./Annotation&#34;)
            annotations = []
            maxannid = 0
            for ann in annots:
                annid = int(ann.attrib[&#34;Id&#34;])
                maxannid = max(maxannid, annid)
                anntype = ann.attrib[&#34;Type&#34;]
                startnode = ann.attrib[&#34;StartNode&#34;]
                endnode = ann.attrib[&#34;EndNode&#34;]
                startoff = node2offset[startnode]
                endoff = node2offset[endnode]
                feats = ann.findall(&#34;./Feature&#34;)
                features = parsefeatures(feats)
                if len(features) == 0:
                    features = None
                annotation = {
                    &#34;id&#34;: annid,
                    &#34;type&#34;: anntype,
                    &#34;start&#34;: startoff,
                    &#34;end&#34;: endoff,
                    &#34;features&#34;: features,
                }
                annotations.append(annotation)
            annset = {
                &#34;name&#34;: setname,
                &#34;annotations&#34;: annotations,
                &#34;next_annid&#34;: maxannid + 1,
            }
            annotation_sets[setname] = annset

        docmap = {
            &#34;text&#34;: text,
            &#34;features&#34;: docfeatures,
            &#34;offset_type&#34;: &#34;p&#34;,
            &#34;annotation_sets&#34;: annotation_sets,
        }

        doc = Document.from_dict(docmap)
        return doc</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.GateXmlLoader.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, ignore_unknown_types=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt>clazz:</dt>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>ignore_unknown_types</code></strong></dt>
<dd>(Default value = False)</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(clazz, from_ext=None, ignore_unknown_types=False):
    &#34;&#34;&#34;

    Args:
      clazz:
      from_ext: (Default value = None)
      ignore_unknown_types: (Default value = False)

    Returns:

    &#34;&#34;&#34;
    # TODO: the code below is just an outline and needs work!
    # TODO: make use of the test document created in repo project-python-gatenlp
    import xml.etree.ElementTree as ET

    isurl, extstr = is_url(from_ext)
    if isurl:
        xmlstring = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
        root = ET.fromstring(xmlstring)
    else:
        tree = ET.parse(extstr)
        root = tree.getroot()

    # or: root = ET.fromstring(xmlstring)

    # check we do have a GATE document

    assert root.tag == &#34;GateDocument&#34;
    assert root.attrib == {&#34;version&#34;: &#34;3&#34;}

    def parsefeatures(feats):
        &#34;&#34;&#34;

        Args:
          feats:

        Returns:

        &#34;&#34;&#34;
        features = {}
        for feat in list(feats):
            name = None
            value = None
            for el in list(feat):
                if el.tag == &#34;Name&#34;:
                    if el.get(&#34;className&#34;) == &#34;java.lang.String&#34;:
                        name = el.text
                    else:
                        raise Exception(
                            &#34;Odd Feature Name type: &#34; + el.get(&#34;className&#34;)
                        )
                elif el.tag == &#34;Value&#34;:
                    cls_name = el.get(&#34;className&#34;)
                    if cls_name == &#34;java.lang.String&#34;:
                        value = el.text
                    elif cls_name == &#34;java.lang.Integer&#34;:
                        value = int(el.text)
                    elif cls_name == &#34;java.lang.Long&#34;:
                        value = int(el.text)
                    elif cls_name == &#34;java.math.BigDecimal&#34;:
                        value = float(el.text)
                    elif cls_name == &#34;java.lang.Boolean&#34;:
                        value = bool(el.text)
                    # elif cls_name == &#34;gate.corpora.ObjectWrapper&#34;:
                    #    value = GateXmlLoader.value4objectwrapper(el.text)
                    else:
                        if ignore_unknown_types:
                            print(
                                f&#34;Warning: ignoring feature with serialization type: {cls_name}&#34;,
                                file=sys.stderr,
                            )
                        else:
                            raise Exception(
                                &#34;Unsupported serialization type: &#34;
                                + el.get(&#34;className&#34;)
                            )
            if name is not None and value is not None:
                features[name] = value
        return features

    # get the document features
    docfeatures = {}
    feats = root.findall(&#34;./GateDocumentFeatures/Feature&#34;)

    docfeatures = parsefeatures(feats)

    textwithnodes = root.findall(&#34;./TextWithNodes&#34;)
    text = &#34;&#34;
    node2offset = {}
    curoff = 0
    for item in textwithnodes:
        if item.text:
            print(&#34;Got item text: &#34;, item.text)
            text += item.text
            # TODO HTML unescape item text
            curoff += len(item.text)
        for node in item:
            nodeid = node.get(&#34;id&#34;)
            node2offset[nodeid] = curoff
            if node.tail:
                # TODO: unescape item.text?
                print(&#34;Gote node tail: &#34;, node.tail)
                text += node.tail
                curoff += len(node.tail)

    annsets = root.findall(&#34;./AnnotationSet&#34;)

    annotation_sets = {}  # map name - set
    for annset in annsets:
        if annset.get(&#34;Name&#34;):
            setname = annset.get(&#34;Name&#34;)
        else:
            setname = &#34;&#34;
        annots = annset.findall(&#34;./Annotation&#34;)
        annotations = []
        maxannid = 0
        for ann in annots:
            annid = int(ann.attrib[&#34;Id&#34;])
            maxannid = max(maxannid, annid)
            anntype = ann.attrib[&#34;Type&#34;]
            startnode = ann.attrib[&#34;StartNode&#34;]
            endnode = ann.attrib[&#34;EndNode&#34;]
            startoff = node2offset[startnode]
            endoff = node2offset[endnode]
            feats = ann.findall(&#34;./Feature&#34;)
            features = parsefeatures(feats)
            if len(features) == 0:
                features = None
            annotation = {
                &#34;id&#34;: annid,
                &#34;type&#34;: anntype,
                &#34;start&#34;: startoff,
                &#34;end&#34;: endoff,
                &#34;features&#34;: features,
            }
            annotations.append(annotation)
        annset = {
            &#34;name&#34;: setname,
            &#34;annotations&#34;: annotations,
            &#34;next_annid&#34;: maxannid + 1,
        }
        annotation_sets[setname] = annset

    docmap = {
        &#34;text&#34;: text,
        &#34;features&#34;: docfeatures,
        &#34;offset_type&#34;: &#34;p&#34;,
        &#34;annotation_sets&#34;: annotation_sets,
    }

    doc = Document.from_dict(docmap)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.GateXmlLoader.value4objectwrapper"><code class="name flex">
<span>def <span class="ident">value4objectwrapper</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>This may one day convert things like lists, maps, shared objects to Python, but for
now we always throw an exeption.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>return:</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def value4objectwrapper(text):
    &#34;&#34;&#34;This may one day convert things like lists, maps, shared objects to Python, but for
    now we always throw an exeption.

    Args:
      text: return:

    Returns:

    &#34;&#34;&#34;
    raise Exception(
        &#34;Cannot load GATE XML which contains gate.corpora.ObjectWrapper data&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.HtmlAnnViewerSerializer"><code class="flex name class">
<span>class <span class="ident">HtmlAnnViewerSerializer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HtmlAnnViewerSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def javascript():
        &#34;&#34;&#34;
        Return the Javascript needed for the HTML Annotation viewer.

        Returns: Javascript string.

        &#34;&#34;&#34;
        jsloc = os.path.join(
            os.path.dirname(__file__), &#34;_htmlviewer&#34;, JS_GATENLP_FILE_NAME
        )
        if not os.path.exists(jsloc):
            raise Exception(
                &#34;Could not find JavsScript file, {} does not exist&#34;.format(jsloc)
            )
        with open(jsloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
            js = infp.read()
            js = &#34;&#34;&#34;&lt;script type=&#34;text/javascript&#34;&gt;&#34;&#34;&#34; + js + &#34;&lt;/script&gt;&#34;
        return js

    @staticmethod
    def init_javscript():
        import IPython

        IPython.display.display_html(HtmlAnnViewerSerializer.javascript(), raw=True)

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        notebook=False,
        offline=False,
        add_js=True,
        htmlid=None,
        stretch_height=False,
        annsets=None,
        doc_style=None,
        **kwargs,
    ):
        &#34;&#34;&#34;Convert a document to HTML for visualizing it.

        Args:
            clazz: the class of the object to save
            inst: the instance/object to save
            to_ext:  the destination where to save to unless to_mem is given
            to_mem: if true, ignores to_ext and returns the representation
            notebook: if True only create a div which can be injected into a notebook or other HTML, otherwise
                generate a full HTML document
            offline: if true, include all the Javascript needed in the generated HTML , otherwise load library
                from the internet.
            add_js: if true (default), add the necessary Javascript either directly or by loading a library from
                the internet. If false, assume that the Javascript is already there (only makes sense with
                notebook=True).
            htmlid: the id to use for HTML ids so it is possible to have several independent viewers in the
                same HTML page and to style the output from a separate notebook cell
            max_height1: if this is set, then the maximum height of the first row of the viewer is set to the
                given value (default: 20em). If this is None, then the height is set to
            stretch_height: if False, rows 1 and 2 of the viewer will not have the height set, but only
                min and max height (default min is 10em for row1 and 7em for row2, max is the double of those).
                If True, no max haight is set and instead the height is set to a percentage (default is
                67vh for row 1 and 30vh for row 2). The values used can be changed via gateconfig.
            annsets: if None, include all annotation sets and types, otherwise this should be a list of either
                set names, or tuples, where the first entry is a set name and the second entry is either a type
                name or list of type names to include.
            doc_style: if not None, any additional styling for the document text box, if None, use whatever
                is defined in gatenlpconfig or do not use.
            kwargs: swallow any other kwargs.

        Returns: if to_mem is True, returns the representation, otherwise None.

        &#34;&#34;&#34;
        if not isinstance(inst, Document):
            raise Exception(&#34;Not a document!&#34;)
        # TODO: why are we doing a deepcopy here?
        doccopy = inst.deepcopy(annsets=annsets)
        doccopy.to_offset_type(&#34;j&#34;)
        json = doccopy.save_mem(fmt=&#34;json&#34;, **kwargs)
        htmlloc = os.path.join(
            os.path.dirname(__file__), &#34;_htmlviewer&#34;, HTML_TEMPLATE_FILE_NAME
        )
        if not os.path.exists(htmlloc):
            raise Exception(
                &#34;Could not find HTML template, {} does not exist&#34;.format(htmlloc)
            )
        with open(htmlloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
            html = infp.read()
        txtcolor = gatenlpconfig.doc_html_repr_txtcolor
        if notebook:
            str_start = &#34;&lt;!--STARTDIV--&gt;&#34;
            str_end = &#34;&lt;!--ENDDIV--&gt;&#34;
            idx1 = html.find(str_start) + len(str_start)
            idx2 = html.find(str_end)
            if htmlid:
                rndpref = str(htmlid)
            else:
                rndpref = &#34;&#34;.join(choice(ascii_uppercase) for i in range(10))
            html = html[idx1:idx2]
            html = f&#34;&#34;&#34;&lt;div&gt;&lt;style&gt;#{rndpref}-wrapper {{ color: {txtcolor} !important; }}&lt;/style&gt;
&lt;div id=&#34;{rndpref}-wrapper&#34;&gt;
{html}
&lt;/div&gt;&lt;/div&gt;&#34;&#34;&#34;
            # replace the prefix with a random one
            html = html.replace(&#34;GATENLPID&#34;, rndpref)
        if offline:
            # global html_ann_viewer_serializer_js_loaded
            # if not html_ann_viewer_serializer_js_loaded:
            if add_js:
                jsloc = os.path.join(
                    os.path.dirname(__file__), &#34;_htmlviewer&#34;, JS_GATENLP_FILE_NAME
                )
                if not os.path.exists(jsloc):
                    raise Exception(
                        &#34;Could not find JavsScript file, {} does not exist&#34;.format(
                            jsloc
                        )
                    )
                with open(jsloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
                    js = infp.read()
                    js = &#34;&#34;&#34;&lt;script type=&#34;text/javascript&#34;&gt;&#34;&#34;&#34; + js + &#34;&lt;/script&gt;&#34;
                # html_ann_viewer_serializer_js_loaded = True
            else:
                js = &#34;&#34;
        else:
            js = JS_JQUERY + JS_GATENLP
        if stretch_height:
            height1 = gatenlpconfig.doc_html_repr_height1_stretch
            height2 = gatenlpconfig.doc_html_repr_height2_stretch
        else:
            height1 = gatenlpconfig.doc_html_repr_height1_nostretch
            height2 = gatenlpconfig.doc_html_repr_height2_nostretch
        html = html.replace(&#34;$$JAVASCRIPT$$&#34;, js, 1).replace(&#34;$$JSONDATA$$&#34;, json, 1)
        html = html.replace(&#34;$$HEIGHT1$$&#34;, height1, 1).replace(
            &#34;$$HEIGHT2$$&#34;, height2, 1
        )
        if doc_style is None:
            doc_style = gatenlpconfig.doc_html_repr_doc_style
        if doc_style is None:
            doc_style = &#34;&#34;
        html = html.replace(&#34;$$DOCTEXTSTYLE$$&#34;, doc_style, 1)
        if to_mem:
            return html
        else:
            with open(to_ext, &#34;wt&#34;, encoding=&#34;utf-8&#34;) as outfp:
                outfp.write(html)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.HtmlAnnViewerSerializer.init_javscript"><code class="name flex">
<span>def <span class="ident">init_javscript</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def init_javscript():
    import IPython

    IPython.display.display_html(HtmlAnnViewerSerializer.javascript(), raw=True)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.HtmlAnnViewerSerializer.javascript"><code class="name flex">
<span>def <span class="ident">javascript</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the Javascript needed for the HTML Annotation viewer.</p>
<p>Returns: Javascript string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def javascript():
    &#34;&#34;&#34;
    Return the Javascript needed for the HTML Annotation viewer.

    Returns: Javascript string.

    &#34;&#34;&#34;
    jsloc = os.path.join(
        os.path.dirname(__file__), &#34;_htmlviewer&#34;, JS_GATENLP_FILE_NAME
    )
    if not os.path.exists(jsloc):
        raise Exception(
            &#34;Could not find JavsScript file, {} does not exist&#34;.format(jsloc)
        )
    with open(jsloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
        js = infp.read()
        js = &#34;&#34;&#34;&lt;script type=&#34;text/javascript&#34;&gt;&#34;&#34;&#34; + js + &#34;&lt;/script&gt;&#34;
    return js</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.HtmlAnnViewerSerializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, notebook=False, offline=False, add_js=True, htmlid=None, stretch_height=False, annsets=None, doc_style=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a document to HTML for visualizing it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>the class of the object to save</dd>
<dt><strong><code>inst</code></strong></dt>
<dd>the instance/object to save</dd>
<dt><strong><code>to_ext</code></strong></dt>
<dd>the destination where to save to unless to_mem is given</dd>
<dt><strong><code>to_mem</code></strong></dt>
<dd>if true, ignores to_ext and returns the representation</dd>
<dt><strong><code>notebook</code></strong></dt>
<dd>if True only create a div which can be injected into a notebook or other HTML, otherwise
generate a full HTML document</dd>
<dt><strong><code>offline</code></strong></dt>
<dd>if true, include all the Javascript needed in the generated HTML , otherwise load library
from the internet.</dd>
<dt><strong><code>add_js</code></strong></dt>
<dd>if true (default), add the necessary Javascript either directly or by loading a library from
the internet. If false, assume that the Javascript is already there (only makes sense with
notebook=True).</dd>
<dt><strong><code>htmlid</code></strong></dt>
<dd>the id to use for HTML ids so it is possible to have several independent viewers in the
same HTML page and to style the output from a separate notebook cell</dd>
<dt><strong><code>max_height1</code></strong></dt>
<dd>if this is set, then the maximum height of the first row of the viewer is set to the
given value (default: 20em). If this is None, then the height is set to</dd>
<dt><strong><code>stretch_height</code></strong></dt>
<dd>if False, rows 1 and 2 of the viewer will not have the height set, but only
min and max height (default min is 10em for row1 and 7em for row2, max is the double of those).
If True, no max haight is set and instead the height is set to a percentage (default is
67vh for row 1 and 30vh for row 2). The values used can be changed via gateconfig.</dd>
<dt><strong><code>annsets</code></strong></dt>
<dd>if None, include all annotation sets and types, otherwise this should be a list of either
set names, or tuples, where the first entry is a set name and the second entry is either a type
name or list of type names to include.</dd>
<dt><strong><code>doc_style</code></strong></dt>
<dd>if not None, any additional styling for the document text box, if None, use whatever
is defined in gatenlpconfig or do not use.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>swallow any other kwargs.</dd>
</dl>
<p>Returns: if to_mem is True, returns the representation, otherwise None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        notebook=False,
        offline=False,
        add_js=True,
        htmlid=None,
        stretch_height=False,
        annsets=None,
        doc_style=None,
        **kwargs,
    ):
        &#34;&#34;&#34;Convert a document to HTML for visualizing it.

        Args:
            clazz: the class of the object to save
            inst: the instance/object to save
            to_ext:  the destination where to save to unless to_mem is given
            to_mem: if true, ignores to_ext and returns the representation
            notebook: if True only create a div which can be injected into a notebook or other HTML, otherwise
                generate a full HTML document
            offline: if true, include all the Javascript needed in the generated HTML , otherwise load library
                from the internet.
            add_js: if true (default), add the necessary Javascript either directly or by loading a library from
                the internet. If false, assume that the Javascript is already there (only makes sense with
                notebook=True).
            htmlid: the id to use for HTML ids so it is possible to have several independent viewers in the
                same HTML page and to style the output from a separate notebook cell
            max_height1: if this is set, then the maximum height of the first row of the viewer is set to the
                given value (default: 20em). If this is None, then the height is set to
            stretch_height: if False, rows 1 and 2 of the viewer will not have the height set, but only
                min and max height (default min is 10em for row1 and 7em for row2, max is the double of those).
                If True, no max haight is set and instead the height is set to a percentage (default is
                67vh for row 1 and 30vh for row 2). The values used can be changed via gateconfig.
            annsets: if None, include all annotation sets and types, otherwise this should be a list of either
                set names, or tuples, where the first entry is a set name and the second entry is either a type
                name or list of type names to include.
            doc_style: if not None, any additional styling for the document text box, if None, use whatever
                is defined in gatenlpconfig or do not use.
            kwargs: swallow any other kwargs.

        Returns: if to_mem is True, returns the representation, otherwise None.

        &#34;&#34;&#34;
        if not isinstance(inst, Document):
            raise Exception(&#34;Not a document!&#34;)
        # TODO: why are we doing a deepcopy here?
        doccopy = inst.deepcopy(annsets=annsets)
        doccopy.to_offset_type(&#34;j&#34;)
        json = doccopy.save_mem(fmt=&#34;json&#34;, **kwargs)
        htmlloc = os.path.join(
            os.path.dirname(__file__), &#34;_htmlviewer&#34;, HTML_TEMPLATE_FILE_NAME
        )
        if not os.path.exists(htmlloc):
            raise Exception(
                &#34;Could not find HTML template, {} does not exist&#34;.format(htmlloc)
            )
        with open(htmlloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
            html = infp.read()
        txtcolor = gatenlpconfig.doc_html_repr_txtcolor
        if notebook:
            str_start = &#34;&lt;!--STARTDIV--&gt;&#34;
            str_end = &#34;&lt;!--ENDDIV--&gt;&#34;
            idx1 = html.find(str_start) + len(str_start)
            idx2 = html.find(str_end)
            if htmlid:
                rndpref = str(htmlid)
            else:
                rndpref = &#34;&#34;.join(choice(ascii_uppercase) for i in range(10))
            html = html[idx1:idx2]
            html = f&#34;&#34;&#34;&lt;div&gt;&lt;style&gt;#{rndpref}-wrapper {{ color: {txtcolor} !important; }}&lt;/style&gt;
&lt;div id=&#34;{rndpref}-wrapper&#34;&gt;
{html}
&lt;/div&gt;&lt;/div&gt;&#34;&#34;&#34;
            # replace the prefix with a random one
            html = html.replace(&#34;GATENLPID&#34;, rndpref)
        if offline:
            # global html_ann_viewer_serializer_js_loaded
            # if not html_ann_viewer_serializer_js_loaded:
            if add_js:
                jsloc = os.path.join(
                    os.path.dirname(__file__), &#34;_htmlviewer&#34;, JS_GATENLP_FILE_NAME
                )
                if not os.path.exists(jsloc):
                    raise Exception(
                        &#34;Could not find JavsScript file, {} does not exist&#34;.format(
                            jsloc
                        )
                    )
                with open(jsloc, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
                    js = infp.read()
                    js = &#34;&#34;&#34;&lt;script type=&#34;text/javascript&#34;&gt;&#34;&#34;&#34; + js + &#34;&lt;/script&gt;&#34;
                # html_ann_viewer_serializer_js_loaded = True
            else:
                js = &#34;&#34;
        else:
            js = JS_JQUERY + JS_GATENLP
        if stretch_height:
            height1 = gatenlpconfig.doc_html_repr_height1_stretch
            height2 = gatenlpconfig.doc_html_repr_height2_stretch
        else:
            height1 = gatenlpconfig.doc_html_repr_height1_nostretch
            height2 = gatenlpconfig.doc_html_repr_height2_nostretch
        html = html.replace(&#34;$$JAVASCRIPT$$&#34;, js, 1).replace(&#34;$$JSONDATA$$&#34;, json, 1)
        html = html.replace(&#34;$$HEIGHT1$$&#34;, height1, 1).replace(
            &#34;$$HEIGHT2$$&#34;, height2, 1
        )
        if doc_style is None:
            doc_style = gatenlpconfig.doc_html_repr_doc_style
        if doc_style is None:
            doc_style = &#34;&#34;
        html = html.replace(&#34;$$DOCTEXTSTYLE$$&#34;, doc_style, 1)
        if to_mem:
            return html
        else:
            with open(to_ext, &#34;wt&#34;, encoding=&#34;utf-8&#34;) as outfp:
                outfp.write(html)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.HtmlLoader"><code class="flex name class">
<span>class <span class="ident">HtmlLoader</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HtmlLoader:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def load_rendered(
        clazz,
        from_ext=None,
        from_mem=None,
        parser=None,
        markup_set_name=&#34;Original markups&#34;,
        process_soup=None,
        offset_mapper=None,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          parser: (Default value = None)
          markup_set_name: (Default value = &#34;Original markups&#34;)
          process_soup: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        raise Exception(&#34;Rendered html parser not yet implemented&#34;)

    @staticmethod
    def load(
        clazz,
        from_ext=None,
        from_mem=None,
        parser=&#34;html.parser&#34;,
        markup_set_name=&#34;Original markups&#34;,
        encoding=None,
        **kwargs,
    ):
        &#34;&#34;&#34;Load a HTML file.

        Args:
            clazz: param from_ext:
            from_ext: file our URL source
            from_mem:  string source
            parser: one of &#34;html.parser&#34;, &#34;lxml&#34;, &#34;lxml-xml&#34;, &#34;html5lib&#34; (default is &#34;html.parser&#34;)
            markup_set_name: the annotation set name for the set to contain the HTML
                annotations (Default value = &#34;Original markups&#34;)
            encoding: the encoding to use for reading the file
        &#34;&#34;&#34;
        # NOTE: for now we have a simple heuristic for adding newlines to the text:
        # before and after a block element, a newline is added unless there is already one
        # NOTE: for now we use  multi_valued_attributes=None which prevents attributes of the
        # form &#34;class=&#39;val1 val2&#39;&#34; to get converted into features with a list of values.
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                from_mem = get_str_from_url(extstr, encoding=encoding)
        if from_mem:
            bs = BeautifulSoup(from_mem, features=parser, multi_valued_attributes=None)
        else:
            with open(extstr, encoding=encoding) as infp:
                bs = BeautifulSoup(infp, features=parser, multi_valued_attributes=None)
        # we recursively iterate the tree depth first, going through the children
        # and adding to a list that either contains the text or a dict with the information
        # about annotations we want to add
        nlels = {
            &#34;pre&#34;,
            &#34;br&#34;,
            &#34;p&#34;,
            &#34;div&#34;,
            &#34;tr&#34;,
            &#34;h1&#34;,
            &#34;h2&#34;,
            &#34;h3&#34;,
            &#34;h4&#34;,
            &#34;h5&#34;,
            &#34;h6&#34;,
            &#34;li&#34;,
            &#34;address&#34;,
            &#34;article&#34;,
            &#34;aside&#34;,
            &#34;blockquote&#34;,
            &#34;del&#34;,
            &#34;figure&#34;,
            &#34;figcaption&#34;,
            &#34;footer&#34;,
            &#34;header&#34;,
            &#34;hr&#34;,
            &#34;ins&#34;,
            &#34;main&#34;,
            &#34;nav&#34;,
            &#34;section&#34;,
            &#34;summary&#34;,
            &#34;input&#34;,
            &#34;legend&#34;,
            &#34;option&#34;,
            &#34;textarea&#34;,
            &#34;bdi&#34;,
            &#34;bdo&#34;,
            &#34;center&#34;,
            &#34;code&#34;,
            &#34;dfn&#34;,
            &#34;menu&#34;,
            &#34;dir&#34;,
            &#34;caption&#34;,
        }
        ignoreels = {&#34;script&#34;, &#34;style&#34;}
        docinfo = {&#34;anninfos&#34;: [], &#34;curoffset&#34;: 0, &#34;curid&#34;: 0, &#34;text&#34;: &#34;&#34;}

        def walktree(el):
            &#34;&#34;&#34;

            Args:
              el:

            Returns:

            &#34;&#34;&#34;
            # print(&#34;DEBUG: type=&#34;, type(el))
            if isinstance(el, bs4.element.Doctype):
                # print(&#34;DEBUG: got doctype&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Comment):
                # print(&#34;DEBUG: got Comment&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Script):
                # print(&#34;DEBUG: got Script&#34;, type(el))
                pass
            elif isinstance(el, bs4.element.Tag):
                # print(&#34;DEBUG: got tag: &#34;, type(el), &#34; name=&#34;,el.name)
                # some tags we ignore completely:
                if el.name in ignoreels:
                    return
                # for some tags we insert a new line before, but only if we do not already have one
                if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and el.name in nlels:
                    docinfo[&#34;text&#34;] += &#34;\n&#34;
                    # print(&#34;DEBUG: adding newline before at &#34;, docinfo[&#34;curoffset&#34;])
                    docinfo[&#34;curoffset&#34;] += 1
                ann = {
                    &#34;type&#34;: el.name,
                    &#34;features&#34;: el.attrs,
                    &#34;id&#34;: docinfo[&#34;curid&#34;],
                    &#34;event&#34;: &#34;start&#34;,
                    &#34;start&#34;: docinfo[&#34;curoffset&#34;],
                }
                thisid = docinfo[&#34;curid&#34;]
                docinfo[&#34;anninfos&#34;].append(ann)
                docinfo[&#34;curid&#34;] += 1
                for child in el.children:
                    walktree(child)
                # for some tags we insert a new line after
                if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and el.name in nlels:
                    docinfo[&#34;text&#34;] += &#34;\n&#34;
                    # print(&#34;DEBUG: adding newline after at &#34;, docinfo[&#34;curoffset&#34;])
                    docinfo[&#34;curoffset&#34;] += 1
                docinfo[&#34;anninfos&#34;].append(
                    {&#34;event&#34;: &#34;end&#34;, &#34;id&#34;: thisid, &#34;end&#34;: docinfo[&#34;curoffset&#34;]}
                )
            elif isinstance(el, bs4.element.NavigableString):
                # print(&#34;DEBUG: got text: &#34;, el)
                text = str(el)
                if text == &#34;\n&#34; and docinfo[&#34;text&#34;].endswith(&#34;\n&#34;):
                    return
                docinfo[&#34;text&#34;] += text
                docinfo[&#34;curoffset&#34;] += len(el)
            else:
                print(&#34;WARNING: odd element type&#34;, type(el))

        walktree(bs)
        # need to add the end corresponding to bs
        # print(&#34;DEBUG: got docinfo:\n&#34;,docinfo)
        id2anninfo = {}  # from id to anninfo
        nstart = 0
        for anninfo in docinfo[&#34;anninfos&#34;]:
            if anninfo[&#34;event&#34;] == &#34;start&#34;:
                nstart += 1
                id2anninfo[anninfo[&#34;id&#34;]] = anninfo
        nend = 0
        for anninfo in docinfo[&#34;anninfos&#34;]:
            if anninfo[&#34;event&#34;] == &#34;end&#34;:
                nend += 1
                end = anninfo[&#34;end&#34;]
                annid = anninfo[&#34;id&#34;]
                anninfo = id2anninfo[annid]
                anninfo[&#34;end&#34;] = end
        # print(&#34;DEBUG: got nstart/nend&#34;, nstart, nend)
        assert nstart == nend
        # print(&#34;DEBUG: got id2anninfo:\n&#34;, id2anninfo)
        doc = Document(docinfo[&#34;text&#34;])
        annset = doc.annset(markup_set_name)
        for i in range(nstart):
            anninfo = id2anninfo[i]
            annset.add(
                anninfo[&#34;start&#34;],
                anninfo[&#34;end&#34;],
                anntype=anninfo[&#34;type&#34;],
                features=anninfo[&#34;features&#34;],
            )
        return doc</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.HtmlLoader.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, parser='html.parser', markup_set_name='Original markups', encoding=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a HTML file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>param from_ext:</dd>
<dt><strong><code>from_ext</code></strong></dt>
<dd>file our URL source</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>string source</dd>
<dt><strong><code>parser</code></strong></dt>
<dd>one of "html.parser", "lxml", "lxml-xml", "html5lib" (default is "html.parser")</dd>
<dt><strong><code>markup_set_name</code></strong></dt>
<dd>the annotation set name for the set to contain the HTML
annotations (Default value = "Original markups")</dd>
<dt><strong><code>encoding</code></strong></dt>
<dd>the encoding to use for reading the file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(
    clazz,
    from_ext=None,
    from_mem=None,
    parser=&#34;html.parser&#34;,
    markup_set_name=&#34;Original markups&#34;,
    encoding=None,
    **kwargs,
):
    &#34;&#34;&#34;Load a HTML file.

    Args:
        clazz: param from_ext:
        from_ext: file our URL source
        from_mem:  string source
        parser: one of &#34;html.parser&#34;, &#34;lxml&#34;, &#34;lxml-xml&#34;, &#34;html5lib&#34; (default is &#34;html.parser&#34;)
        markup_set_name: the annotation set name for the set to contain the HTML
            annotations (Default value = &#34;Original markups&#34;)
        encoding: the encoding to use for reading the file
    &#34;&#34;&#34;
    # NOTE: for now we have a simple heuristic for adding newlines to the text:
    # before and after a block element, a newline is added unless there is already one
    # NOTE: for now we use  multi_valued_attributes=None which prevents attributes of the
    # form &#34;class=&#39;val1 val2&#39;&#34; to get converted into features with a list of values.
    isurl, extstr = is_url(from_ext)
    if from_ext is not None:
        if isurl:
            from_mem = get_str_from_url(extstr, encoding=encoding)
    if from_mem:
        bs = BeautifulSoup(from_mem, features=parser, multi_valued_attributes=None)
    else:
        with open(extstr, encoding=encoding) as infp:
            bs = BeautifulSoup(infp, features=parser, multi_valued_attributes=None)
    # we recursively iterate the tree depth first, going through the children
    # and adding to a list that either contains the text or a dict with the information
    # about annotations we want to add
    nlels = {
        &#34;pre&#34;,
        &#34;br&#34;,
        &#34;p&#34;,
        &#34;div&#34;,
        &#34;tr&#34;,
        &#34;h1&#34;,
        &#34;h2&#34;,
        &#34;h3&#34;,
        &#34;h4&#34;,
        &#34;h5&#34;,
        &#34;h6&#34;,
        &#34;li&#34;,
        &#34;address&#34;,
        &#34;article&#34;,
        &#34;aside&#34;,
        &#34;blockquote&#34;,
        &#34;del&#34;,
        &#34;figure&#34;,
        &#34;figcaption&#34;,
        &#34;footer&#34;,
        &#34;header&#34;,
        &#34;hr&#34;,
        &#34;ins&#34;,
        &#34;main&#34;,
        &#34;nav&#34;,
        &#34;section&#34;,
        &#34;summary&#34;,
        &#34;input&#34;,
        &#34;legend&#34;,
        &#34;option&#34;,
        &#34;textarea&#34;,
        &#34;bdi&#34;,
        &#34;bdo&#34;,
        &#34;center&#34;,
        &#34;code&#34;,
        &#34;dfn&#34;,
        &#34;menu&#34;,
        &#34;dir&#34;,
        &#34;caption&#34;,
    }
    ignoreels = {&#34;script&#34;, &#34;style&#34;}
    docinfo = {&#34;anninfos&#34;: [], &#34;curoffset&#34;: 0, &#34;curid&#34;: 0, &#34;text&#34;: &#34;&#34;}

    def walktree(el):
        &#34;&#34;&#34;

        Args:
          el:

        Returns:

        &#34;&#34;&#34;
        # print(&#34;DEBUG: type=&#34;, type(el))
        if isinstance(el, bs4.element.Doctype):
            # print(&#34;DEBUG: got doctype&#34;, type(el))
            pass
        elif isinstance(el, bs4.element.Comment):
            # print(&#34;DEBUG: got Comment&#34;, type(el))
            pass
        elif isinstance(el, bs4.element.Script):
            # print(&#34;DEBUG: got Script&#34;, type(el))
            pass
        elif isinstance(el, bs4.element.Tag):
            # print(&#34;DEBUG: got tag: &#34;, type(el), &#34; name=&#34;,el.name)
            # some tags we ignore completely:
            if el.name in ignoreels:
                return
            # for some tags we insert a new line before, but only if we do not already have one
            if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and el.name in nlels:
                docinfo[&#34;text&#34;] += &#34;\n&#34;
                # print(&#34;DEBUG: adding newline before at &#34;, docinfo[&#34;curoffset&#34;])
                docinfo[&#34;curoffset&#34;] += 1
            ann = {
                &#34;type&#34;: el.name,
                &#34;features&#34;: el.attrs,
                &#34;id&#34;: docinfo[&#34;curid&#34;],
                &#34;event&#34;: &#34;start&#34;,
                &#34;start&#34;: docinfo[&#34;curoffset&#34;],
            }
            thisid = docinfo[&#34;curid&#34;]
            docinfo[&#34;anninfos&#34;].append(ann)
            docinfo[&#34;curid&#34;] += 1
            for child in el.children:
                walktree(child)
            # for some tags we insert a new line after
            if not docinfo[&#34;text&#34;].endswith(&#34;\n&#34;) and el.name in nlels:
                docinfo[&#34;text&#34;] += &#34;\n&#34;
                # print(&#34;DEBUG: adding newline after at &#34;, docinfo[&#34;curoffset&#34;])
                docinfo[&#34;curoffset&#34;] += 1
            docinfo[&#34;anninfos&#34;].append(
                {&#34;event&#34;: &#34;end&#34;, &#34;id&#34;: thisid, &#34;end&#34;: docinfo[&#34;curoffset&#34;]}
            )
        elif isinstance(el, bs4.element.NavigableString):
            # print(&#34;DEBUG: got text: &#34;, el)
            text = str(el)
            if text == &#34;\n&#34; and docinfo[&#34;text&#34;].endswith(&#34;\n&#34;):
                return
            docinfo[&#34;text&#34;] += text
            docinfo[&#34;curoffset&#34;] += len(el)
        else:
            print(&#34;WARNING: odd element type&#34;, type(el))

    walktree(bs)
    # need to add the end corresponding to bs
    # print(&#34;DEBUG: got docinfo:\n&#34;,docinfo)
    id2anninfo = {}  # from id to anninfo
    nstart = 0
    for anninfo in docinfo[&#34;anninfos&#34;]:
        if anninfo[&#34;event&#34;] == &#34;start&#34;:
            nstart += 1
            id2anninfo[anninfo[&#34;id&#34;]] = anninfo
    nend = 0
    for anninfo in docinfo[&#34;anninfos&#34;]:
        if anninfo[&#34;event&#34;] == &#34;end&#34;:
            nend += 1
            end = anninfo[&#34;end&#34;]
            annid = anninfo[&#34;id&#34;]
            anninfo = id2anninfo[annid]
            anninfo[&#34;end&#34;] = end
    # print(&#34;DEBUG: got nstart/nend&#34;, nstart, nend)
    assert nstart == nend
    # print(&#34;DEBUG: got id2anninfo:\n&#34;, id2anninfo)
    doc = Document(docinfo[&#34;text&#34;])
    annset = doc.annset(markup_set_name)
    for i in range(nstart):
        anninfo = id2anninfo[i]
        annset.add(
            anninfo[&#34;start&#34;],
            anninfo[&#34;end&#34;],
            anntype=anninfo[&#34;type&#34;],
            features=anninfo[&#34;features&#34;],
        )
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.HtmlLoader.load_rendered"><code class="name flex">
<span>def <span class="ident">load_rendered</span></span>(<span>clazz, from_ext=None, from_mem=None, parser=None, markup_set_name='Original markups', process_soup=None, offset_mapper=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt>clazz:</dt>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>parser</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>markup_set_name</code></strong></dt>
<dd>(Default value = "Original markups")</dd>
<dt><strong><code>process_soup</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
</dl>
<p>**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_rendered(
    clazz,
    from_ext=None,
    from_mem=None,
    parser=None,
    markup_set_name=&#34;Original markups&#34;,
    process_soup=None,
    offset_mapper=None,
    **kwargs,
):
    &#34;&#34;&#34;

    Args:
      clazz:
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      parser: (Default value = None)
      markup_set_name: (Default value = &#34;Original markups&#34;)
      process_soup: (Default value = None)
      offset_mapper: (Default value = None)
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    raise Exception(&#34;Rendered html parser not yet implemented&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.JsonSerializer"><code class="flex name class">
<span>class <span class="ident">JsonSerializer</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class performs the saving and load of Documents and ChangeLog instances to and from the
BDOC JSON format files, optionally with gzip compression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JsonSerializer:
    &#34;&#34;&#34;
    This class performs the saving and load of Documents and ChangeLog instances to and from the
    BDOC JSON format files, optionally with gzip compression.
    &#34;&#34;&#34;

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        offset_type=None,
        offset_mapper=None,
        gzip=False,
        annsets=None,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz: the class of the object that gets saved
          inst: the object to get saved
          to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
          to_mem: if True, return a String serialization
          offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
          offset_mapper: the offset mapper to use, only needed if the type needs to get converted
          gzip: if True, the JSON gets gzip compressed
          annsets: which annotation sets and types to include, list of set names or (setanmes, types) tuples
          **kwargs:
        &#34;&#34;&#34;
        d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, annsets=annsets, **kwargs)
        if to_mem:
            if gzip:
                compress(json.dumps(d).encode(&#34;UTF-8&#34;))
            else:
                return json.dumps(d)
        else:
            if gzip:
                with gopen(to_ext, JSON_WRITE) as outfp:
                    json.dump(d, outfp)
            else:
                with open(to_ext, JSON_WRITE) as outfp:
                    json.dump(d, outfp)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;
        Invokes the save method with gzip=True
        &#34;&#34;&#34;
        JsonSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(
        clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        # print(&#34;RUNNING load with from_ext=&#34;, from_ext, &#34; from_mem=&#34;, from_mem)

        if from_ext is not None and from_mem is not None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)
        if from_ext is None and from_mem is None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)

        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                # print(&#34;DEBUG: we got a URL&#34;)
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
            else:
                # print(&#34;DEBUG: not a URL !!!&#34;)
                pass
        if from_mem is not None:
            if gzip:
                d = json.loads(decompress(from_mem).decode(&#34;UTF-8&#34;))
            else:
                d = json.loads(from_mem)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        else:  # from_ext must have been not None and a path
            if gzip:
                with gopen(extstr, JSON_READ) as infp:
                    d = json.load(infp)
            else:
                with open(extstr, JSON_READ) as infp:
                    d = json.load(infp)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        return JsonSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.JsonSerializer.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt>clazz:</dt>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
</dl>
<p>**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(
    clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs
):
    &#34;&#34;&#34;

    Args:
      clazz:
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      gzip: (Default value = False)
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    # print(&#34;RUNNING load with from_ext=&#34;, from_ext, &#34; from_mem=&#34;, from_mem)

    if from_ext is not None and from_mem is not None:
        raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)
    if from_ext is None and from_mem is None:
        raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)

    isurl, extstr = is_url(from_ext)
    if from_ext is not None:
        if isurl:
            # print(&#34;DEBUG: we got a URL&#34;)
            if gzip:
                from_mem = get_bytes_from_url(extstr)
            else:
                from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
        else:
            # print(&#34;DEBUG: not a URL !!!&#34;)
            pass
    if from_mem is not None:
        if gzip:
            d = json.loads(decompress(from_mem).decode(&#34;UTF-8&#34;))
        else:
            d = json.loads(from_mem)
        doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
    else:  # from_ext must have been not None and a path
        if gzip:
            with gopen(extstr, JSON_READ) as infp:
                d = json.load(infp)
        else:
            with open(extstr, JSON_READ) as infp:
                d = json.load(infp)
        doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.JsonSerializer.load_gzip"><code class="name flex">
<span>def <span class="ident">load_gzip</span></span>(<span>clazz, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>clazz:
**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_gzip(clazz, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz:
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    return JsonSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.JsonSerializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, gzip=False, annsets=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>the class of the object that gets saved</dd>
<dt><strong><code>inst</code></strong></dt>
<dd>the object to get saved</dd>
<dt><strong><code>to_ext</code></strong></dt>
<dd>where to save to, this should be a file path, only one of to_ext and to_mem should be specified</dd>
<dt><strong><code>to_mem</code></strong></dt>
<dd>if True, return a String serialization</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>the offset type to use for saving, if None (default) use "p" (Python)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>the offset mapper to use, only needed if the type needs to get converted</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>if True, the JSON gets gzip compressed</dd>
<dt><strong><code>annsets</code></strong></dt>
<dd>which annotation sets and types to include, list of set names or (setanmes, types) tuples</dd>
</dl>
<p>**kwargs:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(
    clazz,
    inst,
    to_ext=None,
    to_mem=None,
    offset_type=None,
    offset_mapper=None,
    gzip=False,
    annsets=None,
    **kwargs,
):
    &#34;&#34;&#34;

    Args:
      clazz: the class of the object that gets saved
      inst: the object to get saved
      to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
      to_mem: if True, return a String serialization
      offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
      offset_mapper: the offset mapper to use, only needed if the type needs to get converted
      gzip: if True, the JSON gets gzip compressed
      annsets: which annotation sets and types to include, list of set names or (setanmes, types) tuples
      **kwargs:
    &#34;&#34;&#34;
    d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, annsets=annsets, **kwargs)
    if to_mem:
        if gzip:
            compress(json.dumps(d).encode(&#34;UTF-8&#34;))
        else:
            return json.dumps(d)
    else:
        if gzip:
            with gopen(to_ext, JSON_WRITE) as outfp:
                json.dump(d, outfp)
        else:
            with open(to_ext, JSON_WRITE) as outfp:
                json.dump(d, outfp)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.JsonSerializer.save_gzip"><code class="name flex">
<span>def <span class="ident">save_gzip</span></span>(<span>clazz, inst, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Invokes the save method with gzip=True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_gzip(clazz, inst, **kwargs):
    &#34;&#34;&#34;
    Invokes the save method with gzip=True
    &#34;&#34;&#34;
    JsonSerializer.save(clazz, inst, gzip=True, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.MsgPackSerializer"><code class="flex name class">
<span>class <span class="ident">MsgPackSerializer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MsgPackSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def document2stream(doc: Document, stream):
        &#34;&#34;&#34;

        Args:
          doc: Document:
          stream:
          doc: Document:

        Returns:

        &#34;&#34;&#34;
        pack(MSGPACK_VERSION_HDR, stream)
        pack(doc.offset_type, stream)
        pack(doc.text, stream)
        pack(doc.name, stream)
        pack(doc._features.to_dict(), stream)
        pack(len(doc._annotation_sets), stream)
        for name, annset in doc._annotation_sets.items():
            pack(name, stream)
            pack(annset._next_annid, stream)
            pack(len(annset), stream)
            for ann in annset.fast_iter():
                pack(ann.type, stream)
                pack(ann.start, stream)
                pack(ann.end, stream)
                pack(ann.id, stream)
                pack(ann.features.to_dict(), stream)

    @staticmethod
    def stream2document(stream):
        &#34;&#34;&#34;

        Args:
          stream:

        Returns:

        &#34;&#34;&#34;
        u = Unpacker(stream)
        version = u.unpack()
        if version != MSGPACK_VERSION_HDR:
            raise Exception(&#34;MsgPack data starts with wrong version&#34;)
        doc = Document()
        doc.offset_type = u.unpack()
        doc._text = u.unpack()
        doc.name = u.unpack()
        doc._features = Features(u.unpack())
        nsets = u.unpack()
        setsdict = dict()
        doc.annotation_sets = setsdict
        for iset in range(nsets):
            sname = u.unpack()
            if sname is None:
                sname = &#34;&#34;
            annset = AnnotationSet(name=sname, owner_doc=doc)
            annset._next_annid = u.unpack()
            nanns = u.unpack()
            for iann in range(nanns):
                atype = u.unpack()
                astart = u.unpack()
                aend = u.unpack()
                aid = u.unpack()
                afeatures = u.unpack()
                ann = Annotation(astart, aend, atype, annid=aid, features=afeatures)
                annset._annotations[aid] = ann
            setsdict[sname] = annset
        doc._annotation_sets = setsdict
        return doc

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        offset_type=None,
        offset_mapper=None,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          inst:
          to_ext: (Default value = None)
          to_mem: (Default value = None)
          offset_type: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        if isinstance(inst, Document):
            writer = MsgPackSerializer.document2stream
        elif isinstance(inst, ChangeLog):
            raise Exception(&#34;Not implemented yet&#34;)
        else:
            raise Exception(&#34;Object not supported&#34;)
        if to_mem:
            f = io.BytesIO()
        else:
            f = open(to_ext, &#34;wb&#34;)
        writer(inst, f)
        if to_mem:
            return f.getvalue()
        else:
            f.close()

    @staticmethod
    def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        if clazz == Document:
            reader = MsgPackSerializer.stream2document
        elif clazz == ChangeLog:
            raise Exception(&#34;Not implemented yet&#34;)
        else:
            raise Exception(&#34;Object not supported&#34;)

        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                from_mem = get_bytes_from_url(extstr)
        if from_mem:
            f = io.BytesIO(from_mem)
        else:
            f = open(extstr, &#34;rb&#34;)
        doc = reader(f)
        return doc</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.MsgPackSerializer.document2stream"><code class="name flex">
<span>def <span class="ident">document2stream</span></span>(<span>doc:<a title="gatenlp.document.Document" href="../document.html#gatenlp.document.Document">Document</a>, stream)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>doc</code></strong></dt>
<dd>Document:</dd>
<dt>stream:</dt>
<dt><strong><code>doc</code></strong></dt>
<dd>Document:</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def document2stream(doc: Document, stream):
    &#34;&#34;&#34;

    Args:
      doc: Document:
      stream:
      doc: Document:

    Returns:

    &#34;&#34;&#34;
    pack(MSGPACK_VERSION_HDR, stream)
    pack(doc.offset_type, stream)
    pack(doc.text, stream)
    pack(doc.name, stream)
    pack(doc._features.to_dict(), stream)
    pack(len(doc._annotation_sets), stream)
    for name, annset in doc._annotation_sets.items():
        pack(name, stream)
        pack(annset._next_annid, stream)
        pack(len(annset), stream)
        for ann in annset.fast_iter():
            pack(ann.type, stream)
            pack(ann.start, stream)
            pack(ann.end, stream)
            pack(ann.id, stream)
            pack(ann.features.to_dict(), stream)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.MsgPackSerializer.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, offset_mapper=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt>clazz:</dt>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
</dl>
<p>**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(clazz, from_ext=None, from_mem=None, offset_mapper=None, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz:
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    if clazz == Document:
        reader = MsgPackSerializer.stream2document
    elif clazz == ChangeLog:
        raise Exception(&#34;Not implemented yet&#34;)
    else:
        raise Exception(&#34;Object not supported&#34;)

    isurl, extstr = is_url(from_ext)
    if from_ext is not None:
        if isurl:
            from_mem = get_bytes_from_url(extstr)
    if from_mem:
        f = io.BytesIO(from_mem)
    else:
        f = open(extstr, &#34;rb&#34;)
    doc = reader(f)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.MsgPackSerializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt>clazz:</dt>
<dt>inst:</dt>
<dt><strong><code>to_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>to_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
</dl>
<p>**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(
    clazz,
    inst,
    to_ext=None,
    to_mem=None,
    offset_type=None,
    offset_mapper=None,
    **kwargs,
):
    &#34;&#34;&#34;

    Args:
      clazz:
      inst:
      to_ext: (Default value = None)
      to_mem: (Default value = None)
      offset_type: (Default value = None)
      offset_mapper: (Default value = None)
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    if isinstance(inst, Document):
        writer = MsgPackSerializer.document2stream
    elif isinstance(inst, ChangeLog):
        raise Exception(&#34;Not implemented yet&#34;)
    else:
        raise Exception(&#34;Object not supported&#34;)
    if to_mem:
        f = io.BytesIO()
    else:
        f = open(to_ext, &#34;wb&#34;)
    writer(inst, f)
    if to_mem:
        return f.getvalue()
    else:
        f.close()</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.MsgPackSerializer.stream2document"><code class="name flex">
<span>def <span class="ident">stream2document</span></span>(<span>stream)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>stream:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def stream2document(stream):
    &#34;&#34;&#34;

    Args:
      stream:

    Returns:

    &#34;&#34;&#34;
    u = Unpacker(stream)
    version = u.unpack()
    if version != MSGPACK_VERSION_HDR:
        raise Exception(&#34;MsgPack data starts with wrong version&#34;)
    doc = Document()
    doc.offset_type = u.unpack()
    doc._text = u.unpack()
    doc.name = u.unpack()
    doc._features = Features(u.unpack())
    nsets = u.unpack()
    setsdict = dict()
    doc.annotation_sets = setsdict
    for iset in range(nsets):
        sname = u.unpack()
        if sname is None:
            sname = &#34;&#34;
        annset = AnnotationSet(name=sname, owner_doc=doc)
        annset._next_annid = u.unpack()
        nanns = u.unpack()
        for iann in range(nanns):
            atype = u.unpack()
            astart = u.unpack()
            aend = u.unpack()
            aid = u.unpack()
            afeatures = u.unpack()
            ann = Annotation(astart, aend, atype, annid=aid, features=afeatures)
            annset._annotations[aid] = ann
        setsdict[sname] = annset
    doc._annotation_sets = setsdict
    return doc</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.PickleSerializer"><code class="flex name class">
<span>class <span class="ident">PickleSerializer</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class performs the saving and load of Documents and ChangeLog instances to and from pickle format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PickleSerializer:
    &#34;&#34;&#34;
    This class performs the saving and load of Documents and ChangeLog instances to and from pickle format.
    &#34;&#34;&#34;

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        offset_type=None,
        offset_mapper=None,
        gzip=False,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz: the class of the object that gets saved
          inst: the object to get saved
          to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
          to_mem: if True, return a String serialization
          offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
          offset_mapper: the offset mapper to use, only needed if the type needs to get converted
          gzip: must be False, gzip is not supported
          **kwargs:
        &#34;&#34;&#34;
        if gzip:
            raise Exception(&#34;Gzip not supported for pickle&#34;)
        if to_mem:
            return pickle.dumps(inst, protocol=-1)
        else:
            with open(to_ext, &#34;wb&#34;) as outfp:
                pickle.dump(inst, outfp, protocol=-1)

    @staticmethod
    def load(
        clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False) must be False, True not supported
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        # print(&#34;RUNNING load with from_ext=&#34;, from_ext, &#34; from_mem=&#34;, from_mem)

        if from_ext is not None and from_mem is not None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)
        if from_ext is None and from_mem is None:
            raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)

        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                from_mem = get_bytes_from_url(extstr)
            else:
                # print(&#34;DEBUG: not a URL !!!&#34;)
                pass
        if from_mem is not None:
            doc = pickle.loads(from_mem)
        else:  # from_ext must have been not None and a path
            with open(extstr, &#34;rb&#34;) as infp:
                doc = pickle.load(infp)
        return doc</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.PickleSerializer.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt>clazz:</dt>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False) must be False, True not supported</dd>
</dl>
<p>**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(
    clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs
):
    &#34;&#34;&#34;

    Args:
      clazz:
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      gzip: (Default value = False) must be False, True not supported
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    # print(&#34;RUNNING load with from_ext=&#34;, from_ext, &#34; from_mem=&#34;, from_mem)

    if from_ext is not None and from_mem is not None:
        raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)
    if from_ext is None and from_mem is None:
        raise Exception(&#34;Exactly one of from_ext and from_mem must be specified &#34;)

    isurl, extstr = is_url(from_ext)
    if from_ext is not None:
        if isurl:
            from_mem = get_bytes_from_url(extstr)
        else:
            # print(&#34;DEBUG: not a URL !!!&#34;)
            pass
    if from_mem is not None:
        doc = pickle.loads(from_mem)
    else:  # from_ext must have been not None and a path
        with open(extstr, &#34;rb&#34;) as infp:
            doc = pickle.load(infp)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.PickleSerializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>the class of the object that gets saved</dd>
<dt><strong><code>inst</code></strong></dt>
<dd>the object to get saved</dd>
<dt><strong><code>to_ext</code></strong></dt>
<dd>where to save to, this should be a file path, only one of to_ext and to_mem should be specified</dd>
<dt><strong><code>to_mem</code></strong></dt>
<dd>if True, return a String serialization</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>the offset type to use for saving, if None (default) use "p" (Python)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>the offset mapper to use, only needed if the type needs to get converted</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>must be False, gzip is not supported</dd>
</dl>
<p>**kwargs:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(
    clazz,
    inst,
    to_ext=None,
    to_mem=None,
    offset_type=None,
    offset_mapper=None,
    gzip=False,
    **kwargs,
):
    &#34;&#34;&#34;

    Args:
      clazz: the class of the object that gets saved
      inst: the object to get saved
      to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
      to_mem: if True, return a String serialization
      offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
      offset_mapper: the offset mapper to use, only needed if the type needs to get converted
      gzip: must be False, gzip is not supported
      **kwargs:
    &#34;&#34;&#34;
    if gzip:
        raise Exception(&#34;Gzip not supported for pickle&#34;)
    if to_mem:
        return pickle.dumps(inst, protocol=-1)
    else:
        with open(to_ext, &#34;wb&#34;) as outfp:
            pickle.dump(inst, outfp, protocol=-1)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.PlainTextSerializer"><code class="flex name class">
<span>class <span class="ident">PlainTextSerializer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlainTextSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        offset_type=None,
        offset_mapper=None,
        encoding=&#34;UTF-8&#34;,
        gzip=False,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          inst:
          to_ext: (Default value = None)
          to_mem: (Default value = None)
          offset_type: (Default value = None)
          offset_mapper: (Default value = None)
          encoding: (Default value = &#34;UTF-8&#34;)
          gzip: (Default value = False)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        txt = inst.text
        if txt is None:
            txt = &#34;&#34;
        if to_mem:
            if gzip:
                compress(txt.encode(encoding))
            else:
                return txt
        else:
            if gzip:
                with gopen(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                    outfp.write(txt)
            else:
                with open(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                    outfp.write(txt)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          inst:
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        PlainTextSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(
        clazz,
        from_ext=None,
        from_mem=None,
        offset_mapper=None,
        encoding=&#34;UTF-8&#34;,
        gzip=False,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          encoding: (Default value = &#34;UTF-8&#34;)
          gzip: (Default value = False)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=encoding)
        if from_mem is not None:
            if gzip:
                txt = decompress(from_mem).decode(encoding)
            else:
                txt = from_mem
            doc = Document(txt)
        else:
            if gzip:
                with gopen(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                    txt = infp.read()
            else:
                with open(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                    txt = infp.read()
            doc = Document(txt)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        return PlainTextSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.PlainTextSerializer.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, offset_mapper=None, encoding='UTF-8', gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt>clazz:</dt>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>encoding</code></strong></dt>
<dd>(Default value = "UTF-8")</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
</dl>
<p>**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(
    clazz,
    from_ext=None,
    from_mem=None,
    offset_mapper=None,
    encoding=&#34;UTF-8&#34;,
    gzip=False,
    **kwargs,
):
    &#34;&#34;&#34;

    Args:
      clazz:
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      encoding: (Default value = &#34;UTF-8&#34;)
      gzip: (Default value = False)
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    isurl, extstr = is_url(from_ext)
    if from_ext is not None:
        if isurl:
            if gzip:
                from_mem = get_bytes_from_url(extstr)
            else:
                from_mem = get_str_from_url(extstr, encoding=encoding)
    if from_mem is not None:
        if gzip:
            txt = decompress(from_mem).decode(encoding)
        else:
            txt = from_mem
        doc = Document(txt)
    else:
        if gzip:
            with gopen(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                txt = infp.read()
        else:
            with open(extstr, &#34;rt&#34;, encoding=encoding) as infp:
                txt = infp.read()
        doc = Document(txt)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.PlainTextSerializer.load_gzip"><code class="name flex">
<span>def <span class="ident">load_gzip</span></span>(<span>clazz, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>clazz:
**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_gzip(clazz, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz:
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    return PlainTextSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.PlainTextSerializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, encoding='UTF-8', gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt>clazz:</dt>
<dt>inst:</dt>
<dt><strong><code>to_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>to_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>encoding</code></strong></dt>
<dd>(Default value = "UTF-8")</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
</dl>
<p>**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(
    clazz,
    inst,
    to_ext=None,
    to_mem=None,
    offset_type=None,
    offset_mapper=None,
    encoding=&#34;UTF-8&#34;,
    gzip=False,
    **kwargs,
):
    &#34;&#34;&#34;

    Args:
      clazz:
      inst:
      to_ext: (Default value = None)
      to_mem: (Default value = None)
      offset_type: (Default value = None)
      offset_mapper: (Default value = None)
      encoding: (Default value = &#34;UTF-8&#34;)
      gzip: (Default value = False)
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    txt = inst.text
    if txt is None:
        txt = &#34;&#34;
    if to_mem:
        if gzip:
            compress(txt.encode(encoding))
        else:
            return txt
    else:
        if gzip:
            with gopen(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                outfp.write(txt)
        else:
            with open(to_ext, &#34;wt&#34;, encoding=encoding) as outfp:
                outfp.write(txt)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.PlainTextSerializer.save_gzip"><code class="name flex">
<span>def <span class="ident">save_gzip</span></span>(<span>clazz, inst, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>clazz:
inst:
**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_gzip(clazz, inst, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz:
      inst:
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    PlainTextSerializer.save(clazz, inst, gzip=True, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.TweetV1Serializer"><code class="flex name class">
<span>class <span class="ident">TweetV1Serializer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TweetV1Serializer:

    @staticmethod
    def doc2twitterv1dict(doc, annsets=None, prefix_sep=None):
        d = doc.to_dict(annsets=annsets)
        ret = {&#34;full_text&#34;: doc.text}
        ents = defaultdict(list)
        for setname, annset in d.get(&#34;annotation_sets&#34;, {}).items():
            for ann in annset.get(&#34;annotations&#34;, []):
                anntype = ann[&#34;type&#34;]
                if prefix_sep is not None and setname != &#34;&#34;:
                    anntype = setname + prefix_sep + anntype
                annlist = ents[anntype]
                twitterann = {
                    &#34;indices&#34;: [ann[&#34;start&#34;], ann[&#34;end&#34;]]
                }
                twitterann.update(ann[&#34;features&#34;])
                annlist.append(twitterann)
        ret[&#34;entities&#34;] = ents
        return ret

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        annsets=None,
        prefix_sep=None,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
            clazz: the class of the object that gets saved
            inst: the object to get saved
            to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
            to_mem: if True, return a String serialization
            offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
            offset_mapper: the offset mapper to use, only needed if the type needs to get converted
            annsets: which annotation sets and types to include, list of set names or (setanmes, types) tuples
            prefix_types: if not None, prefix all types with the name of the annotation set the annotation comes from
                and use the given string as the separator (can be the empty string for no seaparator).
                For annotations from the default set the type stays unchanged.
          **kwargs:
        &#34;&#34;&#34;
        d = TweetV1Serializer.doc2twitterv1dict(inst, annsets=annsets, prefix_sep=prefix_sep)
        if to_mem:
            return json.dumps(d)
        else:
            with open(to_ext, JSON_WRITE) as outfp:
                json.dump(d, outfp)

    @staticmethod
    def load(
        clazz,
        from_ext=None,
        from_mem=None,
        include_fields=None,
        include_entities=True,
        include_quote=False,
        outsetname=&#34;Original markups&#34;,
        tweet_ann=&#34;Tweet&#34;,
    ):
        &#34;&#34;&#34;
        Load a tweet from Twitter JSON format.

        IMPORTANT: this is still very experimental, will change in the future!

        Args:
            clazz: internal use
            from_ext: the file/url to load from
            from_mem: string to load from
            include_fields: a list of fields to include where nested field names are dot-separated, e.g.
               &#34;user.location&#34;. All these fields are included using the nested field name in either the
               features of the tweet annotation with the Type specified, or the features of the document
               if `tweet_ann` is None.
            include_entities: create annotations for the tweet entities in the set with outsetname
            include_quote: if True, add the quoted tweet after an empty line and treat it as a separate
               tweet just like the original tweet.
            outset: the annotation set where to put entity annotations and the tweet annotation(s)
            tweet_ann: the annotation type to use to span the tweet and contain all the features.

        Returns:
            document representing the tweet
        &#34;&#34;&#34;
        if from_ext is not None:
            isurl, extstr = is_url(from_ext)
            if isurl:
                jsonstr = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
                tweet = json.loads(jsonstr)
            else:
                with open(extstr, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
                    tweet = json.load(infp)
        elif from_mem is not None:
            tweet = json.loads(from_mem)
        else:
            raise Exception(&#34;Cannot load from None&#34;)
        if tweet is None:
            raise Exception(&#34;Could not decode Tweet JSON&#34;)
        if tweet.get(&#34;truncated&#34;):
            text = get_nested(tweet, &#34;extended_tweet.full_text&#34;)
        else:
            text = get_nested(tweet, &#34;text&#34;)
        if text is None:
            raise Exception(&#34;No text field found&#34;)
        quoted_status = None
        if include_quote:
            quoted_status = tweet.get(&#34;quoted_status&#34;)
            if quoted_status is not None:
                qtext = quoted_status.get(&#34;text&#34;, &#34;&#34;)
                text += &#34;\n&#34; + qtext
        doc = Document(text)
        anns = doc.annset(outsetname)
        if tweet_ann:
            ann = anns.add(0, len(text), tweet_ann)
            features = ann.features
        else:
            features = doc.features
        if include_fields is None:
            include_fields = TWITTER_DEFAULT_INCLUDE_FIELDS
        for field in include_fields:
            if field.startswith(&#34;$&#34;):
                if field == &#34;$is_retweet_status&#34;:
                    rs = get_nested(tweet, &#34;retweeted_status&#34;, silent=True)
                    if rs is not None:
                        features[field] = True
                continue
            val = get_nested(tweet, field, silent=True)
            if val is not None:
                features[field] = val
        if include_entities:
            if tweet.get(&#34;truncated&#34;):
                entities = get_nested(tweet, &#34;extended_tweet.entities&#34;, default={})
            else:
                entities = get_nested(tweet, &#34;entities&#34;, default={})
        for etype, elist in entities.items():
            for ent in elist:
                start, end = ent[&#34;indices&#34;]
                anns.add(start, end, etype)
        # TODO: if we have a quoted_status, add features and entities from there:
        # Essentially the same processing as for the original tweet, but at document offset
        # len(tweet)+1 (2?)
        return doc</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.TweetV1Serializer.doc2twitterv1dict"><code class="name flex">
<span>def <span class="ident">doc2twitterv1dict</span></span>(<span>doc, annsets=None, prefix_sep=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def doc2twitterv1dict(doc, annsets=None, prefix_sep=None):
    d = doc.to_dict(annsets=annsets)
    ret = {&#34;full_text&#34;: doc.text}
    ents = defaultdict(list)
    for setname, annset in d.get(&#34;annotation_sets&#34;, {}).items():
        for ann in annset.get(&#34;annotations&#34;, []):
            anntype = ann[&#34;type&#34;]
            if prefix_sep is not None and setname != &#34;&#34;:
                anntype = setname + prefix_sep + anntype
            annlist = ents[anntype]
            twitterann = {
                &#34;indices&#34;: [ann[&#34;start&#34;], ann[&#34;end&#34;]]
            }
            twitterann.update(ann[&#34;features&#34;])
            annlist.append(twitterann)
    ret[&#34;entities&#34;] = ents
    return ret</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.TweetV1Serializer.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, include_fields=None, include_entities=True, include_quote=False, outsetname='Original markups', tweet_ann='Tweet')</span>
</code></dt>
<dd>
<div class="desc"><p>Load a tweet from Twitter JSON format.</p>
<p>IMPORTANT: this is still very experimental, will change in the future!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>clazz</code></strong></dt>
<dd>internal use</dd>
<dt><strong><code>from_ext</code></strong></dt>
<dd>the file/url to load from</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>string to load from</dd>
<dt><strong><code>include_fields</code></strong></dt>
<dd>a list of fields to include where nested field names are dot-separated, e.g.
"user.location". All these fields are included using the nested field name in either the
features of the tweet annotation with the Type specified, or the features of the document
if <code>tweet_ann</code> is None.</dd>
<dt><strong><code>include_entities</code></strong></dt>
<dd>create annotations for the tweet entities in the set with outsetname</dd>
<dt><strong><code>include_quote</code></strong></dt>
<dd>if True, add the quoted tweet after an empty line and treat it as a separate
tweet just like the original tweet.</dd>
<dt><strong><code>outset</code></strong></dt>
<dd>the annotation set where to put entity annotations and the tweet annotation(s)</dd>
<dt><strong><code>tweet_ann</code></strong></dt>
<dd>the annotation type to use to span the tweet and contain all the features.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>document representing the tweet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(
    clazz,
    from_ext=None,
    from_mem=None,
    include_fields=None,
    include_entities=True,
    include_quote=False,
    outsetname=&#34;Original markups&#34;,
    tweet_ann=&#34;Tweet&#34;,
):
    &#34;&#34;&#34;
    Load a tweet from Twitter JSON format.

    IMPORTANT: this is still very experimental, will change in the future!

    Args:
        clazz: internal use
        from_ext: the file/url to load from
        from_mem: string to load from
        include_fields: a list of fields to include where nested field names are dot-separated, e.g.
           &#34;user.location&#34;. All these fields are included using the nested field name in either the
           features of the tweet annotation with the Type specified, or the features of the document
           if `tweet_ann` is None.
        include_entities: create annotations for the tweet entities in the set with outsetname
        include_quote: if True, add the quoted tweet after an empty line and treat it as a separate
           tweet just like the original tweet.
        outset: the annotation set where to put entity annotations and the tweet annotation(s)
        tweet_ann: the annotation type to use to span the tweet and contain all the features.

    Returns:
        document representing the tweet
    &#34;&#34;&#34;
    if from_ext is not None:
        isurl, extstr = is_url(from_ext)
        if isurl:
            jsonstr = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
            tweet = json.loads(jsonstr)
        else:
            with open(extstr, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as infp:
                tweet = json.load(infp)
    elif from_mem is not None:
        tweet = json.loads(from_mem)
    else:
        raise Exception(&#34;Cannot load from None&#34;)
    if tweet is None:
        raise Exception(&#34;Could not decode Tweet JSON&#34;)
    if tweet.get(&#34;truncated&#34;):
        text = get_nested(tweet, &#34;extended_tweet.full_text&#34;)
    else:
        text = get_nested(tweet, &#34;text&#34;)
    if text is None:
        raise Exception(&#34;No text field found&#34;)
    quoted_status = None
    if include_quote:
        quoted_status = tweet.get(&#34;quoted_status&#34;)
        if quoted_status is not None:
            qtext = quoted_status.get(&#34;text&#34;, &#34;&#34;)
            text += &#34;\n&#34; + qtext
    doc = Document(text)
    anns = doc.annset(outsetname)
    if tweet_ann:
        ann = anns.add(0, len(text), tweet_ann)
        features = ann.features
    else:
        features = doc.features
    if include_fields is None:
        include_fields = TWITTER_DEFAULT_INCLUDE_FIELDS
    for field in include_fields:
        if field.startswith(&#34;$&#34;):
            if field == &#34;$is_retweet_status&#34;:
                rs = get_nested(tweet, &#34;retweeted_status&#34;, silent=True)
                if rs is not None:
                    features[field] = True
            continue
        val = get_nested(tweet, field, silent=True)
        if val is not None:
            features[field] = val
    if include_entities:
        if tweet.get(&#34;truncated&#34;):
            entities = get_nested(tweet, &#34;extended_tweet.entities&#34;, default={})
        else:
            entities = get_nested(tweet, &#34;entities&#34;, default={})
    for etype, elist in entities.items():
        for ent in elist:
            start, end = ent[&#34;indices&#34;]
            anns.add(start, end, etype)
    # TODO: if we have a quoted_status, add features and entities from there:
    # Essentially the same processing as for the original tweet, but at document offset
    # len(tweet)+1 (2?)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.TweetV1Serializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, annsets=None, prefix_sep=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>clazz: the class of the object that gets saved
inst: the object to get saved
to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
to_mem: if True, return a String serialization
offset_type: the offset type to use for saving, if None (default) use "p" (Python)
offset_mapper: the offset mapper to use, only needed if the type needs to get converted
annsets: which annotation sets and types to include, list of set names or (setanmes, types) tuples
prefix_types: if not None, prefix all types with the name of the annotation set the annotation comes from
and use the given string as the separator (can be the empty string for no seaparator).
For annotations from the default set the type stays unchanged.
**kwargs:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(
    clazz,
    inst,
    to_ext=None,
    to_mem=None,
    annsets=None,
    prefix_sep=None,
    **kwargs,
):
    &#34;&#34;&#34;

    Args:
        clazz: the class of the object that gets saved
        inst: the object to get saved
        to_ext: where to save to, this should be a file path, only one of to_ext and to_mem should be specified
        to_mem: if True, return a String serialization
        offset_type: the offset type to use for saving, if None (default) use &#34;p&#34; (Python)
        offset_mapper: the offset mapper to use, only needed if the type needs to get converted
        annsets: which annotation sets and types to include, list of set names or (setanmes, types) tuples
        prefix_types: if not None, prefix all types with the name of the annotation set the annotation comes from
            and use the given string as the separator (can be the empty string for no seaparator).
            For annotations from the default set the type stays unchanged.
      **kwargs:
    &#34;&#34;&#34;
    d = TweetV1Serializer.doc2twitterv1dict(inst, annsets=annsets, prefix_sep=prefix_sep)
    if to_mem:
        return json.dumps(d)
    else:
        with open(to_ext, JSON_WRITE) as outfp:
            json.dump(d, outfp)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.serialization.default.YamlSerializer"><code class="flex name class">
<span>class <span class="ident">YamlSerializer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class YamlSerializer:
    &#34;&#34;&#34; &#34;&#34;&#34;

    @staticmethod
    def save(
        clazz,
        inst,
        to_ext=None,
        to_mem=None,
        offset_type=None,
        offset_mapper=None,
        gzip=False,
        annsets=None,
        **kwargs,
    ):
        &#34;&#34;&#34;

        Args:
            clazz:
            inst:
            to_ext: (Default value = None)
            to_mem: (Default value = None)
            offset_type: (Default value = None)
            offset_mapper: (Default value = None)
            gzip: (Default value = False)
            annsets: which annotation sets and types to include, list of set names or (setanmes, types) tuples
            **kwargs:
        &#34;&#34;&#34;
        d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, annsets=annsets, **kwargs)
        if to_mem:
            if gzip:
                compress(yaml.dump(d, Dumper=yaml_dumper).encode(&#34;UTF-8&#34;))
            else:
                return yaml.dump(d, Dumper=yaml_dumper)
        else:
            if gzip:
                with gopen(to_ext, &#34;wt&#34;) as outfp:
                    yaml.dump(d, outfp, Dumper=yaml_dumper)
            else:
                with open(to_ext, &#34;wt&#34;) as outfp:
                    yaml.dump(d, outfp, Dumper=yaml_dumper)

    @staticmethod
    def save_gzip(clazz, inst, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          inst:
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        YamlSerializer.save(clazz, inst, gzip=True, **kwargs)

    @staticmethod
    def load(
        clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs
    ):
        &#34;&#34;&#34;

        Args:
          clazz:
          from_ext: (Default value = None)
          from_mem: (Default value = None)
          offset_mapper: (Default value = None)
          gzip: (Default value = False)
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        isurl, extstr = is_url(from_ext)
        if from_ext is not None:
            if isurl:
                if gzip:
                    from_mem = get_bytes_from_url(extstr)
                else:
                    from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
        if from_mem is not None:
            if gzip:
                d = yaml.load(decompress(from_mem).decode(&#34;UTF-8&#34;), Loader=yaml_loader)
            else:
                d = yaml.load(from_mem, Loader=yaml_loader)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        else:
            if gzip:
                with gopen(extstr, &#34;rt&#34;) as infp:
                    d = yaml.load(infp, Loader=yaml_loader)
            else:
                with open(extstr, &#34;rt&#34;) as infp:
                    d = yaml.load(infp, Loader=yaml_loader)
            doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
        return doc

    @staticmethod
    def load_gzip(clazz, **kwargs):
        &#34;&#34;&#34;

        Args:
          clazz:
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        return YamlSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.serialization.default.YamlSerializer.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt>clazz:</dt>
<dt><strong><code>from_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>from_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
</dl>
<p>**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(
    clazz, from_ext=None, from_mem=None, offset_mapper=None, gzip=False, **kwargs
):
    &#34;&#34;&#34;

    Args:
      clazz:
      from_ext: (Default value = None)
      from_mem: (Default value = None)
      offset_mapper: (Default value = None)
      gzip: (Default value = False)
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    isurl, extstr = is_url(from_ext)
    if from_ext is not None:
        if isurl:
            if gzip:
                from_mem = get_bytes_from_url(extstr)
            else:
                from_mem = get_str_from_url(extstr, encoding=&#34;utf-8&#34;)
    if from_mem is not None:
        if gzip:
            d = yaml.load(decompress(from_mem).decode(&#34;UTF-8&#34;), Loader=yaml_loader)
        else:
            d = yaml.load(from_mem, Loader=yaml_loader)
        doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
    else:
        if gzip:
            with gopen(extstr, &#34;rt&#34;) as infp:
                d = yaml.load(infp, Loader=yaml_loader)
        else:
            with open(extstr, &#34;rt&#34;) as infp:
                d = yaml.load(infp, Loader=yaml_loader)
        doc = clazz.from_dict(d, offset_mapper=offset_mapper, **kwargs)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.YamlSerializer.load_gzip"><code class="name flex">
<span>def <span class="ident">load_gzip</span></span>(<span>clazz, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>clazz:
**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_gzip(clazz, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz:
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    return YamlSerializer.load(clazz, gzip=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.YamlSerializer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>clazz, inst, to_ext=None, to_mem=None, offset_type=None, offset_mapper=None, gzip=False, annsets=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt>clazz:</dt>
<dt>inst:</dt>
<dt><strong><code>to_ext</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>to_mem</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>gzip</code></strong></dt>
<dd>(Default value = False)</dd>
<dt><strong><code>annsets</code></strong></dt>
<dd>which annotation sets and types to include, list of set names or (setanmes, types) tuples</dd>
</dl>
<p>**kwargs:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(
    clazz,
    inst,
    to_ext=None,
    to_mem=None,
    offset_type=None,
    offset_mapper=None,
    gzip=False,
    annsets=None,
    **kwargs,
):
    &#34;&#34;&#34;

    Args:
        clazz:
        inst:
        to_ext: (Default value = None)
        to_mem: (Default value = None)
        offset_type: (Default value = None)
        offset_mapper: (Default value = None)
        gzip: (Default value = False)
        annsets: which annotation sets and types to include, list of set names or (setanmes, types) tuples
        **kwargs:
    &#34;&#34;&#34;
    d = inst.to_dict(offset_type=offset_type, offset_mapper=offset_mapper, annsets=annsets, **kwargs)
    if to_mem:
        if gzip:
            compress(yaml.dump(d, Dumper=yaml_dumper).encode(&#34;UTF-8&#34;))
        else:
            return yaml.dump(d, Dumper=yaml_dumper)
    else:
        if gzip:
            with gopen(to_ext, &#34;wt&#34;) as outfp:
                yaml.dump(d, outfp, Dumper=yaml_dumper)
        else:
            with open(to_ext, &#34;wt&#34;) as outfp:
                yaml.dump(d, outfp, Dumper=yaml_dumper)</code></pre>
</details>
</dd>
<dt id="gatenlp.serialization.default.YamlSerializer.save_gzip"><code class="name flex">
<span>def <span class="ident">save_gzip</span></span>(<span>clazz, inst, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>clazz:
inst:
**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_gzip(clazz, inst, **kwargs):
    &#34;&#34;&#34;

    Args:
      clazz:
      inst:
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    YamlSerializer.save(clazz, inst, gzip=True, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.serialization" href="index.html">gatenlp.serialization</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gatenlp.serialization.default.determine_loader" href="#gatenlp.serialization.default.determine_loader">determine_loader</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_changelog_loader" href="#gatenlp.serialization.default.get_changelog_loader">get_changelog_loader</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_changelog_saver" href="#gatenlp.serialization.default.get_changelog_saver">get_changelog_saver</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_document_loader" href="#gatenlp.serialization.default.get_document_loader">get_document_loader</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_document_saver" href="#gatenlp.serialization.default.get_document_saver">get_document_saver</a></code></li>
<li><code><a title="gatenlp.serialization.default.get_handler" href="#gatenlp.serialization.default.get_handler">get_handler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.serialization.default.GateXmlLoader" href="#gatenlp.serialization.default.GateXmlLoader">GateXmlLoader</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.GateXmlLoader.load" href="#gatenlp.serialization.default.GateXmlLoader.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.GateXmlLoader.value4objectwrapper" href="#gatenlp.serialization.default.GateXmlLoader.value4objectwrapper">value4objectwrapper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.HtmlAnnViewerSerializer" href="#gatenlp.serialization.default.HtmlAnnViewerSerializer">HtmlAnnViewerSerializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.HtmlAnnViewerSerializer.init_javscript" href="#gatenlp.serialization.default.HtmlAnnViewerSerializer.init_javscript">init_javscript</a></code></li>
<li><code><a title="gatenlp.serialization.default.HtmlAnnViewerSerializer.javascript" href="#gatenlp.serialization.default.HtmlAnnViewerSerializer.javascript">javascript</a></code></li>
<li><code><a title="gatenlp.serialization.default.HtmlAnnViewerSerializer.save" href="#gatenlp.serialization.default.HtmlAnnViewerSerializer.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.HtmlLoader" href="#gatenlp.serialization.default.HtmlLoader">HtmlLoader</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.HtmlLoader.load" href="#gatenlp.serialization.default.HtmlLoader.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.HtmlLoader.load_rendered" href="#gatenlp.serialization.default.HtmlLoader.load_rendered">load_rendered</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.JsonSerializer" href="#gatenlp.serialization.default.JsonSerializer">JsonSerializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.JsonSerializer.load" href="#gatenlp.serialization.default.JsonSerializer.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.JsonSerializer.load_gzip" href="#gatenlp.serialization.default.JsonSerializer.load_gzip">load_gzip</a></code></li>
<li><code><a title="gatenlp.serialization.default.JsonSerializer.save" href="#gatenlp.serialization.default.JsonSerializer.save">save</a></code></li>
<li><code><a title="gatenlp.serialization.default.JsonSerializer.save_gzip" href="#gatenlp.serialization.default.JsonSerializer.save_gzip">save_gzip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.MsgPackSerializer" href="#gatenlp.serialization.default.MsgPackSerializer">MsgPackSerializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.MsgPackSerializer.document2stream" href="#gatenlp.serialization.default.MsgPackSerializer.document2stream">document2stream</a></code></li>
<li><code><a title="gatenlp.serialization.default.MsgPackSerializer.load" href="#gatenlp.serialization.default.MsgPackSerializer.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.MsgPackSerializer.save" href="#gatenlp.serialization.default.MsgPackSerializer.save">save</a></code></li>
<li><code><a title="gatenlp.serialization.default.MsgPackSerializer.stream2document" href="#gatenlp.serialization.default.MsgPackSerializer.stream2document">stream2document</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.PickleSerializer" href="#gatenlp.serialization.default.PickleSerializer">PickleSerializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.PickleSerializer.load" href="#gatenlp.serialization.default.PickleSerializer.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.PickleSerializer.save" href="#gatenlp.serialization.default.PickleSerializer.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.PlainTextSerializer" href="#gatenlp.serialization.default.PlainTextSerializer">PlainTextSerializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.PlainTextSerializer.load" href="#gatenlp.serialization.default.PlainTextSerializer.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.PlainTextSerializer.load_gzip" href="#gatenlp.serialization.default.PlainTextSerializer.load_gzip">load_gzip</a></code></li>
<li><code><a title="gatenlp.serialization.default.PlainTextSerializer.save" href="#gatenlp.serialization.default.PlainTextSerializer.save">save</a></code></li>
<li><code><a title="gatenlp.serialization.default.PlainTextSerializer.save_gzip" href="#gatenlp.serialization.default.PlainTextSerializer.save_gzip">save_gzip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.TweetV1Serializer" href="#gatenlp.serialization.default.TweetV1Serializer">TweetV1Serializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.TweetV1Serializer.doc2twitterv1dict" href="#gatenlp.serialization.default.TweetV1Serializer.doc2twitterv1dict">doc2twitterv1dict</a></code></li>
<li><code><a title="gatenlp.serialization.default.TweetV1Serializer.load" href="#gatenlp.serialization.default.TweetV1Serializer.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.TweetV1Serializer.save" href="#gatenlp.serialization.default.TweetV1Serializer.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.serialization.default.YamlSerializer" href="#gatenlp.serialization.default.YamlSerializer">YamlSerializer</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.serialization.default.YamlSerializer.load" href="#gatenlp.serialization.default.YamlSerializer.load">load</a></code></li>
<li><code><a title="gatenlp.serialization.default.YamlSerializer.load_gzip" href="#gatenlp.serialization.default.YamlSerializer.load_gzip">load_gzip</a></code></li>
<li><code><a title="gatenlp.serialization.default.YamlSerializer.save" href="#gatenlp.serialization.default.YamlSerializer.save">save</a></code></li>
<li><code><a title="gatenlp.serialization.default.YamlSerializer.save_gzip" href="#gatenlp.serialization.default.YamlSerializer.save_gzip">save_gzip</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>