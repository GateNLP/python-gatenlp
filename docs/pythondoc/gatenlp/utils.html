<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev16+g8c2bb0d.d20201028" />
<title>gatenlp.utils API documentation</title>
<meta name="description" content="Various utilities that could be useful in several modules." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.utils</code></h1>
</header>
<section id="section-intro">
<p>Various utilities that could be useful in several modules.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Various utilities that could be useful in several modules.
&#34;&#34;&#34;
import numbers
import sys
import os
import logging
import logging.config
import datetime
import time
from functools import wraps


def match_substrings(text, items, getstr=None, cmp=None, unmatched=False):
    &#34;&#34;&#34;
    Matches each item from the items sequence with sum substring of the text
    in a greedy fashion. An item is either already a string or getstr is used
    to retrieve a string from it. The text and substrings are normally
    compared with normal string equality but cmp can be replaced with
    a two-argument function that does the comparison instead.
    This function expects that all items are present in the text, in their order
    and without overlapping! If this is not the case, an exception is raised.

    Args:
      text: the text to use for matching
      items: items that are or contains substrings to match
      getstr: a function that retrieves the text from an item (Default value = None)
      cmp: a function that compares to strings and returns a boolean \
    that indicates if they should be considered to be equal. (Default value = None)
      unmatched: if true returns two lists of tuples, where the second list\
    contains the offsets of text not matched by the items (Default value = False)

    Returns:
      a list of tuples (start, end, item) where start and end are the\
      start and end offsets of a substring in the text and item is the item for that substring.

    &#34;&#34;&#34;
    if getstr is None:
        getstr = lambda x: x
    if cmp is None:
        cmp = lambda x, y: x == y
    ltxt = len(text)
    ret = []
    ret2 = []
    item_idx = 0
    start = 0
    lastunmatched = 0
    while start &lt; ltxt:
        itemorig = items[item_idx]
        item = getstr(itemorig)
        end = start + len(item)
        if end &gt; ltxt:
            raise Exception(&#34;Text too short to match next item: {}&#34;.format(item))
        if cmp(text[start:end], item):
            if unmatched and start &gt; lastunmatched:
                ret2.append((lastunmatched, start))
                lastunmatched = start + len(item)
            ret.append((start, end, itemorig))
            start += len(item)
            item_idx += 1
            if item_idx == len(items):
                break
        else:
            start += 1
    if item_idx != len(items):
        raise Exception(
            &#34;Not all items matched but {} of {}&#34;.format(item_idx, len(items))
        )
    if unmatched and lastunmatched != ltxt:
        ret2.append((lastunmatched, ltxt))
    if unmatched:
        return ret, ret2
    else:
        return ret


start = 0
LOGGING_FORMAT = &#34;%(asctime)s|%(levelname)s|%(name)s|%(message)s&#34;


def init_logger(name=None, file=None, lvl=None, config=None, debug=False, args=None):
    &#34;&#34;&#34;
    Configure the root logger (this only works the very first time, all subsequent
    invocations will not modify the root logger). The root logger is initialized
    with a standard format the given log level and, if specified the outputs to the
    given file.

    The get a new logger for the given name is retrieved using the given name or
    the invoking command if None. It is also set to the given logging leve and returned.

    TODO: If file is not given but args is given and has &#34;outpref&#34; parameter, log to
    file &#34;outpref.DATETIME.log&#34; as well.

    Args:
        name: name to use in the log, if None, __name__
        file: if given, log to this destination in addition to stderr
        lvl: set logging level
        config: if specified, set logger config from this file
        args: not used yet

    Returns:
        A logger instance for name (always the same instance for the same name)
    &#34;&#34;&#34;

    if name is None:
        name = sys.argv[0]
    if lvl is None:
        if debug:
            lvl = logging.DEBUG
        else:
            lvl = logging.INFO
    if config:
        # NOTE we could also configure from a yaml file or a dictionary, see
        # http://zetcode.com/python/logging/
        # see doc on logging.config
        logging.config.fileConfig(fname=config)
    # get the root logger
    rl = logging.getLogger()
    rl.setLevel(lvl)
    # NOTE: basicConfig does nothing if there is already a handler, so it only runs once, but we create the additional
    # handler for the file, if needed, only if the root logger has no handlers yet as well
    addhandlers = []
    fmt = logging.Formatter(LOGGING_FORMAT)
    hndlr = logging.StreamHandler(sys.stderr)
    hndlr.setFormatter(fmt)
    addhandlers.append(hndlr)
    if file and len(logging.getLogger().handlers) == 0:
        hndlr = logging.FileHandler(file)
        hndlr.setFormatter(fmt)
        addhandlers.append(hndlr)
    logging.basicConfig(level=lvl, handlers=addhandlers)
    # now get the handler for name
    logger = logging.getLogger(name)
    return logger


def run_start(logger=None, name=None, lvl=None):
    &#34;&#34;&#34;
    Define time when running starts.

    Returns:
        system time in seconds
    &#34;&#34;&#34;
    global start
    if logger is None:
        logger = init_logger(name=name, lvl=lvl)
    logger.info(
        &#34;Started: {}&#34;.format(datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M%S&#34;))
    )
    start = time.time()
    return start


def run_stop(logger=None, name=None):
    &#34;&#34;&#34;
    Log and return formatted elapsed run time.

    Returns:
        tuple of formatted run time, run time in seconds
    &#34;&#34;&#34;
    if logger is None:
        logger = init_logger(name=name)
    logger.info(
        &#34;Stpped: {}&#34;.format(datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M%S&#34;))
    )
    if start == 0:
        logger.warning(&#34;Run timing not set up properly, no time!&#34;)
        return &#34;&#34;, 0
    stop = time.time()
    delta = stop - start
    deltastr = str(datetime.timedelta(seconds=delta))
    logger.info(f&#34;Runtime: {deltastr}&#34;)
    return deltastr, delta


def file4logger(thelogger, noext=False):
    &#34;&#34;&#34;
    Return the first logging file found for this logger or None if there is no file handler.

    Args:
        thelogger: logger

    Returns:
        file path (string)
    &#34;&#34;&#34;
    lpath = None
    for h in thelogger.handlers:
        if isinstance(h, logging.FileHandler):
            lpath = h.baseFilename
            if noext:
                lpath = os.path.splitext(lpath)[0]
            break
    return lpath


def support_annotation_or_set(method):
    &#34;&#34;&#34;
    Decorator to allow a method that normally takes a start and end
    offset to take an annotation or annotation set, or any other object that has
    &#34;start&#34; and &#34;end&#34; attributes, or a pair of offsets instead.
    It also allows to take a single offset instead which will then be used
    to create a length one span (start is the original offset, end is the original offset plus one)

    Args:
      method: the method that gets converted by this decorator.

    Returns:
        the adapted method which now takes an annotation or annotation set as well as start/end offsets.
    &#34;&#34;&#34;

    @wraps(method)
    def _support_annotation_or_set(self, *args, **kwargs):
        from gatenlp.annotation import Annotation

        annid = None
        if len(args) == 1:
            obj = args[0]
            if hasattr(obj, &#34;start&#34;) and hasattr(obj, &#34;end&#34;):
                left, right = obj.start, obj.end
            elif isinstance(obj, (tuple, list)) and len(obj) == 2:
                left, right = obj
            elif isinstance(obj, numbers.Integral):
                left, right = obj, obj + 1
            else:
                raise Exception(
                    &#34;Not an annotation or an annotation set or pair: {}&#34;.format(args[0])
                )
            if isinstance(obj, Annotation):
                annid = obj.id
        else:
            assert len(args) == 2
            left, right = args
        # if the called method/function does have an annid keyword, pass it, otherwise omit
        if &#34;annid&#34; in method.__code__.co_varnames:
            return method(self, left, right, annid=annid, **kwargs)
        else:
            return method(self, left, right, **kwargs)

    return _support_annotation_or_set


class _CheckHtml:

    def _repr_html_(self):
        return &#34;yes&#34;

    def __repr__(self):
        return &#34;no&#34;


_checkhtml = _CheckHtml()

_in_notebook = [None]


def in_notebook():
    if _in_notebook[0] is not None:
        return _in_notebook[0]
    try:
        from IPython import get_ipython
        ip = get_ipython()
        if ip is None:
            # we have IPython installed but not running from IPython
            _in_notebook[0] = False
        else:
            from IPython.core.interactiveshell import InteractiveShell
            format = InteractiveShell.instance().display_formatter.format
            if len(format(_checkhtml, include=&#34;text/html&#34;)[0]):
                _in_notebook[0] = True
            else:
                _in_notebook[0] = False
    except:
        # We do not even have IPython installed
        _in_notebook[0] = False
    return _in_notebook[0]


def allowspan(method):
    @wraps(method)
    def _allowspan(self, *args, **kwargs):
        assert len(args) &gt; 1
        maybespan = args[0]
        if hasattr(maybespan, &#34;start&#34;) and hasattr(maybespan, &#34;end&#34;):
            return method(self, maybespan.start, maybespan.end, *args[1:], **kwargs)
        else:
            return method(self, *args, **kwargs)
    return _allowspan</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gatenlp.utils.allowspan"><code class="name flex">
<span>def <span class="ident">allowspan</span></span>(<span>method)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allowspan(method):
    @wraps(method)
    def _allowspan(self, *args, **kwargs):
        assert len(args) &gt; 1
        maybespan = args[0]
        if hasattr(maybespan, &#34;start&#34;) and hasattr(maybespan, &#34;end&#34;):
            return method(self, maybespan.start, maybespan.end, *args[1:], **kwargs)
        else:
            return method(self, *args, **kwargs)
    return _allowspan</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.file4logger"><code class="name flex">
<span>def <span class="ident">file4logger</span></span>(<span>thelogger, noext=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the first logging file found for this logger or None if there is no file handler.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>thelogger</code></strong></dt>
<dd>logger</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>file path (string)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file4logger(thelogger, noext=False):
    &#34;&#34;&#34;
    Return the first logging file found for this logger or None if there is no file handler.

    Args:
        thelogger: logger

    Returns:
        file path (string)
    &#34;&#34;&#34;
    lpath = None
    for h in thelogger.handlers:
        if isinstance(h, logging.FileHandler):
            lpath = h.baseFilename
            if noext:
                lpath = os.path.splitext(lpath)[0]
            break
    return lpath</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.in_notebook"><code class="name flex">
<span>def <span class="ident">in_notebook</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_notebook():
    if _in_notebook[0] is not None:
        return _in_notebook[0]
    try:
        from IPython import get_ipython
        ip = get_ipython()
        if ip is None:
            # we have IPython installed but not running from IPython
            _in_notebook[0] = False
        else:
            from IPython.core.interactiveshell import InteractiveShell
            format = InteractiveShell.instance().display_formatter.format
            if len(format(_checkhtml, include=&#34;text/html&#34;)[0]):
                _in_notebook[0] = True
            else:
                _in_notebook[0] = False
    except:
        # We do not even have IPython installed
        _in_notebook[0] = False
    return _in_notebook[0]</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.init_logger"><code class="name flex">
<span>def <span class="ident">init_logger</span></span>(<span>name=None, file=None, lvl=None, config=None, debug=False, args=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the root logger (this only works the very first time, all subsequent
invocations will not modify the root logger). The root logger is initialized
with a standard format the given log level and, if specified the outputs to the
given file.</p>
<p>The get a new logger for the given name is retrieved using the given name or
the invoking command if None. It is also set to the given logging leve and returned.</p>
<p>TODO: If file is not given but args is given and has "outpref" parameter, log to
file "outpref.DATETIME.log" as well.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name to use in the log, if None, <strong>name</strong></dd>
<dt><strong><code>file</code></strong></dt>
<dd>if given, log to this destination in addition to stderr</dd>
<dt><strong><code>lvl</code></strong></dt>
<dd>set logging level</dd>
<dt><strong><code>config</code></strong></dt>
<dd>if specified, set logger config from this file</dd>
<dt><strong><code>args</code></strong></dt>
<dd>not used yet</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A logger instance for name (always the same instance for the same name)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_logger(name=None, file=None, lvl=None, config=None, debug=False, args=None):
    &#34;&#34;&#34;
    Configure the root logger (this only works the very first time, all subsequent
    invocations will not modify the root logger). The root logger is initialized
    with a standard format the given log level and, if specified the outputs to the
    given file.

    The get a new logger for the given name is retrieved using the given name or
    the invoking command if None. It is also set to the given logging leve and returned.

    TODO: If file is not given but args is given and has &#34;outpref&#34; parameter, log to
    file &#34;outpref.DATETIME.log&#34; as well.

    Args:
        name: name to use in the log, if None, __name__
        file: if given, log to this destination in addition to stderr
        lvl: set logging level
        config: if specified, set logger config from this file
        args: not used yet

    Returns:
        A logger instance for name (always the same instance for the same name)
    &#34;&#34;&#34;

    if name is None:
        name = sys.argv[0]
    if lvl is None:
        if debug:
            lvl = logging.DEBUG
        else:
            lvl = logging.INFO
    if config:
        # NOTE we could also configure from a yaml file or a dictionary, see
        # http://zetcode.com/python/logging/
        # see doc on logging.config
        logging.config.fileConfig(fname=config)
    # get the root logger
    rl = logging.getLogger()
    rl.setLevel(lvl)
    # NOTE: basicConfig does nothing if there is already a handler, so it only runs once, but we create the additional
    # handler for the file, if needed, only if the root logger has no handlers yet as well
    addhandlers = []
    fmt = logging.Formatter(LOGGING_FORMAT)
    hndlr = logging.StreamHandler(sys.stderr)
    hndlr.setFormatter(fmt)
    addhandlers.append(hndlr)
    if file and len(logging.getLogger().handlers) == 0:
        hndlr = logging.FileHandler(file)
        hndlr.setFormatter(fmt)
        addhandlers.append(hndlr)
    logging.basicConfig(level=lvl, handlers=addhandlers)
    # now get the handler for name
    logger = logging.getLogger(name)
    return logger</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.match_substrings"><code class="name flex">
<span>def <span class="ident">match_substrings</span></span>(<span>text, items, getstr=None, cmp=None, unmatched=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Matches each item from the items sequence with sum substring of the text
in a greedy fashion. An item is either already a string or getstr is used
to retrieve a string from it. The text and substrings are normally
compared with normal string equality but cmp can be replaced with
a two-argument function that does the comparison instead.
This function expects that all items are present in the text, in their order
and without overlapping! If this is not the case, an exception is raised.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>the text to use for matching</dd>
<dt><strong><code>items</code></strong></dt>
<dd>items that are or contains substrings to match</dd>
<dt><strong><code>getstr</code></strong></dt>
<dd>a function that retrieves the text from an item (Default value = None)</dd>
<dt><strong><code>cmp</code></strong></dt>
<dd>a function that compares to strings and returns a boolean
that indicates if they should be considered to be equal. (Default value = None)</dd>
<dt><strong><code>unmatched</code></strong></dt>
<dd>if true returns two lists of tuples, where the second list
contains the offsets of text not matched by the items (Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a list of tuples (start, end, item) where start and end are the
start and end offsets of a substring in the text and item is the item for that substring.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_substrings(text, items, getstr=None, cmp=None, unmatched=False):
    &#34;&#34;&#34;
    Matches each item from the items sequence with sum substring of the text
    in a greedy fashion. An item is either already a string or getstr is used
    to retrieve a string from it. The text and substrings are normally
    compared with normal string equality but cmp can be replaced with
    a two-argument function that does the comparison instead.
    This function expects that all items are present in the text, in their order
    and without overlapping! If this is not the case, an exception is raised.

    Args:
      text: the text to use for matching
      items: items that are or contains substrings to match
      getstr: a function that retrieves the text from an item (Default value = None)
      cmp: a function that compares to strings and returns a boolean \
    that indicates if they should be considered to be equal. (Default value = None)
      unmatched: if true returns two lists of tuples, where the second list\
    contains the offsets of text not matched by the items (Default value = False)

    Returns:
      a list of tuples (start, end, item) where start and end are the\
      start and end offsets of a substring in the text and item is the item for that substring.

    &#34;&#34;&#34;
    if getstr is None:
        getstr = lambda x: x
    if cmp is None:
        cmp = lambda x, y: x == y
    ltxt = len(text)
    ret = []
    ret2 = []
    item_idx = 0
    start = 0
    lastunmatched = 0
    while start &lt; ltxt:
        itemorig = items[item_idx]
        item = getstr(itemorig)
        end = start + len(item)
        if end &gt; ltxt:
            raise Exception(&#34;Text too short to match next item: {}&#34;.format(item))
        if cmp(text[start:end], item):
            if unmatched and start &gt; lastunmatched:
                ret2.append((lastunmatched, start))
                lastunmatched = start + len(item)
            ret.append((start, end, itemorig))
            start += len(item)
            item_idx += 1
            if item_idx == len(items):
                break
        else:
            start += 1
    if item_idx != len(items):
        raise Exception(
            &#34;Not all items matched but {} of {}&#34;.format(item_idx, len(items))
        )
    if unmatched and lastunmatched != ltxt:
        ret2.append((lastunmatched, ltxt))
    if unmatched:
        return ret, ret2
    else:
        return ret</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.run_start"><code class="name flex">
<span>def <span class="ident">run_start</span></span>(<span>logger=None, name=None, lvl=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Define time when running starts.</p>
<h2 id="returns">Returns</h2>
<p>system time in seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_start(logger=None, name=None, lvl=None):
    &#34;&#34;&#34;
    Define time when running starts.

    Returns:
        system time in seconds
    &#34;&#34;&#34;
    global start
    if logger is None:
        logger = init_logger(name=name, lvl=lvl)
    logger.info(
        &#34;Started: {}&#34;.format(datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M%S&#34;))
    )
    start = time.time()
    return start</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.run_stop"><code class="name flex">
<span>def <span class="ident">run_stop</span></span>(<span>logger=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Log and return formatted elapsed run time.</p>
<h2 id="returns">Returns</h2>
<p>tuple of formatted run time, run time in seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_stop(logger=None, name=None):
    &#34;&#34;&#34;
    Log and return formatted elapsed run time.

    Returns:
        tuple of formatted run time, run time in seconds
    &#34;&#34;&#34;
    if logger is None:
        logger = init_logger(name=name)
    logger.info(
        &#34;Stpped: {}&#34;.format(datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M%S&#34;))
    )
    if start == 0:
        logger.warning(&#34;Run timing not set up properly, no time!&#34;)
        return &#34;&#34;, 0
    stop = time.time()
    delta = stop - start
    deltastr = str(datetime.timedelta(seconds=delta))
    logger.info(f&#34;Runtime: {deltastr}&#34;)
    return deltastr, delta</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.support_annotation_or_set"><code class="name flex">
<span>def <span class="ident">support_annotation_or_set</span></span>(<span>method)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to allow a method that normally takes a start and end
offset to take an annotation or annotation set, or any other object that has
"start" and "end" attributes, or a pair of offsets instead.
It also allows to take a single offset instead which will then be used
to create a length one span (start is the original offset, end is the original offset plus one)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>the method that gets converted by this decorator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the adapted method which now takes an annotation or annotation set as well as start/end offsets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def support_annotation_or_set(method):
    &#34;&#34;&#34;
    Decorator to allow a method that normally takes a start and end
    offset to take an annotation or annotation set, or any other object that has
    &#34;start&#34; and &#34;end&#34; attributes, or a pair of offsets instead.
    It also allows to take a single offset instead which will then be used
    to create a length one span (start is the original offset, end is the original offset plus one)

    Args:
      method: the method that gets converted by this decorator.

    Returns:
        the adapted method which now takes an annotation or annotation set as well as start/end offsets.
    &#34;&#34;&#34;

    @wraps(method)
    def _support_annotation_or_set(self, *args, **kwargs):
        from gatenlp.annotation import Annotation

        annid = None
        if len(args) == 1:
            obj = args[0]
            if hasattr(obj, &#34;start&#34;) and hasattr(obj, &#34;end&#34;):
                left, right = obj.start, obj.end
            elif isinstance(obj, (tuple, list)) and len(obj) == 2:
                left, right = obj
            elif isinstance(obj, numbers.Integral):
                left, right = obj, obj + 1
            else:
                raise Exception(
                    &#34;Not an annotation or an annotation set or pair: {}&#34;.format(args[0])
                )
            if isinstance(obj, Annotation):
                annid = obj.id
        else:
            assert len(args) == 2
            left, right = args
        # if the called method/function does have an annid keyword, pass it, otherwise omit
        if &#34;annid&#34; in method.__code__.co_varnames:
            return method(self, left, right, annid=annid, **kwargs)
        else:
            return method(self, left, right, **kwargs)

    return _support_annotation_or_set</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp" href="index.html">gatenlp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gatenlp.utils.allowspan" href="#gatenlp.utils.allowspan">allowspan</a></code></li>
<li><code><a title="gatenlp.utils.file4logger" href="#gatenlp.utils.file4logger">file4logger</a></code></li>
<li><code><a title="gatenlp.utils.in_notebook" href="#gatenlp.utils.in_notebook">in_notebook</a></code></li>
<li><code><a title="gatenlp.utils.init_logger" href="#gatenlp.utils.init_logger">init_logger</a></code></li>
<li><code><a title="gatenlp.utils.match_substrings" href="#gatenlp.utils.match_substrings">match_substrings</a></code></li>
<li><code><a title="gatenlp.utils.run_start" href="#gatenlp.utils.run_start">run_start</a></code></li>
<li><code><a title="gatenlp.utils.run_stop" href="#gatenlp.utils.run_stop">run_stop</a></code></li>
<li><code><a title="gatenlp.utils.support_annotation_or_set" href="#gatenlp.utils.support_annotation_or_set">support_annotation_or_set</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev16+g8c2bb0d.d20201028</a>.</p>
</footer>
</body>
</html>