<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>gatenlp.utils API documentation</title>
<meta name="description" content="Various utilities that could be useful in several modules." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.utils</code></h1>
</header>
<section id="section-intro">
<p>Various utilities that could be useful in several modules.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Various utilities that could be useful in several modules.
&#34;&#34;&#34;
import sys
import os
import logging
import datetime
import time


def to_dict(obj):
    &#34;&#34;&#34;If obj is not None, call its to_dict method, otherwise return None

    Args:
      obj: the object on which to call to_dict

    Returns:
      the result of to_dict or None

    &#34;&#34;&#34;
    if obj is None:
        return None
    else:
        return obj.to_dict()


def to_list(obj):
    &#34;&#34;&#34;If obj is not None, call its to_list method, otherwise return None

    Args:
      obj: the object on which to call to_list

    Returns:
      the result of to_list or None

    &#34;&#34;&#34;
    if obj is None:
        return None
    else:
        return obj.to_list()


def match_substrings(text, items, getstr=None, cmp=None, unmatched=False):
    &#34;&#34;&#34;Matches each item from the items sequence with sum substring of the text
    in a greedy fashion. An item is either already a string or getstr is used
    to retrieve a string from it. The text and substrings are normally
    compared with normal string equality but cmp can be replaced with
    a two-argument function that does the comparison instead.
    This function expects that all items are present in the text, in their order
    and without overlapping! If this is not the case, an exception is raised.

    Args:
      text: the text to use for matching
      items: items that are or contains substrings to match
      getstr: a function that retrieves the text from an item (Default value = None)
      cmp: a function that compares to strings and returns a boolean \
    that indicates if they should be considered to be equal. (Default value = None)
      unmatched: if true returns two lists of tuples, where the second list\
    contains the offsets of text not matched by the items (Default value = False)

    Returns:
      a list of tuples (start, end, item) where start and end are the\
      start and end offsets of a substring in the text and item is the item for that substring.

    &#34;&#34;&#34;
    if getstr is None:
        getstr = lambda x: x
    if cmp is None:
        cmp = lambda x,y: x == y
    ltxt = len(text)
    ret = []
    ret2 = []
    item_idx = 0
    start = 0
    lastunmatched = 0
    while start &lt; ltxt:
        itemorig = items[item_idx]
        item = getstr(itemorig)
        end = start + len(item)
        if end &gt; ltxt:
            raise Exception(&#34;Text too short to match next item: {}&#34;.format(item))
        if cmp(text[start:end], item):
            if unmatched and start &gt; lastunmatched:
                ret2.append((lastunmatched, start))
                lastunmatched = start + len(item)
            ret.append((start, end, itemorig))
            start += len(item)
            item_idx += 1
            if item_idx == len(items):
                break
        else:
            start += 1
    if item_idx != len(items):
        raise Exception(&#34;Not all items matched but {} of {}&#34;.format(item_idx, len(items)))
    if unmatched and lastunmatched != ltxt:
        ret2.append((lastunmatched, ltxt))
    if unmatched:
        return ret, ret2
    else:
        return ret


logger = None
start = 0


def set_logger(name=None, file=None, lvl=None, args=None):
    &#34;&#34;&#34;
    Set up logger for the module &#34;name&#34;. If file is given, log to that file as well.
    If file is not given but args is given and has &#34;outpref&#34; parameter, log to
    file &#34;outpref.DATETIME.log&#34; as well.

    Args:
        name: name to use in the log, if None, uses sys.argv[0]
        file: if given, log to this destination in addition to stderr
        lvl: set logging level
        args: not used yet

    Returns:
        The logger instance
    &#34;&#34;&#34;
    global logger
    if name is None:
        name = sys.argv[0]
    if logger:
        raise Exception(&#34;Odd, we should not have a logger yet?&#34;)
    logger = logging.getLogger(name)
    if lvl is None:
        lvl = logging.INFO
    logger.setLevel(lvl)
    fmt = logging.Formatter(&#39;%(asctime)s|%(levelname)s|%(name)s|%(message)s&#39;)
    hndlr = logging.StreamHandler(sys.stderr)
    hndlr.setFormatter(fmt)
    logger.addHandler(hndlr)
    if file:
        hdnlr = logging.FileHandler(file)
        hndlr.setFormatter(fmt)
        logger.addHandler(hdnlr)
    logger.info(&#34;Started: {}&#34;.format(datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M%S&#34;)))
    return logger


def ensurelogger():
    &#34;&#34;&#34;
    Make sure the global logger is set to some logger. This should not be necessary
    if the set_logger function is properly used, but guards against situations where
    functions that require a logger are used without proper setting up the logger.

    Returns:
        A logger instance.
    &#34;&#34;&#34;
    global logger
    if not logger:
        logger = logging.getLogger(&#34;UNINITIALIZEDLOGGER&#34;)
    return logger


def run_start():
    &#34;&#34;&#34;
    Define time when running starts.

    Returns:
        system time in seconds
    &#34;&#34;&#34;
    global  start
    start = time.time()
    return start


def run_stop():
    &#34;&#34;&#34;
    Log and return formatted elapsed run time.

    Returns:
        tuple of formatted run time, run time in seconds
    &#34;&#34;&#34;
    logger = ensurelogger()
    if start == 0:
        logger.warning(&#34;Run timing not set up properly, no time!&#34;)
        return &#34;&#34;,0
    stop = time.time()
    delta = stop - start
    deltastr = str(datetime.timedelta(seconds=delta))
    logger.info(f&#34;Runtime: {deltastr}&#34;)
    return deltastr, delta


def file4logger(thelogger, noext=False):
    &#34;&#34;&#34;
    Return the first logging file found for this logger or None if there is no file handler.

    Args:
        thelogger: logger

    Returns:
        file path (string)
    &#34;&#34;&#34;
    lpath = None
    for h in thelogger.handlers:
        if isinstance(h, logging.FileHandler):
            lpath = h.baseFilename
            if noext:
                lpath = os.path.splitext(lpath)[0]
            break
    return lpath</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gatenlp.utils.ensurelogger"><code class="name flex">
<span>def <span class="ident">ensurelogger</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure the global logger is set to some logger. This should not be necessary
if the set_logger function is properly used, but guards against situations where
functions that require a logger are used without proper setting up the logger.</p>
<h2 id="returns">Returns</h2>
<p>A logger instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensurelogger():
    &#34;&#34;&#34;
    Make sure the global logger is set to some logger. This should not be necessary
    if the set_logger function is properly used, but guards against situations where
    functions that require a logger are used without proper setting up the logger.

    Returns:
        A logger instance.
    &#34;&#34;&#34;
    global logger
    if not logger:
        logger = logging.getLogger(&#34;UNINITIALIZEDLOGGER&#34;)
    return logger</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.file4logger"><code class="name flex">
<span>def <span class="ident">file4logger</span></span>(<span>thelogger, noext=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the first logging file found for this logger or None if there is no file handler.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>thelogger</code></strong></dt>
<dd>logger</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>file path (string)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file4logger(thelogger, noext=False):
    &#34;&#34;&#34;
    Return the first logging file found for this logger or None if there is no file handler.

    Args:
        thelogger: logger

    Returns:
        file path (string)
    &#34;&#34;&#34;
    lpath = None
    for h in thelogger.handlers:
        if isinstance(h, logging.FileHandler):
            lpath = h.baseFilename
            if noext:
                lpath = os.path.splitext(lpath)[0]
            break
    return lpath</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.match_substrings"><code class="name flex">
<span>def <span class="ident">match_substrings</span></span>(<span>text, items, getstr=None, cmp=None, unmatched=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Matches each item from the items sequence with sum substring of the text
in a greedy fashion. An item is either already a string or getstr is used
to retrieve a string from it. The text and substrings are normally
compared with normal string equality but cmp can be replaced with
a two-argument function that does the comparison instead.
This function expects that all items are present in the text, in their order
and without overlapping! If this is not the case, an exception is raised.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>the text to use for matching</dd>
<dt><strong><code>items</code></strong></dt>
<dd>items that are or contains substrings to match</dd>
<dt><strong><code>getstr</code></strong></dt>
<dd>a function that retrieves the text from an item (Default value = None)</dd>
<dt><strong><code>cmp</code></strong></dt>
<dd>a function that compares to strings and returns a boolean
that indicates if they should be considered to be equal. (Default value = None)</dd>
<dt><strong><code>unmatched</code></strong></dt>
<dd>if true returns two lists of tuples, where the second list
contains the offsets of text not matched by the items (Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a list of tuples (start, end, item) where start and end are the
start and end offsets of a substring in the text and item is the item for that substring.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_substrings(text, items, getstr=None, cmp=None, unmatched=False):
    &#34;&#34;&#34;Matches each item from the items sequence with sum substring of the text
    in a greedy fashion. An item is either already a string or getstr is used
    to retrieve a string from it. The text and substrings are normally
    compared with normal string equality but cmp can be replaced with
    a two-argument function that does the comparison instead.
    This function expects that all items are present in the text, in their order
    and without overlapping! If this is not the case, an exception is raised.

    Args:
      text: the text to use for matching
      items: items that are or contains substrings to match
      getstr: a function that retrieves the text from an item (Default value = None)
      cmp: a function that compares to strings and returns a boolean \
    that indicates if they should be considered to be equal. (Default value = None)
      unmatched: if true returns two lists of tuples, where the second list\
    contains the offsets of text not matched by the items (Default value = False)

    Returns:
      a list of tuples (start, end, item) where start and end are the\
      start and end offsets of a substring in the text and item is the item for that substring.

    &#34;&#34;&#34;
    if getstr is None:
        getstr = lambda x: x
    if cmp is None:
        cmp = lambda x,y: x == y
    ltxt = len(text)
    ret = []
    ret2 = []
    item_idx = 0
    start = 0
    lastunmatched = 0
    while start &lt; ltxt:
        itemorig = items[item_idx]
        item = getstr(itemorig)
        end = start + len(item)
        if end &gt; ltxt:
            raise Exception(&#34;Text too short to match next item: {}&#34;.format(item))
        if cmp(text[start:end], item):
            if unmatched and start &gt; lastunmatched:
                ret2.append((lastunmatched, start))
                lastunmatched = start + len(item)
            ret.append((start, end, itemorig))
            start += len(item)
            item_idx += 1
            if item_idx == len(items):
                break
        else:
            start += 1
    if item_idx != len(items):
        raise Exception(&#34;Not all items matched but {} of {}&#34;.format(item_idx, len(items)))
    if unmatched and lastunmatched != ltxt:
        ret2.append((lastunmatched, ltxt))
    if unmatched:
        return ret, ret2
    else:
        return ret</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.run_start"><code class="name flex">
<span>def <span class="ident">run_start</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Define time when running starts.</p>
<h2 id="returns">Returns</h2>
<p>system time in seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_start():
    &#34;&#34;&#34;
    Define time when running starts.

    Returns:
        system time in seconds
    &#34;&#34;&#34;
    global  start
    start = time.time()
    return start</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.run_stop"><code class="name flex">
<span>def <span class="ident">run_stop</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Log and return formatted elapsed run time.</p>
<h2 id="returns">Returns</h2>
<p>tuple of formatted run time, run time in seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_stop():
    &#34;&#34;&#34;
    Log and return formatted elapsed run time.

    Returns:
        tuple of formatted run time, run time in seconds
    &#34;&#34;&#34;
    logger = ensurelogger()
    if start == 0:
        logger.warning(&#34;Run timing not set up properly, no time!&#34;)
        return &#34;&#34;,0
    stop = time.time()
    delta = stop - start
    deltastr = str(datetime.timedelta(seconds=delta))
    logger.info(f&#34;Runtime: {deltastr}&#34;)
    return deltastr, delta</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.set_logger"><code class="name flex">
<span>def <span class="ident">set_logger</span></span>(<span>name=None, file=None, lvl=None, args=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up logger for the module "name". If file is given, log to that file as well.
If file is not given but args is given and has "outpref" parameter, log to
file "outpref.DATETIME.log" as well.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name to use in the log, if None, uses sys.argv[0]</dd>
<dt><strong><code>file</code></strong></dt>
<dd>if given, log to this destination in addition to stderr</dd>
<dt><strong><code>lvl</code></strong></dt>
<dd>set logging level</dd>
<dt><strong><code>args</code></strong></dt>
<dd>not used yet</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The logger instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_logger(name=None, file=None, lvl=None, args=None):
    &#34;&#34;&#34;
    Set up logger for the module &#34;name&#34;. If file is given, log to that file as well.
    If file is not given but args is given and has &#34;outpref&#34; parameter, log to
    file &#34;outpref.DATETIME.log&#34; as well.

    Args:
        name: name to use in the log, if None, uses sys.argv[0]
        file: if given, log to this destination in addition to stderr
        lvl: set logging level
        args: not used yet

    Returns:
        The logger instance
    &#34;&#34;&#34;
    global logger
    if name is None:
        name = sys.argv[0]
    if logger:
        raise Exception(&#34;Odd, we should not have a logger yet?&#34;)
    logger = logging.getLogger(name)
    if lvl is None:
        lvl = logging.INFO
    logger.setLevel(lvl)
    fmt = logging.Formatter(&#39;%(asctime)s|%(levelname)s|%(name)s|%(message)s&#39;)
    hndlr = logging.StreamHandler(sys.stderr)
    hndlr.setFormatter(fmt)
    logger.addHandler(hndlr)
    if file:
        hdnlr = logging.FileHandler(file)
        hndlr.setFormatter(fmt)
        logger.addHandler(hdnlr)
    logger.info(&#34;Started: {}&#34;.format(datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M%S&#34;)))
    return logger</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><p>If obj is not None, call its to_dict method, otherwise return None</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>the object on which to call to_dict</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the result of to_dict or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(obj):
    &#34;&#34;&#34;If obj is not None, call its to_dict method, otherwise return None

    Args:
      obj: the object on which to call to_dict

    Returns:
      the result of to_dict or None

    &#34;&#34;&#34;
    if obj is None:
        return None
    else:
        return obj.to_dict()</code></pre>
</details>
</dd>
<dt id="gatenlp.utils.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><p>If obj is not None, call its to_list method, otherwise return None</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>the object on which to call to_list</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the result of to_list or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(obj):
    &#34;&#34;&#34;If obj is not None, call its to_list method, otherwise return None

    Args:
      obj: the object on which to call to_list

    Returns:
      the result of to_list or None

    &#34;&#34;&#34;
    if obj is None:
        return None
    else:
        return obj.to_list()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp" href="index.html">gatenlp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="gatenlp.utils.ensurelogger" href="#gatenlp.utils.ensurelogger">ensurelogger</a></code></li>
<li><code><a title="gatenlp.utils.file4logger" href="#gatenlp.utils.file4logger">file4logger</a></code></li>
<li><code><a title="gatenlp.utils.match_substrings" href="#gatenlp.utils.match_substrings">match_substrings</a></code></li>
<li><code><a title="gatenlp.utils.run_start" href="#gatenlp.utils.run_start">run_start</a></code></li>
<li><code><a title="gatenlp.utils.run_stop" href="#gatenlp.utils.run_stop">run_stop</a></code></li>
<li><code><a title="gatenlp.utils.set_logger" href="#gatenlp.utils.set_logger">set_logger</a></code></li>
<li><code><a title="gatenlp.utils.to_dict" href="#gatenlp.utils.to_dict">to_dict</a></code></li>
<li><code><a title="gatenlp.utils.to_list" href="#gatenlp.utils.to_list">to_list</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>