<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev16+g8c2bb0d.d20201028" />
<title>gatenlp.features API documentation</title>
<meta name="description" content="Module that implements class Feature for representing features." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.features</code></h1>
</header>
<section id="section-intro">
<p>Module that implements class Feature for representing features.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that implements class Feature for representing features.
&#34;&#34;&#34;
# Implementation note: Features should behave much like a dict. However, inheriting from dict
# is problematic, because dict has an odd way to implement interdependent methods, e.g. ne and eq
# are implemented separately, so the inheriting class would need to implement them separately too.
# Similar for clear and __delitem__ and other method pairs.
#
# Possible alternate approaches:
# * implement everything ourselves
# * inherit from collections.abc.MutableMapping and implement delitem, getitem, setitem, iter, len and repr
# * inherit from collections.UserDict and implement delitem, setitem and repr
#   This one IS NOT a dict but WRAPS around a dict which is accessible as self.data
# Since Features is meant to be pretty close to how a dict works and originally was implemented by
# wrapping an actual dict, the collections.UserDict approach seems to be more adequate.

from collections import UserDict
import copy as lib_copy



class Features(UserDict):
    &#34;&#34;&#34;A dict-like class for storing features, which are mappings from string feature names to
    arbitrary feature values. If the Features instance is a field in another object where
    changes are getting logged in a change log, it should pass on the logger, a method for
    logging feature changes. Any copy of an instance of Features will not receive the logger,
    in order to make sure that logging happens, the instance stored in the original owning
    object must be used.

    Args:

    Returns:

    &#34;&#34;&#34;

    def __init__(self, *args, logger=None, **kwargs):
        &#34;&#34;&#34;
        Initialize a Features object.

        :param initialfeatures: the initial features, as for a dict.
        :param logger: a function for logging any changes to the feature map. This should be
          a method implemented in the owning object. It should take the following parameters:
          command, featurename, featurevalue.
        &#34;&#34;&#34;
        self._logger = logger
        if len(args) == 1:
            posarg = args[0]
            if isinstance(posarg, Features):
                super().__init__(posarg.data, **kwargs)
            else:
                super().__init__(posarg, **kwargs)
        else:
            super().__init__(**kwargs)

    def __delitem__(self, featurename):
        &#34;&#34;&#34;
        Remove the feature with the given feature name. This raises a key error if featurename is
        not in the Features. To silently remove a key, if it exists, use `pop(fname, None)`

        :param featurename: name of the feature to remove
        :return:
        &#34;&#34;&#34;
        if self._logger:
            self._logger(&#34;feature:remove&#34;, feature=featurename)
        del self.data[featurename]

    def __repr__(self):
        &#34;&#34;&#34;
        Return string representation of the Features object.

        :return: string representation.
        &#34;&#34;&#34;
        return f&#34;Features({self.data.__repr__()})&#34;

    def __setitem__(self, featurename, featurevalue):
        &#34;&#34;&#34;
        Set a feature with the given name to the given value.

        :param featurename: feature name, must be string
        :param featurevalue:  feature value
        :return:
        &#34;&#34;&#34;
        if featurename is None or not isinstance(featurename, str):
            raise Exception(&#34;A feature name must be a string, not {}&#34;.format(type(featurename)))
        if self._logger:
            self._logger(&#34;feature:set&#34;, feature=featurename, value=featurevalue)
        self.data[featurename] = featurevalue

    def clear(self):
        &#34;&#34;&#34;Remove all features.
        
        :return:

        Args:

        Returns:

        &#34;&#34;&#34;
        if self._logger:
            self._logger(&#34;features:clear&#34;)
        self.data.clear()

    def copy(self, deep=False):
        &#34;&#34;&#34;Return a shallow (or deep if deep=True) copy of the features. The result is another
        instance of Features which is detached from the owner and which does not log
        the changes. However, if the copy is shallow and feature values are references
        to mutable objects, they can still get modified in the original set (without
        any logging!).

        Args:
          deep: if True return a deep instead of a shallow copy of the features. (Default value = False)

        Returns:
          a dictionary with the features

        &#34;&#34;&#34;
        ret = Features()
        if deep:
            ret.data = deep(self.data)
        else:
            ret.data = self.data.copy()
        ret._logger = None
        return ret

    def to_dict(self, deepcopy=False, memo=None):
        &#34;&#34;&#34;
        Return a dictionary representation of the features. The returned dictionary is always a shallow
        copy of the original dictionary of features, but will be a deep copy if the parameter `deepcopy` is True.

        Note:
            Features with names that start with two underscores are considered &#34;internal/transient&#34; features
            and not saved. Features with names that start with one underscore are considered &#34;internal&#34; but
            do get saved/serialized.

        Args:
          deepcopy: if True, the dictionary is a deep copy so that mutable objects
              in the original are unaffected if they get modified in the copy. (Default value = False)
          memo: if deepcopy is True, the memo object to use for deepcopy, if any

        Returns:
          the dict representation of the features

        &#34;&#34;&#34;
        ret = dict()
        for k,v in self.data.items():
            if k.startswith(&#34;__&#34;):
                continue
            if deepcopy:
                ret[k] = lib_copy.deepcopy(v)
            else:
                ret[k] = v
        return ret

    @staticmethod
    def from_dict(thedict, deepcopy=False, memo=None):
        &#34;&#34;&#34;
        Create a Features instance from a dictionary. If deepcopy is True, a deepcopy is created.
        
        NOTE: no checks are done to make sure that feature names are string only!

        Args:
          thedict: the dictionary from which to create the Features.
          deepcopy: if True and copy is True, use a deep copy of the dictionary (Default value = False)
          memo: if deepcopy is True, the memo object to use for deepcopying

        Returns:
          the Features instance

        &#34;&#34;&#34;
        ret = Features()
        if deepcopy:
            ret.data = lib_copy.deepcopy(thedict, memo=memo)
        else:
            ret.data = thedict.copy()
        return ret</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.features.Features"><code class="flex name class">
<span>class <span class="ident">Features</span></span>
<span>(</span><span>*args, logger=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A dict-like class for storing features, which are mappings from string feature names to
arbitrary feature values. If the Features instance is a field in another object where
changes are getting logged in a change log, it should pass on the logger, a method for
logging feature changes. Any copy of an instance of Features will not receive the logger,
in order to make sure that logging happens, the instance stored in the original owning
object must be used.</p>
<p>Args:</p>
<p>Returns:</p>
<p>Initialize a Features object.</p>
<p>:param initialfeatures: the initial features, as for a dict.
:param logger: a function for logging any changes to the feature map. This should be
a method implemented in the owning object. It should take the following parameters:
command, featurename, featurevalue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Features(UserDict):
    &#34;&#34;&#34;A dict-like class for storing features, which are mappings from string feature names to
    arbitrary feature values. If the Features instance is a field in another object where
    changes are getting logged in a change log, it should pass on the logger, a method for
    logging feature changes. Any copy of an instance of Features will not receive the logger,
    in order to make sure that logging happens, the instance stored in the original owning
    object must be used.

    Args:

    Returns:

    &#34;&#34;&#34;

    def __init__(self, *args, logger=None, **kwargs):
        &#34;&#34;&#34;
        Initialize a Features object.

        :param initialfeatures: the initial features, as for a dict.
        :param logger: a function for logging any changes to the feature map. This should be
          a method implemented in the owning object. It should take the following parameters:
          command, featurename, featurevalue.
        &#34;&#34;&#34;
        self._logger = logger
        if len(args) == 1:
            posarg = args[0]
            if isinstance(posarg, Features):
                super().__init__(posarg.data, **kwargs)
            else:
                super().__init__(posarg, **kwargs)
        else:
            super().__init__(**kwargs)

    def __delitem__(self, featurename):
        &#34;&#34;&#34;
        Remove the feature with the given feature name. This raises a key error if featurename is
        not in the Features. To silently remove a key, if it exists, use `pop(fname, None)`

        :param featurename: name of the feature to remove
        :return:
        &#34;&#34;&#34;
        if self._logger:
            self._logger(&#34;feature:remove&#34;, feature=featurename)
        del self.data[featurename]

    def __repr__(self):
        &#34;&#34;&#34;
        Return string representation of the Features object.

        :return: string representation.
        &#34;&#34;&#34;
        return f&#34;Features({self.data.__repr__()})&#34;

    def __setitem__(self, featurename, featurevalue):
        &#34;&#34;&#34;
        Set a feature with the given name to the given value.

        :param featurename: feature name, must be string
        :param featurevalue:  feature value
        :return:
        &#34;&#34;&#34;
        if featurename is None or not isinstance(featurename, str):
            raise Exception(&#34;A feature name must be a string, not {}&#34;.format(type(featurename)))
        if self._logger:
            self._logger(&#34;feature:set&#34;, feature=featurename, value=featurevalue)
        self.data[featurename] = featurevalue

    def clear(self):
        &#34;&#34;&#34;Remove all features.
        
        :return:

        Args:

        Returns:

        &#34;&#34;&#34;
        if self._logger:
            self._logger(&#34;features:clear&#34;)
        self.data.clear()

    def copy(self, deep=False):
        &#34;&#34;&#34;Return a shallow (or deep if deep=True) copy of the features. The result is another
        instance of Features which is detached from the owner and which does not log
        the changes. However, if the copy is shallow and feature values are references
        to mutable objects, they can still get modified in the original set (without
        any logging!).

        Args:
          deep: if True return a deep instead of a shallow copy of the features. (Default value = False)

        Returns:
          a dictionary with the features

        &#34;&#34;&#34;
        ret = Features()
        if deep:
            ret.data = deep(self.data)
        else:
            ret.data = self.data.copy()
        ret._logger = None
        return ret

    def to_dict(self, deepcopy=False, memo=None):
        &#34;&#34;&#34;
        Return a dictionary representation of the features. The returned dictionary is always a shallow
        copy of the original dictionary of features, but will be a deep copy if the parameter `deepcopy` is True.

        Note:
            Features with names that start with two underscores are considered &#34;internal/transient&#34; features
            and not saved. Features with names that start with one underscore are considered &#34;internal&#34; but
            do get saved/serialized.

        Args:
          deepcopy: if True, the dictionary is a deep copy so that mutable objects
              in the original are unaffected if they get modified in the copy. (Default value = False)
          memo: if deepcopy is True, the memo object to use for deepcopy, if any

        Returns:
          the dict representation of the features

        &#34;&#34;&#34;
        ret = dict()
        for k,v in self.data.items():
            if k.startswith(&#34;__&#34;):
                continue
            if deepcopy:
                ret[k] = lib_copy.deepcopy(v)
            else:
                ret[k] = v
        return ret

    @staticmethod
    def from_dict(thedict, deepcopy=False, memo=None):
        &#34;&#34;&#34;
        Create a Features instance from a dictionary. If deepcopy is True, a deepcopy is created.
        
        NOTE: no checks are done to make sure that feature names are string only!

        Args:
          thedict: the dictionary from which to create the Features.
          deepcopy: if True and copy is True, use a deep copy of the dictionary (Default value = False)
          memo: if deepcopy is True, the memo object to use for deepcopying

        Returns:
          the Features instance

        &#34;&#34;&#34;
        ret = Features()
        if deepcopy:
            ret.data = lib_copy.deepcopy(thedict, memo=memo)
        else:
            ret.data = thedict.copy()
        return ret</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.UserDict</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.features.Features.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>thedict, deepcopy=False, memo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Features instance from a dictionary. If deepcopy is True, a deepcopy is created.</p>
<p>NOTE: no checks are done to make sure that feature names are string only!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>thedict</code></strong></dt>
<dd>the dictionary from which to create the Features.</dd>
<dt><strong><code>deepcopy</code></strong></dt>
<dd>if True and copy is True, use a deep copy of the dictionary (Default value = False)</dd>
<dt><strong><code>memo</code></strong></dt>
<dd>if deepcopy is True, the memo object to use for deepcopying</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the Features instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(thedict, deepcopy=False, memo=None):
    &#34;&#34;&#34;
    Create a Features instance from a dictionary. If deepcopy is True, a deepcopy is created.
    
    NOTE: no checks are done to make sure that feature names are string only!

    Args:
      thedict: the dictionary from which to create the Features.
      deepcopy: if True and copy is True, use a deep copy of the dictionary (Default value = False)
      memo: if deepcopy is True, the memo object to use for deepcopying

    Returns:
      the Features instance

    &#34;&#34;&#34;
    ret = Features()
    if deepcopy:
        ret.data = lib_copy.deepcopy(thedict, memo=memo)
    else:
        ret.data = thedict.copy()
    return ret</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.features.Features.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all features.</p>
<p>:return:</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Remove all features.
    
    :return:

    Args:

    Returns:

    &#34;&#34;&#34;
    if self._logger:
        self._logger(&#34;features:clear&#34;)
    self.data.clear()</code></pre>
</details>
</dd>
<dt id="gatenlp.features.Features.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, deep=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a shallow (or deep if deep=True) copy of the features. The result is another
instance of Features which is detached from the owner and which does not log
the changes. However, if the copy is shallow and feature values are references
to mutable objects, they can still get modified in the original set (without
any logging!).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>deep</code></strong></dt>
<dd>if True return a deep instead of a shallow copy of the features. (Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a dictionary with the features</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, deep=False):
    &#34;&#34;&#34;Return a shallow (or deep if deep=True) copy of the features. The result is another
    instance of Features which is detached from the owner and which does not log
    the changes. However, if the copy is shallow and feature values are references
    to mutable objects, they can still get modified in the original set (without
    any logging!).

    Args:
      deep: if True return a deep instead of a shallow copy of the features. (Default value = False)

    Returns:
      a dictionary with the features

    &#34;&#34;&#34;
    ret = Features()
    if deep:
        ret.data = deep(self.data)
    else:
        ret.data = self.data.copy()
    ret._logger = None
    return ret</code></pre>
</details>
</dd>
<dt id="gatenlp.features.Features.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, deepcopy=False, memo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary representation of the features. The returned dictionary is always a shallow
copy of the original dictionary of features, but will be a deep copy if the parameter <code>deepcopy</code> is True.</p>
<h2 id="note">Note</h2>
<p>Features with names that start with two underscores are considered "internal/transient" features
and not saved. Features with names that start with one underscore are considered "internal" but
do get saved/serialized.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>deepcopy</code></strong></dt>
<dd>if True, the dictionary is a deep copy so that mutable objects
in the original are unaffected if they get modified in the copy. (Default value = False)</dd>
<dt><strong><code>memo</code></strong></dt>
<dd>if deepcopy is True, the memo object to use for deepcopy, if any</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the dict representation of the features</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, deepcopy=False, memo=None):
    &#34;&#34;&#34;
    Return a dictionary representation of the features. The returned dictionary is always a shallow
    copy of the original dictionary of features, but will be a deep copy if the parameter `deepcopy` is True.

    Note:
        Features with names that start with two underscores are considered &#34;internal/transient&#34; features
        and not saved. Features with names that start with one underscore are considered &#34;internal&#34; but
        do get saved/serialized.

    Args:
      deepcopy: if True, the dictionary is a deep copy so that mutable objects
          in the original are unaffected if they get modified in the copy. (Default value = False)
      memo: if deepcopy is True, the memo object to use for deepcopy, if any

    Returns:
      the dict representation of the features

    &#34;&#34;&#34;
    ret = dict()
    for k,v in self.data.items():
        if k.startswith(&#34;__&#34;):
            continue
        if deepcopy:
            ret[k] = lib_copy.deepcopy(v)
        else:
            ret[k] = v
    return ret</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp" href="index.html">gatenlp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.features.Features" href="#gatenlp.features.Features">Features</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.features.Features.clear" href="#gatenlp.features.Features.clear">clear</a></code></li>
<li><code><a title="gatenlp.features.Features.copy" href="#gatenlp.features.Features.copy">copy</a></code></li>
<li><code><a title="gatenlp.features.Features.from_dict" href="#gatenlp.features.Features.from_dict">from_dict</a></code></li>
<li><code><a title="gatenlp.features.Features.to_dict" href="#gatenlp.features.Features.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev16+g8c2bb0d.d20201028</a>.</p>
</footer>
</body>
</html>