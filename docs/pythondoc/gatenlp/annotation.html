<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev16+g8c2bb0d.d20201028" />
<title>gatenlp.annotation API documentation</title>
<meta name="description" content="Module for Annotation class which represents information about a span of text in
a document." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.annotation</code></h1>
</header>
<section id="section-intro">
<p>Module for Annotation class which represents information about a span of text in
a document.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module for Annotation class which represents information about a span of text in  a document.
&#34;&#34;&#34;
import sys
from typing import List, Union, Dict, Set, Tuple
import copy as lib_copy
from functools import total_ordering
from gatenlp.features import Features
from gatenlp.offsetmapper import OFFSET_TYPE_JAVA, OFFSET_TYPE_PYTHON
from gatenlp.utils import support_annotation_or_set


@total_ordering
class Annotation:
    &#34;&#34;&#34;
    An annotation represents information about a span of text. It contains the start and end
    offsets of the span, an &#34;annotation type&#34; and an arbitrary number of features.

    In addition it contains an id which has no meaning for the annotation itself but is
    used to uniquely identify an annotation within the set it is contained in.

    All fields except the features are immutable, once the annotation has been created
    only the features can be changed.
    &#34;&#34;&#34;

    def __init__(
            self, start: int, end: int, anntype: str,
            features=None,
            annid: int = 0
    ):
        &#34;&#34;&#34;
        This constructor creates a new annotation instance. Once an annotation has been created,
        the start, end, type and id fields cannot be changed.

        NOTE: this should almost never be done directly
        and instead the method AnnotationSet.add should be used.

        Args:
            start: start offset of the annotation
            end: end offset of the annotation
            anntype: annotation type
            features: an initial collection of features, None for no features.
            annid: the id of the annotation
        &#34;&#34;&#34;
        if end &lt; start:
            raise Exception(f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, id={annid}, features={features}: start &gt; end&#34;)
        if not isinstance(annid, int):
            raise Exception(f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, id={annid}, features={features}: annid is not an int&#34;)
        if isinstance(features, int):
            raise Exception(f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, id={annid}, features={features}: features must not be an int&#34;)
        # super().__init__(features)
        if annid is not None and not isinstance(annid, int):
            raise Exception(&#34;Parameter annid must be an int, mixed up with features?&#34;)
        if features is not None and isinstance(features, int):
            raise Exception(&#34;Parameter features must not be an int: mixed up with annid?&#34;)
        self._owner_set = None
        self._features = Features(features, logger=self._log_feature_change)
        self._type = anntype
        self._start = start
        self._end = end
        self._id = annid

    @property
    def type(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the annotation type.
        &#34;&#34;&#34;
        return self._type

    @property
    def start(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the start offset.
        &#34;&#34;&#34;
        return self._start

    @property
    def end(self):
        &#34;&#34;&#34;
        Returns the end offset.
        &#34;&#34;&#34;
        return self._end

    @property
    def features(self):
        &#34;&#34;&#34;
        Returns the features for the annotation.
        &#34;&#34;&#34;
        return self._features

    @property
    def id(self):
        &#34;&#34;&#34;
        Returns the annotation id.
        &#34;&#34;&#34;
        return self._id

    @property
    def span(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Returns a tuple with the start and end offset of the annotation.
        &#34;&#34;&#34;
        return self.start, self.end

    def _changelog(self):
        if self._owner_set is not None:
            return self._owner_set.changelog

    # TODO: for now at least, make sure only simple JSON serialisable things are used! We do NOT
    # allow any user specific types in order to make sure what we create is interchangeable with GATE.
    # In addition we do NOT allow None features.
    # So a feature name always has to be a string (not None), the value has to be anything that is json
    # serialisable (except None keys for maps).
    # For performance reasons we check the feature name but not the value (maybe make checking optional
    # on by default but still optional?)
    def _log_feature_change(self, command: str, feature: str = None, value=None) -&gt; None:
        &#34;&#34;&#34;

        Args:
          command: str: 
          feature: str:  (Default value = None)
          value:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if self._changelog() is None:
            return
        command = &#34;ann-&#34;+command
        ch = {
            &#34;command&#34;: command,
            &#34;type&#34;: &#34;annotation&#34;,
            &#34;set&#34;: self._owner_set.name,
            &#34;id&#34;: self.id}
        if feature is not None:
            ch[&#34;feature&#34;] = feature
        if value is not None:
            ch[&#34;value&#34;] = value
        self._changelog().append(ch)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;
        Two annotations are identical if they are the same object or if all the fields
        are equal.
        &#34;&#34;&#34;
        if not isinstance(other, Annotation):
            return False
        if self is other:
            return True
        return self.start == other.start and self.end == other.end and \
               self.type == other.type and self.id == other.id and self._features == other._features

    def __hash__(self):
        &#34;&#34;&#34;
        The hash depends on the annotation ID and the owning set.
        &#34;&#34;&#34;
        return hash((self.id, self._owner_set))

    def __lt__(self, other) -&gt; bool:
        &#34;&#34;&#34;
        Comparison for sorting: this sorts by increasing start offset,  then increasing annotation id.
        Since annotation ids within a set are unique, this guarantees a unique order of annotations that
        come from an annotation set.

        Note: for now the other object has to be an instance of Annotation, duck typing is not supported!
        &#34;&#34;&#34;
        if not isinstance(other, Annotation):
            raise Exception(&#34;Cannot compare to non-Annotation&#34;)
        if self.start &lt; other.start:
            return True
        elif self.start &gt; other.start:
            return False
        else:
            return self.id &lt; other.id

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        String representation of the annotation.
        &#34;&#34;&#34;
        return &#34;Annotation({},{},{},features={},id={})&#34;.format(self.start, self.end, self.type, self._features, self.id)

    @property
    def length(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the length of the annotation: this is the length of the offset span.
        Since the end offset is one after the last
        element, we return end-start. Note: this is deliberately not implemented as len(ann), as
        len(annset) returns the number of annotations in the set but annset.length() also returns the
        span length of the annotation set, so the method name for this is identical between annotations
        and annotation sets.
        &#34;&#34;&#34;
        return self.end - self.start

    @support_annotation_or_set
    def isoverlapping(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is overlapping with the given span, annotation or
        annotation set.
        An annotation is overlapping with a span if the first or last character
        is inside that span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if overlapping, `False` otherwise

        &#34;&#34;&#34;
        return self.iscovering(start) or self.iscovering(end - 1)

    @support_annotation_or_set
    def iscoextensive(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is coextensive with the given span, annotation or
        annotation set, i.e. has exactly the same start and end offsets.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if coextensive, `False` otherwise

        &#34;&#34;&#34;
        return self.start == start and self.end == end

    @support_annotation_or_set
    def iswithin(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is within the given span, annotation or
        annotation set, i.e. both the start and end offsets of this annotation
        are after the given start and before the given end.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if within, `False` otherwise

        &#34;&#34;&#34;
        return start &lt;= self.start and end &gt;= self.end

    @support_annotation_or_set
    def isbefore(self, start: int, end: int, immediately=False) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is before the other span, i.e. the end of this annotation
        is before the start of the other annotation or span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span
          immediately: if true checks if this annotation ends immediately before the other one (Default value = False)

        Returns:
          True if before, False otherwise

        &#34;&#34;&#34;
        if immediately:
            return self.end == start
        else:
            return self.end &lt;= start

    @support_annotation_or_set
    def isafter(self, start: int, end: int, immediately=False) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is after the other span, i.e. the start of this annotation
        is after the end of the other annotation or span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span
          immediately: if true checks if this annotation starts immediately after the other one (Default value = False)

        Returns:
          True if after, False otherwise

        &#34;&#34;&#34;
        if immediately:
            return self.start == end
        else:
            return self.start &gt;= end

    @support_annotation_or_set
    def gap(self, start: int, end: int):
        &#34;&#34;&#34;Return the gep between this annotation and the other annotation. This is the distance between
        the last character of the first annotation and the first character of the second annotation in
        sequence, so it is always independent of the order of the two annotations.
        
        This is negative if the annotations overlap.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of span
          end: end offset of span

        Returns:
          size of gap

        &#34;&#34;&#34;
        if self.start &lt; start:
            ann1start = self.start
            ann1end = self.end
            ann2start = start
            ann2end = end
        else:
            ann2start = self.start
            ann2end = self.end
            ann1start = start
            ann1end = end
        return ann2start - ann1end

    @support_annotation_or_set
    def iscovering(self, start: int, end: int = None) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is covering the given span, annotation or
        annotation set, i.e. both the given start and end offsets
        are after the start of this annotation and before the end of this annotation.
        
        If end is not given, then the method checks if start is an offset of a character
        contained in the span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          True if covering, False otherwise

        &#34;&#34;&#34;
        if end is None:
            return self.start &lt;= start &lt; self.end
        else:
            return self.start &lt;= start and self.end &gt;= end

    def to_dict(self, offset_mapper=None, offset_type=None):
        &#34;&#34;&#34;
        Return a representation of this annotation as a nested map. This representation is
        used for several serialization methods.

        Args:
            offset_mapper: the offset mapper to use, must be specified if `offset_type` is specified.
            offset_type: the offset type to be used for the conversionm must be specified if
               `offset_mapper` is specified

        Returns:
            the dictionary representation of the Annotation
        &#34;&#34;&#34;
        if (offset_mapper and not offset_type) or (not offset_mapper and offset_type):
            raise Exception(&#34;offset_mapper and offset_type must be specified both or none&#34;)
        if offset_mapper is not None:
            if offset_type == OFFSET_TYPE_JAVA:
                start = offset_mapper.convert_to_java(self._start)
                end = offset_mapper.convert_to_java(self._end)
            elif offset_type == OFFSET_TYPE_PYTHON:
                start = offset_mapper.convert_to_python(self._start)
                end = offset_mapper.convert_to_python(self._end)
            else:
                raise Exception(f&#34;Not a valid offset type: {offset_type}, must be &#39;p&#39; or &#39;j&#39;&#34;)
        else:
            start = self._start
            end = self._end
        return {
            &#34;type&#34;: self.type,
            &#34;start&#34;: start,
            &#34;end&#34;: end,
            &#34;id&#34;: self.id,
            &#34;features&#34;: self._features.to_dict(),
        }

    @staticmethod
    def from_dict(dictrepr, owner_set=None, **kwargs):
        &#34;&#34;&#34;
        Construct an annotation object from the dictionary representation.

        Args:
          dictrepr: dictionary representation
          owner_set: the owning set the annotation should have (Default value = None)
          kwargs: ignored
        &#34;&#34;&#34;
        ann = Annotation(
            start=dictrepr.get(&#34;start&#34;),
            end=dictrepr.get(&#34;end&#34;),
            anntype=dictrepr.get(&#34;type&#34;),
            annid=dictrepr.get(&#34;id&#34;),
            features=dictrepr.get(&#34;features&#34;)
        )
        ann._owner_set = owner_set
        return ann

    def __copy__(self):
        return Annotation(self._start, self._end, self._type, annid=self._id, features=self._features)

    def copy(self):
        &#34;&#34;&#34;
        Return a shallow copy of the annotation (features are shared).
        &#34;&#34;&#34;
        return self.__copy__()

    def __deepcopy__(self, memo=None):
        if self._features is not None:
            fts = lib_copy.deepcopy(self._features.to_dict(), memo=memo)
        else:
            fts = None
        return Annotation(self._start, self._end, self._type, annid=self._id, features=fts)

    def deepcopy(self, memo=None):
        &#34;&#34;&#34;
        Return a deep copy of the annotation (features and their values are copied as well).
        &#34;&#34;&#34;
        return lib_copy.deepcopy(self, memo=memo)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.annotation.Annotation"><code class="flex name class">
<span>class <span class="ident">Annotation</span></span>
<span>(</span><span>start: int, end: int, anntype: str, features=None, annid: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>An annotation represents information about a span of text. It contains the start and end
offsets of the span, an "annotation type" and an arbitrary number of features.</p>
<p>In addition it contains an id which has no meaning for the annotation itself but is
used to uniquely identify an annotation within the set it is contained in.</p>
<p>All fields except the features are immutable, once the annotation has been created
only the features can be changed.</p>
<p>This constructor creates a new annotation instance. Once an annotation has been created,
the start, end, type and id fields cannot be changed.</p>
<p>NOTE: this should almost never be done directly
and instead the method AnnotationSet.add should be used.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the annotation</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the annotation</dd>
<dt><strong><code>anntype</code></strong></dt>
<dd>annotation type</dd>
<dt><strong><code>features</code></strong></dt>
<dd>an initial collection of features, None for no features.</dd>
<dt><strong><code>annid</code></strong></dt>
<dd>the id of the annotation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Annotation:
    &#34;&#34;&#34;
    An annotation represents information about a span of text. It contains the start and end
    offsets of the span, an &#34;annotation type&#34; and an arbitrary number of features.

    In addition it contains an id which has no meaning for the annotation itself but is
    used to uniquely identify an annotation within the set it is contained in.

    All fields except the features are immutable, once the annotation has been created
    only the features can be changed.
    &#34;&#34;&#34;

    def __init__(
            self, start: int, end: int, anntype: str,
            features=None,
            annid: int = 0
    ):
        &#34;&#34;&#34;
        This constructor creates a new annotation instance. Once an annotation has been created,
        the start, end, type and id fields cannot be changed.

        NOTE: this should almost never be done directly
        and instead the method AnnotationSet.add should be used.

        Args:
            start: start offset of the annotation
            end: end offset of the annotation
            anntype: annotation type
            features: an initial collection of features, None for no features.
            annid: the id of the annotation
        &#34;&#34;&#34;
        if end &lt; start:
            raise Exception(f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, id={annid}, features={features}: start &gt; end&#34;)
        if not isinstance(annid, int):
            raise Exception(f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, id={annid}, features={features}: annid is not an int&#34;)
        if isinstance(features, int):
            raise Exception(f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, id={annid}, features={features}: features must not be an int&#34;)
        # super().__init__(features)
        if annid is not None and not isinstance(annid, int):
            raise Exception(&#34;Parameter annid must be an int, mixed up with features?&#34;)
        if features is not None and isinstance(features, int):
            raise Exception(&#34;Parameter features must not be an int: mixed up with annid?&#34;)
        self._owner_set = None
        self._features = Features(features, logger=self._log_feature_change)
        self._type = anntype
        self._start = start
        self._end = end
        self._id = annid

    @property
    def type(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the annotation type.
        &#34;&#34;&#34;
        return self._type

    @property
    def start(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the start offset.
        &#34;&#34;&#34;
        return self._start

    @property
    def end(self):
        &#34;&#34;&#34;
        Returns the end offset.
        &#34;&#34;&#34;
        return self._end

    @property
    def features(self):
        &#34;&#34;&#34;
        Returns the features for the annotation.
        &#34;&#34;&#34;
        return self._features

    @property
    def id(self):
        &#34;&#34;&#34;
        Returns the annotation id.
        &#34;&#34;&#34;
        return self._id

    @property
    def span(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Returns a tuple with the start and end offset of the annotation.
        &#34;&#34;&#34;
        return self.start, self.end

    def _changelog(self):
        if self._owner_set is not None:
            return self._owner_set.changelog

    # TODO: for now at least, make sure only simple JSON serialisable things are used! We do NOT
    # allow any user specific types in order to make sure what we create is interchangeable with GATE.
    # In addition we do NOT allow None features.
    # So a feature name always has to be a string (not None), the value has to be anything that is json
    # serialisable (except None keys for maps).
    # For performance reasons we check the feature name but not the value (maybe make checking optional
    # on by default but still optional?)
    def _log_feature_change(self, command: str, feature: str = None, value=None) -&gt; None:
        &#34;&#34;&#34;

        Args:
          command: str: 
          feature: str:  (Default value = None)
          value:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if self._changelog() is None:
            return
        command = &#34;ann-&#34;+command
        ch = {
            &#34;command&#34;: command,
            &#34;type&#34;: &#34;annotation&#34;,
            &#34;set&#34;: self._owner_set.name,
            &#34;id&#34;: self.id}
        if feature is not None:
            ch[&#34;feature&#34;] = feature
        if value is not None:
            ch[&#34;value&#34;] = value
        self._changelog().append(ch)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;
        Two annotations are identical if they are the same object or if all the fields
        are equal.
        &#34;&#34;&#34;
        if not isinstance(other, Annotation):
            return False
        if self is other:
            return True
        return self.start == other.start and self.end == other.end and \
               self.type == other.type and self.id == other.id and self._features == other._features

    def __hash__(self):
        &#34;&#34;&#34;
        The hash depends on the annotation ID and the owning set.
        &#34;&#34;&#34;
        return hash((self.id, self._owner_set))

    def __lt__(self, other) -&gt; bool:
        &#34;&#34;&#34;
        Comparison for sorting: this sorts by increasing start offset,  then increasing annotation id.
        Since annotation ids within a set are unique, this guarantees a unique order of annotations that
        come from an annotation set.

        Note: for now the other object has to be an instance of Annotation, duck typing is not supported!
        &#34;&#34;&#34;
        if not isinstance(other, Annotation):
            raise Exception(&#34;Cannot compare to non-Annotation&#34;)
        if self.start &lt; other.start:
            return True
        elif self.start &gt; other.start:
            return False
        else:
            return self.id &lt; other.id

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        String representation of the annotation.
        &#34;&#34;&#34;
        return &#34;Annotation({},{},{},features={},id={})&#34;.format(self.start, self.end, self.type, self._features, self.id)

    @property
    def length(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the length of the annotation: this is the length of the offset span.
        Since the end offset is one after the last
        element, we return end-start. Note: this is deliberately not implemented as len(ann), as
        len(annset) returns the number of annotations in the set but annset.length() also returns the
        span length of the annotation set, so the method name for this is identical between annotations
        and annotation sets.
        &#34;&#34;&#34;
        return self.end - self.start

    @support_annotation_or_set
    def isoverlapping(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is overlapping with the given span, annotation or
        annotation set.
        An annotation is overlapping with a span if the first or last character
        is inside that span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if overlapping, `False` otherwise

        &#34;&#34;&#34;
        return self.iscovering(start) or self.iscovering(end - 1)

    @support_annotation_or_set
    def iscoextensive(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is coextensive with the given span, annotation or
        annotation set, i.e. has exactly the same start and end offsets.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if coextensive, `False` otherwise

        &#34;&#34;&#34;
        return self.start == start and self.end == end

    @support_annotation_or_set
    def iswithin(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is within the given span, annotation or
        annotation set, i.e. both the start and end offsets of this annotation
        are after the given start and before the given end.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if within, `False` otherwise

        &#34;&#34;&#34;
        return start &lt;= self.start and end &gt;= self.end

    @support_annotation_or_set
    def isbefore(self, start: int, end: int, immediately=False) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is before the other span, i.e. the end of this annotation
        is before the start of the other annotation or span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span
          immediately: if true checks if this annotation ends immediately before the other one (Default value = False)

        Returns:
          True if before, False otherwise

        &#34;&#34;&#34;
        if immediately:
            return self.end == start
        else:
            return self.end &lt;= start

    @support_annotation_or_set
    def isafter(self, start: int, end: int, immediately=False) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is after the other span, i.e. the start of this annotation
        is after the end of the other annotation or span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span
          immediately: if true checks if this annotation starts immediately after the other one (Default value = False)

        Returns:
          True if after, False otherwise

        &#34;&#34;&#34;
        if immediately:
            return self.start == end
        else:
            return self.start &gt;= end

    @support_annotation_or_set
    def gap(self, start: int, end: int):
        &#34;&#34;&#34;Return the gep between this annotation and the other annotation. This is the distance between
        the last character of the first annotation and the first character of the second annotation in
        sequence, so it is always independent of the order of the two annotations.
        
        This is negative if the annotations overlap.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of span
          end: end offset of span

        Returns:
          size of gap

        &#34;&#34;&#34;
        if self.start &lt; start:
            ann1start = self.start
            ann1end = self.end
            ann2start = start
            ann2end = end
        else:
            ann2start = self.start
            ann2end = self.end
            ann1start = start
            ann1end = end
        return ann2start - ann1end

    @support_annotation_or_set
    def iscovering(self, start: int, end: int = None) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is covering the given span, annotation or
        annotation set, i.e. both the given start and end offsets
        are after the start of this annotation and before the end of this annotation.
        
        If end is not given, then the method checks if start is an offset of a character
        contained in the span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          True if covering, False otherwise

        &#34;&#34;&#34;
        if end is None:
            return self.start &lt;= start &lt; self.end
        else:
            return self.start &lt;= start and self.end &gt;= end

    def to_dict(self, offset_mapper=None, offset_type=None):
        &#34;&#34;&#34;
        Return a representation of this annotation as a nested map. This representation is
        used for several serialization methods.

        Args:
            offset_mapper: the offset mapper to use, must be specified if `offset_type` is specified.
            offset_type: the offset type to be used for the conversionm must be specified if
               `offset_mapper` is specified

        Returns:
            the dictionary representation of the Annotation
        &#34;&#34;&#34;
        if (offset_mapper and not offset_type) or (not offset_mapper and offset_type):
            raise Exception(&#34;offset_mapper and offset_type must be specified both or none&#34;)
        if offset_mapper is not None:
            if offset_type == OFFSET_TYPE_JAVA:
                start = offset_mapper.convert_to_java(self._start)
                end = offset_mapper.convert_to_java(self._end)
            elif offset_type == OFFSET_TYPE_PYTHON:
                start = offset_mapper.convert_to_python(self._start)
                end = offset_mapper.convert_to_python(self._end)
            else:
                raise Exception(f&#34;Not a valid offset type: {offset_type}, must be &#39;p&#39; or &#39;j&#39;&#34;)
        else:
            start = self._start
            end = self._end
        return {
            &#34;type&#34;: self.type,
            &#34;start&#34;: start,
            &#34;end&#34;: end,
            &#34;id&#34;: self.id,
            &#34;features&#34;: self._features.to_dict(),
        }

    @staticmethod
    def from_dict(dictrepr, owner_set=None, **kwargs):
        &#34;&#34;&#34;
        Construct an annotation object from the dictionary representation.

        Args:
          dictrepr: dictionary representation
          owner_set: the owning set the annotation should have (Default value = None)
          kwargs: ignored
        &#34;&#34;&#34;
        ann = Annotation(
            start=dictrepr.get(&#34;start&#34;),
            end=dictrepr.get(&#34;end&#34;),
            anntype=dictrepr.get(&#34;type&#34;),
            annid=dictrepr.get(&#34;id&#34;),
            features=dictrepr.get(&#34;features&#34;)
        )
        ann._owner_set = owner_set
        return ann

    def __copy__(self):
        return Annotation(self._start, self._end, self._type, annid=self._id, features=self._features)

    def copy(self):
        &#34;&#34;&#34;
        Return a shallow copy of the annotation (features are shared).
        &#34;&#34;&#34;
        return self.__copy__()

    def __deepcopy__(self, memo=None):
        if self._features is not None:
            fts = lib_copy.deepcopy(self._features.to_dict(), memo=memo)
        else:
            fts = None
        return Annotation(self._start, self._end, self._type, annid=self._id, features=fts)

    def deepcopy(self, memo=None):
        &#34;&#34;&#34;
        Return a deep copy of the annotation (features and their values are copied as well).
        &#34;&#34;&#34;
        return lib_copy.deepcopy(self, memo=memo)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.annotation.Annotation.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>dictrepr, owner_set=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct an annotation object from the dictionary representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dictrepr</code></strong></dt>
<dd>dictionary representation</dd>
<dt><strong><code>owner_set</code></strong></dt>
<dd>the owning set the annotation should have (Default value = None)</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>ignored</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(dictrepr, owner_set=None, **kwargs):
    &#34;&#34;&#34;
    Construct an annotation object from the dictionary representation.

    Args:
      dictrepr: dictionary representation
      owner_set: the owning set the annotation should have (Default value = None)
      kwargs: ignored
    &#34;&#34;&#34;
    ann = Annotation(
        start=dictrepr.get(&#34;start&#34;),
        end=dictrepr.get(&#34;end&#34;),
        anntype=dictrepr.get(&#34;type&#34;),
        annid=dictrepr.get(&#34;id&#34;),
        features=dictrepr.get(&#34;features&#34;)
    )
    ann._owner_set = owner_set
    return ann</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="gatenlp.annotation.Annotation.end"><code class="name">property/get <span class="ident">end</span></code></dt>
<dd>
<div class="desc"><p>Returns the end offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end(self):
    &#34;&#34;&#34;
    Returns the end offset.
    &#34;&#34;&#34;
    return self._end</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.features"><code class="name">property/get <span class="ident">features</span></code></dt>
<dd>
<div class="desc"><p>Returns the features for the annotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def features(self):
    &#34;&#34;&#34;
    Returns the features for the annotation.
    &#34;&#34;&#34;
    return self._features</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.id"><code class="name">property/get <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>Returns the annotation id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self):
    &#34;&#34;&#34;
    Returns the annotation id.
    &#34;&#34;&#34;
    return self._id</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.length"><code class="name">property/get <span class="ident">length</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the length of the annotation: this is the length of the offset span.
Since the end offset is one after the last
element, we return end-start. Note: this is deliberately not implemented as len(ann), as
len(annset) returns the number of annotations in the set but annset.length() also returns the
span length of the annotation set, so the method name for this is identical between annotations
and annotation sets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the length of the annotation: this is the length of the offset span.
    Since the end offset is one after the last
    element, we return end-start. Note: this is deliberately not implemented as len(ann), as
    len(annset) returns the number of annotations in the set but annset.length() also returns the
    span length of the annotation set, so the method name for this is identical between annotations
    and annotation sets.
    &#34;&#34;&#34;
    return self.end - self.start</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.span"><code class="name">property/get <span class="ident">span</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Returns a tuple with the start and end offset of the annotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def span(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
    Returns a tuple with the start and end offset of the annotation.
    &#34;&#34;&#34;
    return self.start, self.end</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.start"><code class="name">property/get <span class="ident">start</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the start offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the start offset.
    &#34;&#34;&#34;
    return self._start</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.type"><code class="name">property/get <span class="ident">type</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the annotation type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the annotation type.
    &#34;&#34;&#34;
    return self._type</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.annotation.Annotation.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a shallow copy of the annotation (features are shared).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    Return a shallow copy of the annotation (features are shared).
    &#34;&#34;&#34;
    return self.__copy__()</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.deepcopy"><code class="name flex">
<span>def <span class="ident">deepcopy</span></span>(<span>self, memo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a deep copy of the annotation (features and their values are copied as well).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deepcopy(self, memo=None):
    &#34;&#34;&#34;
    Return a deep copy of the annotation (features and their values are copied as well).
    &#34;&#34;&#34;
    return lib_copy.deepcopy(self, memo=memo)</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.gap"><code class="name flex">
<span>def <span class="ident">gap</span></span>(<span>self, start: int, end: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the gep between this annotation and the other annotation. This is the distance between
the last character of the first annotation and the first character of the second annotation in
sequence, so it is always independent of the order of the two annotations.</p>
<p>This is negative if the annotations overlap.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>size of gap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def gap(self, start: int, end: int):
    &#34;&#34;&#34;Return the gep between this annotation and the other annotation. This is the distance between
    the last character of the first annotation and the first character of the second annotation in
    sequence, so it is always independent of the order of the two annotations.
    
    This is negative if the annotations overlap.

    Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
      (see gatenlp._utils.support_annotation_or_set)

    Args:
      start: start offset of span
      end: end offset of span

    Returns:
      size of gap

    &#34;&#34;&#34;
    if self.start &lt; start:
        ann1start = self.start
        ann1end = self.end
        ann2start = start
        ann2end = end
    else:
        ann2start = self.start
        ann2end = self.end
        ann1start = start
        ann1end = end
    return ann2start - ann1end</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.isafter"><code class="name flex">
<span>def <span class="ident">isafter</span></span>(<span>self, start: int, end: int, immediately=False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is after the other span, i.e. the start of this annotation
is after the end of the other annotation or span.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>immediately</code></strong></dt>
<dd>if true checks if this annotation starts immediately after the other one (Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if after, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def isafter(self, start: int, end: int, immediately=False) -&gt; bool:
    &#34;&#34;&#34;Checks if this annotation is after the other span, i.e. the start of this annotation
    is after the end of the other annotation or span.

    Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
      (see gatenlp._utils.support_annotation_or_set)

    Args:
      start: start offset of the span
      end: end offset of the span
      immediately: if true checks if this annotation starts immediately after the other one (Default value = False)

    Returns:
      True if after, False otherwise

    &#34;&#34;&#34;
    if immediately:
        return self.start == end
    else:
        return self.start &gt;= end</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.isbefore"><code class="name flex">
<span>def <span class="ident">isbefore</span></span>(<span>self, start: int, end: int, immediately=False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is before the other span, i.e. the end of this annotation
is before the start of the other annotation or span.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>immediately</code></strong></dt>
<dd>if true checks if this annotation ends immediately before the other one (Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if before, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def isbefore(self, start: int, end: int, immediately=False) -&gt; bool:
    &#34;&#34;&#34;
    Checks if this annotation is before the other span, i.e. the end of this annotation
    is before the start of the other annotation or span.

    Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
      (see gatenlp._utils.support_annotation_or_set)

    Args:
      start: start offset of the span
      end: end offset of the span
      immediately: if true checks if this annotation ends immediately before the other one (Default value = False)

    Returns:
      True if before, False otherwise

    &#34;&#34;&#34;
    if immediately:
        return self.end == start
    else:
        return self.end &lt;= start</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.iscoextensive"><code class="name flex">
<span>def <span class="ident">iscoextensive</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is coextensive with the given span, annotation or
annotation set, i.e. has exactly the same start and end offsets.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>True</code> if coextensive, <code>False</code> otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def iscoextensive(self, start: int, end: int) -&gt; bool:
    &#34;&#34;&#34;
    Checks if this annotation is coextensive with the given span, annotation or
    annotation set, i.e. has exactly the same start and end offsets.

    Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
      (see gatenlp._utils.support_annotation_or_set)

    Args:
      start: start offset of the span
      end: end offset of the span

    Returns:
      `True` if coextensive, `False` otherwise

    &#34;&#34;&#34;
    return self.start == start and self.end == end</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.iscovering"><code class="name flex">
<span>def <span class="ident">iscovering</span></span>(<span>self, start: int, end: int = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is covering the given span, annotation or
annotation set, i.e. both the given start and end offsets
are after the start of this annotation and before the end of this annotation.</p>
<p>If end is not given, then the method checks if start is an offset of a character
contained in the span.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if covering, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def iscovering(self, start: int, end: int = None) -&gt; bool:
    &#34;&#34;&#34;Checks if this annotation is covering the given span, annotation or
    annotation set, i.e. both the given start and end offsets
    are after the start of this annotation and before the end of this annotation.
    
    If end is not given, then the method checks if start is an offset of a character
    contained in the span.

    Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
      (see gatenlp._utils.support_annotation_or_set)

    Args:
      start: start offset of the span
      end: end offset of the span

    Returns:
      True if covering, False otherwise

    &#34;&#34;&#34;
    if end is None:
        return self.start &lt;= start &lt; self.end
    else:
        return self.start &lt;= start and self.end &gt;= end</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.isoverlapping"><code class="name flex">
<span>def <span class="ident">isoverlapping</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is overlapping with the given span, annotation or
annotation set.
An annotation is overlapping with a span if the first or last character
is inside that span.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>True</code> if overlapping, <code>False</code> otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def isoverlapping(self, start: int, end: int) -&gt; bool:
    &#34;&#34;&#34;
    Checks if this annotation is overlapping with the given span, annotation or
    annotation set.
    An annotation is overlapping with a span if the first or last character
    is inside that span.

    Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
      (see gatenlp._utils.support_annotation_or_set)

    Args:
      start: start offset of the span
      end: end offset of the span

    Returns:
      `True` if overlapping, `False` otherwise

    &#34;&#34;&#34;
    return self.iscovering(start) or self.iscovering(end - 1)</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.iswithin"><code class="name flex">
<span>def <span class="ident">iswithin</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is within the given span, annotation or
annotation set, i.e. both the start and end offsets of this annotation
are after the given start and before the given end.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>True</code> if within, <code>False</code> otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def iswithin(self, start: int, end: int) -&gt; bool:
    &#34;&#34;&#34;
    Checks if this annotation is within the given span, annotation or
    annotation set, i.e. both the start and end offsets of this annotation
    are after the given start and before the given end.

    Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
      (see gatenlp._utils.support_annotation_or_set)

    Args:
      start: start offset of the span
      end: end offset of the span

    Returns:
      `True` if within, `False` otherwise

    &#34;&#34;&#34;
    return start &lt;= self.start and end &gt;= self.end</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, offset_mapper=None, offset_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a representation of this annotation as a nested map. This representation is
used for several serialization methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>the offset mapper to use, must be specified if <code>offset_type</code> is specified.</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>the offset type to be used for the conversionm must be specified if
<code>offset_mapper</code> is specified</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the dictionary representation of the Annotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, offset_mapper=None, offset_type=None):
    &#34;&#34;&#34;
    Return a representation of this annotation as a nested map. This representation is
    used for several serialization methods.

    Args:
        offset_mapper: the offset mapper to use, must be specified if `offset_type` is specified.
        offset_type: the offset type to be used for the conversionm must be specified if
           `offset_mapper` is specified

    Returns:
        the dictionary representation of the Annotation
    &#34;&#34;&#34;
    if (offset_mapper and not offset_type) or (not offset_mapper and offset_type):
        raise Exception(&#34;offset_mapper and offset_type must be specified both or none&#34;)
    if offset_mapper is not None:
        if offset_type == OFFSET_TYPE_JAVA:
            start = offset_mapper.convert_to_java(self._start)
            end = offset_mapper.convert_to_java(self._end)
        elif offset_type == OFFSET_TYPE_PYTHON:
            start = offset_mapper.convert_to_python(self._start)
            end = offset_mapper.convert_to_python(self._end)
        else:
            raise Exception(f&#34;Not a valid offset type: {offset_type}, must be &#39;p&#39; or &#39;j&#39;&#34;)
    else:
        start = self._start
        end = self._end
    return {
        &#34;type&#34;: self.type,
        &#34;start&#34;: start,
        &#34;end&#34;: end,
        &#34;id&#34;: self.id,
        &#34;features&#34;: self._features.to_dict(),
    }</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp" href="index.html">gatenlp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.annotation.Annotation" href="#gatenlp.annotation.Annotation">Annotation</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.annotation.Annotation.copy" href="#gatenlp.annotation.Annotation.copy">copy</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.deepcopy" href="#gatenlp.annotation.Annotation.deepcopy">deepcopy</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.end" href="#gatenlp.annotation.Annotation.end">end</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.features" href="#gatenlp.annotation.Annotation.features">features</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.from_dict" href="#gatenlp.annotation.Annotation.from_dict">from_dict</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.gap" href="#gatenlp.annotation.Annotation.gap">gap</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.id" href="#gatenlp.annotation.Annotation.id">id</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.isafter" href="#gatenlp.annotation.Annotation.isafter">isafter</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.isbefore" href="#gatenlp.annotation.Annotation.isbefore">isbefore</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.iscoextensive" href="#gatenlp.annotation.Annotation.iscoextensive">iscoextensive</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.iscovering" href="#gatenlp.annotation.Annotation.iscovering">iscovering</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.isoverlapping" href="#gatenlp.annotation.Annotation.isoverlapping">isoverlapping</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.iswithin" href="#gatenlp.annotation.Annotation.iswithin">iswithin</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.length" href="#gatenlp.annotation.Annotation.length">length</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.span" href="#gatenlp.annotation.Annotation.span">span</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.start" href="#gatenlp.annotation.Annotation.start">start</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.to_dict" href="#gatenlp.annotation.Annotation.to_dict">to_dict</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.type" href="#gatenlp.annotation.Annotation.type">type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev16+g8c2bb0d.d20201028</a>.</p>
</footer>
</body>
</html>