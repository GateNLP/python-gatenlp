<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev22+gf4251dd" />
<title>gatenlp.annotation API documentation</title>
<meta name="description" content="Module for Annotation class which represents information about a span of text in
a document." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.annotation</code></h1>
</header>
<section id="section-intro">
<p>Module for Annotation class which represents information about a span of text in
a document.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module for Annotation class which represents information about a span of text in  a document.
&#34;&#34;&#34;
import copy as lib_copy
from functools import total_ordering
from gatenlp.features import Features
from gatenlp.offsetmapper import OFFSET_TYPE_JAVA, OFFSET_TYPE_PYTHON
from gatenlp.utils import support_annotation_or_set, allowspan
from gatenlp.span import Span


@total_ordering
class Annotation:
    &#34;&#34;&#34;
    An annotation represents information about a span of text. It contains the start and end
    offsets of the span, an &#34;annotation type&#34; and an arbitrary number of features.

    In addition it contains an id which has no meaning for the annotation itself but is
    used to uniquely identify an annotation within the set it is contained in.

    All fields except the features are immutable, once the annotation has been created
    only the features can be changed.
    &#34;&#34;&#34;

    @allowspan
    def __init__(
        self, start: int, end: int, anntype: str, features=None, annid: int = 0
    ):
        &#34;&#34;&#34;
        This constructor creates a new annotation instance. Once an annotation has been created,
        the start, end, type and id fields cannot be changed.

        NOTE: this should almost never be done directly
        and instead the method AnnotationSet.add should be used.

        Args:
            start: start offset of the annotation
            end: end offset of the annotation
            anntype: annotation type
            features: an initial collection of features, None for no features.
            annid: the id of the annotation
        &#34;&#34;&#34;
        if end &lt; start:
            raise Exception(
                f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, &#34;
                &#34;id={annid}, features={features}: start &gt; end&#34;
            )
        if not isinstance(annid, int):
            raise Exception(
                f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, &#34;
                &#34;id={annid}, features={features}: annid is not an int&#34;
            )
        if isinstance(features, int):
            raise Exception(
                f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, &#34;
                &#34;id={annid}, features={features}: features must not be an int, mixed up with annid?&#34;
            )
        self._owner_set = None
        self._features = Features(features, logger=self._log_feature_change)
        self._type = anntype
        self._start = start
        self._end = end
        self._id = annid

    @property
    def type(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the annotation type.
        &#34;&#34;&#34;
        return self._type

    @property
    def start(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the start offset.
        &#34;&#34;&#34;
        return self._start

    @property
    def end(self):
        &#34;&#34;&#34;
        Returns the end offset.
        &#34;&#34;&#34;
        return self._end

    @property
    def features(self):
        &#34;&#34;&#34;
        Returns the features for the annotation.
        &#34;&#34;&#34;
        return self._features

    @property
    def id(self):
        &#34;&#34;&#34;
        Returns the annotation id.
        &#34;&#34;&#34;
        return self._id

    @property
    def span(self) -&gt; Span:
        &#34;&#34;&#34;
        Returns a tuple with the start and end offset of the annotation.
        &#34;&#34;&#34;
        return Span(self._start, self._end)

    def _changelog(self):
        if self._owner_set is not None:
            return self._owner_set.changelog

    # TODO: for now at least, make sure only simple JSON serialisable things are used! We do NOT
    # allow any user specific types in order to make sure what we create is interchangeable
    # with GATE.
    # In addition we do NOT allow None features.
    # So a feature name always has to be a string (not None), the value has to be anything
    # that is json
    # serialisable (except None keys for maps).
    # For performance reasons we check the feature name but not the value (maybe make checking
    # optional
    # on by default but still optional?)
    def _log_feature_change(
        self, command: str, feature: str = None, value=None
    ) -&gt; None:
        &#34;&#34;&#34;

        Args:
          command: str:
          feature: str:  (Default value = None)
          value:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if self._changelog() is None:
            return
        command = &#34;ann-&#34; + command
        ch = {
            &#34;command&#34;: command,
            &#34;type&#34;: &#34;annotation&#34;,
            &#34;set&#34;: self._owner_set.name,
            &#34;id&#34;: self.id,
        }
        if feature is not None:
            ch[&#34;feature&#34;] = feature
        if value is not None:
            ch[&#34;value&#34;] = value
        self._changelog().append(ch)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;
        Two annotations are identical if they are the same object or if all the fields
        are equal (including the annotation id)!
        &#34;&#34;&#34;
        if not isinstance(other, Annotation):
            return False
        if self is other:
            return True
        return (
            self.start == other.start
            and self.end == other.end
            and self.type == other.type
            and self.id == other.id
            and self._features == other._features
        )

    def __hash__(self):
        &#34;&#34;&#34;
        The hash depends on the annotation ID and the owning set.
        &#34;&#34;&#34;
        return hash((self.id, self._owner_set))

    def __lt__(self, other) -&gt; bool:
        &#34;&#34;&#34;
        Comparison for sorting: this sorts by increasing start offset,
        then increasing annotation id.
        Since annotation ids within a set are unique, this guarantees a unique order of
        annotations that
        come from an annotation set.

        Note: for now the other object has to be an instance of Annotation, duck typing is
        not supported!
        &#34;&#34;&#34;
        if not isinstance(other, Annotation):
            raise Exception(&#34;Cannot compare to non-Annotation&#34;)
        if self.start &lt; other.start:
            return True
        elif self.start &gt; other.start:
            return False
        else:
            return self.id &lt; other.id

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        String representation of the annotation.
        &#34;&#34;&#34;
        return &#34;Annotation({},{},{},features={},id={})&#34;.format(
            self.start, self.end, self.type, self._features, self.id
        )

    @property
    def length(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the length of the annotation: this is the length of the offset span.
        Since the end offset is one after the last
        element, we return end-start. Note: this is deliberately not implemented as len(ann), as
        len(annset) returns the number of annotations in the set but annset.length()
        also returns the
        span length of the annotation set, so the method name for this is identical between
        annotations
        and annotation sets.
        &#34;&#34;&#34;
        return self.end - self.start

    @support_annotation_or_set
    def isoverlapping(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is overlapping with the given span, annotation or
        annotation set.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if overlapping, `False` otherwise

        &#34;&#34;&#34;
        if start == end:
            return self.iscovering(start)
        else:
            return self.iscovering(start) or self.iscovering(end - 1)

    @support_annotation_or_set
    def isleftoverlapping(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is overlapping with the given span, annotation or
        annotation set on the left, i.e. the last character is inside the span and the
        first character is before the span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if left-overlapping, `False` otherwise

        &#34;&#34;&#34;
        return self.start &lt;= start and self.end &lt;= end

    @support_annotation_or_set
    def isrightoverlapping(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is overlapping with the given span, annotation or
        annotation set on the right, i.e. the first character is inside the span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if right-overlapping, `False` otherwise

        &#34;&#34;&#34;
        return self.start &gt;= start and self.end &gt;= end

    @support_annotation_or_set
    def iscoextensive(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is coextensive with the given span, annotation or
        annotation set, i.e. has exactly the same start and end offsets.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if coextensive, `False` otherwise

        &#34;&#34;&#34;
        return self.start == start and self.end == end

    @support_annotation_or_set
    def iswithin(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is within the given span, annotation or
        annotation set, i.e. both the start and end offsets of this annotation
        are after the given start and before the given end.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if within, `False` otherwise

        &#34;&#34;&#34;
        return start &lt;= self.start and end &gt;= self.end

    @support_annotation_or_set
    def isbefore(self, start: int, end: int, immediately=False) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is before the other span, i.e. the end of this annotation
        is before the start of the other annotation or span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
            start: start offset of the span
            end: end offset of the span
            immediately: if true checks if this annotation ends immediately before the
                other one (Default value = False)

        Returns:
          True if before, False otherwise

        &#34;&#34;&#34;
        if immediately:
            return self.end == start
        else:
            return self.end &lt;= start

    @support_annotation_or_set
    def isafter(self, start: int, end: int, immediately=False) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is after the other span, i.e. the start of this annotation
        is after the end of the other annotation or span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span
          immediately: if true checks if this annotation starts immediately after the other one
              (Default value = False)

        Returns:
          True if after, False otherwise

        &#34;&#34;&#34;
        if immediately:
            return self.start == end
        else:
            return self.start &gt;= end

    @support_annotation_or_set
    def isstartingat(self, start: int, end: int) -&gt; bool:
        return self._start == start

    @support_annotation_or_set
    def isendingwith(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is ending at the same offset as the given span or annotation.

        Args:
            start: start of the span (ignored)
            end: end of the span

        Returns:
            True if ending at the same offset as the span or annotation

        &#34;&#34;&#34;
        return self._end == end

    @support_annotation_or_set
    def gap(self, start: int, end: int) -&gt; int:
        &#34;&#34;&#34;
        Return the gep between this annotation and the other annotation.
        This is the distance between
        the last character of the first annotation and the first character of the
        second annotation in
        sequence, so it is always independent of the order of the two annotations.

        This is negative if the annotations overlap.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
            (see gatenlp._utils.support_annotation_or_set)

        Args:
            start: start offset of span
            end: end offset of span

        Returns:
          size of gap

        &#34;&#34;&#34;
        if self.start &lt; start:
            # ann1start = self.start
            ann1end = self.end
            ann2start = start
            # ann2end = end
        else:
            ann2start = self.start
            # ann2end = self.end
            # ann1start = start
            ann1end = end
        return ann2start - ann1end

    @support_annotation_or_set
    def iscovering(self, start: int, end=None) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is covering the given span, annotation or
        annotation set, i.e. both the given start and end offsets
        are after the start of this annotation and before the end of this annotation.

        If end is not given, then the method checks if start is an offset of a character
        contained in the span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          True if covering, False otherwise

        &#34;&#34;&#34;
        if end is None:
            if self.end == self.start:
                return self.start == start
            else:
                return self.start &lt;= start &lt; self.end
        else:
            return self.start &lt;= start and self.end &gt;= end

    def to_dict(self, offset_mapper=None, offset_type=None, **kwargs):
        &#34;&#34;&#34;
        Return a representation of this annotation as a nested map. This representation is
        used for several serialization methods.

        Args:
            offset_mapper: the offset mapper to use, must be specified if
                `offset_type` is specified.
            offset_type: the offset type to be used for the conversionm must be specified if
                `offset_mapper` is specified

        Returns:
            the dictionary representation of the Annotation
        &#34;&#34;&#34;
        if (offset_mapper and not offset_type) or (not offset_mapper and offset_type):
            raise Exception(
                &#34;offset_mapper and offset_type must be specified both or none&#34;
            )
        if offset_mapper is not None:
            if offset_type == OFFSET_TYPE_JAVA:
                start = offset_mapper.convert_to_java(self._start)
                end = offset_mapper.convert_to_java(self._end)
            elif offset_type == OFFSET_TYPE_PYTHON:
                start = offset_mapper.convert_to_python(self._start)
                end = offset_mapper.convert_to_python(self._end)
            else:
                raise Exception(
                    f&#34;Not a valid offset type: {offset_type}, must be &#39;p&#39; or &#39;j&#39;&#34;
                )
        else:
            start = self._start
            end = self._end
        return {
            &#34;type&#34;: self.type,
            &#34;start&#34;: start,
            &#34;end&#34;: end,
            &#34;id&#34;: self.id,
            &#34;features&#34;: self._features.to_dict(),
        }

    @staticmethod
    def from_dict(dictrepr, owner_set=None, **kwargs):
        &#34;&#34;&#34;
        Construct an annotation object from the dictionary representation.

        Args:
          dictrepr: dictionary representation
          owner_set: the owning set the annotation should have (Default value = None)
          kwargs: ignored
        &#34;&#34;&#34;
        ann = Annotation(
            dictrepr.get(&#34;start&#34;),
            dictrepr.get(&#34;end&#34;),
            dictrepr.get(&#34;type&#34;),
            annid=dictrepr.get(&#34;id&#34;),
            features=dictrepr.get(&#34;features&#34;),
        )
        ann._owner_set = owner_set
        return ann

    def __copy__(self):
        return Annotation(
            self._start, self._end, self._type, annid=self._id, features=self._features
        )

    def copy(self):
        &#34;&#34;&#34;
        Return a shallow copy of the annotation (features are shared).
        &#34;&#34;&#34;
        return self.__copy__()

    def __deepcopy__(self, memo=None):
        if self._features is not None:
            fts = lib_copy.deepcopy(self._features.to_dict(), memo=memo)
        else:
            fts = None
        return Annotation(
            self._start, self._end, self._type, annid=self._id, features=fts
        )

    def deepcopy(self, memo=None):
        &#34;&#34;&#34;
        Return a deep copy of the annotation (features and their values are copied as well).
        &#34;&#34;&#34;
        return lib_copy.deepcopy(self, memo=memo)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.annotation.Annotation"><code class="flex name class">
<span>class <span class="ident">Annotation</span></span>
<span>(</span><span>start: int, end: int, anntype: str, features=None, annid: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>An annotation represents information about a span of text. It contains the start and end
offsets of the span, an "annotation type" and an arbitrary number of features.</p>
<p>In addition it contains an id which has no meaning for the annotation itself but is
used to uniquely identify an annotation within the set it is contained in.</p>
<p>All fields except the features are immutable, once the annotation has been created
only the features can be changed.</p>
<p>This constructor creates a new annotation instance. Once an annotation has been created,
the start, end, type and id fields cannot be changed.</p>
<p>NOTE: this should almost never be done directly
and instead the method AnnotationSet.add should be used.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the annotation</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the annotation</dd>
<dt><strong><code>anntype</code></strong></dt>
<dd>annotation type</dd>
<dt><strong><code>features</code></strong></dt>
<dd>an initial collection of features, None for no features.</dd>
<dt><strong><code>annid</code></strong></dt>
<dd>the id of the annotation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Annotation:
    &#34;&#34;&#34;
    An annotation represents information about a span of text. It contains the start and end
    offsets of the span, an &#34;annotation type&#34; and an arbitrary number of features.

    In addition it contains an id which has no meaning for the annotation itself but is
    used to uniquely identify an annotation within the set it is contained in.

    All fields except the features are immutable, once the annotation has been created
    only the features can be changed.
    &#34;&#34;&#34;

    @allowspan
    def __init__(
        self, start: int, end: int, anntype: str, features=None, annid: int = 0
    ):
        &#34;&#34;&#34;
        This constructor creates a new annotation instance. Once an annotation has been created,
        the start, end, type and id fields cannot be changed.

        NOTE: this should almost never be done directly
        and instead the method AnnotationSet.add should be used.

        Args:
            start: start offset of the annotation
            end: end offset of the annotation
            anntype: annotation type
            features: an initial collection of features, None for no features.
            annid: the id of the annotation
        &#34;&#34;&#34;
        if end &lt; start:
            raise Exception(
                f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, &#34;
                &#34;id={annid}, features={features}: start &gt; end&#34;
            )
        if not isinstance(annid, int):
            raise Exception(
                f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, &#34;
                &#34;id={annid}, features={features}: annid is not an int&#34;
            )
        if isinstance(features, int):
            raise Exception(
                f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, &#34;
                &#34;id={annid}, features={features}: features must not be an int, mixed up with annid?&#34;
            )
        self._owner_set = None
        self._features = Features(features, logger=self._log_feature_change)
        self._type = anntype
        self._start = start
        self._end = end
        self._id = annid

    @property
    def type(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the annotation type.
        &#34;&#34;&#34;
        return self._type

    @property
    def start(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the start offset.
        &#34;&#34;&#34;
        return self._start

    @property
    def end(self):
        &#34;&#34;&#34;
        Returns the end offset.
        &#34;&#34;&#34;
        return self._end

    @property
    def features(self):
        &#34;&#34;&#34;
        Returns the features for the annotation.
        &#34;&#34;&#34;
        return self._features

    @property
    def id(self):
        &#34;&#34;&#34;
        Returns the annotation id.
        &#34;&#34;&#34;
        return self._id

    @property
    def span(self) -&gt; Span:
        &#34;&#34;&#34;
        Returns a tuple with the start and end offset of the annotation.
        &#34;&#34;&#34;
        return Span(self._start, self._end)

    def _changelog(self):
        if self._owner_set is not None:
            return self._owner_set.changelog

    # TODO: for now at least, make sure only simple JSON serialisable things are used! We do NOT
    # allow any user specific types in order to make sure what we create is interchangeable
    # with GATE.
    # In addition we do NOT allow None features.
    # So a feature name always has to be a string (not None), the value has to be anything
    # that is json
    # serialisable (except None keys for maps).
    # For performance reasons we check the feature name but not the value (maybe make checking
    # optional
    # on by default but still optional?)
    def _log_feature_change(
        self, command: str, feature: str = None, value=None
    ) -&gt; None:
        &#34;&#34;&#34;

        Args:
          command: str:
          feature: str:  (Default value = None)
          value:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if self._changelog() is None:
            return
        command = &#34;ann-&#34; + command
        ch = {
            &#34;command&#34;: command,
            &#34;type&#34;: &#34;annotation&#34;,
            &#34;set&#34;: self._owner_set.name,
            &#34;id&#34;: self.id,
        }
        if feature is not None:
            ch[&#34;feature&#34;] = feature
        if value is not None:
            ch[&#34;value&#34;] = value
        self._changelog().append(ch)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;
        Two annotations are identical if they are the same object or if all the fields
        are equal (including the annotation id)!
        &#34;&#34;&#34;
        if not isinstance(other, Annotation):
            return False
        if self is other:
            return True
        return (
            self.start == other.start
            and self.end == other.end
            and self.type == other.type
            and self.id == other.id
            and self._features == other._features
        )

    def __hash__(self):
        &#34;&#34;&#34;
        The hash depends on the annotation ID and the owning set.
        &#34;&#34;&#34;
        return hash((self.id, self._owner_set))

    def __lt__(self, other) -&gt; bool:
        &#34;&#34;&#34;
        Comparison for sorting: this sorts by increasing start offset,
        then increasing annotation id.
        Since annotation ids within a set are unique, this guarantees a unique order of
        annotations that
        come from an annotation set.

        Note: for now the other object has to be an instance of Annotation, duck typing is
        not supported!
        &#34;&#34;&#34;
        if not isinstance(other, Annotation):
            raise Exception(&#34;Cannot compare to non-Annotation&#34;)
        if self.start &lt; other.start:
            return True
        elif self.start &gt; other.start:
            return False
        else:
            return self.id &lt; other.id

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        String representation of the annotation.
        &#34;&#34;&#34;
        return &#34;Annotation({},{},{},features={},id={})&#34;.format(
            self.start, self.end, self.type, self._features, self.id
        )

    @property
    def length(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the length of the annotation: this is the length of the offset span.
        Since the end offset is one after the last
        element, we return end-start. Note: this is deliberately not implemented as len(ann), as
        len(annset) returns the number of annotations in the set but annset.length()
        also returns the
        span length of the annotation set, so the method name for this is identical between
        annotations
        and annotation sets.
        &#34;&#34;&#34;
        return self.end - self.start

    @support_annotation_or_set
    def isoverlapping(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is overlapping with the given span, annotation or
        annotation set.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if overlapping, `False` otherwise

        &#34;&#34;&#34;
        if start == end:
            return self.iscovering(start)
        else:
            return self.iscovering(start) or self.iscovering(end - 1)

    @support_annotation_or_set
    def isleftoverlapping(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is overlapping with the given span, annotation or
        annotation set on the left, i.e. the last character is inside the span and the
        first character is before the span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if left-overlapping, `False` otherwise

        &#34;&#34;&#34;
        return self.start &lt;= start and self.end &lt;= end

    @support_annotation_or_set
    def isrightoverlapping(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is overlapping with the given span, annotation or
        annotation set on the right, i.e. the first character is inside the span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if right-overlapping, `False` otherwise

        &#34;&#34;&#34;
        return self.start &gt;= start and self.end &gt;= end

    @support_annotation_or_set
    def iscoextensive(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is coextensive with the given span, annotation or
        annotation set, i.e. has exactly the same start and end offsets.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if coextensive, `False` otherwise

        &#34;&#34;&#34;
        return self.start == start and self.end == end

    @support_annotation_or_set
    def iswithin(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is within the given span, annotation or
        annotation set, i.e. both the start and end offsets of this annotation
        are after the given start and before the given end.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          `True` if within, `False` otherwise

        &#34;&#34;&#34;
        return start &lt;= self.start and end &gt;= self.end

    @support_annotation_or_set
    def isbefore(self, start: int, end: int, immediately=False) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is before the other span, i.e. the end of this annotation
        is before the start of the other annotation or span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
            start: start offset of the span
            end: end offset of the span
            immediately: if true checks if this annotation ends immediately before the
                other one (Default value = False)

        Returns:
          True if before, False otherwise

        &#34;&#34;&#34;
        if immediately:
            return self.end == start
        else:
            return self.end &lt;= start

    @support_annotation_or_set
    def isafter(self, start: int, end: int, immediately=False) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is after the other span, i.e. the start of this annotation
        is after the end of the other annotation or span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span
          immediately: if true checks if this annotation starts immediately after the other one
              (Default value = False)

        Returns:
          True if after, False otherwise

        &#34;&#34;&#34;
        if immediately:
            return self.start == end
        else:
            return self.start &gt;= end

    @support_annotation_or_set
    def isstartingat(self, start: int, end: int) -&gt; bool:
        return self._start == start

    @support_annotation_or_set
    def isendingwith(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if this annotation is ending at the same offset as the given span or annotation.

        Args:
            start: start of the span (ignored)
            end: end of the span

        Returns:
            True if ending at the same offset as the span or annotation

        &#34;&#34;&#34;
        return self._end == end

    @support_annotation_or_set
    def gap(self, start: int, end: int) -&gt; int:
        &#34;&#34;&#34;
        Return the gep between this annotation and the other annotation.
        This is the distance between
        the last character of the first annotation and the first character of the
        second annotation in
        sequence, so it is always independent of the order of the two annotations.

        This is negative if the annotations overlap.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
            (see gatenlp._utils.support_annotation_or_set)

        Args:
            start: start offset of span
            end: end offset of span

        Returns:
          size of gap

        &#34;&#34;&#34;
        if self.start &lt; start:
            # ann1start = self.start
            ann1end = self.end
            ann2start = start
            # ann2end = end
        else:
            ann2start = self.start
            # ann2end = self.end
            # ann1start = start
            ann1end = end
        return ann2start - ann1end

    @support_annotation_or_set
    def iscovering(self, start: int, end=None) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is covering the given span, annotation or
        annotation set, i.e. both the given start and end offsets
        are after the start of this annotation and before the end of this annotation.

        If end is not given, then the method checks if start is an offset of a character
        contained in the span.

        Note: this can be called with an Annotation or AnnotationSet instead of `start` and `end`
          (see gatenlp._utils.support_annotation_or_set)

        Args:
          start: start offset of the span
          end: end offset of the span

        Returns:
          True if covering, False otherwise

        &#34;&#34;&#34;
        if end is None:
            if self.end == self.start:
                return self.start == start
            else:
                return self.start &lt;= start &lt; self.end
        else:
            return self.start &lt;= start and self.end &gt;= end

    def to_dict(self, offset_mapper=None, offset_type=None, **kwargs):
        &#34;&#34;&#34;
        Return a representation of this annotation as a nested map. This representation is
        used for several serialization methods.

        Args:
            offset_mapper: the offset mapper to use, must be specified if
                `offset_type` is specified.
            offset_type: the offset type to be used for the conversionm must be specified if
                `offset_mapper` is specified

        Returns:
            the dictionary representation of the Annotation
        &#34;&#34;&#34;
        if (offset_mapper and not offset_type) or (not offset_mapper and offset_type):
            raise Exception(
                &#34;offset_mapper and offset_type must be specified both or none&#34;
            )
        if offset_mapper is not None:
            if offset_type == OFFSET_TYPE_JAVA:
                start = offset_mapper.convert_to_java(self._start)
                end = offset_mapper.convert_to_java(self._end)
            elif offset_type == OFFSET_TYPE_PYTHON:
                start = offset_mapper.convert_to_python(self._start)
                end = offset_mapper.convert_to_python(self._end)
            else:
                raise Exception(
                    f&#34;Not a valid offset type: {offset_type}, must be &#39;p&#39; or &#39;j&#39;&#34;
                )
        else:
            start = self._start
            end = self._end
        return {
            &#34;type&#34;: self.type,
            &#34;start&#34;: start,
            &#34;end&#34;: end,
            &#34;id&#34;: self.id,
            &#34;features&#34;: self._features.to_dict(),
        }

    @staticmethod
    def from_dict(dictrepr, owner_set=None, **kwargs):
        &#34;&#34;&#34;
        Construct an annotation object from the dictionary representation.

        Args:
          dictrepr: dictionary representation
          owner_set: the owning set the annotation should have (Default value = None)
          kwargs: ignored
        &#34;&#34;&#34;
        ann = Annotation(
            dictrepr.get(&#34;start&#34;),
            dictrepr.get(&#34;end&#34;),
            dictrepr.get(&#34;type&#34;),
            annid=dictrepr.get(&#34;id&#34;),
            features=dictrepr.get(&#34;features&#34;),
        )
        ann._owner_set = owner_set
        return ann

    def __copy__(self):
        return Annotation(
            self._start, self._end, self._type, annid=self._id, features=self._features
        )

    def copy(self):
        &#34;&#34;&#34;
        Return a shallow copy of the annotation (features are shared).
        &#34;&#34;&#34;
        return self.__copy__()

    def __deepcopy__(self, memo=None):
        if self._features is not None:
            fts = lib_copy.deepcopy(self._features.to_dict(), memo=memo)
        else:
            fts = None
        return Annotation(
            self._start, self._end, self._type, annid=self._id, features=fts
        )

    def deepcopy(self, memo=None):
        &#34;&#34;&#34;
        Return a deep copy of the annotation (features and their values are copied as well).
        &#34;&#34;&#34;
        return lib_copy.deepcopy(self, memo=memo)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.annotation.Annotation.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>dictrepr, owner_set=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct an annotation object from the dictionary representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dictrepr</code></strong></dt>
<dd>dictionary representation</dd>
<dt><strong><code>owner_set</code></strong></dt>
<dd>the owning set the annotation should have (Default value = None)</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>ignored</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="gatenlp.annotation.Annotation.end"><code class="name">property/get <span class="ident">end</span></code></dt>
<dd>
<div class="desc"><p>Returns the end offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end(self):
    &#34;&#34;&#34;
    Returns the end offset.
    &#34;&#34;&#34;
    return self._end</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.features"><code class="name">property/get <span class="ident">features</span></code></dt>
<dd>
<div class="desc"><p>Returns the features for the annotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def features(self):
    &#34;&#34;&#34;
    Returns the features for the annotation.
    &#34;&#34;&#34;
    return self._features</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.id"><code class="name">property/get <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>Returns the annotation id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self):
    &#34;&#34;&#34;
    Returns the annotation id.
    &#34;&#34;&#34;
    return self._id</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.length"><code class="name">property/get <span class="ident">length</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the length of the annotation: this is the length of the offset span.
Since the end offset is one after the last
element, we return end-start. Note: this is deliberately not implemented as len(ann), as
len(annset) returns the number of annotations in the set but annset.length()
also returns the
span length of the annotation set, so the method name for this is identical between
annotations
and annotation sets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the length of the annotation: this is the length of the offset span.
    Since the end offset is one after the last
    element, we return end-start. Note: this is deliberately not implemented as len(ann), as
    len(annset) returns the number of annotations in the set but annset.length()
    also returns the
    span length of the annotation set, so the method name for this is identical between
    annotations
    and annotation sets.
    &#34;&#34;&#34;
    return self.end - self.start</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.span"><code class="name">property/get <span class="ident">span</span> : <a title="gatenlp.span.Span" href="span.html#gatenlp.span.Span">Span</a></code></dt>
<dd>
<div class="desc"><p>Returns a tuple with the start and end offset of the annotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def span(self) -&gt; Span:
    &#34;&#34;&#34;
    Returns a tuple with the start and end offset of the annotation.
    &#34;&#34;&#34;
    return Span(self._start, self._end)</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.start"><code class="name">property/get <span class="ident">start</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the start offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the start offset.
    &#34;&#34;&#34;
    return self._start</code></pre>
</details>
</dd>
<dt id="gatenlp.annotation.Annotation.type"><code class="name">property/get <span class="ident">type</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the annotation type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the annotation type.
    &#34;&#34;&#34;
    return self._type</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.annotation.Annotation.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a shallow copy of the annotation (features are shared).</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.deepcopy"><code class="name flex">
<span>def <span class="ident">deepcopy</span></span>(<span>self, memo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a deep copy of the annotation (features and their values are copied as well).</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.gap"><code class="name flex">
<span>def <span class="ident">gap</span></span>(<span>self, start: int, end: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the gep between this annotation and the other annotation.
This is the distance between
the last character of the first annotation and the first character of the
second annotation in
sequence, so it is always independent of the order of the two annotations.</p>
<p>This is negative if the annotations overlap.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>size of gap</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.isafter"><code class="name flex">
<span>def <span class="ident">isafter</span></span>(<span>self, start: int, end: int, immediately=False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is after the other span, i.e. the start of this annotation
is after the end of the other annotation or span.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>immediately</code></strong></dt>
<dd>if true checks if this annotation starts immediately after the other one
(Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if after, False otherwise</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.isbefore"><code class="name flex">
<span>def <span class="ident">isbefore</span></span>(<span>self, start: int, end: int, immediately=False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is before the other span, i.e. the end of this annotation
is before the start of the other annotation or span.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>immediately</code></strong></dt>
<dd>if true checks if this annotation ends immediately before the
other one (Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if before, False otherwise</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.iscoextensive"><code class="name flex">
<span>def <span class="ident">iscoextensive</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is coextensive with the given span, annotation or
annotation set, i.e. has exactly the same start and end offsets.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>True</code> if coextensive, <code>False</code> otherwise</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.iscovering"><code class="name flex">
<span>def <span class="ident">iscovering</span></span>(<span>self, start: int, end=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is covering the given span, annotation or
annotation set, i.e. both the given start and end offsets
are after the start of this annotation and before the end of this annotation.</p>
<p>If end is not given, then the method checks if start is an offset of a character
contained in the span.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if covering, False otherwise</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.isendingwith"><code class="name flex">
<span>def <span class="ident">isendingwith</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is ending at the same offset as the given span or annotation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start of the span (ignored)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end of the span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if ending at the same offset as the span or annotation</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.isleftoverlapping"><code class="name flex">
<span>def <span class="ident">isleftoverlapping</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is overlapping with the given span, annotation or
annotation set on the left, i.e. the last character is inside the span and the
first character is before the span.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>True</code> if left-overlapping, <code>False</code> otherwise</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.isoverlapping"><code class="name flex">
<span>def <span class="ident">isoverlapping</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is overlapping with the given span, annotation or
annotation set.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>True</code> if overlapping, <code>False</code> otherwise</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.isrightoverlapping"><code class="name flex">
<span>def <span class="ident">isrightoverlapping</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is overlapping with the given span, annotation or
annotation set on the right, i.e. the first character is inside the span.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>True</code> if right-overlapping, <code>False</code> otherwise</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.isstartingat"><code class="name flex">
<span>def <span class="ident">isstartingat</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gatenlp.annotation.Annotation.iswithin"><code class="name flex">
<span>def <span class="ident">iswithin</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is within the given span, annotation or
annotation set, i.e. both the start and end offsets of this annotation
are after the given start and before the given end.</p>
<p>Note: this can be called with an Annotation or AnnotationSet instead of <code>start</code> and <code>end</code>
(see gatenlp._utils.support_annotation_or_set)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>True</code> if within, <code>False</code> otherwise</p></div>
</dd>
<dt id="gatenlp.annotation.Annotation.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, offset_mapper=None, offset_type=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a representation of this annotation as a nested map. This representation is
used for several serialization methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>the offset mapper to use, must be specified if
<code>offset_type</code> is specified.</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>the offset type to be used for the conversionm must be specified if
<code>offset_mapper</code> is specified</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the dictionary representation of the Annotation</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp" href="index.html">gatenlp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.annotation.Annotation" href="#gatenlp.annotation.Annotation">Annotation</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.annotation.Annotation.copy" href="#gatenlp.annotation.Annotation.copy">copy</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.deepcopy" href="#gatenlp.annotation.Annotation.deepcopy">deepcopy</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.end" href="#gatenlp.annotation.Annotation.end">end</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.features" href="#gatenlp.annotation.Annotation.features">features</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.from_dict" href="#gatenlp.annotation.Annotation.from_dict">from_dict</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.gap" href="#gatenlp.annotation.Annotation.gap">gap</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.id" href="#gatenlp.annotation.Annotation.id">id</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.isafter" href="#gatenlp.annotation.Annotation.isafter">isafter</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.isbefore" href="#gatenlp.annotation.Annotation.isbefore">isbefore</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.iscoextensive" href="#gatenlp.annotation.Annotation.iscoextensive">iscoextensive</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.iscovering" href="#gatenlp.annotation.Annotation.iscovering">iscovering</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.isendingwith" href="#gatenlp.annotation.Annotation.isendingwith">isendingwith</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.isleftoverlapping" href="#gatenlp.annotation.Annotation.isleftoverlapping">isleftoverlapping</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.isoverlapping" href="#gatenlp.annotation.Annotation.isoverlapping">isoverlapping</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.isrightoverlapping" href="#gatenlp.annotation.Annotation.isrightoverlapping">isrightoverlapping</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.isstartingat" href="#gatenlp.annotation.Annotation.isstartingat">isstartingat</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.iswithin" href="#gatenlp.annotation.Annotation.iswithin">iswithin</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.length" href="#gatenlp.annotation.Annotation.length">length</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.span" href="#gatenlp.annotation.Annotation.span">span</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.start" href="#gatenlp.annotation.Annotation.start">start</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.to_dict" href="#gatenlp.annotation.Annotation.to_dict">to_dict</a></code></li>
<li><code><a title="gatenlp.annotation.Annotation.type" href="#gatenlp.annotation.Annotation.type">type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev22+gf4251dd</a>.</p>
</footer>
</body>
</html>