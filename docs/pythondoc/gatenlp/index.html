<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>gatenlp API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>gatenlp</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># NOTE: do not place a comment at the end of the version assignment
# line since we parse that line in a shell script!
__version__ = &#34;0.9&#34;
import logging
try:
    import sortedcontainers
except Exception as ex:
    import sys
    print(&#34;ERROR: required package sortedcontainers cannot be imported!&#34;, file=sys.stderr)
    print(&#34;Please install it, using e.g. &#39;pip install -U sortedcontainers&#39;&#34;, file=sys.stderr)
    sys.exit(1)
# TODO: check version of sortedcontainers (we have 2.1.0)
logging.basicConfig()
logger = logging.getLogger(&#34;gatenlp&#34;)
logger.setLevel(logging.INFO)

# this attribute globally holds the processing resource last defined
# so it can be used for interacting with the GATE python plugin
from gatenlp.gate_interaction import _pr_decorator as GateNlpPr
from gatenlp.gate_interaction import interact
from gatenlp.annotation import Annotation
from gatenlp.document import Document
from gatenlp.annotation_set import AnnotationSet
from gatenlp.changelog import ChangeLog
from gatenlp.gateslave import GateSlave

__all__ = [&#34;GateNlpPr&#34;, &#34;Annotation&#34;, &#34;Document&#34;, &#34;AnnotationSet&#34;,
           &#34;ChangeLog&#34;, &#34;logger&#34;]

gate_python_plugin_pr = None</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="gatenlp.annotation" href="annotation.html">gatenlp.annotation</a></code></dt>
<dd>
<div class="desc"><p>An annotation is immutable, but the features it contains are mutable.</p></div>
</dd>
<dt><code class="name"><a title="gatenlp.annotation_set" href="annotation_set.html">gatenlp.annotation_set</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="gatenlp.changelog" href="changelog.html">gatenlp.changelog</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="gatenlp.document" href="document.html">gatenlp.document</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="gatenlp.features" href="features.html">gatenlp.features</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="gatenlp.gate_interaction" href="gate_interaction.html">gatenlp.gate_interaction</a></code></dt>
<dd>
<div class="desc"><p>Support for interacting between a GATE (java) process and a gatenlp (Python) process.</p></div>
</dd>
<dt><code class="name"><a title="gatenlp.gatenlpconfig" href="gatenlpconfig.html">gatenlp.gatenlpconfig</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="gatenlp.gateslave" href="gateslave.html">gatenlp.gateslave</a></code></dt>
<dd>
<div class="desc"><p>Module for interacting with a Java GATE process, running API commands on it and
exchanging data with it.</p></div>
</dd>
<dt><code class="name"><a title="gatenlp.impl" href="impl/index.html">gatenlp.impl</a></code></dt>
<dd>
<div class="desc"><p>This subpackage contains modules for (temporary) implementation of
datastructures and algorithms needed. Some of these may get replaced
by other …</p></div>
</dd>
<dt><code class="name"><a title="gatenlp.lang" href="lang/index.html">gatenlp.lang</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="gatenlp.lib_spacy" href="lib_spacy.html">gatenlp.lib_spacy</a></code></dt>
<dd>
<div class="desc"><p>Support for using spacy: convert from spacy to gatenlp documents and annotations.</p></div>
</dd>
<dt><code class="name"><a title="gatenlp.lib_stanfordnlp" href="lib_stanfordnlp.html">gatenlp.lib_stanfordnlp</a></code></dt>
<dd>
<div class="desc"><p>Support for using stanfordnlp: convert from stanfordnlp output to gatenlp documents and annotations.</p></div>
</dd>
<dt><code class="name"><a title="gatenlp.lib_stanza" href="lib_stanza.html">gatenlp.lib_stanza</a></code></dt>
<dd>
<div class="desc"><p>Support for using stanford stanza (see <a href="https://stanfordnlp.github.io/stanza/">https://stanfordnlp.github.io/stanza/</a>):
convert from stanford Stanza output to gatenlp documents and annotations.</p></div>
</dd>
<dt><code class="name"><a title="gatenlp.offsetmapper" href="offsetmapper.html">gatenlp.offsetmapper</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="gatenlp.processing" href="processing/index.html">gatenlp.processing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="gatenlp.serialization" href="serialization/index.html">gatenlp.serialization</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="gatenlp.utils" href="utils.html">gatenlp.utils</a></code></dt>
<dd>
<div class="desc"><p>Various utilities that could be useful in several modules.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gatenlp.GateNlpPr"><code class="name flex">
<span>def <span class="ident">GateNlpPr</span></span>(<span>what)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the decorator to identify a class or function as a processing
resource. This is made available with the name PR in the gatenlp
package.</p>
<p>This creates an instance of PRWrapper and registers all the relevant
functions of the decorated class or the decorated function in the
wrapper.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>what</code></strong></dt>
<dd>the class or function to decorate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>modified class or function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _pr_decorator(what):
    &#34;&#34;&#34;This is the decorator to identify a class or function as a processing
    resource. This is made available with the name PR in the gatenlp
    package.
    
    This creates an instance of PRWrapper and registers all the relevant
    functions of the decorated class or the decorated function in the
    wrapper.

    Args:
      what: the class or function to decorate.

    Returns:
      modified class or function

    &#34;&#34;&#34;
    gatenlp.gate_python_plugin_pr = &#34;The PR from here!!!&#34;

    wrapper = _PrWrapper()
    if inspect.isclass(what):
        what = what()   # create an instance
        # TODO: instead of this we could just as well store the instance and 
        # directly call the instance methods from the wrapper!
        execmethod = _has_method(what, &#34;__call__&#34;)
        if not execmethod:
            raise Exception(&#34;PR does not have a __call__(doc) method.&#34;)
        allowkws = _check_exec(execmethod)
        wrapper.func_execute_allowkws = allowkws
        wrapper.func_execute = execmethod
        startmethod = _has_method(what, &#34;start&#34;)
        if startmethod:
            wrapper.func_start = startmethod
            if inspect.getfullargspec(startmethod).varkw:
                wrapper.func_start_allowkws = True
        finishmethod = _has_method(what, &#34;finish&#34;)
        if finishmethod:
            wrapper.func_finish = finishmethod
            if inspect.getfullargspec(finishmethod).varkw:
                wrapper.func_finish_allowkws = True
        reducemethod = _has_method(what, &#34;reduce&#34;)
        if reducemethod:
            wrapper.func_reduce = reducemethod
            if inspect.getfullargspec(reducemethod).varkw:
                wrapper.func_reduce_allowkws = True

    elif inspect.isfunction(what):
        allowkws = _check_exec(what)
        wrapper.func_execute = what
        wrapper.func_execute_allowkws = allowkws
    else:
        raise Exception(f&#34;Decorator applied to something that is not a function or class: {what}&#34;)
    gatenlp.gate_python_plugin_pr = wrapper
    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.Annotation"><code class="flex name class">
<span>class <span class="ident">Annotation</span></span>
<span>(</span><span>start: int, end: int, anntype: str, features=None, annid: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>An annotation represents information about a span of text. It contains the start and end
offsets of the span, an "annotation type" and it is a feature bearer.
In addition it contains an id which has no meaning for the annotation itself but is
used to uniquely identify an annotation within the set it is contained in.
All fields except the features are immutable, once the annotation has been created
only the features can be changed.</p>
<p>Args:</p>
<p>Returns:</p>
<p>Create a new annotation instance. NOTE: this should almost never be done directly
and instead the method annotation_set.add should be used!
Once an annotation has been created, the start, end, type and id fields must not
be changed!</p>
<p>:param start: start offset of the annotation
:param end: end offset of the annotation
:param anntype: annotation type
:param features: an initial collection of features, None for no features.
:param annid: the id of the annotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Annotation:
    &#34;&#34;&#34;An annotation represents information about a span of text. It contains the start and end
    offsets of the span, an &#34;annotation type&#34; and it is a feature bearer.
    In addition it contains an id which has no meaning for the annotation itself but is
    used to uniquely identify an annotation within the set it is contained in.
    All fields except the features are immutable, once the annotation has been created
    only the features can be changed.

    Args:

    Returns:

    &#34;&#34;&#34;

    @property
    def type(self):
        &#34;&#34;&#34;:return: the type of the annotation, immutable.&#34;&#34;&#34;
        return self._type

    @property
    def start(self):
        &#34;&#34;&#34;:return: the start offset of the annotation, immutable.&#34;&#34;&#34;
        return self._start

    @property
    def end(self):
        &#34;&#34;&#34;Returns the end offset of the annotation, immutable.
        
        :return:

        Args:

        Returns:

        &#34;&#34;&#34;
        return self._end

    @property
    def features(self):
        &#34;&#34;&#34;Get the features for the annotation.
        
        :return: the Features object.

        Args:

        Returns:

        &#34;&#34;&#34;
        return self._features

    @property
    def id(self):
        &#34;&#34;&#34;

        Args:

        Returns:
          :return:

        &#34;&#34;&#34;
        return self._id

    @property
    def span(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Returns a tuple with the start and end offset of the annotation.
        
        :return: tuple of start and end offsets

        Args:

        Returns:

        &#34;&#34;&#34;
        return self.start, self.end

    def __init__(
            self, start: int, end: int, anntype: str,
            features=None,
            annid: int = 0
    ):
        &#34;&#34;&#34;
        Create a new annotation instance. NOTE: this should almost never be done directly
        and instead the method annotation_set.add should be used!
        Once an annotation has been created, the start, end, type and id fields must not
        be changed!

        :param start: start offset of the annotation
        :param end: end offset of the annotation
        :param anntype: annotation type
        :param features: an initial collection of features, None for no features.
        :param annid: the id of the annotation
        &#34;&#34;&#34;
        if end &lt; start:
            raise Exception(f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, id={annid}, features={features}: start &gt; end&#34;)
        if not isinstance(annid, int):
            raise Exception(f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, id={annid}, features={features}: annid is not an int&#34;)
        if isinstance(features, int):
            raise Exception(f&#34;Cannot create annotation start={start}, end={end}, type={anntype}, id={annid}, features={features}: features must not be an int&#34;)
        # super().__init__(features)
        if annid is not None and not isinstance(annid, int):
            raise Exception(&#34;Parameter annid must be an int, mixed up with features?&#34;)
        if features is not None and isinstance(features, int):
            raise Exception(&#34;Parameter features must not be an int: mixed up with annid?&#34;)
        self._owner_set = None
        self._features = Features(features, logger=self._log_feature_change)
        self._type = anntype
        self._start = start
        self._end = end
        self._id = annid

    def _changelog(self):
        &#34;&#34;&#34;

        Args:

        Returns:
          :return: the changelog

        &#34;&#34;&#34;
        if self._owner_set is not None:
            return self._owner_set.changelog

    # TODO: for now at least, make sure only simple JSON serialisable things are used! We do NOT
    # allow any user specific types in order to make sure what we create is interchangeable with GATE.
    # In addition we do NOT allow None features.
    # So a feature name always has to be a string (not None), the value has to be anything that is json
    # serialisable (except None keys for maps).
    # For performance reasons we check the feature name but not the value (maybe make checking optional
    # on by default but still optional?)
    def _log_feature_change(self, command: str, feature: str = None, value=None) -&gt; None:
        &#34;&#34;&#34;

        Args:
          command: str: 
          feature: str:  (Default value = None)
          value:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if self._changelog() is None:
            return
        command = &#34;ann-&#34;+command
        ch = {
            &#34;command&#34;: command,
            &#34;type&#34;: &#34;annotation&#34;,
            &#34;set&#34;: self._owner_set.name,
            &#34;id&#34;: self.id}
        if feature is not None:
            ch[&#34;feature&#34;] = feature
        if value is not None:
            ch[&#34;value&#34;] = value
        self._changelog().append(ch)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;
        Two annotations are identical if they are the same object or if all the fields
        are equal.

        :param other: the object to compare with
        :return: if the annotations are equal
        &#34;&#34;&#34;
        if not isinstance(other, Annotation):
            return False
        if self is other:
            return True
        return self.start == other.start and self.end == other.end and \
               self.type == other.type and self.id == other.id and self._features == other._features

    def __hash__(self):
        &#34;&#34;&#34;
        The hash depends on the annotation ID and the owning set.

        :return: hash
        &#34;&#34;&#34;
        return hash((self.id, self._owner_set))

    def __lt__(self, other) -&gt; bool:
        &#34;&#34;&#34;
        Comparison for sorting: this sorts by increasing start offset,  then increasing annotation id.
        Since annotation ids within a set are unique, this guarantees a unique order of annotations that
        come from an annotation set.
        NOTE: for now the other object has to be an instance of Annotation, duck typing is not supported!

        :param other: another annotation
        :return:
        &#34;&#34;&#34;
        if not isinstance(other, Annotation):
            raise Exception(&#34;Cannot compare to non-Annotation&#34;)
        if self.start &lt; other.start:
            return True
        elif self.start &gt; other.start:
            return False
        else:
            return self.id &lt; other.id

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        String representation of the annotation.

        :return: string representation
        &#34;&#34;&#34;
        return &#34;Annotation({},{},{},features={},id={})&#34;.format(self.start, self.end, self.type, self._features, self.id)

    @property
    def length(self) -&gt; int:
        &#34;&#34;&#34;The length of the annotation is the length of the offset span. Since the end offset is one after the last
        element, we return end-start. Note: this is deliberately not implemented as len(ann), as
        len(annset) returns the number of annotations in the set but annset.length() also returns the
        span length of the annotation set, so the method name for this is identical between annotations
        and annotation sets.
        
        :return:

        Args:

        Returns:

        &#34;&#34;&#34;
        return self.end - self.start

    @support_annotation_or_set
    def isoverlapping(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is overlapping with the given span, annotation or
        annotation set.
        An annotation is overlapping with a span if the first or last character
        is inside that span.

        Args:
          start: start offset of the span
          end: end offset of the span
          start: int: 
          end: int: 

        Returns:
          True if overlapping, False otherwise

        &#34;&#34;&#34;
        return self.iscovering(start) or self.iscovering(end - 1)

    @support_annotation_or_set
    def iscoextensive(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is coextensive with the given span, annotation or
        annotation set, i.e. has exactly the same start and end offsets.

        Args:
          start: start offset of the span
          end: end offset of the span
          start: int: 
          end: int: 

        Returns:
          True if coextensive, False otherwise

        &#34;&#34;&#34;
        return self.start == start and self.end == end

    @support_annotation_or_set
    def iswithin(self, start: int, end: int) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is within the given span, annotation or
        annotation set, i.e. both the start and end offsets of this annotation
        are after the given start and before the given end.

        Args:
          start: start offset of the span
          end: end offset of the span
          start: int: 
          end: int: 

        Returns:
          True if within, False otherwise

        &#34;&#34;&#34;
        return start &lt;= self.start and end &gt;= self.end

    @support_annotation_or_set
    def isbefore(self, start: int, end: int, immediately=False) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is before the other span, i.e. the end of this annotation
        is before the start of the other annotation or span.

        Args:
          start: start offset of the span
          end: end offset of the span
          immediately: if true checks if this annotation ends immediately before the other one (Default value = False)
          start: int: 
          end: int: 

        Returns:
          True if before, False otherwise

        &#34;&#34;&#34;
        if immediately:
            return self.end == start
        else:
            return self.end &lt;= start

    @support_annotation_or_set
    def isafter(self, start: int, end: int, immediately=False) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is after the other span, i.e. the start of this annotation
        is after the end of the other annotation or span.

        Args:
          start: start offset of the span
          end: end offset of the span
          immediately: if true checks if this annotation starts immediately after the other one (Default value = False)
          start: int: 
          end: int: 

        Returns:
          True if after, False otherwise

        &#34;&#34;&#34;
        if immediately:
            return self.start == end
        else:
            return self.start &gt;= end

    @support_annotation_or_set
    def gap(self, start: int, end: int):
        &#34;&#34;&#34;Return the gep between this annotation and the other annotation. This is the distance between
        the last character of the first annotation and the first character of the second annotation in
        sequence, so it is always independent of the order of the two annotations.
        
        This is negative if the annotations overlap.

        Args:
          start: start offset of span
          end: end offset of span
          start: int: 
          end: int: 

        Returns:
          size of gap

        &#34;&#34;&#34;
        if self.start &lt; start:
            ann1start = self.start
            ann1end = self.end
            ann2start = start
            ann2end = end
        else:
            ann2start = self.start
            ann2end = self.end
            ann1start = start
            ann1end = end
        return ann2start - ann1end

    @support_annotation_or_set
    def iscovering(self, start: int, end: int = None) -&gt; bool:
        &#34;&#34;&#34;Checks if this annotation is covering the given span, annotation or
        annotation set, i.e. both the given start and end offsets
        are after the start of this annotation and before the end of this annotation.
        
        If end is not given, then the method checks if start is an offset of a character
        contained in the span.

        Args:
          start: start offset of the span
          end: end offset of the span
          start: int: 
          end: int:  (Default value = None)

        Returns:
          True if covering, False otherwise

        &#34;&#34;&#34;
        if end is None:
            return self.start &lt;= start &lt; self.end
        else:
            return self.start &lt;= start and self.end &gt;= end

    def to_dict(self, offset_mapper=None, offset_type=None):
        &#34;&#34;&#34;Return a representation of this annotation as a nested map. This representation is
        used for several serialization methods.

        Args:
          offset_mapper: used if an offset_type is also specified. (Default value = None)
          offset_type: return: (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if (offset_mapper and not offset_type) or (not offset_mapper and offset_type):
            raise Exception(&#34;offset_mapper and offset_type must be specified both or none&#34;)
        if offset_mapper is not None:
            if offset_type == OFFSET_TYPE_JAVA:
                start = offset_mapper.convert_to_java(self._start)
                end = offset_mapper.convert_to_java(self._end)
            elif offset_type == OFFSET_TYPE_PYTHON:
                start = offset_mapper.convert_to_python(self._start)
                end = offset_mapper.convert_to_python(self._end)
            else:
                raise Exception(f&#34;Not a valid offset type: {offset_type}, must be &#39;p&#39; or &#39;j&#39;&#34;)
        else:
            start = self._start
            end = self._end
        return {
            &#34;type&#34;: self.type,
            &#34;start&#34;: start,
            &#34;end&#34;: end,
            &#34;id&#34;: self.id,
            &#34;features&#34;: self._features.to_dict(),
        }

    @staticmethod
    def from_dict(dictrepr, owner_set=None, **kwargs):
        &#34;&#34;&#34;Construct an annotation object from the dictionary representation.

        Args:
          dictrepr: dictionary representation
          owner_set: the owning set the annotation should have (Default value = None)
          kwargs: ignored
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        ann = Annotation(
            start=dictrepr.get(&#34;start&#34;),
            end=dictrepr.get(&#34;end&#34;),
            anntype=dictrepr.get(&#34;type&#34;),
            annid=dictrepr.get(&#34;id&#34;),
            features=dictrepr.get(&#34;features&#34;)
        )
        ann._owner_set = owner_set
        return ann

    def __copy__(self):
        return Annotation(self._start, self._end, self._type, annid=self._id, features=self._features)

    def copy(self):
        &#34;&#34;&#34;

        Args:

        Returns:
          :return: shallow copy

        &#34;&#34;&#34;
        return self.__copy__()

    def __deepcopy__(self, memo=None):
        if self._features is not None:
            fts = copy.deepcopy(self._features.to_dict(), memo=memo)
        else:
            fts = None
        return Annotation(self._start, self._end, self._type, annid=self._id, features=fts)

    def deepcopy(self):
        &#34;&#34;&#34;

        Args:

        Returns:
          :return: deep copy

        &#34;&#34;&#34;
        return copy.deepcopy(self)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.Annotation.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>dictrepr, owner_set=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct an annotation object from the dictionary representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dictrepr</code></strong></dt>
<dd>dictionary representation</dd>
<dt><strong><code>owner_set</code></strong></dt>
<dd>the owning set the annotation should have (Default value = None)</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>ignored</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(dictrepr, owner_set=None, **kwargs):
    &#34;&#34;&#34;Construct an annotation object from the dictionary representation.

    Args:
      dictrepr: dictionary representation
      owner_set: the owning set the annotation should have (Default value = None)
      kwargs: ignored
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    ann = Annotation(
        start=dictrepr.get(&#34;start&#34;),
        end=dictrepr.get(&#34;end&#34;),
        anntype=dictrepr.get(&#34;type&#34;),
        annid=dictrepr.get(&#34;id&#34;),
        features=dictrepr.get(&#34;features&#34;)
    )
    ann._owner_set = owner_set
    return ann</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="gatenlp.Annotation.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<div class="desc"><p>Returns the end offset of the annotation, immutable.</p>
<p>:return:</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end(self):
    &#34;&#34;&#34;Returns the end offset of the annotation, immutable.
    
    :return:

    Args:

    Returns:

    &#34;&#34;&#34;
    return self._end</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.features"><code class="name">var <span class="ident">features</span></code></dt>
<dd>
<div class="desc"><p>Get the features for the annotation.</p>
<p>:return: the Features object.</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def features(self):
    &#34;&#34;&#34;Get the features for the annotation.
    
    :return: the Features object.

    Args:

    Returns:

    &#34;&#34;&#34;
    return self._features</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self):
    &#34;&#34;&#34;

    Args:

    Returns:
      :return:

    &#34;&#34;&#34;
    return self._id</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.length"><code class="name">var <span class="ident">length</span> : int</code></dt>
<dd>
<div class="desc"><p>The length of the annotation is the length of the offset span. Since the end offset is one after the last
element, we return end-start. Note: this is deliberately not implemented as len(ann), as
len(annset) returns the number of annotations in the set but annset.length() also returns the
span length of the annotation set, so the method name for this is identical between annotations
and annotation sets.</p>
<p>:return:</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self) -&gt; int:
    &#34;&#34;&#34;The length of the annotation is the length of the offset span. Since the end offset is one after the last
    element, we return end-start. Note: this is deliberately not implemented as len(ann), as
    len(annset) returns the number of annotations in the set but annset.length() also returns the
    span length of the annotation set, so the method name for this is identical between annotations
    and annotation sets.
    
    :return:

    Args:

    Returns:

    &#34;&#34;&#34;
    return self.end - self.start</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.span"><code class="name">var <span class="ident">span</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Returns a tuple with the start and end offset of the annotation.</p>
<p>:return: tuple of start and end offsets</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def span(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Returns a tuple with the start and end offset of the annotation.
    
    :return: tuple of start and end offsets

    Args:

    Returns:

    &#34;&#34;&#34;
    return self.start, self.end</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.start"><code class="name">var <span class="ident">start</span></code></dt>
<dd>
<div class="desc"><p>:return: the start offset of the annotation, immutable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start(self):
    &#34;&#34;&#34;:return: the start offset of the annotation, immutable.&#34;&#34;&#34;
    return self._start</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>:return: the type of the annotation, immutable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self):
    &#34;&#34;&#34;:return: the type of the annotation, immutable.&#34;&#34;&#34;
    return self._type</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.Annotation.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>:return: shallow copy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;

    Args:

    Returns:
      :return: shallow copy

    &#34;&#34;&#34;
    return self.__copy__()</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.deepcopy"><code class="name flex">
<span>def <span class="ident">deepcopy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>:return: deep copy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deepcopy(self):
    &#34;&#34;&#34;

    Args:

    Returns:
      :return: deep copy

    &#34;&#34;&#34;
    return copy.deepcopy(self)</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.gap"><code class="name flex">
<span>def <span class="ident">gap</span></span>(<span>self, start: int, end: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the gep between this annotation and the other annotation. This is the distance between
the last character of the first annotation and the first character of the second annotation in
sequence, so it is always independent of the order of the two annotations.</p>
<p>This is negative if the annotations overlap.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of span</dd>
<dt><strong><code>start</code></strong></dt>
<dd>int: </dd>
<dt><strong><code>end</code></strong></dt>
<dd>int: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>size of gap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def gap(self, start: int, end: int):
    &#34;&#34;&#34;Return the gep between this annotation and the other annotation. This is the distance between
    the last character of the first annotation and the first character of the second annotation in
    sequence, so it is always independent of the order of the two annotations.
    
    This is negative if the annotations overlap.

    Args:
      start: start offset of span
      end: end offset of span
      start: int: 
      end: int: 

    Returns:
      size of gap

    &#34;&#34;&#34;
    if self.start &lt; start:
        ann1start = self.start
        ann1end = self.end
        ann2start = start
        ann2end = end
    else:
        ann2start = self.start
        ann2end = self.end
        ann1start = start
        ann1end = end
    return ann2start - ann1end</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.isafter"><code class="name flex">
<span>def <span class="ident">isafter</span></span>(<span>self, start: int, end: int, immediately=False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is after the other span, i.e. the start of this annotation
is after the end of the other annotation or span.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>immediately</code></strong></dt>
<dd>if true checks if this annotation starts immediately after the other one (Default value = False)</dd>
<dt><strong><code>start</code></strong></dt>
<dd>int: </dd>
<dt><strong><code>end</code></strong></dt>
<dd>int: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if after, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def isafter(self, start: int, end: int, immediately=False) -&gt; bool:
    &#34;&#34;&#34;Checks if this annotation is after the other span, i.e. the start of this annotation
    is after the end of the other annotation or span.

    Args:
      start: start offset of the span
      end: end offset of the span
      immediately: if true checks if this annotation starts immediately after the other one (Default value = False)
      start: int: 
      end: int: 

    Returns:
      True if after, False otherwise

    &#34;&#34;&#34;
    if immediately:
        return self.start == end
    else:
        return self.start &gt;= end</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.isbefore"><code class="name flex">
<span>def <span class="ident">isbefore</span></span>(<span>self, start: int, end: int, immediately=False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is before the other span, i.e. the end of this annotation
is before the start of the other annotation or span.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>immediately</code></strong></dt>
<dd>if true checks if this annotation ends immediately before the other one (Default value = False)</dd>
<dt><strong><code>start</code></strong></dt>
<dd>int: </dd>
<dt><strong><code>end</code></strong></dt>
<dd>int: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if before, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def isbefore(self, start: int, end: int, immediately=False) -&gt; bool:
    &#34;&#34;&#34;Checks if this annotation is before the other span, i.e. the end of this annotation
    is before the start of the other annotation or span.

    Args:
      start: start offset of the span
      end: end offset of the span
      immediately: if true checks if this annotation ends immediately before the other one (Default value = False)
      start: int: 
      end: int: 

    Returns:
      True if before, False otherwise

    &#34;&#34;&#34;
    if immediately:
        return self.end == start
    else:
        return self.end &lt;= start</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.iscoextensive"><code class="name flex">
<span>def <span class="ident">iscoextensive</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is coextensive with the given span, annotation or
annotation set, i.e. has exactly the same start and end offsets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>start</code></strong></dt>
<dd>int: </dd>
<dt><strong><code>end</code></strong></dt>
<dd>int: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if coextensive, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def iscoextensive(self, start: int, end: int) -&gt; bool:
    &#34;&#34;&#34;Checks if this annotation is coextensive with the given span, annotation or
    annotation set, i.e. has exactly the same start and end offsets.

    Args:
      start: start offset of the span
      end: end offset of the span
      start: int: 
      end: int: 

    Returns:
      True if coextensive, False otherwise

    &#34;&#34;&#34;
    return self.start == start and self.end == end</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.iscovering"><code class="name flex">
<span>def <span class="ident">iscovering</span></span>(<span>self, start: int, end: int = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is covering the given span, annotation or
annotation set, i.e. both the given start and end offsets
are after the start of this annotation and before the end of this annotation.</p>
<p>If end is not given, then the method checks if start is an offset of a character
contained in the span.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>start</code></strong></dt>
<dd>int: </dd>
<dt><strong><code>end</code></strong></dt>
<dd>int:
(Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if covering, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def iscovering(self, start: int, end: int = None) -&gt; bool:
    &#34;&#34;&#34;Checks if this annotation is covering the given span, annotation or
    annotation set, i.e. both the given start and end offsets
    are after the start of this annotation and before the end of this annotation.
    
    If end is not given, then the method checks if start is an offset of a character
    contained in the span.

    Args:
      start: start offset of the span
      end: end offset of the span
      start: int: 
      end: int:  (Default value = None)

    Returns:
      True if covering, False otherwise

    &#34;&#34;&#34;
    if end is None:
        return self.start &lt;= start &lt; self.end
    else:
        return self.start &lt;= start and self.end &gt;= end</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.isoverlapping"><code class="name flex">
<span>def <span class="ident">isoverlapping</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is overlapping with the given span, annotation or
annotation set.
An annotation is overlapping with a span if the first or last character
is inside that span.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>start</code></strong></dt>
<dd>int: </dd>
<dt><strong><code>end</code></strong></dt>
<dd>int: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if overlapping, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def isoverlapping(self, start: int, end: int) -&gt; bool:
    &#34;&#34;&#34;Checks if this annotation is overlapping with the given span, annotation or
    annotation set.
    An annotation is overlapping with a span if the first or last character
    is inside that span.

    Args:
      start: start offset of the span
      end: end offset of the span
      start: int: 
      end: int: 

    Returns:
      True if overlapping, False otherwise

    &#34;&#34;&#34;
    return self.iscovering(start) or self.iscovering(end - 1)</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.iswithin"><code class="name flex">
<span>def <span class="ident">iswithin</span></span>(<span>self, start: int, end: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this annotation is within the given span, annotation or
annotation set, i.e. both the start and end offsets of this annotation
are after the given start and before the given end.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>start</code></strong></dt>
<dd>int: </dd>
<dt><strong><code>end</code></strong></dt>
<dd>int: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if within, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def iswithin(self, start: int, end: int) -&gt; bool:
    &#34;&#34;&#34;Checks if this annotation is within the given span, annotation or
    annotation set, i.e. both the start and end offsets of this annotation
    are after the given start and before the given end.

    Args:
      start: start offset of the span
      end: end offset of the span
      start: int: 
      end: int: 

    Returns:
      True if within, False otherwise

    &#34;&#34;&#34;
    return start &lt;= self.start and end &gt;= self.end</code></pre>
</details>
</dd>
<dt id="gatenlp.Annotation.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, offset_mapper=None, offset_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a representation of this annotation as a nested map. This representation is
used for several serialization methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>used if an offset_type is also specified. (Default value = None)</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>return: (Default value = None)</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, offset_mapper=None, offset_type=None):
    &#34;&#34;&#34;Return a representation of this annotation as a nested map. This representation is
    used for several serialization methods.

    Args:
      offset_mapper: used if an offset_type is also specified. (Default value = None)
      offset_type: return: (Default value = None)

    Returns:

    &#34;&#34;&#34;
    if (offset_mapper and not offset_type) or (not offset_mapper and offset_type):
        raise Exception(&#34;offset_mapper and offset_type must be specified both or none&#34;)
    if offset_mapper is not None:
        if offset_type == OFFSET_TYPE_JAVA:
            start = offset_mapper.convert_to_java(self._start)
            end = offset_mapper.convert_to_java(self._end)
        elif offset_type == OFFSET_TYPE_PYTHON:
            start = offset_mapper.convert_to_python(self._start)
            end = offset_mapper.convert_to_python(self._end)
        else:
            raise Exception(f&#34;Not a valid offset type: {offset_type}, must be &#39;p&#39; or &#39;j&#39;&#34;)
    else:
        start = self._start
        end = self._end
    return {
        &#34;type&#34;: self.type,
        &#34;start&#34;: start,
        &#34;end&#34;: end,
        &#34;id&#34;: self.id,
        &#34;features&#34;: self._features.to_dict(),
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.AnnotationSet"><code class="flex name class">
<span>class <span class="ident">AnnotationSet</span></span>
<span>(</span><span>name: str = '', owner_doc: <a title="gatenlp.Document" href="#gatenlp.Document">Document</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new annotation set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the annotation set. This is only really needed if the changelog is used.</dd>
<dt><strong><code>changelog</code></strong></dt>
<dd>if a changelog is used, then all changes to the set and its annotations are logged</dd>
<dt><strong><code>owner_doc</code></strong></dt>
<dd>if this is set, the set and all sets created from it can be queried for the</dd>
</dl>
<p>owning document and offsets get checked against the text of the owning document, if it has
text.</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnotationSet:
    def __init__(self, name: str = &#34;&#34;, owner_doc: &#34;Document&#34; = None):
        &#34;&#34;&#34;Create a new annotation set.

        Args:
          name: the name of the annotation set. This is only really needed if the changelog is used.
          changelog: if a changelog is used, then all changes to the set and its annotations are logged
          owner_doc: if this is set, the set and all sets created from it can be queried for the
        owning document and offsets get checked against the text of the owning document, if it has
        text.

        Returns:

        &#34;&#34;&#34;
        # print(&#34;CREATING annotation set {} with changelog {} &#34;.format(name, changelog), file=sys.stderr)
        self._name = name
        self._owner_doc = owner_doc

        # NOTE: the index is only created when we actually need it!
        # TODO: python 3.5
        # self._index_by_offset: SortedIntvls = None
        self._index_by_offset = None
        self._index_by_type = None
        # internally we represent the annotations as a map from annotation id (int) to Annotation
        self._annotations = {}
        self._is_immutable = False
        self._next_annid = 0

    @property
    def name(self):
        &#34;&#34;&#34;Get the name of the annotation set. NOTE: the name of a set cannot be changed.
        
        :return: name of annotation set

        Args:

        Returns:

        &#34;&#34;&#34;
        return self._name

    @property
    def changelog(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        if self._owner_doc is None:
            return None
        return self._owner_doc.changelog

    def __setattr__(self, key, value):
        &#34;&#34;&#34;
        Prevent immutable fields from getting overridden, once they have been
        set.

        :param key: attribute to set
        :param value: value to set attribute to
        :return:
        &#34;&#34;&#34;
        if key == &#34;name&#34; or key == &#34;owner_doc&#34;:
            if self.__dict__.get(key, None) is None:
                super().__setattr__(key, value)
            else:
                raise Exception(&#34;AnnotationSet attribute cannot get changed after being set&#34;)
        else:
            super().__setattr__(key, value)

    def detach(self, restrict_to=None) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;Create an immutable copy of this set, optionally restricted to the given annotation ids.

        Args:
          restrict_to: an iterable of annotation ids, if None, all the annotations from this set. (Default value = None)

        Returns:
          an immutable annotation set with all the annotations of this set or restricted to the ids
          in restrict_to

        &#34;&#34;&#34;
        annset = AnnotationSet(name=&#34;detached-from:&#34;+self.name)
        annset._is_immutable = True
        if restrict_to is None:
            annset._annotations = {annid: self._annotations[annid] for annid in self._annotations.keys()}
        else:
            annset._annotations = {annid: self._annotations[annid] for annid in restrict_to}
        annset._next_annid = self._next_annid
        return annset

    def detach_from(self, anns: Iterable) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;Create an immutable detached annotation set from the annotations in anns which could by
        either a collection of annotations or annotation ids (int numbers) which are assumed to
        be the annotation ids from this set.
        
        The next annotation id for the created set is the highest seen annotation id from anns plus one.

        Args:
          anns: an iterable of annotations
          anns: Iterable: 

        Returns:
          an immutable annotation set with all the annotations of this set or restricted to the ids
          in restrict_to

        &#34;&#34;&#34;
        annset = AnnotationSet(name=&#34;detached-from:&#34;+self.name)
        annset._is_immutable = True
        annset._annotations = {}
        nextid = -1
        for ann in anns:
            if isinstance(ann, int):
                annset._annotations[ann] = self._annotations[ann]
                annid = ann
            else:
                annset._annotations[id] = ann
                annid = ann.id
            if annid &gt; nextid:
                nextid = annid
        annset._next_annid = nextid + 1
        return annset

    @property
    def immutable(self) -&gt; bool:
        &#34;&#34;&#34;

        Args:

        Returns:
          :return: True if immutable

        &#34;&#34;&#34;
        return self._is_immutable

    @immutable.setter
    def immutable(self, val: bool) -&gt; None:
        &#34;&#34;&#34;Set the annotationset to mutable (False) or immutable (True)

        Args:
          val: boolean, True to set to immutable, False, otherwise.
          val: bool: 

        Returns:

        &#34;&#34;&#34;
        self._is_immutable = val

    def isdetached(self) -&gt; bool:
        &#34;&#34;&#34; &#34;&#34;&#34;
        return self._owner_doc is None

    def _create_index_by_offset(self) -&gt; None:
        &#34;&#34;&#34;Generates the offset index, if it does not already exist.
        The offset index is an interval tree that stores the annotation ids for the offset interval of the annotation.

        Args:

        Returns:

        &#34;&#34;&#34;
        if self._index_by_offset is None:
            self._index_by_offset = SortedIntvls()
            for ann in self._annotations.values():
                self._index_by_offset.add(ann.start, ann.end, ann.id)

    def _create_index_by_type(self) -&gt; None:
        &#34;&#34;&#34;Generates the type index, if it does not already exist. The type index is a map from
        annotation type to a set of all annotation ids with that type.

        Args:

        Returns:

        &#34;&#34;&#34;
        if self._index_by_type is None:
            self._index_by_type = defaultdict(set)
            for ann in self._annotations.values():
                self._index_by_type[ann.type].add(ann.id)

    def _add_to_indices(self, annotation: Annotation) -&gt; None:
        &#34;&#34;&#34;If we have created the indices, add the annotation to them.

        Args:
          annotation: the annotation to add to the indices.
          annotation: Annotation: 

        Returns:

        &#34;&#34;&#34;
        if self._index_by_type is not None:
            self._index_by_type[annotation.type].add(annotation.id)
        if self._index_by_offset is not None:
            self._index_by_offset.add(annotation.start, annotation.end, annotation.id)

    def _remove_from_indices(self, annotation: Annotation) -&gt; None:
        &#34;&#34;&#34;Remove an annotation from the indices.

        Args:
          annotation: the annotation to remove.
          annotation: Annotation: 

        Returns:

        &#34;&#34;&#34;
        if self._index_by_offset is not None:
            self._index_by_offset.remove(annotation.start, annotation.end, annotation.id)
        if self._index_by_type is not None:
            self._index_by_type[annotation.type].remove(annotation.id)

    @staticmethod
    def _intvs2idlist(intvs, ignore=None) -&gt; List[int]:
        &#34;&#34;&#34;Convert an iterable of interval tuples (start, end, id) to a list of ids

        Args:
          intvs: iterable of interval tuples
          ignore: an optional annotation id that should not get included in the result (Default value = None)

        Returns:
          list of ids

        &#34;&#34;&#34;
        if ignore is not None:
            return [i[2] for i in intvs if i[2] != ignore]
        else:
            return [i[2] for i in intvs]

    @staticmethod
    def _intvs2idset(intvs, ignore=None) -&gt; Set[int]:
        &#34;&#34;&#34;Convert an iterable of interval tuples (start, end, id) to a set of ids

        Args:
          intvs: iterable of interval tuples
          ignore:  (Default value = None)

        Returns:
          set of ids

        &#34;&#34;&#34;
        ret = set()
        if ignore is not None:
            for i in intvs:
                if i[2] != ignore:
                    ret.add(i[2])
        else:
            for i in intvs:
                ret.add(i[2])
        return ret

    def _restrict_intvs(self, intvs, ignore=None) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;

        Args:
          intvs: 
          ignore:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        return self.detach(restrict_to=AnnotationSet._intvs2idlist(intvs, ignore=ignore))

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Return number of annotations in the set.

        :return: number of annotations
        &#34;&#34;&#34;
        return len(self._annotations)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;

        Args:

        Returns:
          :return: number of annotations

        &#34;&#34;&#34;
        return len(self._annotations)

    @property
    def document(self) -&gt; Union[&#34;Document&#34;, None]:
        &#34;&#34;&#34;Get the owning document, if known. If the owning document was not set, return None.
        
        :return: the document this annotation set belongs to or None if unknown.

        Args:

        Returns:

        &#34;&#34;&#34;
        return self._owner_doc

    @support_annotation_or_set
    def _check_offsets(self, start: int, end: int, annid=None) -&gt; None:
        &#34;&#34;&#34;Checks the offsets for the given span/annotation against the document boundaries, if we know the owning
        document and if the owning document has text.

        Args:
          start: int: 
          end: int: 
          annid:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if self._owner_doc is None:
            return
        if self._owner_doc.text is None:
            return
        doc_size = len(self._owner_doc)

        if start &lt; 0:
            raise InvalidOffsetError(&#34;Annotation starts before 0&#34;)
        if end &lt; 0:
            raise InvalidOffsetError(&#34;Annotation ends before 0&#34;)
        if start &gt; end:
            raise InvalidOffsetError(&#34;Annotation ends before it starts&#34;)
        if start &gt; doc_size:
            raise InvalidOffsetError(
                &#34;Annotation starts after document ends: start={}, docsize={}&#34;.format(start, doc_size))
        if end &gt; doc_size:
            raise InvalidOffsetError(
                &#34;Annotation ends after document ends: end={}, docsize={}&#34;.format(end, doc_size))

    @property
    def start(self):
        &#34;&#34;&#34;

        Args:

        Returns:
          This needs the index and creates it if necessary.
          
          Throws an exception if there are no annotations in the set.
          
          :return: smallest annotation offset

        &#34;&#34;&#34;
        if self.size == 0:
            raise Exception(&#34;Annotation set is empty, cannot determine start offset&#34;)
        self._create_index_by_offset()
        return self._index_by_offset.min_start()

    @property
    def end(self):
        &#34;&#34;&#34;Returns the end offset of the annotation set, i.e. the biggest end offset of any annotation.
        This needs the index and creates it if necessary.
        
        :return: largest end offset

        Args:

        Returns:

        &#34;&#34;&#34;
        if self.size == 0:
            raise Exception(&#34;Annotation set is empty, cannot determine end offset&#34;)
        self._create_index_by_offset()
        return self._index_by_offset.max_end()

    @property
    def length(self):
        &#34;&#34;&#34;

        Args:

        Returns:
          This needs the index and creates it if necessary.
          
          :return: length of the annotation set span

        &#34;&#34;&#34;
        return self.end() - self.start()

    def add(self, start: int, end: int, anntype: str, features: Dict[str, Any] = None, annid: int = None):
        &#34;&#34;&#34;Add an annotation to the set. Once an annotation has been added, the start and end offsets,
        the type, and the annotation id are immutable.

        Args:
          start: start offset
          end: end offset
          anntype: the annotation type
          features: a map, an iterable of tuples or an existing feature map. In any case, the features are used
        to create a new feature map for this annotation. If the map is empty or this parameter is None, the
        annotation does not store any map at all.
          annid: the annotation id, if not specified the next free one for this set is used. NOTE: the id should
        normally left unspecified and get assigned automatically.
          start: int: 
          end: int: 
          anntype: str: 
          features: Dict[str: 
          Any]:  (Default value = None)
          annid: int:  (Default value = None)

        Returns:
          the new annotation

        &#34;&#34;&#34;
        if annid is not None and not isinstance(annid, int):
            raise Exception(&#34;Parameter annid must be an int, mixed up with features?&#34;)
        if features is not None and isinstance(features, int):
            raise Exception(&#34;Parameter features must not be an int: mixed up with annid?&#34;)
        if self._is_immutable:
            raise Exception(&#34;Cannot add an annotation to an immutable annotation set&#34;)
        self._check_offsets(start, end)
        if annid and annid in self._annotations:
            raise Exception(&#34;Cannot add annotation with id {}, already in set&#34;.format(annid))
        if annid is None:
            annid = self._next_annid
            self._next_annid = self._next_annid + 1
        ann = Annotation(start, end, anntype, features=features, annid=annid)
        ann._owner_set = self
        if not self._annotations:
            self._annotations = {}
        self._annotations[annid] = ann
        self._add_to_indices(ann)
        if self.changelog is not None:
            entry = {
                    &#34;command&#34;: &#34;annotation:add&#34;,
                    &#34;set&#34;: self.name,
                    &#34;start&#34;: ann.start,
                    &#34;end&#34;: ann.end,
                    &#34;type&#34;: ann.type,
                    &#34;features&#34;: ann._features.to_dict(),
                    &#34;id&#34;: ann.id
                }
            self.changelog.append(entry)
        return ann

    def add_ann(self, ann, annid: int = None):
        &#34;&#34;&#34;Add a copy of the given ann to the annotation set, either with a new annotation id or
        with the one given.

        Args:
          annid: the annotation id, if not specified the next free one for this set is used.
        NOTE: the id should normally left unspecified and get assigned automatically.
          ann: 
          annid: int:  (Default value = None)

        Returns:
          the annotation id of the added annotation

        &#34;&#34;&#34;
        return self.add(ann.start, ann.end, ann.type, ann.features, annid=annid)

    def remove(self, annotation: Union[int, Annotation]) -&gt; None:
        &#34;&#34;&#34;Remove the given annotation which is either the id or the annotation instance.

        Args:
          annotation: either the id (int) or the annotation instance (Annotation)
          annotation: Union[int: 
          Annotation]: 

        Returns:

        &#34;&#34;&#34;
        annid = None  # make pycharm happy
        if self._is_immutable:
            raise Exception(&#34;Cannot remove an annotation from an immutable annotation set&#34;)
        if isinstance(annotation, int):
            annid = annotation
            if annid not in self._annotations:
                raise Exception(&#34;Annotation with id {} not in annotation set, cannot remove&#34;.format(annid))
            annotation = self._annotations[annid]
        elif isinstance(annotation, Annotation):
            annid = annotation.id
            if annid not in self._annotations:
                raise Exception(&#34;Annotation with id {} does not belong to this set, cannot remove&#34;.format(annid))
        # NOTE: once the annotation has been removed from the set, it could still be referenced
        # somewhere else and its features could get modified. In order to prevent logging of such changes,
        # the owning set gets cleared for the annotation
        annotation._owner_set = None
        del self._annotations[annid]
        if self.changelog is not None:
            self.changelog.append({
                &#34;command&#34;: &#34;annotation:remove&#34;,
                &#34;set&#34;: self.name,
                &#34;id&#34;: annid})
        self._remove_from_indices(annotation)

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Remove all annotations from the set.
        
        :return:

        Args:

        Returns:

        &#34;&#34;&#34;
        self._annotations.clear()
        self._index_by_offset = None
        self._index_by_type = None
        if self.changelog is not None:
            self.changelog.append({
                &#34;command&#34;: &#34;annotations:clear&#34;,
                &#34;set&#34;: self.name})

    def clone_anns(self, memo=None):
        &#34;&#34;&#34;Replace the annotations in this set with copies of the originals. If this is a detached set,
        then this makes sure that any modifications to the annotations do not affect the original annotations
        in the attached set. If this is an attached set, it makes sure that all other detached sets cannot affect
        the annotations in this set any more. The owning set of the annotations that get cloned is cleared.

        Args:
          memo: for internal use by our __deepcopy__ implementation. (Default value = None)

        Returns:

        &#34;&#34;&#34;
        tmpdict = {}
        for annid, ann in self._annotations.items():
            newann = copy.deepcopy(ann, memo=memo)
            ann._owner_set = None
            tmpdict[annid] = newann
        for annid, ann in tmpdict.items():
            self._annotations[annid] = ann

    def __copy__(self):
        &#34;&#34;&#34;
        NOTE: creating a copy always creates a detached set, but a mutable one.
        :return:
        &#34;&#34;&#34;
        c = self.detach()
        c._is_immutable = False
        return c

    def copy(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        return self.__copy__()

    def __deepcopy__(self, memo=None):
        if memo is None:
            memo = {}
        c = self.detach()
        c._is_immutable = False
        c.clone_anns(memo=memo)
        return c

    def deepcopy(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        return copy.deepcopy(self)

    def __iter__(self) -&gt; Iterator:
        &#34;&#34;&#34;
        Iterator for going through all the annotations of the set.

        Important: using the iterator will always create the index if it is not already there!
        For fast iteration use fast_iter() which does not allow sorting or offset ranges.

        :return: a generator for the annotations in document order
        &#34;&#34;&#34;
        # return iter(self._annotations.values())
        return self.iter()

    def fast_iter(self) -&gt; Generator:
        &#34;&#34;&#34;Returns a generator for fast iteration over all annotations in arbitrary order.
        
        :return:

        Args:

        Returns:

        &#34;&#34;&#34;
        if self._annotations:
            for annid, ann in self._annotations.items():
                yield ann

    def iter(self,
             start_ge: Union[int, None] = None,
             start_lt: Union[None, int] = None,
             with_type: str = None,
             reverse: bool = False) -&gt; Generator:
        &#34;&#34;&#34;Returns a generator for going through annotations in document order, otionally limited
        by the other parameters. If two annoations start at the same offset, they are always
        ordered by increasing annotation id.

        Args:
          annotations: an iterable of annotations from this annotation set.
          start_ge: the offset from where to start including annotations
          start_lt: the last offset to use as the starting offset of an annotation
          with_type: only annotations of this type
          reverse: process in reverse document order
          start_ge: Union[int: 
          None]:  (Default value = None)
          start_lt: Union[None: 
          int]:  (Default value = None)
          with_type: str:  (Default value = None)
          reverse: bool:  (Default value = False)

        Returns:
          generator for annotations in document order

        &#34;&#34;&#34;

        if with_type is not None:
            allowedtypes = set()
            if isinstance(type, str):
                allowedtypes.add(with_type)
            else:
                for atype in with_type:
                    allowedtypes.add(atype)
        else:
            allowedtypes = None
        if not self._annotations:
            return
        maxoff = None
        if start_ge is not None:
            assert start_ge &gt;= 0
        if start_lt is not None:
            assert start_lt &gt;= 1
            maxoff = start_lt + 1
        if start_lt is not None and start_ge is not None:
            assert start_lt &gt; start_ge
        self._create_index_by_offset()
        for _start, _end, annid in self._index_by_offset.irange(minoff=start_ge, maxoff=maxoff, reverse=reverse):
            if allowedtypes is not None and self._annotations[annid].type not in allowedtypes:
                continue
            yield self._annotations[annid]

    def reverse_iter(self, **kwargs):
        &#34;&#34;&#34;Same as iter, but with the reverse parameter set to true.

        Args:
          kwargs: Same as for iter(), with revers=True fixed.
          **kwargs: 

        Returns:
          same result as iter()

        &#34;&#34;&#34;
        return self.iter(reverse=True, **kwargs)

    def get(self, annid: Union[int, Annotation], default=None) -&gt; Union[Annotation, None]:
        &#34;&#34;&#34;Gets the annotation with the given annotation id or returns the given default.
        
        NOTE: for handling cases where legacy code still expects the add method to return
        an id and not the annotation, this will accept an annotation so the the frequent
        pattern still works:
        
           annid = annset.add(b,e,t).id
           ann = annset.get(annid)
        
        If an annotation is passed the annotation from the set with the id of that annotation is
        returned, if the annotation is from that set, this will return the same object, if it is
        still in the set (or return the default value).

        Args:
          annid: the annotation id of the annotation to retrieve.
          default: what to return if an annotation with the given id is not found. (Default value = None)
          annid: Union[int: 
          Annotation]: 

        Returns:
          the annotation or the default value.

        &#34;&#34;&#34;
        if isinstance(annid, Annotation):
            annid = annid.id
        return self._annotations.get(annid, default)

    def first(self):
        &#34;&#34;&#34;

        Args:

        Returns:
          :return: first annotation

        &#34;&#34;&#34;
        sz = len(self._annotations)
        if sz == 0:
            raise Exception(&#34;Empty set, there is no first annotation&#34;)
        elif sz == 1:
            return next(iter(self._annotations.values()))
        self._create_index_by_offset()
        _, _, annid = next(self._index_by_offset.irange(reverse=False))
        return self._annotations[annid]

    def last(self):
        &#34;&#34;&#34;

        Args:

        Returns:
          :return: first annotation

        &#34;&#34;&#34;
        sz = len(self._annotations)
        if sz == 0:
            raise Exception(&#34;Empty set, there is no last annotation&#34;)
        elif sz == 1:
            return next(iter(self._annotations.values()))
        self._create_index_by_offset()
        _, _, annid = next(self._index_by_offset.irange(reverse=True))
        return self._annotations[annid]

    def __getitem__(self, annid):
        &#34;&#34;&#34;
        Gets the annotation with the given annotation id or throws an exception.

        :param item: the annotation id
        :return: annotation
        &#34;&#34;&#34;
        return self._annotations[annid]

    def with_type(self, *anntype: Union[str, Iterable],
                  non_overlapping: bool = False) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;Gets annotations of the specified type(s).
        Creates the type index if necessary.

        Args:
          anntype: one or more types or type lists. The union of all types specified that way
        is used to filter the annotations. If no type is specified, all annotations are selected.
          non_overlapping: if True, only return annotations of any of the given types which
        do not overlap with other annotations. If there are several annotations that start at
        the same offset, use the type that comes first in the parameters, if there are more
        than one of that type, use the one that would come first in the usual sort order.
          *anntype: Union[str: 
          Iterable]: 
          non_overlapping: bool:  (Default value = False)

        Returns:
          an immutable annotation set with the matching annotations.

        &#34;&#34;&#34;
        atypes = []
        for atype in anntype:
            if isinstance(atype, str):
                atypes.append(atype)
            else:
                for t in atype:
                    atypes.append(t)
        if not atypes:
            return self.detach()
        self._create_index_by_type()
        annids = set()
        for t in atypes:
            idxs = self._index_by_type.get(t)
            if idxs:
                annids.update(idxs)
        if non_overlapping:
            # need to get annotations grouped by start offset and sorted according to
            # what the Annotation class defines
            allanns = sorted(annids, key=lambda x: self._annotations[x])
            allanns = [self._annotations[x] for x in allanns]
            allannsgrouped = []
            curstart = None
            curset = None
            for ann in allanns:
                if curstart is None:
                    curset = [ann]
                    curstart = ann.start
                elif curstart == ann.start:
                    curset.append(ann)
                else:
                    allannsgrouped.append(curset)
                    curset = [ann]
                    curstart = ann.start
            if curset:
                allannsgrouped.append(curset)
            retanns = []
            # now go through all the grouped annoations and select the top priority one
            # then skip to the next group that does not overlap with the one we just selected
            typepriority = dict()
            for i, atype in enumerate(atypes):
                typepriority[atype] = len(atypes)-i
            curminoffset = 0
            for group in allannsgrouped:
                # instead of sorting, go through the group and find the top priority one
                topann = None
                if len(group) == 1:
                    if group[0].start &gt;= curminoffset:
                        topann = group[0]
                elif len(group) == 0:
                    raise Exception(&#34;We should never get a 0 size group here!&#34;)
                else:
                    for i, ann in enumerate(group):
                        if ann.start &gt;= curminoffset:
                            topann = ann
                            break
                    for ann in group[i+1:]:
                        if ann.start &lt; curminoffset:
                            continue
                        if typepriority[ann.type] &gt; typepriority[topann.type]:
                            topann = ann
                        elif typepriority[ann.type] == typepriority[topann.type]:
                            if ann.end &gt; topann.end:
                                topann = ann
                            elif ann.end == topann.end:
                                if ann.id &gt; topann.id:
                                    topann = ann
                if topann is not None:
                    retanns.append(topann)
                    curminoffset = topann.end
            annids = [ann.id for ann in retanns]
        return self.detach(restrict_to=annids)

    def by_offset(self):
        &#34;&#34;&#34;

        Args:

        Returns:
          annotations that start at the same offset, sorted in their natural order.
          
          NOTE: creates the index!
          
          :return: a generator for lists of annotations

        &#34;&#34;&#34;
        self._create_index_by_offset()
        lastoff = -1
        curlist = []
        for ann in self.iter():
            if ann.start != lastoff:
                if lastoff != -1:
                    yield curlist
                lastoff = ann.start
                curlist = [ann]
            else:
                curlist.append(ann)
        if lastoff != -1:
            yield curlist

    def by_span(self):
        &#34;&#34;&#34;

        Args:

        Returns:
          annotations with identical spans.
          
          NOTE: creates the index!
          
          :return: a generator for lists of annotations

        &#34;&#34;&#34;
        self._create_index_by_offset()
        lastsoff = -1
        lasteoff = -1
        curlist = []
        for ann in self.iter():
            if ann.start != lastsoff or ann.end != lasteoff:
                if lastsoff != -1:
                    yield curlist
                lastsoff = ann.start
                lasteoff = ann.end
                curlist = [ann]
            else:
                curlist.append(ann)
        if lastsoff != -1:
            yield curlist

    @property
    def type_names(self) -&gt; KeysView[str]:
        &#34;&#34;&#34;Gets the names of all types in this set. Creates the type index if necessary.
        
        :return: the set of known annotation type names.

        Args:

        Returns:

        &#34;&#34;&#34;
        self._create_index_by_type()
        return self._index_by_type.keys()

    @support_annotation_or_set
    def start_eq(self, start: int, ignored: Any = None, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;Gets all annotations starting at the given offset (empty if none) and returns them in an immutable
        annotation set.

        Args:
          start: the offset where annotations should start
          ignored: dummy parameter to allow the use of annotations and annotation sets
          start: int: 
          ignored: Any:  (Default value = None)
          annid:  (Default value = None)
          include_self:  (Default value = False)

        Returns:
          annotation set of matching annotations

        &#34;&#34;&#34;
        # NOTE: my assumption about how intervaltree works was wrong, so we need to filter what we get from the
        # point query
        self._create_index_by_offset()
        intvs = self._index_by_offset.starting_from(start)
        if not include_self and annid is not None:
            ignore = annid
        else:
            ignore = None
        return self._restrict_intvs(intvs, ignore=ignore)

    @support_annotation_or_set
    def start_min_ge(self, offset: int, ignored: Any = None, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;Gets all annotations starting at the first possible offset
        at or after the given offset and returns them in an immutable
        annotation set.

        Args:
          offset: The offset
          ignored: dummy parameter to allow the use of annotations and annotation sets
          offset: int: 
          ignored: Any:  (Default value = None)
          annid:  (Default value = None)
          include_self:  (Default value = False)

        Returns:
          annotation set of matching annotations

        &#34;&#34;&#34;
        self._create_index_by_offset()
        intvs = self._index_by_offset.starting_from(offset)
        # now select only those first ones which all have the same offset
        if not include_self and annid is not None:
            ignore = annid
        else:
            ignore = None
        retids = set()
        startoff = None
        for intv in intvs:
            if startoff is None:
                startoff = intv[0]
                if ignore is not None:
                    if ignore != intv[2]:
                        retids.add(intv[2])
                else:
                    retids.add(intv[2])
            elif startoff == intv[0]:
                if ignore is not None:
                    if ignore != intv[2]:
                        retids.add(intv[2])
                else:
                    retids.add(intv[2])
            else:
                break
        return self.detach(restrict_to=retids)

    @support_annotation_or_set
    def start_ge(self, start: int, ignored: Any = None, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;Return the annotations that start at or after the given start offset.

        Args:
          start: Start offset
          ignored: dummy parameter to allow the use of annotations and annotation sets
          start: int: 
          ignored: Any:  (Default value = None)
          annid:  (Default value = None)
          include_self:  (Default value = False)

        Returns:
          an immutable annotation set of the matching annotations

        &#34;&#34;&#34;
        self._create_index_by_offset()
        intvs = self._index_by_offset.starting_from(start)
        if not include_self and annid is not None:
            ignore = annid
        else:
            ignore = None
        return self._restrict_intvs(intvs, ignore=ignore)

    @support_annotation_or_set
    def start_lt(self, offset: int, ignored: Any = None, annid=None) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;Return the annotations that start before the given offset (or annotation). This also accepts an annotation
        or set.

        Args:
          offset: offset before which the annotations should start
          ignored: dummy parameter to allow the use of annotations and annotation sets
          offset: int: 
          ignored: Any:  (Default value = None)
          annid:  (Default value = None)

        Returns:
          an immutable annotation set of the matching annotations

        &#34;&#34;&#34;
        self._create_index_by_offset()
        intvs = self._index_by_offset.starting_before(offset)
        return self._restrict_intvs(intvs)


    @support_annotation_or_set
    def overlapping(self, start: int, end: int, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;Gets annotations overlapping with the given span. Instead of the start and end offsets,
        also accepts an annotation or annotation set.
        
        For each annotation ann in the result set, ann.overlapping(span) is True

        Args:
          start: start offset of the span
          end: end offset of the span
          annid: the annotation id of the annotation representing the span. (Default value = None)
          include_self: if True and the annotation id for the span is given, do not include that
        annotation in the result set. (Default value = False)
          start: int: 
          end: int: 

        Returns:
          an immutable annotation set with the matching annotations

        &#34;&#34;&#34;
        self._create_index_by_offset()
        intvs = self._index_by_offset.overlapping(start, end)
        if not include_self and annid is not None:
            ignore = annid
        else:
            ignore = None
        return self._restrict_intvs(intvs, ignore=ignore)

    @support_annotation_or_set
    def covering(self, start: int, end: int, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;Get the annotations which contain the given offset range (or annotation/annotation set),
        i.e. annotations such that the given offset range is within the annotation.
        
        For each annotation ann in the result set, ann.covering(span) is True.

        Args:
          start: the start offset of the span
          end: the end offset of the span
          annid: the annotation id of the annotation representing the span. (Default value = None)
          include_self: if True and the annotation id for the span is given, do not include that
        annotation in the result set. (Default value = False)
          start: int: 
          end: int: 

        Returns:
          an immutable annotation set with the matching annotations, if any

        &#34;&#34;&#34;
        self._create_index_by_offset()
        intvs = self._index_by_offset.covering(start, end)
        if not include_self and annid is not None:
            ignore = annid
        else:
            ignore = None
        return self._restrict_intvs(intvs, ignore=ignore)

    @support_annotation_or_set
    def within(self, start: int, end: int, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;Gets annotations that fall completely within the given offset range, i.e. annotations
        such that the offset range is covering each of the annotation.
        
        For each annotation ann in the result set, ann.within(span) is True.

        Args:
          start: start offset of the range
          end: end offset of the range
          annid: the annotation id of the annotation representing the span. (Default value = None)
          include_self: if True and the annotation id for the span is given, do not include that
        annotation in the result set. (Default value = False)
          start: int: 
          end: int: 

        Returns:
          an immutable annotation set with the matching annotations

        &#34;&#34;&#34;
        if start == end:
            intvs = []
        elif start &gt; end:
            raise Exception(&#34;Invalid offset range: {},{}&#34;.format(start, end))
        else:
            self._create_index_by_offset()
            intvs = self._index_by_offset.within(start, end)
        if not include_self and annid is not None:
            ignore = annid
        else:
            ignore = None
        return self._restrict_intvs(intvs, ignore=ignore)

    @support_annotation_or_set
    def coextensive(self, start: int, end: int, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
        &#34;&#34;&#34;Return an immutable annotation set with all annotations that start and end at the given offsets.
        
        For each annotation ann in the result set, ann.coextensive(span) is True.

        Args:
          start: start offset of the span
          end: end offset of the span
          annid: the annotation id of the annotation representing the span. (Default value = None)
          include_self: if True and the annotation id for the span is given, do not include that
        annotation in the result set. (Default value = False)
          start: int: 
          end: int: 

        Returns:
          annotation set with all annotations that have the same start and end offsets.

        &#34;&#34;&#34;
        self._create_index_by_offset()
        intvs = self._index_by_offset.at(start, end)
        if not include_self and annid is not None:
            ignore = annid
        else:
            ignore = None
        return self._restrict_intvs(intvs, ignore=ignore)

    @property
    def span(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Returns a tuple with the start and end offset the corresponds to the smallest start offset of any annotation
        and the largest end offset of any annotation.
        (Builds the offset index)
        
        :return: tuple of minimum start offset and maximum end offset

        Args:

        Returns:

        &#34;&#34;&#34;
        self._create_index_by_offset()
        return self._index_by_offset.min_start(), self._index_by_offset.max_end()

    def __contains__(self, annorannid: Union[int, Annotation]) -&gt; bool:
        &#34;&#34;&#34;
        Provides &#39;annotation in annotation_set&#39; functionality

        :param annorannid: the annotation instance or annotation id to check
        :return: true if the annotation exists in the set, false otherwise
        &#34;&#34;&#34;
        if isinstance(annorannid, Annotation):
            return annorannid.id in self._annotations
        return annorannid in self._annotations  # On the off chance someone passed an ID in directly

    contains = __contains__

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        String representation of the set.

        :return: string representation.
        &#34;&#34;&#34;
        return &#34;AnnotationSet({})&#34;.format(repr(list(self.iter())))

    def to_dict(self, **kwargs):
        &#34;&#34;&#34;

        Args:
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        return {
            # NOTE: Changelog is not getting added as it is stored in the document part!
            &#34;name&#34;: self.name,
            &#34;annotations&#34;: list(val.to_dict(**kwargs)
                                for val in self._annotations.values()),
            &#34;next_annid&#34;: self._next_annid,
        }

    @staticmethod
    def from_dict(dictrepr, owner_doc=None, **kwargs):
        &#34;&#34;&#34;

        Args:
          dictrepr: 
          owner_doc:  (Default value = None)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        annset = AnnotationSet(dictrepr.get(&#34;name&#34;), owner_doc=owner_doc)
        annset._next_annid = dictrepr.get(&#34;next_annid&#34;)
        if dictrepr.get(&#34;annotations&#34;):
            annset._annotations = dict(
                (int(a[&#34;id&#34;]), Annotation.from_dict(a, owner_set=annset, **kwargs))
                for a in dictrepr.get(&#34;annotations&#34;))
        else:
            annset._annotations = {}
        return annset</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.AnnotationSet.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>dictrepr, owner_doc=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>dictrepr</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>owner_doc</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(dictrepr, owner_doc=None, **kwargs):
    &#34;&#34;&#34;

    Args:
      dictrepr: 
      owner_doc:  (Default value = None)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    annset = AnnotationSet(dictrepr.get(&#34;name&#34;), owner_doc=owner_doc)
    annset._next_annid = dictrepr.get(&#34;next_annid&#34;)
    if dictrepr.get(&#34;annotations&#34;):
        annset._annotations = dict(
            (int(a[&#34;id&#34;]), Annotation.from_dict(a, owner_set=annset, **kwargs))
            for a in dictrepr.get(&#34;annotations&#34;))
    else:
        annset._annotations = {}
    return annset</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="gatenlp.AnnotationSet.changelog"><code class="name">var <span class="ident">changelog</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def changelog(self):
    &#34;&#34;&#34; &#34;&#34;&#34;
    if self._owner_doc is None:
        return None
    return self._owner_doc.changelog</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.document"><code class="name">var <span class="ident">document</span> : Union[<a title="gatenlp.Document" href="#gatenlp.Document">Document</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Get the owning document, if known. If the owning document was not set, return None.</p>
<p>:return: the document this annotation set belongs to or None if unknown.</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def document(self) -&gt; Union[&#34;Document&#34;, None]:
    &#34;&#34;&#34;Get the owning document, if known. If the owning document was not set, return None.
    
    :return: the document this annotation set belongs to or None if unknown.

    Args:

    Returns:

    &#34;&#34;&#34;
    return self._owner_doc</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<div class="desc"><p>Returns the end offset of the annotation set, i.e. the biggest end offset of any annotation.
This needs the index and creates it if necessary.</p>
<p>:return: largest end offset</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end(self):
    &#34;&#34;&#34;Returns the end offset of the annotation set, i.e. the biggest end offset of any annotation.
    This needs the index and creates it if necessary.
    
    :return: largest end offset

    Args:

    Returns:

    &#34;&#34;&#34;
    if self.size == 0:
        raise Exception(&#34;Annotation set is empty, cannot determine end offset&#34;)
    self._create_index_by_offset()
    return self._index_by_offset.max_end()</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.immutable"><code class="name">var <span class="ident">immutable</span> : bool</code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>:return: True if immutable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def immutable(self) -&gt; bool:
    &#34;&#34;&#34;

    Args:

    Returns:
      :return: True if immutable

    &#34;&#34;&#34;
    return self._is_immutable</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>This needs the index and creates it if necessary.</p>
<p>:return: length of the annotation set span</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self):
    &#34;&#34;&#34;

    Args:

    Returns:
      This needs the index and creates it if necessary.
      
      :return: length of the annotation set span

    &#34;&#34;&#34;
    return self.end() - self.start()</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Get the name of the annotation set. NOTE: the name of a set cannot be changed.</p>
<p>:return: name of annotation set</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;Get the name of the annotation set. NOTE: the name of a set cannot be changed.
    
    :return: name of annotation set

    Args:

    Returns:

    &#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>:return: number of annotations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;

    Args:

    Returns:
      :return: number of annotations

    &#34;&#34;&#34;
    return len(self._annotations)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.span"><code class="name">var <span class="ident">span</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Returns a tuple with the start and end offset the corresponds to the smallest start offset of any annotation
and the largest end offset of any annotation.
(Builds the offset index)</p>
<p>:return: tuple of minimum start offset and maximum end offset</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def span(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Returns a tuple with the start and end offset the corresponds to the smallest start offset of any annotation
    and the largest end offset of any annotation.
    (Builds the offset index)
    
    :return: tuple of minimum start offset and maximum end offset

    Args:

    Returns:

    &#34;&#34;&#34;
    self._create_index_by_offset()
    return self._index_by_offset.min_start(), self._index_by_offset.max_end()</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.start"><code class="name">var <span class="ident">start</span></code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>This needs the index and creates it if necessary.</p>
<p>Throws an exception if there are no annotations in the set.</p>
<p>:return: smallest annotation offset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start(self):
    &#34;&#34;&#34;

    Args:

    Returns:
      This needs the index and creates it if necessary.
      
      Throws an exception if there are no annotations in the set.
      
      :return: smallest annotation offset

    &#34;&#34;&#34;
    if self.size == 0:
        raise Exception(&#34;Annotation set is empty, cannot determine start offset&#34;)
    self._create_index_by_offset()
    return self._index_by_offset.min_start()</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.type_names"><code class="name">var <span class="ident">type_names</span> : KeysView[str]</code></dt>
<dd>
<div class="desc"><p>Gets the names of all types in this set. Creates the type index if necessary.</p>
<p>:return: the set of known annotation type names.</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type_names(self) -&gt; KeysView[str]:
    &#34;&#34;&#34;Gets the names of all types in this set. Creates the type index if necessary.
    
    :return: the set of known annotation type names.

    Args:

    Returns:

    &#34;&#34;&#34;
    self._create_index_by_type()
    return self._index_by_type.keys()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.AnnotationSet.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, start: int, end: int, anntype: str, features: Dict[str, Any] = None, annid: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an annotation to the set. Once an annotation has been added, the start and end offsets,
the type, and the annotation id are immutable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset</dd>
<dt><strong><code>anntype</code></strong></dt>
<dd>the annotation type</dd>
<dt><strong><code>features</code></strong></dt>
<dd>a map, an iterable of tuples or an existing feature map. In any case, the features are used</dd>
</dl>
<p>to create a new feature map for this annotation. If the map is empty or this parameter is None, the
annotation does not store any map at all.
annid: the annotation id, if not specified the next free one for this set is used. NOTE: the id should
normally left unspecified and get assigned automatically.
start: int:
end: int:
anntype: str:
features: Dict[str:
Any]:
(Default value = None)
annid: int:
(Default value = None)</p>
<h2 id="returns">Returns</h2>
<p>the new annotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, start: int, end: int, anntype: str, features: Dict[str, Any] = None, annid: int = None):
    &#34;&#34;&#34;Add an annotation to the set. Once an annotation has been added, the start and end offsets,
    the type, and the annotation id are immutable.

    Args:
      start: start offset
      end: end offset
      anntype: the annotation type
      features: a map, an iterable of tuples or an existing feature map. In any case, the features are used
    to create a new feature map for this annotation. If the map is empty or this parameter is None, the
    annotation does not store any map at all.
      annid: the annotation id, if not specified the next free one for this set is used. NOTE: the id should
    normally left unspecified and get assigned automatically.
      start: int: 
      end: int: 
      anntype: str: 
      features: Dict[str: 
      Any]:  (Default value = None)
      annid: int:  (Default value = None)

    Returns:
      the new annotation

    &#34;&#34;&#34;
    if annid is not None and not isinstance(annid, int):
        raise Exception(&#34;Parameter annid must be an int, mixed up with features?&#34;)
    if features is not None and isinstance(features, int):
        raise Exception(&#34;Parameter features must not be an int: mixed up with annid?&#34;)
    if self._is_immutable:
        raise Exception(&#34;Cannot add an annotation to an immutable annotation set&#34;)
    self._check_offsets(start, end)
    if annid and annid in self._annotations:
        raise Exception(&#34;Cannot add annotation with id {}, already in set&#34;.format(annid))
    if annid is None:
        annid = self._next_annid
        self._next_annid = self._next_annid + 1
    ann = Annotation(start, end, anntype, features=features, annid=annid)
    ann._owner_set = self
    if not self._annotations:
        self._annotations = {}
    self._annotations[annid] = ann
    self._add_to_indices(ann)
    if self.changelog is not None:
        entry = {
                &#34;command&#34;: &#34;annotation:add&#34;,
                &#34;set&#34;: self.name,
                &#34;start&#34;: ann.start,
                &#34;end&#34;: ann.end,
                &#34;type&#34;: ann.type,
                &#34;features&#34;: ann._features.to_dict(),
                &#34;id&#34;: ann.id
            }
        self.changelog.append(entry)
    return ann</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.add_ann"><code class="name flex">
<span>def <span class="ident">add_ann</span></span>(<span>self, ann, annid: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a copy of the given ann to the annotation set, either with a new annotation id or
with the one given.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annid</code></strong></dt>
<dd>the annotation id, if not specified the next free one for this set is used.</dd>
</dl>
<p>NOTE: the id should normally left unspecified and get assigned automatically.
ann:
annid: int:
(Default value = None)</p>
<h2 id="returns">Returns</h2>
<p>the annotation id of the added annotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ann(self, ann, annid: int = None):
    &#34;&#34;&#34;Add a copy of the given ann to the annotation set, either with a new annotation id or
    with the one given.

    Args:
      annid: the annotation id, if not specified the next free one for this set is used.
    NOTE: the id should normally left unspecified and get assigned automatically.
      ann: 
      annid: int:  (Default value = None)

    Returns:
      the annotation id of the added annotation

    &#34;&#34;&#34;
    return self.add(ann.start, ann.end, ann.type, ann.features, annid=annid)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.by_offset"><code class="name flex">
<span>def <span class="ident">by_offset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>annotations that start at the same offset, sorted in their natural order.</p>
<dl>
<dt><code>NOTE</code></dt>
<dd>creates the index!</dd>
</dl>
<p>:return: a generator for lists of annotations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def by_offset(self):
    &#34;&#34;&#34;

    Args:

    Returns:
      annotations that start at the same offset, sorted in their natural order.
      
      NOTE: creates the index!
      
      :return: a generator for lists of annotations

    &#34;&#34;&#34;
    self._create_index_by_offset()
    lastoff = -1
    curlist = []
    for ann in self.iter():
        if ann.start != lastoff:
            if lastoff != -1:
                yield curlist
            lastoff = ann.start
            curlist = [ann]
        else:
            curlist.append(ann)
    if lastoff != -1:
        yield curlist</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.by_span"><code class="name flex">
<span>def <span class="ident">by_span</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>annotations with identical spans.</p>
<dl>
<dt><code>NOTE</code></dt>
<dd>creates the index!</dd>
</dl>
<p>:return: a generator for lists of annotations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def by_span(self):
    &#34;&#34;&#34;

    Args:

    Returns:
      annotations with identical spans.
      
      NOTE: creates the index!
      
      :return: a generator for lists of annotations

    &#34;&#34;&#34;
    self._create_index_by_offset()
    lastsoff = -1
    lasteoff = -1
    curlist = []
    for ann in self.iter():
        if ann.start != lastsoff or ann.end != lasteoff:
            if lastsoff != -1:
                yield curlist
            lastsoff = ann.start
            lasteoff = ann.end
            curlist = [ann]
        else:
            curlist.append(ann)
    if lastsoff != -1:
        yield curlist</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all annotations from the set.</p>
<p>:return:</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Remove all annotations from the set.
    
    :return:

    Args:

    Returns:

    &#34;&#34;&#34;
    self._annotations.clear()
    self._index_by_offset = None
    self._index_by_type = None
    if self.changelog is not None:
        self.changelog.append({
            &#34;command&#34;: &#34;annotations:clear&#34;,
            &#34;set&#34;: self.name})</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.clone_anns"><code class="name flex">
<span>def <span class="ident">clone_anns</span></span>(<span>self, memo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace the annotations in this set with copies of the originals. If this is a detached set,
then this makes sure that any modifications to the annotations do not affect the original annotations
in the attached set. If this is an attached set, it makes sure that all other detached sets cannot affect
the annotations in this set any more. The owning set of the annotations that get cloned is cleared.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>memo</code></strong></dt>
<dd>for internal use by our <strong>deepcopy</strong> implementation. (Default value = None)</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone_anns(self, memo=None):
    &#34;&#34;&#34;Replace the annotations in this set with copies of the originals. If this is a detached set,
    then this makes sure that any modifications to the annotations do not affect the original annotations
    in the attached set. If this is an attached set, it makes sure that all other detached sets cannot affect
    the annotations in this set any more. The owning set of the annotations that get cloned is cleared.

    Args:
      memo: for internal use by our __deepcopy__ implementation. (Default value = None)

    Returns:

    &#34;&#34;&#34;
    tmpdict = {}
    for annid, ann in self._annotations.items():
        newann = copy.deepcopy(ann, memo=memo)
        ann._owner_set = None
        tmpdict[annid] = newann
    for annid, ann in tmpdict.items():
        self._annotations[annid] = ann</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.coextensive"><code class="name flex">
<span>def <span class="ident">coextensive</span></span>(<span>self, start: int, end: int, annid=None, include_self=False) ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return an immutable annotation set with all annotations that start and end at the given offsets.</p>
<p>For each annotation ann in the result set, ann.coextensive(span) is True.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>annid</code></strong></dt>
<dd>the annotation id of the annotation representing the span. (Default value = None)</dd>
<dt><strong><code>include_self</code></strong></dt>
<dd>if True and the annotation id for the span is given, do not include that</dd>
</dl>
<p>annotation in the result set. (Default value = False)
start: int:
end: int: </p>
<h2 id="returns">Returns</h2>
<p>annotation set with all annotations that have the same start and end offsets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def coextensive(self, start: int, end: int, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
    &#34;&#34;&#34;Return an immutable annotation set with all annotations that start and end at the given offsets.
    
    For each annotation ann in the result set, ann.coextensive(span) is True.

    Args:
      start: start offset of the span
      end: end offset of the span
      annid: the annotation id of the annotation representing the span. (Default value = None)
      include_self: if True and the annotation id for the span is given, do not include that
    annotation in the result set. (Default value = False)
      start: int: 
      end: int: 

    Returns:
      annotation set with all annotations that have the same start and end offsets.

    &#34;&#34;&#34;
    self._create_index_by_offset()
    intvs = self._index_by_offset.at(start, end)
    if not include_self and annid is not None:
        ignore = annid
    else:
        ignore = None
    return self._restrict_intvs(intvs, ignore=ignore)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, annorannid: Union[int, <a title="gatenlp.annotation.Annotation" href="annotation.html#gatenlp.annotation.Annotation">Annotation</a>]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Provides 'annotation in annotation_set' functionality</p>
<p>:param annorannid: the annotation instance or annotation id to check
:return: true if the annotation exists in the set, false otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __contains__(self, annorannid: Union[int, Annotation]) -&gt; bool:
    &#34;&#34;&#34;
    Provides &#39;annotation in annotation_set&#39; functionality

    :param annorannid: the annotation instance or annotation id to check
    :return: true if the annotation exists in the set, false otherwise
    &#34;&#34;&#34;
    if isinstance(annorannid, Annotation):
        return annorannid.id in self._annotations
    return annorannid in self._annotations  # On the off chance someone passed an ID in directly</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34; &#34;&#34;&#34;
    return self.__copy__()</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.covering"><code class="name flex">
<span>def <span class="ident">covering</span></span>(<span>self, start: int, end: int, annid=None, include_self=False) ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the annotations which contain the given offset range (or annotation/annotation set),
i.e. annotations such that the given offset range is within the annotation.</p>
<p>For each annotation ann in the result set, ann.covering(span) is True.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>the start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>the end offset of the span</dd>
<dt><strong><code>annid</code></strong></dt>
<dd>the annotation id of the annotation representing the span. (Default value = None)</dd>
<dt><strong><code>include_self</code></strong></dt>
<dd>if True and the annotation id for the span is given, do not include that</dd>
</dl>
<p>annotation in the result set. (Default value = False)
start: int:
end: int: </p>
<h2 id="returns">Returns</h2>
<p>an immutable annotation set with the matching annotations, if any</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def covering(self, start: int, end: int, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
    &#34;&#34;&#34;Get the annotations which contain the given offset range (or annotation/annotation set),
    i.e. annotations such that the given offset range is within the annotation.
    
    For each annotation ann in the result set, ann.covering(span) is True.

    Args:
      start: the start offset of the span
      end: the end offset of the span
      annid: the annotation id of the annotation representing the span. (Default value = None)
      include_self: if True and the annotation id for the span is given, do not include that
    annotation in the result set. (Default value = False)
      start: int: 
      end: int: 

    Returns:
      an immutable annotation set with the matching annotations, if any

    &#34;&#34;&#34;
    self._create_index_by_offset()
    intvs = self._index_by_offset.covering(start, end)
    if not include_self and annid is not None:
        ignore = annid
    else:
        ignore = None
    return self._restrict_intvs(intvs, ignore=ignore)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.deepcopy"><code class="name flex">
<span>def <span class="ident">deepcopy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deepcopy(self):
    &#34;&#34;&#34; &#34;&#34;&#34;
    return copy.deepcopy(self)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.detach"><code class="name flex">
<span>def <span class="ident">detach</span></span>(<span>self, restrict_to=None) ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an immutable copy of this set, optionally restricted to the given annotation ids.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>restrict_to</code></strong></dt>
<dd>an iterable of annotation ids, if None, all the annotations from this set. (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>an immutable annotation set with all the annotations of this set or restricted to the ids
in restrict_to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detach(self, restrict_to=None) -&gt; &#34;AnnotationSet&#34;:
    &#34;&#34;&#34;Create an immutable copy of this set, optionally restricted to the given annotation ids.

    Args:
      restrict_to: an iterable of annotation ids, if None, all the annotations from this set. (Default value = None)

    Returns:
      an immutable annotation set with all the annotations of this set or restricted to the ids
      in restrict_to

    &#34;&#34;&#34;
    annset = AnnotationSet(name=&#34;detached-from:&#34;+self.name)
    annset._is_immutable = True
    if restrict_to is None:
        annset._annotations = {annid: self._annotations[annid] for annid in self._annotations.keys()}
    else:
        annset._annotations = {annid: self._annotations[annid] for annid in restrict_to}
    annset._next_annid = self._next_annid
    return annset</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.detach_from"><code class="name flex">
<span>def <span class="ident">detach_from</span></span>(<span>self, anns: collections.abc.Iterable) ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an immutable detached annotation set from the annotations in anns which could by
either a collection of annotations or annotation ids (int numbers) which are assumed to
be the annotation ids from this set.</p>
<p>The next annotation id for the created set is the highest seen annotation id from anns plus one.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>anns</code></strong></dt>
<dd>an iterable of annotations</dd>
<dt><strong><code>anns</code></strong></dt>
<dd>Iterable: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>an immutable annotation set with all the annotations of this set or restricted to the ids
in restrict_to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detach_from(self, anns: Iterable) -&gt; &#34;AnnotationSet&#34;:
    &#34;&#34;&#34;Create an immutable detached annotation set from the annotations in anns which could by
    either a collection of annotations or annotation ids (int numbers) which are assumed to
    be the annotation ids from this set.
    
    The next annotation id for the created set is the highest seen annotation id from anns plus one.

    Args:
      anns: an iterable of annotations
      anns: Iterable: 

    Returns:
      an immutable annotation set with all the annotations of this set or restricted to the ids
      in restrict_to

    &#34;&#34;&#34;
    annset = AnnotationSet(name=&#34;detached-from:&#34;+self.name)
    annset._is_immutable = True
    annset._annotations = {}
    nextid = -1
    for ann in anns:
        if isinstance(ann, int):
            annset._annotations[ann] = self._annotations[ann]
            annid = ann
        else:
            annset._annotations[id] = ann
            annid = ann.id
        if annid &gt; nextid:
            nextid = annid
    annset._next_annid = nextid + 1
    return annset</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.fast_iter"><code class="name flex">
<span>def <span class="ident">fast_iter</span></span>(<span>self) ‑> Generator</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a generator for fast iteration over all annotations in arbitrary order.</p>
<p>:return:</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fast_iter(self) -&gt; Generator:
    &#34;&#34;&#34;Returns a generator for fast iteration over all annotations in arbitrary order.
    
    :return:

    Args:

    Returns:

    &#34;&#34;&#34;
    if self._annotations:
        for annid, ann in self._annotations.items():
            yield ann</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.first"><code class="name flex">
<span>def <span class="ident">first</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>:return: first annotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first(self):
    &#34;&#34;&#34;

    Args:

    Returns:
      :return: first annotation

    &#34;&#34;&#34;
    sz = len(self._annotations)
    if sz == 0:
        raise Exception(&#34;Empty set, there is no first annotation&#34;)
    elif sz == 1:
        return next(iter(self._annotations.values()))
    self._create_index_by_offset()
    _, _, annid = next(self._index_by_offset.irange(reverse=False))
    return self._annotations[annid]</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, annid: Union[int, <a title="gatenlp.annotation.Annotation" href="annotation.html#gatenlp.annotation.Annotation">Annotation</a>], default=None) ‑> Union[<a title="gatenlp.annotation.Annotation" href="annotation.html#gatenlp.annotation.Annotation">Annotation</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the annotation with the given annotation id or returns the given default.</p>
<p>NOTE: for handling cases where legacy code still expects the add method to return
an id and not the annotation, this will accept an annotation so the the frequent
pattern still works:</p>
<p>annid = annset.add(b,e,t).id
ann = annset.get(annid)</p>
<p>If an annotation is passed the annotation from the set with the id of that annotation is
returned, if the annotation is from that set, this will return the same object, if it is
still in the set (or return the default value).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annid</code></strong></dt>
<dd>the annotation id of the annotation to retrieve.</dd>
<dt><strong><code>default</code></strong></dt>
<dd>what to return if an annotation with the given id is not found. (Default value = None)</dd>
<dt><strong><code>annid</code></strong></dt>
<dd>Union[int: </dd>
</dl>
<p>Annotation]: </p>
<h2 id="returns">Returns</h2>
<p>the annotation or the default value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, annid: Union[int, Annotation], default=None) -&gt; Union[Annotation, None]:
    &#34;&#34;&#34;Gets the annotation with the given annotation id or returns the given default.
    
    NOTE: for handling cases where legacy code still expects the add method to return
    an id and not the annotation, this will accept an annotation so the the frequent
    pattern still works:
    
       annid = annset.add(b,e,t).id
       ann = annset.get(annid)
    
    If an annotation is passed the annotation from the set with the id of that annotation is
    returned, if the annotation is from that set, this will return the same object, if it is
    still in the set (or return the default value).

    Args:
      annid: the annotation id of the annotation to retrieve.
      default: what to return if an annotation with the given id is not found. (Default value = None)
      annid: Union[int: 
      Annotation]: 

    Returns:
      the annotation or the default value.

    &#34;&#34;&#34;
    if isinstance(annid, Annotation):
        annid = annid.id
    return self._annotations.get(annid, default)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.isdetached"><code class="name flex">
<span>def <span class="ident">isdetached</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdetached(self) -&gt; bool:
    &#34;&#34;&#34; &#34;&#34;&#34;
    return self._owner_doc is None</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.iter"><code class="name flex">
<span>def <span class="ident">iter</span></span>(<span>self, start_ge: Union[int, NoneType] = None, start_lt: Union[NoneType, int] = None, with_type: str = None, reverse: bool = False) ‑> Generator</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a generator for going through annotations in document order, otionally limited
by the other parameters. If two annoations start at the same offset, they are always
ordered by increasing annotation id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annotations</code></strong></dt>
<dd>an iterable of annotations from this annotation set.</dd>
<dt><strong><code>start_ge</code></strong></dt>
<dd>the offset from where to start including annotations</dd>
<dt><strong><code>start_lt</code></strong></dt>
<dd>the last offset to use as the starting offset of an annotation</dd>
<dt><strong><code>with_type</code></strong></dt>
<dd>only annotations of this type</dd>
<dt><strong><code>reverse</code></strong></dt>
<dd>process in reverse document order</dd>
<dt><strong><code>start_ge</code></strong></dt>
<dd>Union[int: </dd>
<dt>None]:
(Default value = None)</dt>
<dt><strong><code>start_lt</code></strong></dt>
<dd>Union[None: </dd>
<dt>int]:
(Default value = None)</dt>
<dt><strong><code>with_type</code></strong></dt>
<dd>str:
(Default value = None)</dd>
<dt><strong><code>reverse</code></strong></dt>
<dd>bool:
(Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>generator for annotations in document order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter(self,
         start_ge: Union[int, None] = None,
         start_lt: Union[None, int] = None,
         with_type: str = None,
         reverse: bool = False) -&gt; Generator:
    &#34;&#34;&#34;Returns a generator for going through annotations in document order, otionally limited
    by the other parameters. If two annoations start at the same offset, they are always
    ordered by increasing annotation id.

    Args:
      annotations: an iterable of annotations from this annotation set.
      start_ge: the offset from where to start including annotations
      start_lt: the last offset to use as the starting offset of an annotation
      with_type: only annotations of this type
      reverse: process in reverse document order
      start_ge: Union[int: 
      None]:  (Default value = None)
      start_lt: Union[None: 
      int]:  (Default value = None)
      with_type: str:  (Default value = None)
      reverse: bool:  (Default value = False)

    Returns:
      generator for annotations in document order

    &#34;&#34;&#34;

    if with_type is not None:
        allowedtypes = set()
        if isinstance(type, str):
            allowedtypes.add(with_type)
        else:
            for atype in with_type:
                allowedtypes.add(atype)
    else:
        allowedtypes = None
    if not self._annotations:
        return
    maxoff = None
    if start_ge is not None:
        assert start_ge &gt;= 0
    if start_lt is not None:
        assert start_lt &gt;= 1
        maxoff = start_lt + 1
    if start_lt is not None and start_ge is not None:
        assert start_lt &gt; start_ge
    self._create_index_by_offset()
    for _start, _end, annid in self._index_by_offset.irange(minoff=start_ge, maxoff=maxoff, reverse=reverse):
        if allowedtypes is not None and self._annotations[annid].type not in allowedtypes:
            continue
        yield self._annotations[annid]</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>:return: first annotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last(self):
    &#34;&#34;&#34;

    Args:

    Returns:
      :return: first annotation

    &#34;&#34;&#34;
    sz = len(self._annotations)
    if sz == 0:
        raise Exception(&#34;Empty set, there is no last annotation&#34;)
    elif sz == 1:
        return next(iter(self._annotations.values()))
    self._create_index_by_offset()
    _, _, annid = next(self._index_by_offset.irange(reverse=True))
    return self._annotations[annid]</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.overlapping"><code class="name flex">
<span>def <span class="ident">overlapping</span></span>(<span>self, start: int, end: int, annid=None, include_self=False) ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets annotations overlapping with the given span. Instead of the start and end offsets,
also accepts an annotation or annotation set.</p>
<p>For each annotation ann in the result set, ann.overlapping(span) is True</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the span</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the span</dd>
<dt><strong><code>annid</code></strong></dt>
<dd>the annotation id of the annotation representing the span. (Default value = None)</dd>
<dt><strong><code>include_self</code></strong></dt>
<dd>if True and the annotation id for the span is given, do not include that</dd>
</dl>
<p>annotation in the result set. (Default value = False)
start: int:
end: int: </p>
<h2 id="returns">Returns</h2>
<p>an immutable annotation set with the matching annotations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def overlapping(self, start: int, end: int, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
    &#34;&#34;&#34;Gets annotations overlapping with the given span. Instead of the start and end offsets,
    also accepts an annotation or annotation set.
    
    For each annotation ann in the result set, ann.overlapping(span) is True

    Args:
      start: start offset of the span
      end: end offset of the span
      annid: the annotation id of the annotation representing the span. (Default value = None)
      include_self: if True and the annotation id for the span is given, do not include that
    annotation in the result set. (Default value = False)
      start: int: 
      end: int: 

    Returns:
      an immutable annotation set with the matching annotations

    &#34;&#34;&#34;
    self._create_index_by_offset()
    intvs = self._index_by_offset.overlapping(start, end)
    if not include_self and annid is not None:
        ignore = annid
    else:
        ignore = None
    return self._restrict_intvs(intvs, ignore=ignore)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, annotation: Union[int, <a title="gatenlp.annotation.Annotation" href="annotation.html#gatenlp.annotation.Annotation">Annotation</a>]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the given annotation which is either the id or the annotation instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annotation</code></strong></dt>
<dd>either the id (int) or the annotation instance (Annotation)</dd>
<dt><strong><code>annotation</code></strong></dt>
<dd>Union[int: </dd>
</dl>
<p>Annotation]:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, annotation: Union[int, Annotation]) -&gt; None:
    &#34;&#34;&#34;Remove the given annotation which is either the id or the annotation instance.

    Args:
      annotation: either the id (int) or the annotation instance (Annotation)
      annotation: Union[int: 
      Annotation]: 

    Returns:

    &#34;&#34;&#34;
    annid = None  # make pycharm happy
    if self._is_immutable:
        raise Exception(&#34;Cannot remove an annotation from an immutable annotation set&#34;)
    if isinstance(annotation, int):
        annid = annotation
        if annid not in self._annotations:
            raise Exception(&#34;Annotation with id {} not in annotation set, cannot remove&#34;.format(annid))
        annotation = self._annotations[annid]
    elif isinstance(annotation, Annotation):
        annid = annotation.id
        if annid not in self._annotations:
            raise Exception(&#34;Annotation with id {} does not belong to this set, cannot remove&#34;.format(annid))
    # NOTE: once the annotation has been removed from the set, it could still be referenced
    # somewhere else and its features could get modified. In order to prevent logging of such changes,
    # the owning set gets cleared for the annotation
    annotation._owner_set = None
    del self._annotations[annid]
    if self.changelog is not None:
        self.changelog.append({
            &#34;command&#34;: &#34;annotation:remove&#34;,
            &#34;set&#34;: self.name,
            &#34;id&#34;: annid})
    self._remove_from_indices(annotation)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.reverse_iter"><code class="name flex">
<span>def <span class="ident">reverse_iter</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Same as iter, but with the reverse parameter set to true.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Same as for iter(), with revers=True fixed.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>same result as iter()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse_iter(self, **kwargs):
    &#34;&#34;&#34;Same as iter, but with the reverse parameter set to true.

    Args:
      kwargs: Same as for iter(), with revers=True fixed.
      **kwargs: 

    Returns:
      same result as iter()

    &#34;&#34;&#34;
    return self.iter(reverse=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.start_eq"><code class="name flex">
<span>def <span class="ident">start_eq</span></span>(<span>self, start: int, ignored: Any = None, annid=None, include_self=False) ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets all annotations starting at the given offset (empty if none) and returns them in an immutable
annotation set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>the offset where annotations should start</dd>
<dt><strong><code>ignored</code></strong></dt>
<dd>dummy parameter to allow the use of annotations and annotation sets</dd>
<dt><strong><code>start</code></strong></dt>
<dd>int: </dd>
<dt><strong><code>ignored</code></strong></dt>
<dd>Any:
(Default value = None)</dd>
<dt><strong><code>annid</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>include_self</code></strong></dt>
<dd>(Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>annotation set of matching annotations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def start_eq(self, start: int, ignored: Any = None, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
    &#34;&#34;&#34;Gets all annotations starting at the given offset (empty if none) and returns them in an immutable
    annotation set.

    Args:
      start: the offset where annotations should start
      ignored: dummy parameter to allow the use of annotations and annotation sets
      start: int: 
      ignored: Any:  (Default value = None)
      annid:  (Default value = None)
      include_self:  (Default value = False)

    Returns:
      annotation set of matching annotations

    &#34;&#34;&#34;
    # NOTE: my assumption about how intervaltree works was wrong, so we need to filter what we get from the
    # point query
    self._create_index_by_offset()
    intvs = self._index_by_offset.starting_from(start)
    if not include_self and annid is not None:
        ignore = annid
    else:
        ignore = None
    return self._restrict_intvs(intvs, ignore=ignore)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.start_ge"><code class="name flex">
<span>def <span class="ident">start_ge</span></span>(<span>self, start: int, ignored: Any = None, annid=None, include_self=False) ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the annotations that start at or after the given start offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>Start offset</dd>
<dt><strong><code>ignored</code></strong></dt>
<dd>dummy parameter to allow the use of annotations and annotation sets</dd>
<dt><strong><code>start</code></strong></dt>
<dd>int: </dd>
<dt><strong><code>ignored</code></strong></dt>
<dd>Any:
(Default value = None)</dd>
<dt><strong><code>annid</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>include_self</code></strong></dt>
<dd>(Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>an immutable annotation set of the matching annotations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def start_ge(self, start: int, ignored: Any = None, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
    &#34;&#34;&#34;Return the annotations that start at or after the given start offset.

    Args:
      start: Start offset
      ignored: dummy parameter to allow the use of annotations and annotation sets
      start: int: 
      ignored: Any:  (Default value = None)
      annid:  (Default value = None)
      include_self:  (Default value = False)

    Returns:
      an immutable annotation set of the matching annotations

    &#34;&#34;&#34;
    self._create_index_by_offset()
    intvs = self._index_by_offset.starting_from(start)
    if not include_self and annid is not None:
        ignore = annid
    else:
        ignore = None
    return self._restrict_intvs(intvs, ignore=ignore)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.start_lt"><code class="name flex">
<span>def <span class="ident">start_lt</span></span>(<span>self, offset: int, ignored: Any = None, annid=None) ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the annotations that start before the given offset (or annotation). This also accepts an annotation
or set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offset</code></strong></dt>
<dd>offset before which the annotations should start</dd>
<dt><strong><code>ignored</code></strong></dt>
<dd>dummy parameter to allow the use of annotations and annotation sets</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>int: </dd>
<dt><strong><code>ignored</code></strong></dt>
<dd>Any:
(Default value = None)</dd>
<dt><strong><code>annid</code></strong></dt>
<dd>(Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>an immutable annotation set of the matching annotations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def start_lt(self, offset: int, ignored: Any = None, annid=None) -&gt; &#34;AnnotationSet&#34;:
    &#34;&#34;&#34;Return the annotations that start before the given offset (or annotation). This also accepts an annotation
    or set.

    Args:
      offset: offset before which the annotations should start
      ignored: dummy parameter to allow the use of annotations and annotation sets
      offset: int: 
      ignored: Any:  (Default value = None)
      annid:  (Default value = None)

    Returns:
      an immutable annotation set of the matching annotations

    &#34;&#34;&#34;
    self._create_index_by_offset()
    intvs = self._index_by_offset.starting_before(offset)
    return self._restrict_intvs(intvs)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.start_min_ge"><code class="name flex">
<span>def <span class="ident">start_min_ge</span></span>(<span>self, offset: int, ignored: Any = None, annid=None, include_self=False) ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets all annotations starting at the first possible offset
at or after the given offset and returns them in an immutable
annotation set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offset</code></strong></dt>
<dd>The offset</dd>
<dt><strong><code>ignored</code></strong></dt>
<dd>dummy parameter to allow the use of annotations and annotation sets</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>int: </dd>
<dt><strong><code>ignored</code></strong></dt>
<dd>Any:
(Default value = None)</dd>
<dt><strong><code>annid</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>include_self</code></strong></dt>
<dd>(Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>annotation set of matching annotations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def start_min_ge(self, offset: int, ignored: Any = None, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
    &#34;&#34;&#34;Gets all annotations starting at the first possible offset
    at or after the given offset and returns them in an immutable
    annotation set.

    Args:
      offset: The offset
      ignored: dummy parameter to allow the use of annotations and annotation sets
      offset: int: 
      ignored: Any:  (Default value = None)
      annid:  (Default value = None)
      include_self:  (Default value = False)

    Returns:
      annotation set of matching annotations

    &#34;&#34;&#34;
    self._create_index_by_offset()
    intvs = self._index_by_offset.starting_from(offset)
    # now select only those first ones which all have the same offset
    if not include_self and annid is not None:
        ignore = annid
    else:
        ignore = None
    retids = set()
    startoff = None
    for intv in intvs:
        if startoff is None:
            startoff = intv[0]
            if ignore is not None:
                if ignore != intv[2]:
                    retids.add(intv[2])
            else:
                retids.add(intv[2])
        elif startoff == intv[0]:
            if ignore is not None:
                if ignore != intv[2]:
                    retids.add(intv[2])
            else:
                retids.add(intv[2])
        else:
            break
    return self.detach(restrict_to=retids)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, **kwargs):
    &#34;&#34;&#34;

    Args:
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    return {
        # NOTE: Changelog is not getting added as it is stored in the document part!
        &#34;name&#34;: self.name,
        &#34;annotations&#34;: list(val.to_dict(**kwargs)
                            for val in self._annotations.values()),
        &#34;next_annid&#34;: self._next_annid,
    }</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.with_type"><code class="name flex">
<span>def <span class="ident">with_type</span></span>(<span>self, *anntype: Union[str, collections.abc.Iterable], non_overlapping: bool = False) ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets annotations of the specified type(s).
Creates the type index if necessary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>anntype</code></strong></dt>
<dd>one or more types or type lists. The union of all types specified that way</dd>
</dl>
<p>is used to filter the annotations. If no type is specified, all annotations are selected.
non_overlapping: if True, only return annotations of any of the given types which
do not overlap with other annotations. If there are several annotations that start at
the same offset, use the type that comes first in the parameters, if there are more
than one of that type, use the one that would come first in the usual sort order.
*anntype: Union[str:
Iterable]:
non_overlapping: bool:
(Default value = False)</p>
<h2 id="returns">Returns</h2>
<p>an immutable annotation set with the matching annotations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_type(self, *anntype: Union[str, Iterable],
              non_overlapping: bool = False) -&gt; &#34;AnnotationSet&#34;:
    &#34;&#34;&#34;Gets annotations of the specified type(s).
    Creates the type index if necessary.

    Args:
      anntype: one or more types or type lists. The union of all types specified that way
    is used to filter the annotations. If no type is specified, all annotations are selected.
      non_overlapping: if True, only return annotations of any of the given types which
    do not overlap with other annotations. If there are several annotations that start at
    the same offset, use the type that comes first in the parameters, if there are more
    than one of that type, use the one that would come first in the usual sort order.
      *anntype: Union[str: 
      Iterable]: 
      non_overlapping: bool:  (Default value = False)

    Returns:
      an immutable annotation set with the matching annotations.

    &#34;&#34;&#34;
    atypes = []
    for atype in anntype:
        if isinstance(atype, str):
            atypes.append(atype)
        else:
            for t in atype:
                atypes.append(t)
    if not atypes:
        return self.detach()
    self._create_index_by_type()
    annids = set()
    for t in atypes:
        idxs = self._index_by_type.get(t)
        if idxs:
            annids.update(idxs)
    if non_overlapping:
        # need to get annotations grouped by start offset and sorted according to
        # what the Annotation class defines
        allanns = sorted(annids, key=lambda x: self._annotations[x])
        allanns = [self._annotations[x] for x in allanns]
        allannsgrouped = []
        curstart = None
        curset = None
        for ann in allanns:
            if curstart is None:
                curset = [ann]
                curstart = ann.start
            elif curstart == ann.start:
                curset.append(ann)
            else:
                allannsgrouped.append(curset)
                curset = [ann]
                curstart = ann.start
        if curset:
            allannsgrouped.append(curset)
        retanns = []
        # now go through all the grouped annoations and select the top priority one
        # then skip to the next group that does not overlap with the one we just selected
        typepriority = dict()
        for i, atype in enumerate(atypes):
            typepriority[atype] = len(atypes)-i
        curminoffset = 0
        for group in allannsgrouped:
            # instead of sorting, go through the group and find the top priority one
            topann = None
            if len(group) == 1:
                if group[0].start &gt;= curminoffset:
                    topann = group[0]
            elif len(group) == 0:
                raise Exception(&#34;We should never get a 0 size group here!&#34;)
            else:
                for i, ann in enumerate(group):
                    if ann.start &gt;= curminoffset:
                        topann = ann
                        break
                for ann in group[i+1:]:
                    if ann.start &lt; curminoffset:
                        continue
                    if typepriority[ann.type] &gt; typepriority[topann.type]:
                        topann = ann
                    elif typepriority[ann.type] == typepriority[topann.type]:
                        if ann.end &gt; topann.end:
                            topann = ann
                        elif ann.end == topann.end:
                            if ann.id &gt; topann.id:
                                topann = ann
            if topann is not None:
                retanns.append(topann)
                curminoffset = topann.end
        annids = [ann.id for ann in retanns]
    return self.detach(restrict_to=annids)</code></pre>
</details>
</dd>
<dt id="gatenlp.AnnotationSet.within"><code class="name flex">
<span>def <span class="ident">within</span></span>(<span>self, start: int, end: int, annid=None, include_self=False) ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Gets annotations that fall completely within the given offset range, i.e. annotations
such that the offset range is covering each of the annotation.</p>
<p>For each annotation ann in the result set, ann.within(span) is True.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start offset of the range</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end offset of the range</dd>
<dt><strong><code>annid</code></strong></dt>
<dd>the annotation id of the annotation representing the span. (Default value = None)</dd>
<dt><strong><code>include_self</code></strong></dt>
<dd>if True and the annotation id for the span is given, do not include that</dd>
</dl>
<p>annotation in the result set. (Default value = False)
start: int:
end: int: </p>
<h2 id="returns">Returns</h2>
<p>an immutable annotation set with the matching annotations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@support_annotation_or_set
def within(self, start: int, end: int, annid=None, include_self=False) -&gt; &#34;AnnotationSet&#34;:
    &#34;&#34;&#34;Gets annotations that fall completely within the given offset range, i.e. annotations
    such that the offset range is covering each of the annotation.
    
    For each annotation ann in the result set, ann.within(span) is True.

    Args:
      start: start offset of the range
      end: end offset of the range
      annid: the annotation id of the annotation representing the span. (Default value = None)
      include_self: if True and the annotation id for the span is given, do not include that
    annotation in the result set. (Default value = False)
      start: int: 
      end: int: 

    Returns:
      an immutable annotation set with the matching annotations

    &#34;&#34;&#34;
    if start == end:
        intvs = []
    elif start &gt; end:
        raise Exception(&#34;Invalid offset range: {},{}&#34;.format(start, end))
    else:
        self._create_index_by_offset()
        intvs = self._index_by_offset.within(start, end)
    if not include_self and annid is not None:
        ignore = annid
    else:
        ignore = None
    return self._restrict_intvs(intvs, ignore=ignore)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.ChangeLog"><code class="flex name class">
<span>class <span class="ident">ChangeLog</span></span>
<span>(</span><span>store=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Args:
store: if True, the change log stores the actions it receives (default). This can be set
to false if only callbacks are needed.</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChangeLog:
    def __init__(self, store=True):
        &#34;&#34;&#34;

        Args:
        store: if True, the change log stores the actions it receives (default). This can be set
        to false if only callbacks are needed.

        Returns:

        &#34;&#34;&#34;
        self.changes = []
        self.offset_type = OFFSET_TYPE_PYTHON
        self._handlers = dict()
        self._store = store

    def add_handler(self, actions, handler):
        &#34;&#34;&#34;
        Register a handler to get called back when any of the actions is added.
        If any handler was already registered for one or more of the actions,
        the new handler overrides it.

        Args:
          actions: either a single action string or a collection of several action strings
          handler: a callable that takes the change information

        Returns:

        &#34;&#34;&#34;
        if isinstance(actions, str):
            actions = [actions]
        for a in actions:
            if a not in ACTIONS:
                raise Exception(f&#34;Action {a} not known, cannot add handler&#34;)
            self._handlers[a] = handler

    def append(self, change: Dict):
        &#34;&#34;&#34;

        Args:
          change: Dict: 

        Returns:

        &#34;&#34;&#34;
        assert isinstance(change, dict)
        action = change.get(&#34;command&#34;,None)
        if action is None:
            raise Exception(&#34;Odd change, does not have &#39;command&#39; key&#34;)
        if self._store:
            self.changes.append(change)
        hndlr = self._handlers.get(action)
        if hndlr:
            hndlr()

    def __len__(self) -&gt; int:
        return len(self.changes)

    def _fixup_changes(self, method: Callable, replace=False) -&gt; List[Dict]:
        &#34;&#34;&#34;In-place modify the annotation offsets of the changes according to
        the given method.

        Args:
          method: an object method method for converting offsets from or to python.
          replace: if True, modifies the original change objects in the changelog, otherwise, uses copies (Default value = False)
          method: Callable: 

        Returns:
          the modified changes, a reference to the modified changes list of the instance

        &#34;&#34;&#34;
        if not replace:
            newchanges = []
        for change in self.changes:
            if not replace:
                chg = dict(change)
            else:
                chg = change
            if &#34;start&#34; in change:
                chg[&#34;start&#34;] = method(change[&#34;start&#34;])
            if &#34;end&#34; in change:
                chg[&#34;end&#34;] = method(change[&#34;end&#34;])
            if not replace:
                newchanges.append(chg)
        if replace:
            return self.changes
        else:
            return newchanges

    def fixup_changes(self, offset_mapper, offset_type, replace=True):
        &#34;&#34;&#34;Update the offsets of all annotations in this changelog to the desired
        offset type, if necessary. If the ChangeLog already has that offset type, this does nothing.

        Args:
          offset_mapper: a prepared offset mapper to use
          offset_type: the desired offset type
          replace: if True, replaces the original offsets in the original change objects, otherwise creates
        new change objects and a new changes list and returs it. (Default value = True)

        Returns:
          a reference to the modified changes

        &#34;&#34;&#34;
        if offset_type != self.offset_type:
            if offset_type == OFFSET_TYPE_JAVA:
                method = offset_mapper.convert_to_java
            elif offset_type == OFFSET_TYPE_PYTHON:
                method = offset_mapper.convert_to_python
            else:
                raise Exception(&#34;Not a proper offset type: {}&#34;.format(offset_type))
            if replace:
                self.offset_type = offset_type
            return self._fixup_changes(method, replace=replace)
        else:
            return self.changes

    def __repr__(self) -&gt; str:
        return &#34;ChangeLog([{}])&#34;.format(&#34;,&#34;.join([str(c) for c in self.changes]))

    def format_to(self, fp, prefix=&#34;&#34;) -&gt; None:
        &#34;&#34;&#34;

        Args:
          fp: 
          prefix:  (Default value = &#34;&#34;)

        Returns:

        &#34;&#34;&#34;
        for c in self.changes:
            print(prefix, str(c), sep=&#34;&#34;, file=fp)

    def _json_repr(self, **kwargs) -&gt; Dict:
        &#34;&#34;&#34;

        Args:
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        offset_type = self.offset_type
        changes = self.changes
        if &#34;offset_type&#34; in kwargs and kwargs[&#34;offset_type&#34;] != offset_type:
            om = kwargs.get(&#34;offset_mapper&#34;)
            if om is None:
                raise Exception(&#34;Need to convert offsets, but no offset_mapper parameter given&#34;)
            offset_type = kwargs[&#34;offset_type&#34;]
            if offset_type == OFFSET_TYPE_JAVA:
                changes = self._fixup_changes(om.convert_to_java)
            else:
                changes = self._fixup_changes(om.convert_to_python)
        return {
            &#34;changes&#34;: changes,
            &#34;offset_type&#34;: offset_type,
            &#34;gatenlp_type&#34;: self.gatenlp_type
        }

    @staticmethod
    def _from_json_map(jsonmap, **kwargs) -&gt; &#34;ChangeLog&#34;:
        &#34;&#34;&#34;

        Args:
          jsonmap: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        cl = ChangeLog()
        cl.changes = jsonmap.get(&#34;changes&#34;)
        cl.offset_type = jsonmap.get(&#34;offset_type&#34;)
        if cl.offset_type == OFFSET_TYPE_JAVA:
            # we need either an offset mapper or a document
            if &#34;offset_mapper&#34; in kwargs:
                om = kwargs.get(&#34;offset_mapper&#34;)
            elif &#34;document&#34; in kwargs:
                om = OffsetMapper(kwargs.get(&#34;document&#34;))
            else:
                raise Exception(&#34;Loading a changelog with offset_type JAVA, need kwarg &#39;offset_mapper&#39; or &#39;document&#39;&#34;)
            cl._fixup_changes(om.convert_to_python)
        return cl

    def to_dict(self, **kwargs):
        &#34;&#34;&#34;

        Args:
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        offset_type = self.offset_type
        changes = self.changes
        if &#34;offset_type&#34; in kwargs and kwargs[&#34;offset_type&#34;] != offset_type:
            om = kwargs.get(&#34;offset_mapper&#34;)
            if om is None:
                raise Exception(&#34;Need to convert offsets, but no offset_mapper parameter given&#34;)
            offset_type = kwargs[&#34;offset_type&#34;]
            if offset_type == OFFSET_TYPE_JAVA:
                changes = self._fixup_changes(om.convert_to_java, replace=False)
            else:
                changes = self._fixup_changes(om.convert_to_python, replace=False)
        return {
            &#34;changes&#34;: changes,
            &#34;offset_type&#34;: offset_type
        }

    @staticmethod
    def from_dict(dictrepr, **kwargs):
        &#34;&#34;&#34;

        Args:
          dictrepr: 
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        if dictrepr is None:
            return None
        cl = ChangeLog()
        cl.changes = dictrepr.get(&#34;changes&#34;)
        cl.offset_type = dictrepr.get(&#34;offset_type&#34;)
        if cl.offset_type == OFFSET_TYPE_JAVA:
            # we need either an offset mapper or a document
            if &#34;offset_mapper&#34; in kwargs:
                om = kwargs.get(&#34;offset_mapper&#34;)
            elif &#34;document&#34; in kwargs:
                om = OffsetMapper(kwargs.get(&#34;document&#34;))
            else:
                raise Exception(&#34;Loading a changelog with offset_type JAVA, need kwarg &#39;offset_mapper&#39; or &#39;document&#39;&#34;)
            cl._fixup_changes(om.convert_to_python)
        return cl

    def save(self, whereto, fmt=&#34;json&#34;, offset_type=None, offset_mapper=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;Save the document in the given format.
        
        Additional keyword parameters for format &#34;json&#34;:
        * as_array: boolean, if True stores as array instead of dictionary, using to

        Args:
          whereto: either a file name or something that has a write(string) method.
          fmt: serialization format, one of &#34;json&#34;, &#34;msgpack&#34; or &#34;pickle&#34; (Default value = &#34;json&#34;)
          offset_type: store using the given offset type or keep the current if None (Default value = None)
          offset_mapper: nedded if the offset type should get changed (Default value = None)
          mod: module to use (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional parameters for the format
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        m = importlib.import_module(mod)
        saver = m.get_changelog_saver(whereto, fmt)
        saver(ChangeLog, self, to_ext=whereto, offset_type=offset_type, offset_mapper=offset_mapper, **kwargs)

    def save_mem(self, fmt=&#34;json&#34;, offset_type=None, offset_mapper=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;Serialize and save to a string.
        
        Additional keyword parameters for format &#34;json&#34;:
        * as_array: boolean, if True stores as array instead of dictionary, using to

        Args:
          fmt: serialization format, one of &#34;json&#34;, &#34;msgpack&#34; or &#34;pickle&#34; (Default value = &#34;json&#34;)
          offset_type: store using the given offset type or keep the current if None (Default value = None)
          offset_mapper: nedded if the offset type should get changed (Default value = None)
          mod: module to use (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional parameters for the format
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        m = importlib.import_module(mod)
        saver = m.get_changelog_saver(None, fmt)
        return saver(ChangeLog, self, to_mem=True, offset_type=offset_type, offset_mapper=offset_mapper, **kwargs)

    @staticmethod
    def load(wherefrom, fmt=&#34;json&#34;, offset_mapper=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;

        Args:
          wherefrom: param fmt:
          offset_mapper: offset mapper in case the offsets need to get converted (Default value = None)
          kwargs: return:
          fmt:  (Default value = &#34;json&#34;)
          mod:  (Default value = &#34;gatenlp.serialization.default&#34;)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        m = importlib.import_module(mod)
        loader = m.get_changelog_loader(wherefrom, fmt)
        chl = loader(ChangeLog, from_ext=wherefrom, offset_mapper=offset_mapper, **kwargs)
        if chl.offset_type == OFFSET_TYPE_JAVA:
            chl.fixup_changes(offset_mapper, offset_type=OFFSET_TYPE_PYTHON, replace=True)
        return chl

    @staticmethod
    def load_mem(wherefrom, fmt=&#34;json&#34;, offset_mapper=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;Note: the offset type is always converted to PYTHON when loading!

        Args:
          wherefrom: the string to deserialize
          fmt: param offset_mapper: offset mapper in case the offsets need to get converted (Default value = &#34;json&#34;)
          kwargs: return:
          offset_mapper:  (Default value = None)
          mod:  (Default value = &#34;gatenlp.serialization.default&#34;)
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        m = importlib.import_module(mod)
        loader = m.get_changelog_loader(None, fmt)
        chl = loader(ChangeLog, from_mem=wherefrom, offset_mapper=offset_mapper, **kwargs)
        if chl.offset_type == OFFSET_TYPE_JAVA:
            chl.fixup_changes(offset_mapper, offset_type=OFFSET_TYPE_PYTHON, replace=True)
        return chl

    def pprint(self, out=None):
        &#34;&#34;&#34;Pretty print to the given output stream, sys.stdout if not given.
        :return:

        Args:
          out:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if out is None:
            out = sys.stdout
        print(&#34;ChangeLog(&#34;, file=out)
        for i, c in enumerate(self.changes):
            cmd = c.get(&#34;command&#34;)
            parms = c.copy()
            del parms[&#34;command&#34;]
            print(f&#34;{i}: cmd={cmd} {parms}&#34;)
        print(&#34;)&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.ChangeLog.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>dictrepr, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>dictrepr</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(dictrepr, **kwargs):
    &#34;&#34;&#34;

    Args:
      dictrepr: 
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    if dictrepr is None:
        return None
    cl = ChangeLog()
    cl.changes = dictrepr.get(&#34;changes&#34;)
    cl.offset_type = dictrepr.get(&#34;offset_type&#34;)
    if cl.offset_type == OFFSET_TYPE_JAVA:
        # we need either an offset mapper or a document
        if &#34;offset_mapper&#34; in kwargs:
            om = kwargs.get(&#34;offset_mapper&#34;)
        elif &#34;document&#34; in kwargs:
            om = OffsetMapper(kwargs.get(&#34;document&#34;))
        else:
            raise Exception(&#34;Loading a changelog with offset_type JAVA, need kwarg &#39;offset_mapper&#39; or &#39;document&#39;&#34;)
        cl._fixup_changes(om.convert_to_python)
    return cl</code></pre>
</details>
</dd>
<dt id="gatenlp.ChangeLog.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>wherefrom, fmt='json', offset_mapper=None, mod='gatenlp.serialization.default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>wherefrom</code></strong></dt>
<dd>param fmt:</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>offset mapper in case the offsets need to get converted (Default value = None)</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>return:</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>(Default value = "json")</dd>
<dt><strong><code>mod</code></strong></dt>
<dd>(Default value = "gatenlp.serialization.default")</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(wherefrom, fmt=&#34;json&#34;, offset_mapper=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
    &#34;&#34;&#34;

    Args:
      wherefrom: param fmt:
      offset_mapper: offset mapper in case the offsets need to get converted (Default value = None)
      kwargs: return:
      fmt:  (Default value = &#34;json&#34;)
      mod:  (Default value = &#34;gatenlp.serialization.default&#34;)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    m = importlib.import_module(mod)
    loader = m.get_changelog_loader(wherefrom, fmt)
    chl = loader(ChangeLog, from_ext=wherefrom, offset_mapper=offset_mapper, **kwargs)
    if chl.offset_type == OFFSET_TYPE_JAVA:
        chl.fixup_changes(offset_mapper, offset_type=OFFSET_TYPE_PYTHON, replace=True)
    return chl</code></pre>
</details>
</dd>
<dt id="gatenlp.ChangeLog.load_mem"><code class="name flex">
<span>def <span class="ident">load_mem</span></span>(<span>wherefrom, fmt='json', offset_mapper=None, mod='gatenlp.serialization.default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Note: the offset type is always converted to PYTHON when loading!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wherefrom</code></strong></dt>
<dd>the string to deserialize</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>param offset_mapper: offset mapper in case the offsets need to get converted (Default value = "json")</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>return:</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>mod</code></strong></dt>
<dd>(Default value = "gatenlp.serialization.default")</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_mem(wherefrom, fmt=&#34;json&#34;, offset_mapper=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
    &#34;&#34;&#34;Note: the offset type is always converted to PYTHON when loading!

    Args:
      wherefrom: the string to deserialize
      fmt: param offset_mapper: offset mapper in case the offsets need to get converted (Default value = &#34;json&#34;)
      kwargs: return:
      offset_mapper:  (Default value = None)
      mod:  (Default value = &#34;gatenlp.serialization.default&#34;)
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    m = importlib.import_module(mod)
    loader = m.get_changelog_loader(None, fmt)
    chl = loader(ChangeLog, from_mem=wherefrom, offset_mapper=offset_mapper, **kwargs)
    if chl.offset_type == OFFSET_TYPE_JAVA:
        chl.fixup_changes(offset_mapper, offset_type=OFFSET_TYPE_PYTHON, replace=True)
    return chl</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.ChangeLog.add_handler"><code class="name flex">
<span>def <span class="ident">add_handler</span></span>(<span>self, actions, handler)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a handler to get called back when any of the actions is added.
If any handler was already registered for one or more of the actions,
the new handler overrides it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>actions</code></strong></dt>
<dd>either a single action string or a collection of several action strings</dd>
<dt><strong><code>handler</code></strong></dt>
<dd>a callable that takes the change information</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_handler(self, actions, handler):
    &#34;&#34;&#34;
    Register a handler to get called back when any of the actions is added.
    If any handler was already registered for one or more of the actions,
    the new handler overrides it.

    Args:
      actions: either a single action string or a collection of several action strings
      handler: a callable that takes the change information

    Returns:

    &#34;&#34;&#34;
    if isinstance(actions, str):
        actions = [actions]
    for a in actions:
        if a not in ACTIONS:
            raise Exception(f&#34;Action {a} not known, cannot add handler&#34;)
        self._handlers[a] = handler</code></pre>
</details>
</dd>
<dt id="gatenlp.ChangeLog.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, change: Dict)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>change</code></strong></dt>
<dd>Dict: </dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, change: Dict):
    &#34;&#34;&#34;

    Args:
      change: Dict: 

    Returns:

    &#34;&#34;&#34;
    assert isinstance(change, dict)
    action = change.get(&#34;command&#34;,None)
    if action is None:
        raise Exception(&#34;Odd change, does not have &#39;command&#39; key&#34;)
    if self._store:
        self.changes.append(change)
    hndlr = self._handlers.get(action)
    if hndlr:
        hndlr()</code></pre>
</details>
</dd>
<dt id="gatenlp.ChangeLog.fixup_changes"><code class="name flex">
<span>def <span class="ident">fixup_changes</span></span>(<span>self, offset_mapper, offset_type, replace=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the offsets of all annotations in this changelog to the desired
offset type, if necessary. If the ChangeLog already has that offset type, this does nothing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>a prepared offset mapper to use</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>the desired offset type</dd>
<dt><strong><code>replace</code></strong></dt>
<dd>if True, replaces the original offsets in the original change objects, otherwise creates</dd>
</dl>
<p>new change objects and a new changes list and returs it. (Default value = True)</p>
<h2 id="returns">Returns</h2>
<p>a reference to the modified changes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixup_changes(self, offset_mapper, offset_type, replace=True):
    &#34;&#34;&#34;Update the offsets of all annotations in this changelog to the desired
    offset type, if necessary. If the ChangeLog already has that offset type, this does nothing.

    Args:
      offset_mapper: a prepared offset mapper to use
      offset_type: the desired offset type
      replace: if True, replaces the original offsets in the original change objects, otherwise creates
    new change objects and a new changes list and returs it. (Default value = True)

    Returns:
      a reference to the modified changes

    &#34;&#34;&#34;
    if offset_type != self.offset_type:
        if offset_type == OFFSET_TYPE_JAVA:
            method = offset_mapper.convert_to_java
        elif offset_type == OFFSET_TYPE_PYTHON:
            method = offset_mapper.convert_to_python
        else:
            raise Exception(&#34;Not a proper offset type: {}&#34;.format(offset_type))
        if replace:
            self.offset_type = offset_type
        return self._fixup_changes(method, replace=replace)
    else:
        return self.changes</code></pre>
</details>
</dd>
<dt id="gatenlp.ChangeLog.format_to"><code class="name flex">
<span>def <span class="ident">format_to</span></span>(<span>self, fp, prefix='') ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>fp</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>(Default value = "")</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_to(self, fp, prefix=&#34;&#34;) -&gt; None:
    &#34;&#34;&#34;

    Args:
      fp: 
      prefix:  (Default value = &#34;&#34;)

    Returns:

    &#34;&#34;&#34;
    for c in self.changes:
        print(prefix, str(c), sep=&#34;&#34;, file=fp)</code></pre>
</details>
</dd>
<dt id="gatenlp.ChangeLog.pprint"><code class="name flex">
<span>def <span class="ident">pprint</span></span>(<span>self, out=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty print to the given output stream, sys.stdout if not given.
:return:</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>out</code></strong></dt>
<dd>(Default value = None)</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pprint(self, out=None):
    &#34;&#34;&#34;Pretty print to the given output stream, sys.stdout if not given.
    :return:

    Args:
      out:  (Default value = None)

    Returns:

    &#34;&#34;&#34;
    if out is None:
        out = sys.stdout
    print(&#34;ChangeLog(&#34;, file=out)
    for i, c in enumerate(self.changes):
        cmd = c.get(&#34;command&#34;)
        parms = c.copy()
        del parms[&#34;command&#34;]
        print(f&#34;{i}: cmd={cmd} {parms}&#34;)
    print(&#34;)&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.ChangeLog.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, whereto, fmt='json', offset_type=None, offset_mapper=None, mod='gatenlp.serialization.default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the document in the given format.</p>
<p>Additional keyword parameters for format "json":
* as_array: boolean, if True stores as array instead of dictionary, using to</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>whereto</code></strong></dt>
<dd>either a file name or something that has a write(string) method.</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>serialization format, one of "json", "msgpack" or "pickle" (Default value = "json")</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>store using the given offset type or keep the current if None (Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>nedded if the offset type should get changed (Default value = None)</dd>
<dt><strong><code>mod</code></strong></dt>
<dd>module to use (Default value = "gatenlp.serialization.default")</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>additional parameters for the format</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, whereto, fmt=&#34;json&#34;, offset_type=None, offset_mapper=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
    &#34;&#34;&#34;Save the document in the given format.
    
    Additional keyword parameters for format &#34;json&#34;:
    * as_array: boolean, if True stores as array instead of dictionary, using to

    Args:
      whereto: either a file name or something that has a write(string) method.
      fmt: serialization format, one of &#34;json&#34;, &#34;msgpack&#34; or &#34;pickle&#34; (Default value = &#34;json&#34;)
      offset_type: store using the given offset type or keep the current if None (Default value = None)
      offset_mapper: nedded if the offset type should get changed (Default value = None)
      mod: module to use (Default value = &#34;gatenlp.serialization.default&#34;)
      kwargs: additional parameters for the format
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    m = importlib.import_module(mod)
    saver = m.get_changelog_saver(whereto, fmt)
    saver(ChangeLog, self, to_ext=whereto, offset_type=offset_type, offset_mapper=offset_mapper, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.ChangeLog.save_mem"><code class="name flex">
<span>def <span class="ident">save_mem</span></span>(<span>self, fmt='json', offset_type=None, offset_mapper=None, mod='gatenlp.serialization.default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize and save to a string.</p>
<p>Additional keyword parameters for format "json":
* as_array: boolean, if True stores as array instead of dictionary, using to</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fmt</code></strong></dt>
<dd>serialization format, one of "json", "msgpack" or "pickle" (Default value = "json")</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>store using the given offset type or keep the current if None (Default value = None)</dd>
<dt><strong><code>offset_mapper</code></strong></dt>
<dd>nedded if the offset type should get changed (Default value = None)</dd>
<dt><strong><code>mod</code></strong></dt>
<dd>module to use (Default value = "gatenlp.serialization.default")</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>additional parameters for the format</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_mem(self, fmt=&#34;json&#34;, offset_type=None, offset_mapper=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
    &#34;&#34;&#34;Serialize and save to a string.
    
    Additional keyword parameters for format &#34;json&#34;:
    * as_array: boolean, if True stores as array instead of dictionary, using to

    Args:
      fmt: serialization format, one of &#34;json&#34;, &#34;msgpack&#34; or &#34;pickle&#34; (Default value = &#34;json&#34;)
      offset_type: store using the given offset type or keep the current if None (Default value = None)
      offset_mapper: nedded if the offset type should get changed (Default value = None)
      mod: module to use (Default value = &#34;gatenlp.serialization.default&#34;)
      kwargs: additional parameters for the format
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    m = importlib.import_module(mod)
    saver = m.get_changelog_saver(None, fmt)
    return saver(ChangeLog, self, to_mem=True, offset_type=offset_type, offset_mapper=offset_mapper, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.ChangeLog.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, **kwargs):
    &#34;&#34;&#34;

    Args:
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    offset_type = self.offset_type
    changes = self.changes
    if &#34;offset_type&#34; in kwargs and kwargs[&#34;offset_type&#34;] != offset_type:
        om = kwargs.get(&#34;offset_mapper&#34;)
        if om is None:
            raise Exception(&#34;Need to convert offsets, but no offset_mapper parameter given&#34;)
        offset_type = kwargs[&#34;offset_type&#34;]
        if offset_type == OFFSET_TYPE_JAVA:
            changes = self._fixup_changes(om.convert_to_java, replace=False)
        else:
            changes = self._fixup_changes(om.convert_to_python, replace=False)
    return {
        &#34;changes&#34;: changes,
        &#34;offset_type&#34;: offset_type
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.Document"><code class="flex name class">
<span>class <span class="ident">Document</span></span>
<span>(</span><span>text: str = None, features=None, changelog: <a title="gatenlp.changelog.ChangeLog" href="changelog.html#gatenlp.changelog.ChangeLog">ChangeLog</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a GATE document. This is different from the original Java GATE representation in several ways:</p>
<ul>
<li>
<p>the text is not mutable and can only be set at creation time, so there is no "edit" method</p>
</li>
<li>
<p>as a feature bearer, all the methods to set, get and manipulate features are part of this class, there is
no separate "FeatureMap" to store them</p>
</li>
<li>
<p>does not support listener callbacks</p>
</li>
<li>there is no separate abstraction for "content", the only content possible is text which is a unicode string
that can be acessed with the "text()" method</li>
<li>Spans of text can be directly accessed using doc[from:to]</li>
<li>Features may only have string keys and values which can be json-serialised</li>
<li>Annotation offsets by default are number of Unicde code points, this is different from Java where the offsets
are UTF-16 Unicode code units</li>
<li>Offsets of all annotations can be changed from/to Java (from python index of unicode codepoint to Java index
of UTF-16 code unit and back)</li>
<li>No part of the document has to be present, not even the text (this allows saving just the annotations separately
from the text)</li>
<li>Once the text has been set, it is immutable (no support to edit text and change annotation offsets accordingly)</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>the text of the document. The text can be None to indicate that no initial text should be set. Once</dd>
</dl>
<p>the text has been set for a document, it is immutable and cannot be changed.
features: the initial document features to set, a sequence of key/value tuples
changelog: a ChangeLog instance to use to log changes.</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Document:
    &#34;&#34;&#34;Represent a GATE document. This is different from the original Java GATE representation in several ways:
    
    * the text is not mutable and can only be set at creation time, so there is no &#34;edit&#34; method
    
    * as a feature bearer, all the methods to set, get and manipulate features are part of this class, there is
      no separate &#34;FeatureMap&#34; to store them
    
    * does not support listener callbacks
    * there is no separate abstraction for &#34;content&#34;, the only content possible is text which is a unicode string
      that can be acessed with the &#34;text()&#34; method
    * Spans of text can be directly accessed using doc[from:to]
    * Features may only have string keys and values which can be json-serialised
    * Annotation offsets by default are number of Unicde code points, this is different from Java where the offsets
      are UTF-16 Unicode code units
    * Offsets of all annotations can be changed from/to Java (from python index of unicode codepoint to Java index
      of UTF-16 code unit and back)
    * No part of the document has to be present, not even the text (this allows saving just the annotations separately
      from the text)
    * Once the text has been set, it is immutable (no support to edit text and change annotation offsets accordingly)

    Args:
      text: the text of the document. The text can be None to indicate that no initial text should be set. Once
    the text has been set for a document, it is immutable and cannot be changed.
      features: the initial document features to set, a sequence of key/value tuples
      changelog: a ChangeLog instance to use to log changes.

    Returns:

    &#34;&#34;&#34;

    def __init__(self, text: str = None, features=None, changelog: ChangeLog = None):
        if text is not None:
            assert isinstance(text, str)
        if changelog is not None:
            assert isinstance(changelog, ChangeLog)
        # super().__init__(features)
        self._changelog = changelog
        self._features = Features(features, logger=self._log_feature_change)
        self._annotation_sets = dict()
        self._text = text
        self.offset_type = OFFSET_TYPE_PYTHON
        self._name = &#34;&#34;

    @property
    def name(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        return self._name

    @name.setter
    def name(self, val):
        &#34;&#34;&#34;

        Args:
          val: 

        Returns:

        &#34;&#34;&#34;
        if val is None:
            val = &#34;&#34;
        if not isinstance(val, str):
            raise Exception(&#34;Name must be a string&#34;)
        self._name = val
        if self._changelog is not None:
            ch = {&#34;command&#34;: &#34;name:set&#34;}
            ch[&#34;name&#34;] = val
            self._changelog.append(ch)

    def _ensure_type_python(self) -&gt; None:
        &#34;&#34;&#34; &#34;&#34;&#34;
        if self.offset_type != OFFSET_TYPE_PYTHON:
            raise Exception(&#34;Document cannot be used if it is not type PYTHON, use to_type(OFFSET_TYPE_PYTHON) first&#34;)

    def _fixup_annotations(self, method: Callable) -&gt; None:
        &#34;&#34;&#34;

        Args:
          method: Callable: 

        Returns:

        &#34;&#34;&#34;
        annset_names = self._annotation_sets.keys()
        for annset_name in annset_names:
            annset = self._annotation_sets[annset_name]
            if annset._annotations is not None:
                for ann in annset._annotations.values():
                    ann._start = method(ann._start)
                    ann._end = method(ann._end)

    def to_offset_type(self, offsettype: str) -&gt; OffsetMapper:
        &#34;&#34;&#34;Convert all the offsets of all the annotations in this document to the
        required type, either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON. If the offsets
        are already of that type, this does nothing.
        
        NOTE: if the document has a ChangeLog, it is NOT also converted!
        
        The method returns the offset mapper if anything actually was converted,
        otherwise None.

        Args:
          offsettype: either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON
          offsettype: str: 

        Returns:
          offset mapper or None

        &#34;&#34;&#34;
        om = None
        if offsettype == self.offset_type:
            return
        if offsettype == OFFSET_TYPE_JAVA and self.offset_type == OFFSET_TYPE_PYTHON:
            # convert from currently python to java
            om = OffsetMapper(self._text)
            self._fixup_annotations(om.convert_to_java)
            self.offset_type = OFFSET_TYPE_JAVA
        elif offsettype == OFFSET_TYPE_PYTHON and self.offset_type == OFFSET_TYPE_JAVA:
            # convert from currently java to python
            om = OffsetMapper(self._text)
            self._fixup_annotations(om.convert_to_python)
            self.offset_type = OFFSET_TYPE_PYTHON
        else:
            raise Exception(&#34;Odd offset type&#34;)
        return om

    def apply_changes(self, changes, handle_existing_anns=ADDANN_ADD_WITH_NEW_ID):
        &#34;&#34;&#34;Apply changes from a ChangeLog to this document. `changes` can be a ChangeLog instance,
        a sequence of change objects (dicts) as stored in a ChangeLog instance, or a single change object.
        
        The document is modified in-place.

        Args:
          changes: one or more changes
          handle_existing_anns: what to do if the change from the changelog tries to add an annotation
        with an annotation id that already exists in the target set. (Default value = ADDANN_ADD_WITH_NEW_ID)

        Returns:

        &#34;&#34;&#34;
        if isinstance(changes, dict):
            changes = [changes]
        elif isinstance(changes, ChangeLog):
            changes = changes.changes
        for change in changes:
            cmd = change.get(&#34;command&#34;)
            fname = change.get(&#34;feature&#34;)
            sname = change.get(&#34;set&#34;)
            annid = change.get(&#34;id&#34;)
            if cmd is None:
                raise Exception(&#34;Change without field &#39;command&#39;&#34;)
            if cmd == ACTION_ADD_ANNSET:
                assert sname is not None
                self.annset(sname)
            elif cmd == ACTION_ADD_ANN:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                ann = anns.get(annid)
                start = change.get(&#34;start&#34;)
                end = change.get(&#34;end&#34;)
                anntype = change.get(&#34;type&#34;)

                if ann is None:
                    anns.add(start, end, anntype, annid)
                else:
                    if handle_existing_anns == ADDANN_IGNORE:
                        pass
                    elif handle_existing_anns == ADDANN_ADD_WITH_NEW_ID:
                        anns.add(start, end, anntype)
                    elif handle_existing_anns == ADDANN_REPLACE_ANNOTATION:
                        anns.remove(annid)
                        anns.add(start, end, anntype, annid)
                    elif handle_existing_anns == ADDANN_UPDATE_FEATURES:
                        features = change.get(&#34;features&#34;)
                        ann.features.update(features)
                    elif handle_existing_anns == ADDANN_REPLACE_FEATURES:
                        features = change.get(&#34;features&#34;)
                        ann.features.clear()
                        ann.features.update(features)
                    elif handle_existing_anns == ADDANN_ADD_NEW_FEATURES:
                        features = change.get(&#34;features&#34;)
                        fns = ann.feature_names()
                        for f in features.keys():
                            if f not in fns:
                                ann.features[f] = features[f]

            elif cmd == ACTION_CLEAR_ANNS:
                assert sname is not None
                anns = self.annset(sname)
                anns.clear()
            elif cmd == ACTION_CLEAR_ANN_FEATURES:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                ann = anns.get(annid)
                if ann is not None:
                    ann.features.clear()
                else:
                    pass # ignore, could happen with a detached annotation
            elif cmd == ACTION_CLEAR_DOC_FEATURES:
                self.features.clear()
            elif cmd == ACTION_DEL_ANN_FEATURE:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                ann = anns.get(annid)
                if ann is not None:
                    if fname is not None:
                        ann.features.pop(fname, None)
                else:
                    pass  # ignore, could happen with a detached annotation
            elif cmd == ACTION_DEL_DOC_FEATURE:
                assert fname is not None
                self.features.pop(fname, None)
            elif cmd == ACTION_DEL_ANN:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                anns.remove(annid)

    @property
    def features(self):
        &#34;&#34;&#34;Accesses the features as a FeatureViewer instance. Changes made on this object are
        reflected in the document and recorded in the change log, if there is one.
        
        :return: A FeatureViewer view of the document features.

        Args:

        Returns:

        &#34;&#34;&#34;
        return self._features


    @property
    def changelog(self):
        &#34;&#34;&#34;Get the ChangeLog or None if no ChangeLog has been set.
        
        :return: the changelog

        Args:

        Returns:

        &#34;&#34;&#34;
        return self._changelog

    @changelog.setter
    def changelog(self, chlog):
        &#34;&#34;&#34;Make the document use the given changelog to record all changes
        from this moment on.

        Args:
          chlog: the new changelog to use or None to not use any

        Returns:
          the changelog used previously or None

        &#34;&#34;&#34;
        oldchlog = self._changelog
        self._changelog = chlog
        return oldchlog

    @property
    def text(self) -&gt; str:
        &#34;&#34;&#34;Get the text of the document. For a partial document, the text may be None.
        
        :return: the text of the document

        Args:

        Returns:

        &#34;&#34;&#34;
        self._ensure_type_python()
        return self._text

    @text.setter
    def text(self, value: str) -&gt; None:
        &#34;&#34;&#34;Set the text of the document. This is only possible as long as it has not been set
        yet, after that, the text is immutable.

        Args:
          value: the text for the document
          value: str: 

        Returns:

        &#34;&#34;&#34;
        if self._text is None:
            self._text = value
        else:
            raise NotImplementedError(&#34;Text cannot be modified&#34;)

    def _log_feature_change(self, command: str, feature: str = None, value=None) -&gt; None:
        &#34;&#34;&#34;

        Args:
          command: str: 
          feature: str:  (Default value = None)
          value:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if self._changelog is None:
            return
        command = &#34;doc-&#34;+command
        ch = {&#34;command&#34;: command}
        if command == &#34;doc-feature:set&#34;:
            ch[&#34;feature&#34;] = feature
            ch[&#34;value&#34;] = value
        self._changelog.append(ch)

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Return the length of the text.
        Note: this will convert the type of the document to python!

        :return: the length of the document text
        &#34;&#34;&#34;
        self._ensure_type_python()
        if self._text is None:
            return 0
        else:
            return len(self._text)

    def __getitem__(self, span) -&gt; str:
        &#34;&#34;&#34;
        Get the text for the given span.

        :param span: a single number, an offset range of the form from:to or an annotation.
        If annotation, uses the annotation&#39;s offset span.
        :return: the text of the span
        &#34;&#34;&#34;
        self._ensure_type_python()
        if isinstance(span, Annotation):
            return self.text[span._start:span._end]
        if isinstance(span, AnnotationSet):
            return self.text[span.start():span.end()]
        return self.text[span]

    def annset(self, name: str = &#34;&#34;) -&gt; AnnotationSet:
        &#34;&#34;&#34;Get the named annotation set, if name is not given or the empty string, the default annotation set.
        If the annotation set does not already exist, it is created.

        Args:
          name: the annotation set name, the empty string is used for the &#34;default annotation set&#34;.
          name: str:  (Default value = &#34;&#34;)

        Returns:
          the specified annotation set.

        &#34;&#34;&#34;
        self._ensure_type_python()
        if name not in self._annotation_sets:
            annset = AnnotationSet(owner_doc=self, name=name)
            self._annotation_sets[name] = annset
            if self._changelog:
                self._changelog.append({
                    &#34;command&#34;: &#34;annotations:add&#34;,
                    &#34;set&#34;: name})
            return annset
        else:
            return self._annotation_sets[name]

    def annset_names(self) -&gt; KeysView[str]:
        &#34;&#34;&#34;

        Args:

        Returns:
          :return: annotation set names

        &#34;&#34;&#34;
        self._ensure_type_python()
        return list(self._annotation_sets.keys())
    
    def remove_annset(self, name: str):
        &#34;&#34;&#34;Completely remove the annotation set.

        Args:
          name: name of the annotation set to remove
          name: str: 

        Returns:

        &#34;&#34;&#34;
        if name not in self._annotation_sets:
            raise Exception(f&#34;AnnotationSet with name {name} does not exist&#34;)
        del self._annotation_sets[name]
        if self._changelog:
            self._changelog.append({
                &#34;command&#34;: &#34;annotations:remove&#34;,
                &#34;set&#34;: name})

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        String representation of the document, showing all content.

        :return: string representation
        &#34;&#34;&#34;
        return &#34;Document({},features={},anns={})&#34;.format(self.text, self._features, self._annotation_sets.__repr__())

    def __str__(self) -&gt; str:
        asets = &#34;[&#34;+&#34;,&#34;.join([f&#34;&#39;{k}&#39;:{len(v)}&#34; for k, v in self._annotation_sets.items()])+&#34;]&#34;
        return &#34;Document({},features={},anns={})&#34;.format(self.text, self._features, asets)

    def to_dict(self, offset_type=None, **kwargs):
        &#34;&#34;&#34;Convert this instance to a dictionary that can be used to re-create the instance with
        from_dict.
        NOTE: if there is an active changelog, it is not included in the output as this
        field is considered a transient field!

        Args:
          offset_type: convert to the given offset type on the fly (Default value = None)
          **kwargs: 

        Returns:
          the dictionary representation of this instance

        &#34;&#34;&#34;
        # if the specified offset type is equal to what we have, do nothing, otherwise
        # create an offset mapper and pass it down to where we actually convert the annotations

        om = None
        if offset_type is not None:
            assert offset_type == OFFSET_TYPE_JAVA or offset_type == OFFSET_TYPE_PYTHON
            if offset_type != self.offset_type:
                if self._text is not None:
                    om = OffsetMapper(self._text)
        else:
            offset_type = self.offset_type
        return {
            &#34;annotation_sets&#34;: {name: aset.to_dict() for name, aset in self._annotation_sets.items() },
            &#34;text&#34;: self._text,
            &#34;features&#34;: self._features.to_dict(),
            &#34;offset_type&#34;: offset_type,
            &#34;name&#34;: self.name,
        }

    @staticmethod
    def from_dict(dictrepr, **kwargs):
        &#34;&#34;&#34;Return a Document instance as represented by the dictionary dictrepr.

        Args:
          dictrepr: return: the initialized Document instance
          **kwargs: 

        Returns:
          the initialized Document instance

        &#34;&#34;&#34;
        feats = dictrepr.get(&#34;features&#34;)
        doc = Document(dictrepr.get(&#34;text&#34;), features=feats)
        doc.name = dictrepr.get(&#34;name&#34;)
        doc.offset_type = dictrepr.get(&#34;offset_type&#34;)
        if doc.offset_type != OFFSET_TYPE_JAVA and doc.offset_type != OFFSET_TYPE_PYTHON:
            raise Exception(&#34;Invalid offset type, cannot load: &#34;, doc.offset_type)
        annsets = {name: AnnotationSet.from_dict(adict, owner_doc=doc)
                   for name, adict in dictrepr.get(&#34;annotation_sets&#34;).items()}
        doc._annotation_sets = annsets
        return doc

    def save(self, destination, fmt=None, offset_type=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;Save the document to the destination file.

        Args:
          destination: either a file name or something that has a write(string) method.
          fmt: serialization format, by default the format is inferred from the file extension.
          offset_type: store using the given offset type or keep the current if None (Default value = None)
          mod: module where the document saver is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional parameters for the document saver.
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        if fmt is None or isinstance(fmt, str):
            m = importlib.import_module(mod)
            saver = m.get_document_saver(destination, fmt)
            saver(Document, self, to_ext=destination, offset_type=offset_type, **kwargs)
        else:
            # assume fmt is a callable to get used directly
            fmt(Document, self, to_ext=destination, offset_type=offset_type, **kwargs)

    def save_mem(self, fmt=&#34;json&#34;, offset_type=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;Serialize to a string or bytes in the given format.

        Args:
          fmt: serialization format to use. (Default value = &#34;json&#34;)
          offset_type: store using the given offset type or keep the current if None (Default value = None)
          mod: module where the document saver is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional parameters for the format.
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        if not fmt:
            raise Exception(&#34;Format required.&#34;)
        if isinstance(fmt, str):
            m = importlib.import_module(mod)
            saver = m.get_document_saver(None, fmt)
            return saver(Document, self, to_mem=True, offset_type=offset_type, **kwargs)
        else:
            fmt(Document, self, to_mem=True, offset_type=offset_type, **kwargs)

    @staticmethod
    def load(source, fmt=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;Load or import a document from the given source. The source can be a file path or file name or
        a URL. If the type of the source is str, then if it starts with &#34;http[s]://&#34; it will get treated
        as a URL. In order to deliberatly use a file instead of a URL, create a pathlib Path, in order to
        deliberately use URL instead of a file parse the URL using urllib.
        
        Example: `Document.load(urllib.parse.urlparse(someurl), fmt=theformat)`
        
        Example: `Document.load(pathlib.Path(somepath), fmt=theformat)`
        
        NOTE: the offset type of the document is always converted to PYTHON when loading!

        Args:
          source: the URL or file path to load from.
          fmt: the format of the source. By default the format is inferred by the file extension.
        The format can be a format memnonic like &#34;json&#34;, &#34;html&#34;, or a known mime type like &#34;text/bdocjs&#34;.
          mod: the name of a module where the document loader is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional format specific keyword arguments to pass to the loader
          **kwargs: 

        Returns:
          the loaded document

        &#34;&#34;&#34;
        if fmt is None or isinstance(fmt, str):
            m = importlib.import_module(mod)
            loader = m.get_document_loader(source, fmt)
            doc = loader(Document, from_ext=source, **kwargs)
        else:
            doc = fmt(Document, from_ext=source, **kwargs)
        if doc.offset_type == OFFSET_TYPE_JAVA:
            doc.to_offset_type(OFFSET_TYPE_PYTHON)
        return doc

    @staticmethod
    def load_mem(source, fmt=&#34;json&#34;, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;Create a document from the in-memory serialization in source. Source can be a string or
        bytes, depending on the format.
        
        Note: the offset type is always converted to PYTHON when loading!

        Args:
          source: the string/bytes to deserialize
          fmt: the format (Default value = &#34;json&#34;)
          mod: the name of the module where the loader is implemented (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional arguments to pass to the loader
          **kwargs: 

        Returns:

        &#34;&#34;&#34;
        if not fmt:
            raise Exception(&#34;Format required.&#34;)
        if isinstance(fmt, str):
            m = importlib.import_module(mod)
            loader = m.get_document_loader(None, fmt)
            doc = loader(Document, from_mem=source, **kwargs)
        else:
            doc = fmt(Document, from_mem=source, **kwargs)
        if doc.offset_type == OFFSET_TYPE_JAVA:
            doc.to_offset_type(OFFSET_TYPE_PYTHON)
        return doc

    def __copy__(self):
        &#34;&#34;&#34;
        Creates a shallow copy except the changelog which is set to None.

        :return: shallow copy of the document
        &#34;&#34;&#34;
        doc = Document(self._text)
        doc._annotation_sets = self._annotation_sets
        doc.offset_type = self.offset_type
        doc._features = self._features.copy()
        return doc

    def copy(self):
        &#34;&#34;&#34;Creates a shallow copy except the changelog which is set to None.
        
        :return: shallow copy of the document

        Args:

        Returns:

        &#34;&#34;&#34;
        return self.__copy__()

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        Creates a deep copy, except the changelog which is set to None.

        :param memo: the memoization dictionary to use.

        :return: a deep copy of the document.
        &#34;&#34;&#34;
        if self._features is not None:
            fts = copy.deepcopy(self._features.to_dict(), memo)
        else:
            fts = None
        doc = Document(self._text, features=fts)
        doc._changelog = None
        doc._annotation_sets = copy.deepcopy(self._annotation_sets, memo)
        doc.offset_type = self.offset_type
        return doc

    def deepcopy(self):
        &#34;&#34;&#34;Creates a deep copy, except the changelog which is set to None.

        Args:
          memo: the memoization dictionary to use.

        Returns:
          a deep copy of the document.

        &#34;&#34;&#34;
        return copy.deepcopy(self)

    def _repr_html_(self):
        &#34;&#34;&#34;Render function for Jupyter notebooks. Returns the html-ann-viewer HTML.
        
        :return:

        Args:

        Returns:

        &#34;&#34;&#34;
        return self.repr_html()

    def repr_html(self, notebook=True, offline=None, htmlid=None):
        &#34;&#34;&#34;Return a

        Args:
          notebook: param offline: (Default value = True)
          htmlid: return: (Default value = None)
          offline:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if offline is None:
            offline = gatenlpconfig.doc_html_repr_offline
        return self.save_mem(fmt=&#34;html-ann-viewer&#34;,
                             notebook=notebook,
                             offline=gatenlpconfig.doc_html_repr_offline,
                             htmlid=htmlid)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.Document.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>dictrepr, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a Document instance as represented by the dictionary dictrepr.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dictrepr</code></strong></dt>
<dd>return: the initialized Document instance</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the initialized Document instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(dictrepr, **kwargs):
    &#34;&#34;&#34;Return a Document instance as represented by the dictionary dictrepr.

    Args:
      dictrepr: return: the initialized Document instance
      **kwargs: 

    Returns:
      the initialized Document instance

    &#34;&#34;&#34;
    feats = dictrepr.get(&#34;features&#34;)
    doc = Document(dictrepr.get(&#34;text&#34;), features=feats)
    doc.name = dictrepr.get(&#34;name&#34;)
    doc.offset_type = dictrepr.get(&#34;offset_type&#34;)
    if doc.offset_type != OFFSET_TYPE_JAVA and doc.offset_type != OFFSET_TYPE_PYTHON:
        raise Exception(&#34;Invalid offset type, cannot load: &#34;, doc.offset_type)
    annsets = {name: AnnotationSet.from_dict(adict, owner_doc=doc)
               for name, adict in dictrepr.get(&#34;annotation_sets&#34;).items()}
    doc._annotation_sets = annsets
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>source, fmt=None, mod='gatenlp.serialization.default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load or import a document from the given source. The source can be a file path or file name or
a URL. If the type of the source is str, then if it starts with "http[s]://" it will get treated
as a URL. In order to deliberatly use a file instead of a URL, create a pathlib Path, in order to
deliberately use URL instead of a file parse the URL using urllib.</p>
<p>Example: <code>Document.load(urllib.parse.urlparse(someurl), fmt=theformat)</code></p>
<p>Example: <code>Document.load(pathlib.Path(somepath), fmt=theformat)</code></p>
<p>NOTE: the offset type of the document is always converted to PYTHON when loading!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>the URL or file path to load from.</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>the format of the source. By default the format is inferred by the file extension.</dd>
</dl>
<p>The format can be a format memnonic like "json", "html", or a known mime type like "text/bdocjs".
mod: the name of a module where the document loader is implemented. (Default value = "gatenlp.serialization.default")
kwargs: additional format specific keyword arguments to pass to the loader
**kwargs: </p>
<h2 id="returns">Returns</h2>
<p>the loaded document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(source, fmt=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
    &#34;&#34;&#34;Load or import a document from the given source. The source can be a file path or file name or
    a URL. If the type of the source is str, then if it starts with &#34;http[s]://&#34; it will get treated
    as a URL. In order to deliberatly use a file instead of a URL, create a pathlib Path, in order to
    deliberately use URL instead of a file parse the URL using urllib.
    
    Example: `Document.load(urllib.parse.urlparse(someurl), fmt=theformat)`
    
    Example: `Document.load(pathlib.Path(somepath), fmt=theformat)`
    
    NOTE: the offset type of the document is always converted to PYTHON when loading!

    Args:
      source: the URL or file path to load from.
      fmt: the format of the source. By default the format is inferred by the file extension.
    The format can be a format memnonic like &#34;json&#34;, &#34;html&#34;, or a known mime type like &#34;text/bdocjs&#34;.
      mod: the name of a module where the document loader is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
      kwargs: additional format specific keyword arguments to pass to the loader
      **kwargs: 

    Returns:
      the loaded document

    &#34;&#34;&#34;
    if fmt is None or isinstance(fmt, str):
        m = importlib.import_module(mod)
        loader = m.get_document_loader(source, fmt)
        doc = loader(Document, from_ext=source, **kwargs)
    else:
        doc = fmt(Document, from_ext=source, **kwargs)
    if doc.offset_type == OFFSET_TYPE_JAVA:
        doc.to_offset_type(OFFSET_TYPE_PYTHON)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.load_mem"><code class="name flex">
<span>def <span class="ident">load_mem</span></span>(<span>source, fmt='json', mod='gatenlp.serialization.default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a document from the in-memory serialization in source. Source can be a string or
bytes, depending on the format.</p>
<p>Note: the offset type is always converted to PYTHON when loading!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>the string/bytes to deserialize</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>the format (Default value = "json")</dd>
<dt><strong><code>mod</code></strong></dt>
<dd>the name of the module where the loader is implemented (Default value = "gatenlp.serialization.default")</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>additional arguments to pass to the loader</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_mem(source, fmt=&#34;json&#34;, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
    &#34;&#34;&#34;Create a document from the in-memory serialization in source. Source can be a string or
    bytes, depending on the format.
    
    Note: the offset type is always converted to PYTHON when loading!

    Args:
      source: the string/bytes to deserialize
      fmt: the format (Default value = &#34;json&#34;)
      mod: the name of the module where the loader is implemented (Default value = &#34;gatenlp.serialization.default&#34;)
      kwargs: additional arguments to pass to the loader
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    if not fmt:
        raise Exception(&#34;Format required.&#34;)
    if isinstance(fmt, str):
        m = importlib.import_module(mod)
        loader = m.get_document_loader(None, fmt)
        doc = loader(Document, from_mem=source, **kwargs)
    else:
        doc = fmt(Document, from_mem=source, **kwargs)
    if doc.offset_type == OFFSET_TYPE_JAVA:
        doc.to_offset_type(OFFSET_TYPE_PYTHON)
    return doc</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="gatenlp.Document.changelog"><code class="name">var <span class="ident">changelog</span></code></dt>
<dd>
<div class="desc"><p>Get the ChangeLog or None if no ChangeLog has been set.</p>
<p>:return: the changelog</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def changelog(self):
    &#34;&#34;&#34;Get the ChangeLog or None if no ChangeLog has been set.
    
    :return: the changelog

    Args:

    Returns:

    &#34;&#34;&#34;
    return self._changelog</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.features"><code class="name">var <span class="ident">features</span></code></dt>
<dd>
<div class="desc"><p>Accesses the features as a FeatureViewer instance. Changes made on this object are
reflected in the document and recorded in the change log, if there is one.</p>
<p>:return: A FeatureViewer view of the document features.</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def features(self):
    &#34;&#34;&#34;Accesses the features as a FeatureViewer instance. Changes made on this object are
    reflected in the document and recorded in the change log, if there is one.
    
    :return: A FeatureViewer view of the document features.

    Args:

    Returns:

    &#34;&#34;&#34;
    return self._features</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34; &#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.text"><code class="name">var <span class="ident">text</span> : str</code></dt>
<dd>
<div class="desc"><p>Get the text of the document. For a partial document, the text may be None.</p>
<p>:return: the text of the document</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text(self) -&gt; str:
    &#34;&#34;&#34;Get the text of the document. For a partial document, the text may be None.
    
    :return: the text of the document

    Args:

    Returns:

    &#34;&#34;&#34;
    self._ensure_type_python()
    return self._text</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.Document.annset"><code class="name flex">
<span>def <span class="ident">annset</span></span>(<span>self, name: str = '') ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the named annotation set, if name is not given or the empty string, the default annotation set.
If the annotation set does not already exist, it is created.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>the annotation set name, the empty string is used for the "default annotation set".</dd>
<dt><strong><code>name</code></strong></dt>
<dd>str:
(Default value = "")</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the specified annotation set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def annset(self, name: str = &#34;&#34;) -&gt; AnnotationSet:
    &#34;&#34;&#34;Get the named annotation set, if name is not given or the empty string, the default annotation set.
    If the annotation set does not already exist, it is created.

    Args:
      name: the annotation set name, the empty string is used for the &#34;default annotation set&#34;.
      name: str:  (Default value = &#34;&#34;)

    Returns:
      the specified annotation set.

    &#34;&#34;&#34;
    self._ensure_type_python()
    if name not in self._annotation_sets:
        annset = AnnotationSet(owner_doc=self, name=name)
        self._annotation_sets[name] = annset
        if self._changelog:
            self._changelog.append({
                &#34;command&#34;: &#34;annotations:add&#34;,
                &#34;set&#34;: name})
        return annset
    else:
        return self._annotation_sets[name]</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.annset_names"><code class="name flex">
<span>def <span class="ident">annset_names</span></span>(<span>self) ‑> KeysView[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>:return: annotation set names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def annset_names(self) -&gt; KeysView[str]:
    &#34;&#34;&#34;

    Args:

    Returns:
      :return: annotation set names

    &#34;&#34;&#34;
    self._ensure_type_python()
    return list(self._annotation_sets.keys())</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.apply_changes"><code class="name flex">
<span>def <span class="ident">apply_changes</span></span>(<span>self, changes, handle_existing_anns='add-with-new-id')</span>
</code></dt>
<dd>
<div class="desc"><p>Apply changes from a ChangeLog to this document. <code>changes</code> can be a ChangeLog instance,
a sequence of change objects (dicts) as stored in a ChangeLog instance, or a single change object.</p>
<p>The document is modified in-place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>changes</code></strong></dt>
<dd>one or more changes</dd>
<dt><strong><code>handle_existing_anns</code></strong></dt>
<dd>what to do if the change from the changelog tries to add an annotation</dd>
</dl>
<p>with an annotation id that already exists in the target set. (Default value = ADDANN_ADD_WITH_NEW_ID)</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_changes(self, changes, handle_existing_anns=ADDANN_ADD_WITH_NEW_ID):
    &#34;&#34;&#34;Apply changes from a ChangeLog to this document. `changes` can be a ChangeLog instance,
    a sequence of change objects (dicts) as stored in a ChangeLog instance, or a single change object.
    
    The document is modified in-place.

    Args:
      changes: one or more changes
      handle_existing_anns: what to do if the change from the changelog tries to add an annotation
    with an annotation id that already exists in the target set. (Default value = ADDANN_ADD_WITH_NEW_ID)

    Returns:

    &#34;&#34;&#34;
    if isinstance(changes, dict):
        changes = [changes]
    elif isinstance(changes, ChangeLog):
        changes = changes.changes
    for change in changes:
        cmd = change.get(&#34;command&#34;)
        fname = change.get(&#34;feature&#34;)
        sname = change.get(&#34;set&#34;)
        annid = change.get(&#34;id&#34;)
        if cmd is None:
            raise Exception(&#34;Change without field &#39;command&#39;&#34;)
        if cmd == ACTION_ADD_ANNSET:
            assert sname is not None
            self.annset(sname)
        elif cmd == ACTION_ADD_ANN:
            assert sname is not None
            assert annid is not None
            anns = self.annset(sname)
            ann = anns.get(annid)
            start = change.get(&#34;start&#34;)
            end = change.get(&#34;end&#34;)
            anntype = change.get(&#34;type&#34;)

            if ann is None:
                anns.add(start, end, anntype, annid)
            else:
                if handle_existing_anns == ADDANN_IGNORE:
                    pass
                elif handle_existing_anns == ADDANN_ADD_WITH_NEW_ID:
                    anns.add(start, end, anntype)
                elif handle_existing_anns == ADDANN_REPLACE_ANNOTATION:
                    anns.remove(annid)
                    anns.add(start, end, anntype, annid)
                elif handle_existing_anns == ADDANN_UPDATE_FEATURES:
                    features = change.get(&#34;features&#34;)
                    ann.features.update(features)
                elif handle_existing_anns == ADDANN_REPLACE_FEATURES:
                    features = change.get(&#34;features&#34;)
                    ann.features.clear()
                    ann.features.update(features)
                elif handle_existing_anns == ADDANN_ADD_NEW_FEATURES:
                    features = change.get(&#34;features&#34;)
                    fns = ann.feature_names()
                    for f in features.keys():
                        if f not in fns:
                            ann.features[f] = features[f]

        elif cmd == ACTION_CLEAR_ANNS:
            assert sname is not None
            anns = self.annset(sname)
            anns.clear()
        elif cmd == ACTION_CLEAR_ANN_FEATURES:
            assert sname is not None
            assert annid is not None
            anns = self.annset(sname)
            ann = anns.get(annid)
            if ann is not None:
                ann.features.clear()
            else:
                pass # ignore, could happen with a detached annotation
        elif cmd == ACTION_CLEAR_DOC_FEATURES:
            self.features.clear()
        elif cmd == ACTION_DEL_ANN_FEATURE:
            assert sname is not None
            assert annid is not None
            anns = self.annset(sname)
            ann = anns.get(annid)
            if ann is not None:
                if fname is not None:
                    ann.features.pop(fname, None)
            else:
                pass  # ignore, could happen with a detached annotation
        elif cmd == ACTION_DEL_DOC_FEATURE:
            assert fname is not None
            self.features.pop(fname, None)
        elif cmd == ACTION_DEL_ANN:
            assert sname is not None
            assert annid is not None
            anns = self.annset(sname)
            anns.remove(annid)</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a shallow copy except the changelog which is set to None.</p>
<p>:return: shallow copy of the document</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;Creates a shallow copy except the changelog which is set to None.
    
    :return: shallow copy of the document

    Args:

    Returns:

    &#34;&#34;&#34;
    return self.__copy__()</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.deepcopy"><code class="name flex">
<span>def <span class="ident">deepcopy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a deep copy, except the changelog which is set to None.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>memo</code></strong></dt>
<dd>the memoization dictionary to use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a deep copy of the document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deepcopy(self):
    &#34;&#34;&#34;Creates a deep copy, except the changelog which is set to None.

    Args:
      memo: the memoization dictionary to use.

    Returns:
      a deep copy of the document.

    &#34;&#34;&#34;
    return copy.deepcopy(self)</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.remove_annset"><code class="name flex">
<span>def <span class="ident">remove_annset</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Completely remove the annotation set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name of the annotation set to remove</dd>
<dt><strong><code>name</code></strong></dt>
<dd>str: </dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_annset(self, name: str):
    &#34;&#34;&#34;Completely remove the annotation set.

    Args:
      name: name of the annotation set to remove
      name: str: 

    Returns:

    &#34;&#34;&#34;
    if name not in self._annotation_sets:
        raise Exception(f&#34;AnnotationSet with name {name} does not exist&#34;)
    del self._annotation_sets[name]
    if self._changelog:
        self._changelog.append({
            &#34;command&#34;: &#34;annotations:remove&#34;,
            &#34;set&#34;: name})</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.repr_html"><code class="name flex">
<span>def <span class="ident">repr_html</span></span>(<span>self, notebook=True, offline=None, htmlid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>notebook</code></strong></dt>
<dd>param offline: (Default value = True)</dd>
<dt><strong><code>htmlid</code></strong></dt>
<dd>return: (Default value = None)</dd>
<dt><strong><code>offline</code></strong></dt>
<dd>(Default value = None)</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repr_html(self, notebook=True, offline=None, htmlid=None):
    &#34;&#34;&#34;Return a

    Args:
      notebook: param offline: (Default value = True)
      htmlid: return: (Default value = None)
      offline:  (Default value = None)

    Returns:

    &#34;&#34;&#34;
    if offline is None:
        offline = gatenlpconfig.doc_html_repr_offline
    return self.save_mem(fmt=&#34;html-ann-viewer&#34;,
                         notebook=notebook,
                         offline=gatenlpconfig.doc_html_repr_offline,
                         htmlid=htmlid)</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, destination, fmt=None, offset_type=None, mod='gatenlp.serialization.default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the document to the destination file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>destination</code></strong></dt>
<dd>either a file name or something that has a write(string) method.</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>serialization format, by default the format is inferred from the file extension.</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>store using the given offset type or keep the current if None (Default value = None)</dd>
<dt><strong><code>mod</code></strong></dt>
<dd>module where the document saver is implemented. (Default value = "gatenlp.serialization.default")</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>additional parameters for the document saver.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, destination, fmt=None, offset_type=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
    &#34;&#34;&#34;Save the document to the destination file.

    Args:
      destination: either a file name or something that has a write(string) method.
      fmt: serialization format, by default the format is inferred from the file extension.
      offset_type: store using the given offset type or keep the current if None (Default value = None)
      mod: module where the document saver is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
      kwargs: additional parameters for the document saver.
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    if fmt is None or isinstance(fmt, str):
        m = importlib.import_module(mod)
        saver = m.get_document_saver(destination, fmt)
        saver(Document, self, to_ext=destination, offset_type=offset_type, **kwargs)
    else:
        # assume fmt is a callable to get used directly
        fmt(Document, self, to_ext=destination, offset_type=offset_type, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.save_mem"><code class="name flex">
<span>def <span class="ident">save_mem</span></span>(<span>self, fmt='json', offset_type=None, mod='gatenlp.serialization.default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize to a string or bytes in the given format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fmt</code></strong></dt>
<dd>serialization format to use. (Default value = "json")</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>store using the given offset type or keep the current if None (Default value = None)</dd>
<dt><strong><code>mod</code></strong></dt>
<dd>module where the document saver is implemented. (Default value = "gatenlp.serialization.default")</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>additional parameters for the format.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_mem(self, fmt=&#34;json&#34;, offset_type=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
    &#34;&#34;&#34;Serialize to a string or bytes in the given format.

    Args:
      fmt: serialization format to use. (Default value = &#34;json&#34;)
      offset_type: store using the given offset type or keep the current if None (Default value = None)
      mod: module where the document saver is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
      kwargs: additional parameters for the format.
      **kwargs: 

    Returns:

    &#34;&#34;&#34;
    if not fmt:
        raise Exception(&#34;Format required.&#34;)
    if isinstance(fmt, str):
        m = importlib.import_module(mod)
        saver = m.get_document_saver(None, fmt)
        return saver(Document, self, to_mem=True, offset_type=offset_type, **kwargs)
    else:
        fmt(Document, self, to_mem=True, offset_type=offset_type, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, offset_type=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert this instance to a dictionary that can be used to re-create the instance with
from_dict.
NOTE: if there is an active changelog, it is not included in the output as this
field is considered a transient field!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offset_type</code></strong></dt>
<dd>convert to the given offset type on the fly (Default value = None)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the dictionary representation of this instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, offset_type=None, **kwargs):
    &#34;&#34;&#34;Convert this instance to a dictionary that can be used to re-create the instance with
    from_dict.
    NOTE: if there is an active changelog, it is not included in the output as this
    field is considered a transient field!

    Args:
      offset_type: convert to the given offset type on the fly (Default value = None)
      **kwargs: 

    Returns:
      the dictionary representation of this instance

    &#34;&#34;&#34;
    # if the specified offset type is equal to what we have, do nothing, otherwise
    # create an offset mapper and pass it down to where we actually convert the annotations

    om = None
    if offset_type is not None:
        assert offset_type == OFFSET_TYPE_JAVA or offset_type == OFFSET_TYPE_PYTHON
        if offset_type != self.offset_type:
            if self._text is not None:
                om = OffsetMapper(self._text)
    else:
        offset_type = self.offset_type
    return {
        &#34;annotation_sets&#34;: {name: aset.to_dict() for name, aset in self._annotation_sets.items() },
        &#34;text&#34;: self._text,
        &#34;features&#34;: self._features.to_dict(),
        &#34;offset_type&#34;: offset_type,
        &#34;name&#34;: self.name,
    }</code></pre>
</details>
</dd>
<dt id="gatenlp.Document.to_offset_type"><code class="name flex">
<span>def <span class="ident">to_offset_type</span></span>(<span>self, offsettype: str) ‑> <a title="gatenlp.offsetmapper.OffsetMapper" href="offsetmapper.html#gatenlp.offsetmapper.OffsetMapper">OffsetMapper</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert all the offsets of all the annotations in this document to the
required type, either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON. If the offsets
are already of that type, this does nothing.</p>
<p>NOTE: if the document has a ChangeLog, it is NOT also converted!</p>
<p>The method returns the offset mapper if anything actually was converted,
otherwise None.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offsettype</code></strong></dt>
<dd>either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON</dd>
<dt><strong><code>offsettype</code></strong></dt>
<dd>str: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>offset mapper or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_offset_type(self, offsettype: str) -&gt; OffsetMapper:
    &#34;&#34;&#34;Convert all the offsets of all the annotations in this document to the
    required type, either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON. If the offsets
    are already of that type, this does nothing.
    
    NOTE: if the document has a ChangeLog, it is NOT also converted!
    
    The method returns the offset mapper if anything actually was converted,
    otherwise None.

    Args:
      offsettype: either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON
      offsettype: str: 

    Returns:
      offset mapper or None

    &#34;&#34;&#34;
    om = None
    if offsettype == self.offset_type:
        return
    if offsettype == OFFSET_TYPE_JAVA and self.offset_type == OFFSET_TYPE_PYTHON:
        # convert from currently python to java
        om = OffsetMapper(self._text)
        self._fixup_annotations(om.convert_to_java)
        self.offset_type = OFFSET_TYPE_JAVA
    elif offsettype == OFFSET_TYPE_PYTHON and self.offset_type == OFFSET_TYPE_JAVA:
        # convert from currently java to python
        om = OffsetMapper(self._text)
        self._fixup_annotations(om.convert_to_python)
        self.offset_type = OFFSET_TYPE_PYTHON
    else:
        raise Exception(&#34;Odd offset type&#34;)
    return om</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="gatenlp.annotation" href="annotation.html">gatenlp.annotation</a></code></li>
<li><code><a title="gatenlp.annotation_set" href="annotation_set.html">gatenlp.annotation_set</a></code></li>
<li><code><a title="gatenlp.changelog" href="changelog.html">gatenlp.changelog</a></code></li>
<li><code><a title="gatenlp.document" href="document.html">gatenlp.document</a></code></li>
<li><code><a title="gatenlp.features" href="features.html">gatenlp.features</a></code></li>
<li><code><a title="gatenlp.gate_interaction" href="gate_interaction.html">gatenlp.gate_interaction</a></code></li>
<li><code><a title="gatenlp.gatenlpconfig" href="gatenlpconfig.html">gatenlp.gatenlpconfig</a></code></li>
<li><code><a title="gatenlp.gateslave" href="gateslave.html">gatenlp.gateslave</a></code></li>
<li><code><a title="gatenlp.impl" href="impl/index.html">gatenlp.impl</a></code></li>
<li><code><a title="gatenlp.lang" href="lang/index.html">gatenlp.lang</a></code></li>
<li><code><a title="gatenlp.lib_spacy" href="lib_spacy.html">gatenlp.lib_spacy</a></code></li>
<li><code><a title="gatenlp.lib_stanfordnlp" href="lib_stanfordnlp.html">gatenlp.lib_stanfordnlp</a></code></li>
<li><code><a title="gatenlp.lib_stanza" href="lib_stanza.html">gatenlp.lib_stanza</a></code></li>
<li><code><a title="gatenlp.offsetmapper" href="offsetmapper.html">gatenlp.offsetmapper</a></code></li>
<li><code><a title="gatenlp.processing" href="processing/index.html">gatenlp.processing</a></code></li>
<li><code><a title="gatenlp.serialization" href="serialization/index.html">gatenlp.serialization</a></code></li>
<li><code><a title="gatenlp.utils" href="utils.html">gatenlp.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gatenlp.GateNlpPr" href="#gatenlp.GateNlpPr">GateNlpPr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.Annotation" href="#gatenlp.Annotation">Annotation</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.Annotation.copy" href="#gatenlp.Annotation.copy">copy</a></code></li>
<li><code><a title="gatenlp.Annotation.deepcopy" href="#gatenlp.Annotation.deepcopy">deepcopy</a></code></li>
<li><code><a title="gatenlp.Annotation.end" href="#gatenlp.Annotation.end">end</a></code></li>
<li><code><a title="gatenlp.Annotation.features" href="#gatenlp.Annotation.features">features</a></code></li>
<li><code><a title="gatenlp.Annotation.from_dict" href="#gatenlp.Annotation.from_dict">from_dict</a></code></li>
<li><code><a title="gatenlp.Annotation.gap" href="#gatenlp.Annotation.gap">gap</a></code></li>
<li><code><a title="gatenlp.Annotation.id" href="#gatenlp.Annotation.id">id</a></code></li>
<li><code><a title="gatenlp.Annotation.isafter" href="#gatenlp.Annotation.isafter">isafter</a></code></li>
<li><code><a title="gatenlp.Annotation.isbefore" href="#gatenlp.Annotation.isbefore">isbefore</a></code></li>
<li><code><a title="gatenlp.Annotation.iscoextensive" href="#gatenlp.Annotation.iscoextensive">iscoextensive</a></code></li>
<li><code><a title="gatenlp.Annotation.iscovering" href="#gatenlp.Annotation.iscovering">iscovering</a></code></li>
<li><code><a title="gatenlp.Annotation.isoverlapping" href="#gatenlp.Annotation.isoverlapping">isoverlapping</a></code></li>
<li><code><a title="gatenlp.Annotation.iswithin" href="#gatenlp.Annotation.iswithin">iswithin</a></code></li>
<li><code><a title="gatenlp.Annotation.length" href="#gatenlp.Annotation.length">length</a></code></li>
<li><code><a title="gatenlp.Annotation.span" href="#gatenlp.Annotation.span">span</a></code></li>
<li><code><a title="gatenlp.Annotation.start" href="#gatenlp.Annotation.start">start</a></code></li>
<li><code><a title="gatenlp.Annotation.to_dict" href="#gatenlp.Annotation.to_dict">to_dict</a></code></li>
<li><code><a title="gatenlp.Annotation.type" href="#gatenlp.Annotation.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.AnnotationSet" href="#gatenlp.AnnotationSet">AnnotationSet</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.AnnotationSet.add" href="#gatenlp.AnnotationSet.add">add</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.add_ann" href="#gatenlp.AnnotationSet.add_ann">add_ann</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.by_offset" href="#gatenlp.AnnotationSet.by_offset">by_offset</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.by_span" href="#gatenlp.AnnotationSet.by_span">by_span</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.changelog" href="#gatenlp.AnnotationSet.changelog">changelog</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.clear" href="#gatenlp.AnnotationSet.clear">clear</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.clone_anns" href="#gatenlp.AnnotationSet.clone_anns">clone_anns</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.coextensive" href="#gatenlp.AnnotationSet.coextensive">coextensive</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.contains" href="#gatenlp.AnnotationSet.contains">contains</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.copy" href="#gatenlp.AnnotationSet.copy">copy</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.covering" href="#gatenlp.AnnotationSet.covering">covering</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.deepcopy" href="#gatenlp.AnnotationSet.deepcopy">deepcopy</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.detach" href="#gatenlp.AnnotationSet.detach">detach</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.detach_from" href="#gatenlp.AnnotationSet.detach_from">detach_from</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.document" href="#gatenlp.AnnotationSet.document">document</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.end" href="#gatenlp.AnnotationSet.end">end</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.fast_iter" href="#gatenlp.AnnotationSet.fast_iter">fast_iter</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.first" href="#gatenlp.AnnotationSet.first">first</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.from_dict" href="#gatenlp.AnnotationSet.from_dict">from_dict</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.get" href="#gatenlp.AnnotationSet.get">get</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.immutable" href="#gatenlp.AnnotationSet.immutable">immutable</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.isdetached" href="#gatenlp.AnnotationSet.isdetached">isdetached</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.iter" href="#gatenlp.AnnotationSet.iter">iter</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.last" href="#gatenlp.AnnotationSet.last">last</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.length" href="#gatenlp.AnnotationSet.length">length</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.name" href="#gatenlp.AnnotationSet.name">name</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.overlapping" href="#gatenlp.AnnotationSet.overlapping">overlapping</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.remove" href="#gatenlp.AnnotationSet.remove">remove</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.reverse_iter" href="#gatenlp.AnnotationSet.reverse_iter">reverse_iter</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.size" href="#gatenlp.AnnotationSet.size">size</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.span" href="#gatenlp.AnnotationSet.span">span</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.start" href="#gatenlp.AnnotationSet.start">start</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.start_eq" href="#gatenlp.AnnotationSet.start_eq">start_eq</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.start_ge" href="#gatenlp.AnnotationSet.start_ge">start_ge</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.start_lt" href="#gatenlp.AnnotationSet.start_lt">start_lt</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.start_min_ge" href="#gatenlp.AnnotationSet.start_min_ge">start_min_ge</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.to_dict" href="#gatenlp.AnnotationSet.to_dict">to_dict</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.type_names" href="#gatenlp.AnnotationSet.type_names">type_names</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.with_type" href="#gatenlp.AnnotationSet.with_type">with_type</a></code></li>
<li><code><a title="gatenlp.AnnotationSet.within" href="#gatenlp.AnnotationSet.within">within</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.ChangeLog" href="#gatenlp.ChangeLog">ChangeLog</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.ChangeLog.add_handler" href="#gatenlp.ChangeLog.add_handler">add_handler</a></code></li>
<li><code><a title="gatenlp.ChangeLog.append" href="#gatenlp.ChangeLog.append">append</a></code></li>
<li><code><a title="gatenlp.ChangeLog.fixup_changes" href="#gatenlp.ChangeLog.fixup_changes">fixup_changes</a></code></li>
<li><code><a title="gatenlp.ChangeLog.format_to" href="#gatenlp.ChangeLog.format_to">format_to</a></code></li>
<li><code><a title="gatenlp.ChangeLog.from_dict" href="#gatenlp.ChangeLog.from_dict">from_dict</a></code></li>
<li><code><a title="gatenlp.ChangeLog.load" href="#gatenlp.ChangeLog.load">load</a></code></li>
<li><code><a title="gatenlp.ChangeLog.load_mem" href="#gatenlp.ChangeLog.load_mem">load_mem</a></code></li>
<li><code><a title="gatenlp.ChangeLog.pprint" href="#gatenlp.ChangeLog.pprint">pprint</a></code></li>
<li><code><a title="gatenlp.ChangeLog.save" href="#gatenlp.ChangeLog.save">save</a></code></li>
<li><code><a title="gatenlp.ChangeLog.save_mem" href="#gatenlp.ChangeLog.save_mem">save_mem</a></code></li>
<li><code><a title="gatenlp.ChangeLog.to_dict" href="#gatenlp.ChangeLog.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.Document" href="#gatenlp.Document">Document</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.Document.annset" href="#gatenlp.Document.annset">annset</a></code></li>
<li><code><a title="gatenlp.Document.annset_names" href="#gatenlp.Document.annset_names">annset_names</a></code></li>
<li><code><a title="gatenlp.Document.apply_changes" href="#gatenlp.Document.apply_changes">apply_changes</a></code></li>
<li><code><a title="gatenlp.Document.changelog" href="#gatenlp.Document.changelog">changelog</a></code></li>
<li><code><a title="gatenlp.Document.copy" href="#gatenlp.Document.copy">copy</a></code></li>
<li><code><a title="gatenlp.Document.deepcopy" href="#gatenlp.Document.deepcopy">deepcopy</a></code></li>
<li><code><a title="gatenlp.Document.features" href="#gatenlp.Document.features">features</a></code></li>
<li><code><a title="gatenlp.Document.from_dict" href="#gatenlp.Document.from_dict">from_dict</a></code></li>
<li><code><a title="gatenlp.Document.load" href="#gatenlp.Document.load">load</a></code></li>
<li><code><a title="gatenlp.Document.load_mem" href="#gatenlp.Document.load_mem">load_mem</a></code></li>
<li><code><a title="gatenlp.Document.name" href="#gatenlp.Document.name">name</a></code></li>
<li><code><a title="gatenlp.Document.remove_annset" href="#gatenlp.Document.remove_annset">remove_annset</a></code></li>
<li><code><a title="gatenlp.Document.repr_html" href="#gatenlp.Document.repr_html">repr_html</a></code></li>
<li><code><a title="gatenlp.Document.save" href="#gatenlp.Document.save">save</a></code></li>
<li><code><a title="gatenlp.Document.save_mem" href="#gatenlp.Document.save_mem">save_mem</a></code></li>
<li><code><a title="gatenlp.Document.text" href="#gatenlp.Document.text">text</a></code></li>
<li><code><a title="gatenlp.Document.to_dict" href="#gatenlp.Document.to_dict">to_dict</a></code></li>
<li><code><a title="gatenlp.Document.to_offset_type" href="#gatenlp.Document.to_offset_type">to_offset_type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>