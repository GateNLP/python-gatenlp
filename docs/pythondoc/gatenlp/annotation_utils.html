<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gatenlp.annotation_utils API documentation</title>
<meta name="description" content="Module defining several utility functions for annotating documents in various ways." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.annotation_utils</code></h1>
</header>
<section id="section-intro">
<p>Module defining several utility functions for annotating documents in various ways.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module defining several utility functions for annotating documents in various ways.
&#34;&#34;&#34;
from typing import List, Optional


def annotate_substrings(doc,
                        substrings: List[str],
                        outset_name: str = &#34;&#34;,
                        featureslist: Optional[List[str]] = None,
                        ann_type: str = &#34;Token&#34;,
                        annotate_gaps: bool = False,
                        gap_type: str = &#34;SpaceToken&#34;,
                        raise_if_unmatched: bool = True,
                        from_offset: int = 0,
                        to_offset: Optional[int] = None
                        ):
    &#34;&#34;&#34;
    Annotate the document by matching the text substrings in the substrings list to the corresponding locations
    in the text. If the features list is not None it must be of equal length as susbstrings and contain a dict
    of features to assign to the annotation to create. If annotate_gaps is True, the gaps between matched substrings
    will be annotated with the gap_type type.

    Args:
        doc: the document to annotate
        outset_name: the name of the output annotation set (default set)
        substrings: a list of substrings to match
        featureslist: if not None a list of dicts which are used as features for the annotations created
        ann_type: the type of the annotations created for matching substings
        annotate_gaps: if True, the gaps between matching substrings are annotated using the gap_type
        gap_type: the type to use for gap annotations
        raise_if_unmatched: if True and a substring in the substrings list cannot be matched, an exception is raised,
            otherwise, the unmatchable substring is ignored.
        from_offset: the offset where to start matching
        to_offset: the offset before which a matching substring must end (if None, the end of the document)

    Returns:
        the annotated doc, identical to the document passed
    &#34;&#34;&#34;
    outset = doc.annset(outset_name)
    if featureslist is not None:
        assert len(featureslist) == len(substrings)
    else:
        featureslist = [{} for _ in substrings]
    if to_offset is None:
        to_offset = len(doc.text)
    assert from_offset &lt; to_offset
    assert to_offset &lt;= len(doc.text)
    last_end = from_offset
    for substring, features in zip(substrings, featureslist):
        idx = doc.text.find(substring, last_end, to_offset)
        if idx &lt; 0:  # not found
            if raise_if_unmatched:
                raise Exception(f&#34;Unmatched string &#39;{substring}&#39; in {doc.text} from {last_end} to {to_offset}&#34;)
        else:
            end = idx+len(substring)
            if idx &gt; last_end and annotate_gaps:
                outset.add(last_end, idx, gap_type)
            if end &lt;= to_offset:
                outset.add(idx, end, ann_type, features=features)
            else:
                break
    return doc</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gatenlp.annotation_utils.annotate_substrings"><code class="name flex">
<span>def <span class="ident">annotate_substrings</span></span>(<span>doc, substrings: List[str], outset_name: str = '', featureslist: Optional[List[str]] = None, ann_type: str = 'Token', annotate_gaps: bool = False, gap_type: str = 'SpaceToken', raise_if_unmatched: bool = True, from_offset: int = 0, to_offset: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Annotate the document by matching the text substrings in the substrings list to the corresponding locations
in the text. If the features list is not None it must be of equal length as susbstrings and contain a dict
of features to assign to the annotation to create. If annotate_gaps is True, the gaps between matched substrings
will be annotated with the gap_type type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>doc</code></strong></dt>
<dd>the document to annotate</dd>
<dt><strong><code>outset_name</code></strong></dt>
<dd>the name of the output annotation set (default set)</dd>
<dt><strong><code>substrings</code></strong></dt>
<dd>a list of substrings to match</dd>
<dt><strong><code>featureslist</code></strong></dt>
<dd>if not None a list of dicts which are used as features for the annotations created</dd>
<dt><strong><code>ann_type</code></strong></dt>
<dd>the type of the annotations created for matching substings</dd>
<dt><strong><code>annotate_gaps</code></strong></dt>
<dd>if True, the gaps between matching substrings are annotated using the gap_type</dd>
<dt><strong><code>gap_type</code></strong></dt>
<dd>the type to use for gap annotations</dd>
<dt><strong><code>raise_if_unmatched</code></strong></dt>
<dd>if True and a substring in the substrings list cannot be matched, an exception is raised,
otherwise, the unmatchable substring is ignored.</dd>
<dt><strong><code>from_offset</code></strong></dt>
<dd>the offset where to start matching</dd>
<dt><strong><code>to_offset</code></strong></dt>
<dd>the offset before which a matching substring must end (if None, the end of the document)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the annotated doc, identical to the document passed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def annotate_substrings(doc,
                        substrings: List[str],
                        outset_name: str = &#34;&#34;,
                        featureslist: Optional[List[str]] = None,
                        ann_type: str = &#34;Token&#34;,
                        annotate_gaps: bool = False,
                        gap_type: str = &#34;SpaceToken&#34;,
                        raise_if_unmatched: bool = True,
                        from_offset: int = 0,
                        to_offset: Optional[int] = None
                        ):
    &#34;&#34;&#34;
    Annotate the document by matching the text substrings in the substrings list to the corresponding locations
    in the text. If the features list is not None it must be of equal length as susbstrings and contain a dict
    of features to assign to the annotation to create. If annotate_gaps is True, the gaps between matched substrings
    will be annotated with the gap_type type.

    Args:
        doc: the document to annotate
        outset_name: the name of the output annotation set (default set)
        substrings: a list of substrings to match
        featureslist: if not None a list of dicts which are used as features for the annotations created
        ann_type: the type of the annotations created for matching substings
        annotate_gaps: if True, the gaps between matching substrings are annotated using the gap_type
        gap_type: the type to use for gap annotations
        raise_if_unmatched: if True and a substring in the substrings list cannot be matched, an exception is raised,
            otherwise, the unmatchable substring is ignored.
        from_offset: the offset where to start matching
        to_offset: the offset before which a matching substring must end (if None, the end of the document)

    Returns:
        the annotated doc, identical to the document passed
    &#34;&#34;&#34;
    outset = doc.annset(outset_name)
    if featureslist is not None:
        assert len(featureslist) == len(substrings)
    else:
        featureslist = [{} for _ in substrings]
    if to_offset is None:
        to_offset = len(doc.text)
    assert from_offset &lt; to_offset
    assert to_offset &lt;= len(doc.text)
    last_end = from_offset
    for substring, features in zip(substrings, featureslist):
        idx = doc.text.find(substring, last_end, to_offset)
        if idx &lt; 0:  # not found
            if raise_if_unmatched:
                raise Exception(f&#34;Unmatched string &#39;{substring}&#39; in {doc.text} from {last_end} to {to_offset}&#34;)
        else:
            end = idx+len(substring)
            if idx &gt; last_end and annotate_gaps:
                outset.add(last_end, idx, gap_type)
            if end &lt;= to_offset:
                outset.add(idx, end, ann_type, features=features)
            else:
                break
    return doc</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp" href="index.html">gatenlp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gatenlp.annotation_utils.annotate_substrings" href="#gatenlp.annotation_utils.annotate_substrings">annotate_substrings</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>