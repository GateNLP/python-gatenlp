<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev16+g8c2bb0d.d20201028" />
<title>gatenlp.document API documentation</title>
<meta name="description" content="Module that implements the Document class for representing gatenlp documents with features and annotation sets." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.document</code></h1>
</header>
<section id="section-intro">
<p>Module that implements the Document class for representing gatenlp documents with features and annotation sets.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that implements the Document class for representing gatenlp documents with features and annotation sets.
&#34;&#34;&#34;

from typing import KeysView
from collections import defaultdict
from gatenlp.annotation_set import AnnotationSet
from gatenlp.annotation import Annotation
from gatenlp.changelog import *
from gatenlp.features import Features
from gatenlp.utils import in_notebook
import logging
import importlib
import copy as lib_copy
from gatenlp.gatenlpconfig import gatenlpconfig

logging.basicConfig()
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


class Document:
    &#34;&#34;&#34;Represent a GATE document. This is different from the original Java GATE representation in several ways:

    * the text is not mutable and can only be set at creation time, so there is no &#34;edit&#34; method

    * as a feature bearer, all the methods to set, get and manipulate features are part of this class, there is
      no separate &#34;FeatureMap&#34; to store them

    * does not support listener callbacks
    * there is no separate abstraction for &#34;content&#34;, the only content possible is text which is a unicode string
      that can be acessed with the &#34;text()&#34; method
    * Spans of text can be directly accessed using doc[from:to]
    * Features may only have string keys and values which can be json-serialised
    * Annotation offsets by default are number of Unicde code points, this is different from Java where the offsets
      are UTF-16 Unicode code units
    * Offsets of all annotations can be changed from/to Java (from python index of unicode codepoint to Java index
      of UTF-16 code unit and back)
    * No part of the document has to be present, not even the text (this allows saving just the annotations separately
      from the text)
    * Once the text has been set, it is immutable (no support to edit text and change annotation offsets accordingly)

    Args:
      text: the text of the document. The text can be None to indicate that no initial text should be set. Once
    the text has been set for a document, it is immutable and cannot be changed.
      features: the initial document features to set, a sequence of key/value tuples
      changelog: a ChangeLog instance to use to log changes.

    Returns:

    &#34;&#34;&#34;

    def __init__(self, text: str = None, features=None, changelog: ChangeLog = None):
        if text is not None:
            assert isinstance(text, str)
        if changelog is not None:
            assert isinstance(changelog, ChangeLog)
        self._changelog = changelog
        self._features = Features(features, logger=self._log_feature_change)
        self._annotation_sets = dict()
        self._text = text
        self.offset_type = OFFSET_TYPE_PYTHON
        self._name = &#34;&#34;

    @property
    def name(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        return self._name

    @name.setter
    def name(self, val):
        &#34;&#34;&#34;

        Args:
          val:

        Returns:

        &#34;&#34;&#34;
        if val is None:
            val = &#34;&#34;
        if not isinstance(val, str):
            raise Exception(&#34;Name must be a string&#34;)
        self._name = val
        if self._changelog is not None:
            ch = {&#34;command&#34;: &#34;name:set&#34;}
            ch[&#34;name&#34;] = val
            self._changelog.append(ch)

    def _ensure_type_python(self) -&gt; None:
        &#34;&#34;&#34; &#34;&#34;&#34;
        if self.offset_type != OFFSET_TYPE_PYTHON:
            raise Exception(
                &#34;Document cannot be used if it is not type PYTHON, use to_type(OFFSET_TYPE_PYTHON) first&#34;
            )

    def _fixup_annotations(self, method: Callable) -&gt; None:
        &#34;&#34;&#34;

        Args:
          method: Callable:

        Returns:

        &#34;&#34;&#34;
        annset_names = self._annotation_sets.keys()
        for annset_name in annset_names:
            annset = self._annotation_sets[annset_name]
            if annset._annotations is not None:
                for ann in annset._annotations.values():
                    ann._start = method(ann._start)
                    ann._end = method(ann._end)

    def to_offset_type(self, offsettype: str) -&gt; OffsetMapper:
        &#34;&#34;&#34;Convert all the offsets of all the annotations in this document to the
        required type, either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON. If the offsets
        are already of that type, this does nothing.

        NOTE: if the document has a ChangeLog, it is NOT also converted!

        The method returns the offset mapper if anything actually was converted,
        otherwise None.

        Args:
          offsettype: either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON
          offsettype: str:

        Returns:
          offset mapper or None

        &#34;&#34;&#34;
        om = None
        if offsettype == self.offset_type:
            return
        if offsettype == OFFSET_TYPE_JAVA and self.offset_type == OFFSET_TYPE_PYTHON:
            # convert from currently python to java
            om = OffsetMapper(self._text)
            self._fixup_annotations(om.convert_to_java)
            self.offset_type = OFFSET_TYPE_JAVA
        elif offsettype == OFFSET_TYPE_PYTHON and self.offset_type == OFFSET_TYPE_JAVA:
            # convert from currently java to python
            om = OffsetMapper(self._text)
            self._fixup_annotations(om.convert_to_python)
            self.offset_type = OFFSET_TYPE_PYTHON
        else:
            raise Exception(&#34;Odd offset type&#34;)
        return om

    def apply_changes(self, changes, handle_existing_anns=ADDANN_ADD_WITH_NEW_ID):
        &#34;&#34;&#34;Apply changes from a ChangeLog to this document. `changes` can be a ChangeLog instance,
        a sequence of change objects (dicts) as stored in a ChangeLog instance, or a single change object.

        The document is modified in-place.

        Args:
          changes: one or more changes
          handle_existing_anns: what to do if the change from the changelog tries to add an annotation
        with an annotation id that already exists in the target set. (Default value = ADDANN_ADD_WITH_NEW_ID)

        Returns:

        &#34;&#34;&#34;
        if isinstance(changes, dict):
            changes = [changes]
        elif isinstance(changes, ChangeLog):
            changes = changes.changes
        for change in changes:
            cmd = change.get(&#34;command&#34;)
            fname = change.get(&#34;feature&#34;)
            fvalue = change.get(&#34;value&#34;)
            features = change.get(&#34;features&#34;)
            sname = change.get(&#34;set&#34;)
            annid = change.get(&#34;id&#34;)
            if cmd is None:
                raise Exception(&#34;Change without field &#39;command&#39;&#34;)
            if cmd == ACTION_ADD_ANNSET:
                assert sname is not None
                self.annset(sname)
            elif cmd == ACTION_ADD_ANN:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                ann = anns.get(annid)
                start = change.get(&#34;start&#34;)
                end = change.get(&#34;end&#34;)
                anntype = change.get(&#34;type&#34;)

                if ann is None:
                    anns.add(start, end, anntype, annid=annid, features=features)
                else:
                    if handle_existing_anns == ADDANN_IGNORE:
                        pass
                    elif handle_existing_anns == ADDANN_ADD_WITH_NEW_ID:
                        anns.add(start, end, anntype)
                    elif handle_existing_anns == ADDANN_REPLACE_ANNOTATION:
                        anns.remove(annid)
                        anns.add(start, end, anntype, annid)
                    elif handle_existing_anns == ADDANN_UPDATE_FEATURES:
                        ann.features.update(features)
                    elif handle_existing_anns == ADDANN_REPLACE_FEATURES:
                        ann.features.clear()
                        ann.features.update(features)
                    elif handle_existing_anns == ADDANN_ADD_NEW_FEATURES:
                        fns = ann.feature_names()
                        for f in features.keys():
                            if f not in fns:
                                ann.features[f] = features[f]

            elif cmd == ACTION_CLEAR_ANNS:
                assert sname is not None
                anns = self.annset(sname)
                anns.clear()
            elif cmd == ACTION_CLEAR_ANN_FEATURES:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                ann = anns.get(annid)
                if ann is not None:
                    ann.features.clear()
                else:
                    pass  # ignore, could happen with a detached annotation
            elif cmd == ACTION_CLEAR_DOC_FEATURES:
                self.features.clear()
            elif cmd == ACTION_SET_ANN_FEATURE:
                assert fname is not None
                assert sname is not None
                assert annid is not None
                ann = self.annset(sname).get(annid)
                ann.features[fname] = fvalue
            elif cmd == ACTION_DEL_ANN_FEATURE:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                ann = anns.get(annid)
                if ann is not None:
                    if fname is not None:
                        ann.features.pop(fname, None)
                else:
                    pass  # ignore, could happen with a detached annotation
            elif cmd == ACTION_DEL_DOC_FEATURE:
                assert fname is not None
                self.features.pop(fname, None)
            elif cmd == ACTION_DEL_ANN:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                anns.remove(annid)
            elif cmd == ACTION_SET_DOC_FEATURE:
                assert fname is not None
                self.features[fname] = fvalue
            elif cmd == ACTION_CLEAR_DOC_FEATURES:
                self._features.clear()
            elif cmd == ACTION_DEL_DOC_FEATURE:
                assert fname is not None
                del self._features[fname]
            else:
                raise Exception(&#34;Unknown ChangeLog action: &#34;, cmd)

    @property
    def features(self):
        &#34;&#34;&#34;Accesses the features as a FeatureViewer instance. Changes made on this object are
        reflected in the document and recorded in the change log, if there is one.

        :return: A FeatureViewer view of the document features.

        Args:

        Returns:

        &#34;&#34;&#34;
        return self._features

    @property
    def changelog(self):
        &#34;&#34;&#34;Get the ChangeLog or None if no ChangeLog has been set.

        :return: the changelog

        Args:

        Returns:

        &#34;&#34;&#34;
        return self._changelog

    @changelog.setter
    def changelog(self, chlog):
        &#34;&#34;&#34;Make the document use the given changelog to record all changes
        from this moment on.

        Args:
          chlog: the new changelog to use or None to not use any

        Returns:
          the changelog used previously or None

        &#34;&#34;&#34;
        oldchlog = self._changelog
        self._changelog = chlog
        return oldchlog

    @property
    def text(self) -&gt; str:
        &#34;&#34;&#34;Get the text of the document. For a partial document, the text may be None.

        :return: the text of the document

        Args:

        Returns:

        &#34;&#34;&#34;
        self._ensure_type_python()
        return self._text

    @text.setter
    def text(self, value: str) -&gt; None:
        &#34;&#34;&#34;Set the text of the document. This is only possible as long as it has not been set
        yet, after that, the text is immutable.

        Args:
          value: the text for the document
          value: str:

        Returns:

        &#34;&#34;&#34;
        if self._text is None:
            self._text = value
        else:
            raise NotImplementedError(&#34;Text cannot be modified&#34;)

    def _log_feature_change(
        self, command: str, feature: str = None, value=None
    ) -&gt; None:
        &#34;&#34;&#34;

        Args:
          command: str:
          feature: str:  (Default value = None)
          value:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if self._changelog is None:
            return
        command = &#34;doc-&#34; + command
        ch = {&#34;command&#34;: command}
        if command == &#34;doc-feature:set&#34;:
            ch[&#34;feature&#34;] = feature
            ch[&#34;value&#34;] = value
        self._changelog.append(ch)

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Return the length of the text.
        Note: this will convert the type of the document to python!

        :return: the length of the document text
        &#34;&#34;&#34;
        self._ensure_type_python()
        if self._text is None:
            return 0
        else:
            return len(self._text)

    def __getitem__(self, span) -&gt; str:
        &#34;&#34;&#34;
        Get the text for the given span.

        :param span: a single number, an offset range of the form from:to or an annotation.
        If annotation, uses the annotation&#39;s offset span.
        :return: the text of the span
        &#34;&#34;&#34;
        self._ensure_type_python()
        if isinstance(span, Annotation):
            return self.text[span._start : span._end]
        if isinstance(span, AnnotationSet):
            return self.text[span.start() : span.end()]
        if hasattr(span, &#34;start&#34;) and hasattr(span, &#34;end&#34;):
            return self.text[span.start, span.end]
        return self.text[span]

    def annset(self, name: str = &#34;&#34;) -&gt; AnnotationSet:
        &#34;&#34;&#34;Get the named annotation set, if name is not given or the empty string, the default annotation set.
        If the annotation set does not already exist, it is created.

        Args:
          name: the annotation set name, the empty string is used for the &#34;default annotation set&#34;.
          name: str:  (Default value = &#34;&#34;)

        Returns:
          the specified annotation set.

        &#34;&#34;&#34;
        self._ensure_type_python()
        if name not in self._annotation_sets:
            annset = AnnotationSet(owner_doc=self, name=name)
            self._annotation_sets[name] = annset
            if self._changelog:
                self._changelog.append({&#34;command&#34;: &#34;annotations:add&#34;, &#34;set&#34;: name})
            return annset
        else:
            return self._annotation_sets[name]

    def annset_names(self) -&gt; KeysView[str]:
        &#34;&#34;&#34;

        Args:

        Returns:
          :return: annotation set names

        &#34;&#34;&#34;
        self._ensure_type_python()
        return list(self._annotation_sets.keys())

    def remove_annset(self, name: str):
        &#34;&#34;&#34;Completely remove the annotation set.

        Args:
          name: name of the annotation set to remove
          name: str:

        Returns:

        &#34;&#34;&#34;
        if name not in self._annotation_sets:
            raise Exception(f&#34;AnnotationSet with name {name} does not exist&#34;)
        del self._annotation_sets[name]
        if self._changelog:
            self._changelog.append({&#34;command&#34;: &#34;annotations:remove&#34;, &#34;set&#34;: name})

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        String representation of the document, showing all content.

        :return: string representation
        &#34;&#34;&#34;
        return &#34;Document({},features={},anns={})&#34;.format(
            self.text, self._features, self._annotation_sets.__repr__()
        )

    def __str__(self) -&gt; str:
        asets = (
            &#34;[&#34;
            + &#34;,&#34;.join([f&#34;&#39;{k}&#39;:{len(v)}&#34; for k, v in self._annotation_sets.items()])
            + &#34;]&#34;
        )
        return &#34;Document({},features={},anns={})&#34;.format(
            self.text, self._features, asets
        )

    def to_dict(self, offset_type=None, annsets=None, **kwargs):
        &#34;&#34;&#34;Convert this instance to a dictionary that can be used to re-create the instance with
        from_dict.
        NOTE: if there is an active changelog, it is not included in the output as this
        field is considered a transient field!

        Args:
          offset_type: convert to the given offset type on the fly (Default value = None)
          annsets: if not None, a list of annotation set/type specifications: each element
              is either a string, the name of the annotation set to include, or a tuple where the
              first element is the annotation set name and the second element is either a type name or
              a list of type names. The same annotation set name should not be used in more than one
              specification.
          **kwargs:

        Returns:
          the dictionary representation of this instance

        &#34;&#34;&#34;
        # if the specified offset type is equal to what we have, do nothing, otherwise
        # create an offset mapper and pass it down to where we actually convert the annotations

        om = None
        if offset_type is not None:
            assert offset_type == OFFSET_TYPE_JAVA or offset_type == OFFSET_TYPE_PYTHON
            if offset_type != self.offset_type:
                if self._text is not None:
                    om = OffsetMapper(self._text)
                    kwargs[&#34;offset_mapper&#34;] = om
                    kwargs[&#34;offset_type&#34;] = offset_type
        else:
            offset_type = self.offset_type

        # create the annotation sets map
        if annsets is not None:
            annsets_dict = {}
            for spec in annsets:
                if isinstance(spec, str):
                    annsets_dict[spec] = self._annotation_sets[spec].to_dict(**kwargs)
                else:
                    setname, types = spec
                    if isinstance(types, str):
                        types = [types]
                    annsets_dict[setname] = self._annotation_sets[setname].to_dict(anntypes=types, **kwargs)
        else:
            annsets_dict = {
                name: aset.to_dict(**kwargs)
                for name, aset in self._annotation_sets.items()
            }

        return {
            &#34;annotation_sets&#34;: annsets_dict,
            &#34;text&#34;: self._text,
            &#34;features&#34;: self._features.to_dict(),
            &#34;offset_type&#34;: offset_type,
            &#34;name&#34;: self.name,
        }

    @staticmethod
    def from_dict(dictrepr, **kwargs):
        &#34;&#34;&#34;Return a Document instance as represented by the dictionary dictrepr.

        Args:
          dictrepr: return: the initialized Document instance
          **kwargs:

        Returns:
          the initialized Document instance

        &#34;&#34;&#34;
        feats = dictrepr.get(&#34;features&#34;)
        doc = Document(dictrepr.get(&#34;text&#34;), features=feats)
        doc.name = dictrepr.get(&#34;name&#34;)
        doc.offset_type = dictrepr.get(&#34;offset_type&#34;)
        if (
            doc.offset_type != OFFSET_TYPE_JAVA
            and doc.offset_type != OFFSET_TYPE_PYTHON
        ):
            raise Exception(&#34;Invalid offset type, cannot load: &#34;, doc.offset_type)
        annsets = {
            name: AnnotationSet.from_dict(adict, owner_doc=doc)
            for name, adict in dictrepr.get(&#34;annotation_sets&#34;).items()
        }
        doc._annotation_sets = annsets
        return doc

    def save(
        self,
        destination,
        fmt=None,
        offset_type=None,
        mod=&#34;gatenlp.serialization.default&#34;,
        annsets=None,
        **kwargs,
    ):
        &#34;&#34;&#34;Save the document to the destination file.

        Args:
          destination: either a file name or something that has a write(string) method.
          fmt: serialization format, by default the format is inferred from the file extension.
          offset_type: store using the given offset type or keep the current if None (Default value = None)
          mod: module where the document saver is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
          annsets: if not None, a list of annotation set names or tuples of set name and a list of annotation types
              to include in the serialized document.
          kwargs: additional parameters for the document saver.
          **kwargs:
        &#34;&#34;&#34;
        if annsets is not None:
            kwargs[&#34;annsets&#34;] = annsets
        if fmt is None or isinstance(fmt, str):
            m = importlib.import_module(mod)
            saver = m.get_document_saver(destination, fmt)
            saver(Document, self, to_ext=destination, offset_type=offset_type, **kwargs)
        else:
            # assume fmt is a callable to get used directly
            fmt(Document, self, to_ext=destination, offset_type=offset_type, **kwargs)

    def save_mem(
        self,
        fmt=&#34;json&#34;,
        offset_type=None,
        mod=&#34;gatenlp.serialization.default&#34;,
        **kwargs,
    ):
        &#34;&#34;&#34;Serialize to a string or bytes in the given format.

        Args:
          fmt: serialization format to use. (Default value = &#34;json&#34;)
          offset_type: store using the given offset type or keep the current if None (Default value = None)
          mod: module where the document saver is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional parameters for the format.
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        if not fmt:
            raise Exception(&#34;Format required.&#34;)
        if isinstance(fmt, str):
            m = importlib.import_module(mod)
            saver = m.get_document_saver(None, fmt)
            return saver(Document, self, to_mem=True, offset_type=offset_type, **kwargs)
        else:
            fmt(Document, self, to_mem=True, offset_type=offset_type, **kwargs)

    @staticmethod
    def load(source, fmt=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;Load or import a document from the given source. The source can be a file path or file name or
        a URL. If the type of the source is str, then if it starts with &#34;http[s]://&#34; it will get treated
        as a URL. In order to deliberatly use a file instead of a URL, create a pathlib Path, in order to
        deliberately use URL instead of a file parse the URL using urllib.

        Example: `Document.load(urllib.parse.urlparse(someurl), fmt=theformat)`

        Example: `Document.load(pathlib.Path(somepath), fmt=theformat)`

        NOTE: the offset type of the document is always converted to PYTHON when loading!

        Args:
          source: the URL or file path to load from.
          fmt: the format of the source. By default the format is inferred by the file extension.
        The format can be a format memnonic like &#34;json&#34;, &#34;html&#34;, or a known mime type like &#34;text/bdocjs&#34;.
          mod: the name of a module where the document loader is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional format specific keyword arguments to pass to the loader
          **kwargs:

        Returns:
          the loaded document

        &#34;&#34;&#34;
        if fmt is None or isinstance(fmt, str):
            m = importlib.import_module(mod)
            loader = m.get_document_loader(source, fmt)
            doc = loader(Document, from_ext=source, **kwargs)
        else:
            doc = fmt(Document, from_ext=source, **kwargs)
        if doc.offset_type == OFFSET_TYPE_JAVA:
            doc.to_offset_type(OFFSET_TYPE_PYTHON)
        return doc

    @staticmethod
    def load_mem(source, fmt=&#34;json&#34;, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;Create a document from the in-memory serialization in source. Source can be a string or
        bytes, depending on the format.

        Note: the offset type is always converted to PYTHON when loading!

        Args:
          source: the string/bytes to deserialize
          fmt: the format (Default value = &#34;json&#34;)
          mod: the name of the module where the loader is implemented (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional arguments to pass to the loader
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        if not fmt:
            raise Exception(&#34;Format required.&#34;)
        if isinstance(fmt, str):
            m = importlib.import_module(mod)
            loader = m.get_document_loader(None, fmt)
            doc = loader(Document, from_mem=source, **kwargs)
        else:
            doc = fmt(Document, from_mem=source, **kwargs)
        if doc.offset_type == OFFSET_TYPE_JAVA:
            doc.to_offset_type(OFFSET_TYPE_PYTHON)
        return doc

    def __copy__(self):
        &#34;&#34;&#34;
        Creates a shallow copy except the changelog which is set to None.

        :return: shallow copy of the document
        &#34;&#34;&#34;
        doc = Document(self._text)
        doc._annotation_sets = self._annotation_sets
        doc.offset_type = self.offset_type
        doc._features = self._features.copy()
        return doc

    def copy(self):
        &#34;&#34;&#34;Creates a shallow copy except the changelog which is set to None.

        :return: shallow copy of the document

        Args:

        Returns:

        &#34;&#34;&#34;
        return self.__copy__()

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        Creates a deep copy, except the changelog which is set to None.

        :param memo: the memoization dictionary to use.

        :return: a deep copy of the document.
        &#34;&#34;&#34;
        if self._features is not None:
            fts = lib_copy.deepcopy(self._features.to_dict(), memo)
        else:
            fts = None
        doc = Document(self._text, features=fts)
        doc._changelog = None
        doc._annotation_sets = lib_copy.deepcopy(self._annotation_sets, memo)
        doc.offset_type = self.offset_type
        return doc

    def deepcopy(self, memo=None):
        &#34;&#34;&#34;Creates a deep copy, except the changelog which is set to None.

        Args:
          memo: the memoization dictionary to use.

        Returns:
          a deep copy of the document.

        &#34;&#34;&#34;
        return lib_copy.deepcopy(self, memo=memo)

    def _repr_html_(self):
        &#34;&#34;&#34;
        Render function for Jupyter notebooks. Returns the html-ann-viewer HTML.
        This renders the HTML for notebook, for offline mode, but does not add the JS
        but instead initializes the JS in the notebook unless gatenlp.init_notebook()
        has bee called already.
        &#34;&#34;&#34;
        return self._notebook_show()

    # TODO: maybe allow manual selection of how to show the document, e.g. also by
    # writing to a tmp file and browsing in a browser, or pprint etc.
    def show(self, htmlid=None, annsets=None):
        &#34;&#34;&#34;
        Show the document in a Jupyter notebook. This allows to assign a specific htmlid so
        the generated HTML can be directly styled afterwards.
        This directly sends the rendered document to the cell (no display/HTML necessary).

        Args:
            htmlid: the HTML id prefix to use for classes and element ids.
            annsets: if not None, a list of annotation set/type specifications. Each element is either
                the name of a set to fully include, or a tuple with the name of the set as the first element
                and with a single type name or a list of type names as the second element

        &#34;&#34;&#34;
        if in_notebook():
            self._notebook_show(htmlid=htmlid, display=True, annsets=annsets)
        else:
            return self.__str__()

    def _notebook_show(self, htmlid=None, display=False, annsets=None):
        from gatenlp.gatenlpconfig import gatenlpconfig
        from gatenlp.serialization.default import HtmlAnnViewerSerializer
        from IPython.display import display_html

        if not gatenlpconfig.notebook_js_initialized:
            HtmlAnnViewerSerializer.init_javscript()
            gatenlpconfig.notebook_js_initialized = True
        html = self.save_mem(
            fmt=&#34;html-ann-viewer&#34;,
            notebook=True,
            add_js=False,
            offline=True,
            htmlid=htmlid,
            annsets=annsets,
        )
        if display:
            display_html(html, raw=True)
        else:
            return html


class MultiDocument(Document):
    &#34;&#34;&#34;
    NOTE: This is just experimental for now, DO NOT USE!

    A MultiDocument can store more than one document, each identified by their ids. One of those
    documents is always the &#34;active&#34; one and the MultiDocument can be used just like a Document
    with that content. In addition, there are methods to make each of the other documents active
    and to create mappings between annotations of pairs of documents.

    An AnnotationMapping is something that maps annotations to annotations, either for the same
    document, from the same or different sets, of for different documents. Once an annotation
    becomes part of a mapping, that annotation is becoming immutable. Even if the original annotation
    in the document changes or gets removed, the mapping retains the original copy of the annotation
    until the mapping is modified or removed.
    &#34;&#34;&#34;

    # TODO: ALL necessary fields of the document must be references of mutable objects so that
    # if something is changed for the active document the one stored in the documents map is
    # really updated as well, or we must override the updating method to change both!
    # A better way could be to override all methods to always directly change the document in the
    # documents map, and simply pass on all calls to the activated document.
    # In that case, to_dict and from_dict would actually generate the fields for normal document
    # readers and ignore them on restore
    def __init__(
        self, text: str = None, features=None, changelog: ChangeLog = None, docid=0
    ):
        logger.warning(&#34;Experimental feature, DO NOT USE&#34;)
        self.documents = {}  # map from document id to document
        self._mappings = None  # TODO: we need to implement this
        self._docid = None
        doc = Document(text, features=features, changelog=changelog)
        self.documents[docid] = doc
        self.activate(docid)

    @property
    def docid(self):
        return self._docid

    def activate(self, docid=0):
        if docid not in self.documents:
            raise Exception(f&#34;Cannot activate id {docid}, not in MultiDocument&#34;)
        doc = self.documents[docid]
        self._changelog = doc._changelog
        self._features = doc._features
        self._annotation_sets = doc._annotation_sets
        self._text = doc._text
        self.offset_type = OFFSET_TYPE_PYTHON
        self._name = doc._name
        self._docid = docid

    def add_document(self, doc, docid=None, activate=False):
        if docid is None:
            docid = len(self.documents)
        elif docid in self.documents:
            raise Exception(
                f&#34;Cannot add document to MultiDocument, id {docid} already exists&#34;
            )
        self.documents[docid] = doc
        if activate:
            self.activate(docid)
        return docid

    def to_dict(self, offset_type=None, **kwargs):
        # TODO: check what to do with the offset type parameter!
        # The basic strategy is that we simply create the dictionary for the active document plus
        # the entries for the documents map and the annotation mappings. That way, any reader of the
        # dict representation which just ignored unknown fields can still read this in as a normal
        # document from the active document.
        # The drawback is that the active document is represented twice, but OK
        thedict = {
            &#34;annotation_sets&#34;: {
                name: aset.to_dict() for name, aset in self._annotation_sets.items()
            },
            &#34;text&#34;: self._text,
            &#34;features&#34;: self._features.to_dict(),
            &#34;offset_type&#34;: self.offset_type,
            &#34;name&#34;: self.name,
        }
        thedict[&#34;documents&#34;] = {
            docid: doc.to_dict() for docid, doc in self.documents.items()
        }
        thedict[&#34;docid&#34;] = self._docid
        thedict[&#34;mappings&#34;] = self._mappings
        return thedict

    @staticmethod
    def from_dict(dictrepr, **kwargs):
        &#34;&#34;&#34;
        Create a MultiDocument from the dictionary representation.

        Args:
            dictrepr: the dictionary representation
            **kwargs: additional kwargs to pass on

        Returns:

        &#34;&#34;&#34;
        feats = dictrepr.get(&#34;features&#34;)
        docid = dictrepr.get(&#34;docid&#34;)
        doc = MultiDocument(dictrepr.get(&#34;text&#34;), features=feats, docid=docid)
        doc.name = dictrepr.get(&#34;name&#34;)
        doc.offset_type = dictrepr.get(&#34;offset_type&#34;)
        if (
            doc.offset_type != OFFSET_TYPE_JAVA
            and doc.offset_type != OFFSET_TYPE_PYTHON
        ):
            raise Exception(&#34;Invalid offset type, cannot load: &#34;, doc.offset_type)
        annsets = {
            name: AnnotationSet.from_dict(adict, owner_doc=doc)
            for name, adict in dictrepr.get(&#34;annotation_sets&#34;).items()
        }
        doc._annotation_sets = annsets
        doc.documents = {
            did: Document.from_dict(d)
            for did, d in dictrepr.get(&#34;documents&#34;, {}).items()
        }
        # TODO: get the mappings back!
        return doc</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.document.Document"><code class="flex name class">
<span>class <span class="ident">Document</span></span>
<span>(</span><span>text: str = None, features=None, changelog: <a title="gatenlp.changelog.ChangeLog" href="changelog.html#gatenlp.changelog.ChangeLog">ChangeLog</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a GATE document. This is different from the original Java GATE representation in several ways:</p>
<ul>
<li>
<p>the text is not mutable and can only be set at creation time, so there is no "edit" method</p>
</li>
<li>
<p>as a feature bearer, all the methods to set, get and manipulate features are part of this class, there is
no separate "FeatureMap" to store them</p>
</li>
<li>
<p>does not support listener callbacks</p>
</li>
<li>there is no separate abstraction for "content", the only content possible is text which is a unicode string
that can be acessed with the "text()" method</li>
<li>Spans of text can be directly accessed using doc[from:to]</li>
<li>Features may only have string keys and values which can be json-serialised</li>
<li>Annotation offsets by default are number of Unicde code points, this is different from Java where the offsets
are UTF-16 Unicode code units</li>
<li>Offsets of all annotations can be changed from/to Java (from python index of unicode codepoint to Java index
of UTF-16 code unit and back)</li>
<li>No part of the document has to be present, not even the text (this allows saving just the annotations separately
from the text)</li>
<li>Once the text has been set, it is immutable (no support to edit text and change annotation offsets accordingly)</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>the text of the document. The text can be None to indicate that no initial text should be set. Once</dd>
</dl>
<p>the text has been set for a document, it is immutable and cannot be changed.
features: the initial document features to set, a sequence of key/value tuples
changelog: a ChangeLog instance to use to log changes.</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Document:
    &#34;&#34;&#34;Represent a GATE document. This is different from the original Java GATE representation in several ways:

    * the text is not mutable and can only be set at creation time, so there is no &#34;edit&#34; method

    * as a feature bearer, all the methods to set, get and manipulate features are part of this class, there is
      no separate &#34;FeatureMap&#34; to store them

    * does not support listener callbacks
    * there is no separate abstraction for &#34;content&#34;, the only content possible is text which is a unicode string
      that can be acessed with the &#34;text()&#34; method
    * Spans of text can be directly accessed using doc[from:to]
    * Features may only have string keys and values which can be json-serialised
    * Annotation offsets by default are number of Unicde code points, this is different from Java where the offsets
      are UTF-16 Unicode code units
    * Offsets of all annotations can be changed from/to Java (from python index of unicode codepoint to Java index
      of UTF-16 code unit and back)
    * No part of the document has to be present, not even the text (this allows saving just the annotations separately
      from the text)
    * Once the text has been set, it is immutable (no support to edit text and change annotation offsets accordingly)

    Args:
      text: the text of the document. The text can be None to indicate that no initial text should be set. Once
    the text has been set for a document, it is immutable and cannot be changed.
      features: the initial document features to set, a sequence of key/value tuples
      changelog: a ChangeLog instance to use to log changes.

    Returns:

    &#34;&#34;&#34;

    def __init__(self, text: str = None, features=None, changelog: ChangeLog = None):
        if text is not None:
            assert isinstance(text, str)
        if changelog is not None:
            assert isinstance(changelog, ChangeLog)
        self._changelog = changelog
        self._features = Features(features, logger=self._log_feature_change)
        self._annotation_sets = dict()
        self._text = text
        self.offset_type = OFFSET_TYPE_PYTHON
        self._name = &#34;&#34;

    @property
    def name(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        return self._name

    @name.setter
    def name(self, val):
        &#34;&#34;&#34;

        Args:
          val:

        Returns:

        &#34;&#34;&#34;
        if val is None:
            val = &#34;&#34;
        if not isinstance(val, str):
            raise Exception(&#34;Name must be a string&#34;)
        self._name = val
        if self._changelog is not None:
            ch = {&#34;command&#34;: &#34;name:set&#34;}
            ch[&#34;name&#34;] = val
            self._changelog.append(ch)

    def _ensure_type_python(self) -&gt; None:
        &#34;&#34;&#34; &#34;&#34;&#34;
        if self.offset_type != OFFSET_TYPE_PYTHON:
            raise Exception(
                &#34;Document cannot be used if it is not type PYTHON, use to_type(OFFSET_TYPE_PYTHON) first&#34;
            )

    def _fixup_annotations(self, method: Callable) -&gt; None:
        &#34;&#34;&#34;

        Args:
          method: Callable:

        Returns:

        &#34;&#34;&#34;
        annset_names = self._annotation_sets.keys()
        for annset_name in annset_names:
            annset = self._annotation_sets[annset_name]
            if annset._annotations is not None:
                for ann in annset._annotations.values():
                    ann._start = method(ann._start)
                    ann._end = method(ann._end)

    def to_offset_type(self, offsettype: str) -&gt; OffsetMapper:
        &#34;&#34;&#34;Convert all the offsets of all the annotations in this document to the
        required type, either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON. If the offsets
        are already of that type, this does nothing.

        NOTE: if the document has a ChangeLog, it is NOT also converted!

        The method returns the offset mapper if anything actually was converted,
        otherwise None.

        Args:
          offsettype: either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON
          offsettype: str:

        Returns:
          offset mapper or None

        &#34;&#34;&#34;
        om = None
        if offsettype == self.offset_type:
            return
        if offsettype == OFFSET_TYPE_JAVA and self.offset_type == OFFSET_TYPE_PYTHON:
            # convert from currently python to java
            om = OffsetMapper(self._text)
            self._fixup_annotations(om.convert_to_java)
            self.offset_type = OFFSET_TYPE_JAVA
        elif offsettype == OFFSET_TYPE_PYTHON and self.offset_type == OFFSET_TYPE_JAVA:
            # convert from currently java to python
            om = OffsetMapper(self._text)
            self._fixup_annotations(om.convert_to_python)
            self.offset_type = OFFSET_TYPE_PYTHON
        else:
            raise Exception(&#34;Odd offset type&#34;)
        return om

    def apply_changes(self, changes, handle_existing_anns=ADDANN_ADD_WITH_NEW_ID):
        &#34;&#34;&#34;Apply changes from a ChangeLog to this document. `changes` can be a ChangeLog instance,
        a sequence of change objects (dicts) as stored in a ChangeLog instance, or a single change object.

        The document is modified in-place.

        Args:
          changes: one or more changes
          handle_existing_anns: what to do if the change from the changelog tries to add an annotation
        with an annotation id that already exists in the target set. (Default value = ADDANN_ADD_WITH_NEW_ID)

        Returns:

        &#34;&#34;&#34;
        if isinstance(changes, dict):
            changes = [changes]
        elif isinstance(changes, ChangeLog):
            changes = changes.changes
        for change in changes:
            cmd = change.get(&#34;command&#34;)
            fname = change.get(&#34;feature&#34;)
            fvalue = change.get(&#34;value&#34;)
            features = change.get(&#34;features&#34;)
            sname = change.get(&#34;set&#34;)
            annid = change.get(&#34;id&#34;)
            if cmd is None:
                raise Exception(&#34;Change without field &#39;command&#39;&#34;)
            if cmd == ACTION_ADD_ANNSET:
                assert sname is not None
                self.annset(sname)
            elif cmd == ACTION_ADD_ANN:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                ann = anns.get(annid)
                start = change.get(&#34;start&#34;)
                end = change.get(&#34;end&#34;)
                anntype = change.get(&#34;type&#34;)

                if ann is None:
                    anns.add(start, end, anntype, annid=annid, features=features)
                else:
                    if handle_existing_anns == ADDANN_IGNORE:
                        pass
                    elif handle_existing_anns == ADDANN_ADD_WITH_NEW_ID:
                        anns.add(start, end, anntype)
                    elif handle_existing_anns == ADDANN_REPLACE_ANNOTATION:
                        anns.remove(annid)
                        anns.add(start, end, anntype, annid)
                    elif handle_existing_anns == ADDANN_UPDATE_FEATURES:
                        ann.features.update(features)
                    elif handle_existing_anns == ADDANN_REPLACE_FEATURES:
                        ann.features.clear()
                        ann.features.update(features)
                    elif handle_existing_anns == ADDANN_ADD_NEW_FEATURES:
                        fns = ann.feature_names()
                        for f in features.keys():
                            if f not in fns:
                                ann.features[f] = features[f]

            elif cmd == ACTION_CLEAR_ANNS:
                assert sname is not None
                anns = self.annset(sname)
                anns.clear()
            elif cmd == ACTION_CLEAR_ANN_FEATURES:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                ann = anns.get(annid)
                if ann is not None:
                    ann.features.clear()
                else:
                    pass  # ignore, could happen with a detached annotation
            elif cmd == ACTION_CLEAR_DOC_FEATURES:
                self.features.clear()
            elif cmd == ACTION_SET_ANN_FEATURE:
                assert fname is not None
                assert sname is not None
                assert annid is not None
                ann = self.annset(sname).get(annid)
                ann.features[fname] = fvalue
            elif cmd == ACTION_DEL_ANN_FEATURE:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                ann = anns.get(annid)
                if ann is not None:
                    if fname is not None:
                        ann.features.pop(fname, None)
                else:
                    pass  # ignore, could happen with a detached annotation
            elif cmd == ACTION_DEL_DOC_FEATURE:
                assert fname is not None
                self.features.pop(fname, None)
            elif cmd == ACTION_DEL_ANN:
                assert sname is not None
                assert annid is not None
                anns = self.annset(sname)
                anns.remove(annid)
            elif cmd == ACTION_SET_DOC_FEATURE:
                assert fname is not None
                self.features[fname] = fvalue
            elif cmd == ACTION_CLEAR_DOC_FEATURES:
                self._features.clear()
            elif cmd == ACTION_DEL_DOC_FEATURE:
                assert fname is not None
                del self._features[fname]
            else:
                raise Exception(&#34;Unknown ChangeLog action: &#34;, cmd)

    @property
    def features(self):
        &#34;&#34;&#34;Accesses the features as a FeatureViewer instance. Changes made on this object are
        reflected in the document and recorded in the change log, if there is one.

        :return: A FeatureViewer view of the document features.

        Args:

        Returns:

        &#34;&#34;&#34;
        return self._features

    @property
    def changelog(self):
        &#34;&#34;&#34;Get the ChangeLog or None if no ChangeLog has been set.

        :return: the changelog

        Args:

        Returns:

        &#34;&#34;&#34;
        return self._changelog

    @changelog.setter
    def changelog(self, chlog):
        &#34;&#34;&#34;Make the document use the given changelog to record all changes
        from this moment on.

        Args:
          chlog: the new changelog to use or None to not use any

        Returns:
          the changelog used previously or None

        &#34;&#34;&#34;
        oldchlog = self._changelog
        self._changelog = chlog
        return oldchlog

    @property
    def text(self) -&gt; str:
        &#34;&#34;&#34;Get the text of the document. For a partial document, the text may be None.

        :return: the text of the document

        Args:

        Returns:

        &#34;&#34;&#34;
        self._ensure_type_python()
        return self._text

    @text.setter
    def text(self, value: str) -&gt; None:
        &#34;&#34;&#34;Set the text of the document. This is only possible as long as it has not been set
        yet, after that, the text is immutable.

        Args:
          value: the text for the document
          value: str:

        Returns:

        &#34;&#34;&#34;
        if self._text is None:
            self._text = value
        else:
            raise NotImplementedError(&#34;Text cannot be modified&#34;)

    def _log_feature_change(
        self, command: str, feature: str = None, value=None
    ) -&gt; None:
        &#34;&#34;&#34;

        Args:
          command: str:
          feature: str:  (Default value = None)
          value:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if self._changelog is None:
            return
        command = &#34;doc-&#34; + command
        ch = {&#34;command&#34;: command}
        if command == &#34;doc-feature:set&#34;:
            ch[&#34;feature&#34;] = feature
            ch[&#34;value&#34;] = value
        self._changelog.append(ch)

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Return the length of the text.
        Note: this will convert the type of the document to python!

        :return: the length of the document text
        &#34;&#34;&#34;
        self._ensure_type_python()
        if self._text is None:
            return 0
        else:
            return len(self._text)

    def __getitem__(self, span) -&gt; str:
        &#34;&#34;&#34;
        Get the text for the given span.

        :param span: a single number, an offset range of the form from:to or an annotation.
        If annotation, uses the annotation&#39;s offset span.
        :return: the text of the span
        &#34;&#34;&#34;
        self._ensure_type_python()
        if isinstance(span, Annotation):
            return self.text[span._start : span._end]
        if isinstance(span, AnnotationSet):
            return self.text[span.start() : span.end()]
        if hasattr(span, &#34;start&#34;) and hasattr(span, &#34;end&#34;):
            return self.text[span.start, span.end]
        return self.text[span]

    def annset(self, name: str = &#34;&#34;) -&gt; AnnotationSet:
        &#34;&#34;&#34;Get the named annotation set, if name is not given or the empty string, the default annotation set.
        If the annotation set does not already exist, it is created.

        Args:
          name: the annotation set name, the empty string is used for the &#34;default annotation set&#34;.
          name: str:  (Default value = &#34;&#34;)

        Returns:
          the specified annotation set.

        &#34;&#34;&#34;
        self._ensure_type_python()
        if name not in self._annotation_sets:
            annset = AnnotationSet(owner_doc=self, name=name)
            self._annotation_sets[name] = annset
            if self._changelog:
                self._changelog.append({&#34;command&#34;: &#34;annotations:add&#34;, &#34;set&#34;: name})
            return annset
        else:
            return self._annotation_sets[name]

    def annset_names(self) -&gt; KeysView[str]:
        &#34;&#34;&#34;

        Args:

        Returns:
          :return: annotation set names

        &#34;&#34;&#34;
        self._ensure_type_python()
        return list(self._annotation_sets.keys())

    def remove_annset(self, name: str):
        &#34;&#34;&#34;Completely remove the annotation set.

        Args:
          name: name of the annotation set to remove
          name: str:

        Returns:

        &#34;&#34;&#34;
        if name not in self._annotation_sets:
            raise Exception(f&#34;AnnotationSet with name {name} does not exist&#34;)
        del self._annotation_sets[name]
        if self._changelog:
            self._changelog.append({&#34;command&#34;: &#34;annotations:remove&#34;, &#34;set&#34;: name})

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        String representation of the document, showing all content.

        :return: string representation
        &#34;&#34;&#34;
        return &#34;Document({},features={},anns={})&#34;.format(
            self.text, self._features, self._annotation_sets.__repr__()
        )

    def __str__(self) -&gt; str:
        asets = (
            &#34;[&#34;
            + &#34;,&#34;.join([f&#34;&#39;{k}&#39;:{len(v)}&#34; for k, v in self._annotation_sets.items()])
            + &#34;]&#34;
        )
        return &#34;Document({},features={},anns={})&#34;.format(
            self.text, self._features, asets
        )

    def to_dict(self, offset_type=None, annsets=None, **kwargs):
        &#34;&#34;&#34;Convert this instance to a dictionary that can be used to re-create the instance with
        from_dict.
        NOTE: if there is an active changelog, it is not included in the output as this
        field is considered a transient field!

        Args:
          offset_type: convert to the given offset type on the fly (Default value = None)
          annsets: if not None, a list of annotation set/type specifications: each element
              is either a string, the name of the annotation set to include, or a tuple where the
              first element is the annotation set name and the second element is either a type name or
              a list of type names. The same annotation set name should not be used in more than one
              specification.
          **kwargs:

        Returns:
          the dictionary representation of this instance

        &#34;&#34;&#34;
        # if the specified offset type is equal to what we have, do nothing, otherwise
        # create an offset mapper and pass it down to where we actually convert the annotations

        om = None
        if offset_type is not None:
            assert offset_type == OFFSET_TYPE_JAVA or offset_type == OFFSET_TYPE_PYTHON
            if offset_type != self.offset_type:
                if self._text is not None:
                    om = OffsetMapper(self._text)
                    kwargs[&#34;offset_mapper&#34;] = om
                    kwargs[&#34;offset_type&#34;] = offset_type
        else:
            offset_type = self.offset_type

        # create the annotation sets map
        if annsets is not None:
            annsets_dict = {}
            for spec in annsets:
                if isinstance(spec, str):
                    annsets_dict[spec] = self._annotation_sets[spec].to_dict(**kwargs)
                else:
                    setname, types = spec
                    if isinstance(types, str):
                        types = [types]
                    annsets_dict[setname] = self._annotation_sets[setname].to_dict(anntypes=types, **kwargs)
        else:
            annsets_dict = {
                name: aset.to_dict(**kwargs)
                for name, aset in self._annotation_sets.items()
            }

        return {
            &#34;annotation_sets&#34;: annsets_dict,
            &#34;text&#34;: self._text,
            &#34;features&#34;: self._features.to_dict(),
            &#34;offset_type&#34;: offset_type,
            &#34;name&#34;: self.name,
        }

    @staticmethod
    def from_dict(dictrepr, **kwargs):
        &#34;&#34;&#34;Return a Document instance as represented by the dictionary dictrepr.

        Args:
          dictrepr: return: the initialized Document instance
          **kwargs:

        Returns:
          the initialized Document instance

        &#34;&#34;&#34;
        feats = dictrepr.get(&#34;features&#34;)
        doc = Document(dictrepr.get(&#34;text&#34;), features=feats)
        doc.name = dictrepr.get(&#34;name&#34;)
        doc.offset_type = dictrepr.get(&#34;offset_type&#34;)
        if (
            doc.offset_type != OFFSET_TYPE_JAVA
            and doc.offset_type != OFFSET_TYPE_PYTHON
        ):
            raise Exception(&#34;Invalid offset type, cannot load: &#34;, doc.offset_type)
        annsets = {
            name: AnnotationSet.from_dict(adict, owner_doc=doc)
            for name, adict in dictrepr.get(&#34;annotation_sets&#34;).items()
        }
        doc._annotation_sets = annsets
        return doc

    def save(
        self,
        destination,
        fmt=None,
        offset_type=None,
        mod=&#34;gatenlp.serialization.default&#34;,
        annsets=None,
        **kwargs,
    ):
        &#34;&#34;&#34;Save the document to the destination file.

        Args:
          destination: either a file name or something that has a write(string) method.
          fmt: serialization format, by default the format is inferred from the file extension.
          offset_type: store using the given offset type or keep the current if None (Default value = None)
          mod: module where the document saver is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
          annsets: if not None, a list of annotation set names or tuples of set name and a list of annotation types
              to include in the serialized document.
          kwargs: additional parameters for the document saver.
          **kwargs:
        &#34;&#34;&#34;
        if annsets is not None:
            kwargs[&#34;annsets&#34;] = annsets
        if fmt is None or isinstance(fmt, str):
            m = importlib.import_module(mod)
            saver = m.get_document_saver(destination, fmt)
            saver(Document, self, to_ext=destination, offset_type=offset_type, **kwargs)
        else:
            # assume fmt is a callable to get used directly
            fmt(Document, self, to_ext=destination, offset_type=offset_type, **kwargs)

    def save_mem(
        self,
        fmt=&#34;json&#34;,
        offset_type=None,
        mod=&#34;gatenlp.serialization.default&#34;,
        **kwargs,
    ):
        &#34;&#34;&#34;Serialize to a string or bytes in the given format.

        Args:
          fmt: serialization format to use. (Default value = &#34;json&#34;)
          offset_type: store using the given offset type or keep the current if None (Default value = None)
          mod: module where the document saver is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional parameters for the format.
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        if not fmt:
            raise Exception(&#34;Format required.&#34;)
        if isinstance(fmt, str):
            m = importlib.import_module(mod)
            saver = m.get_document_saver(None, fmt)
            return saver(Document, self, to_mem=True, offset_type=offset_type, **kwargs)
        else:
            fmt(Document, self, to_mem=True, offset_type=offset_type, **kwargs)

    @staticmethod
    def load(source, fmt=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;Load or import a document from the given source. The source can be a file path or file name or
        a URL. If the type of the source is str, then if it starts with &#34;http[s]://&#34; it will get treated
        as a URL. In order to deliberatly use a file instead of a URL, create a pathlib Path, in order to
        deliberately use URL instead of a file parse the URL using urllib.

        Example: `Document.load(urllib.parse.urlparse(someurl), fmt=theformat)`

        Example: `Document.load(pathlib.Path(somepath), fmt=theformat)`

        NOTE: the offset type of the document is always converted to PYTHON when loading!

        Args:
          source: the URL or file path to load from.
          fmt: the format of the source. By default the format is inferred by the file extension.
        The format can be a format memnonic like &#34;json&#34;, &#34;html&#34;, or a known mime type like &#34;text/bdocjs&#34;.
          mod: the name of a module where the document loader is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional format specific keyword arguments to pass to the loader
          **kwargs:

        Returns:
          the loaded document

        &#34;&#34;&#34;
        if fmt is None or isinstance(fmt, str):
            m = importlib.import_module(mod)
            loader = m.get_document_loader(source, fmt)
            doc = loader(Document, from_ext=source, **kwargs)
        else:
            doc = fmt(Document, from_ext=source, **kwargs)
        if doc.offset_type == OFFSET_TYPE_JAVA:
            doc.to_offset_type(OFFSET_TYPE_PYTHON)
        return doc

    @staticmethod
    def load_mem(source, fmt=&#34;json&#34;, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
        &#34;&#34;&#34;Create a document from the in-memory serialization in source. Source can be a string or
        bytes, depending on the format.

        Note: the offset type is always converted to PYTHON when loading!

        Args:
          source: the string/bytes to deserialize
          fmt: the format (Default value = &#34;json&#34;)
          mod: the name of the module where the loader is implemented (Default value = &#34;gatenlp.serialization.default&#34;)
          kwargs: additional arguments to pass to the loader
          **kwargs:

        Returns:

        &#34;&#34;&#34;
        if not fmt:
            raise Exception(&#34;Format required.&#34;)
        if isinstance(fmt, str):
            m = importlib.import_module(mod)
            loader = m.get_document_loader(None, fmt)
            doc = loader(Document, from_mem=source, **kwargs)
        else:
            doc = fmt(Document, from_mem=source, **kwargs)
        if doc.offset_type == OFFSET_TYPE_JAVA:
            doc.to_offset_type(OFFSET_TYPE_PYTHON)
        return doc

    def __copy__(self):
        &#34;&#34;&#34;
        Creates a shallow copy except the changelog which is set to None.

        :return: shallow copy of the document
        &#34;&#34;&#34;
        doc = Document(self._text)
        doc._annotation_sets = self._annotation_sets
        doc.offset_type = self.offset_type
        doc._features = self._features.copy()
        return doc

    def copy(self):
        &#34;&#34;&#34;Creates a shallow copy except the changelog which is set to None.

        :return: shallow copy of the document

        Args:

        Returns:

        &#34;&#34;&#34;
        return self.__copy__()

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        Creates a deep copy, except the changelog which is set to None.

        :param memo: the memoization dictionary to use.

        :return: a deep copy of the document.
        &#34;&#34;&#34;
        if self._features is not None:
            fts = lib_copy.deepcopy(self._features.to_dict(), memo)
        else:
            fts = None
        doc = Document(self._text, features=fts)
        doc._changelog = None
        doc._annotation_sets = lib_copy.deepcopy(self._annotation_sets, memo)
        doc.offset_type = self.offset_type
        return doc

    def deepcopy(self, memo=None):
        &#34;&#34;&#34;Creates a deep copy, except the changelog which is set to None.

        Args:
          memo: the memoization dictionary to use.

        Returns:
          a deep copy of the document.

        &#34;&#34;&#34;
        return lib_copy.deepcopy(self, memo=memo)

    def _repr_html_(self):
        &#34;&#34;&#34;
        Render function for Jupyter notebooks. Returns the html-ann-viewer HTML.
        This renders the HTML for notebook, for offline mode, but does not add the JS
        but instead initializes the JS in the notebook unless gatenlp.init_notebook()
        has bee called already.
        &#34;&#34;&#34;
        return self._notebook_show()

    # TODO: maybe allow manual selection of how to show the document, e.g. also by
    # writing to a tmp file and browsing in a browser, or pprint etc.
    def show(self, htmlid=None, annsets=None):
        &#34;&#34;&#34;
        Show the document in a Jupyter notebook. This allows to assign a specific htmlid so
        the generated HTML can be directly styled afterwards.
        This directly sends the rendered document to the cell (no display/HTML necessary).

        Args:
            htmlid: the HTML id prefix to use for classes and element ids.
            annsets: if not None, a list of annotation set/type specifications. Each element is either
                the name of a set to fully include, or a tuple with the name of the set as the first element
                and with a single type name or a list of type names as the second element

        &#34;&#34;&#34;
        if in_notebook():
            self._notebook_show(htmlid=htmlid, display=True, annsets=annsets)
        else:
            return self.__str__()

    def _notebook_show(self, htmlid=None, display=False, annsets=None):
        from gatenlp.gatenlpconfig import gatenlpconfig
        from gatenlp.serialization.default import HtmlAnnViewerSerializer
        from IPython.display import display_html

        if not gatenlpconfig.notebook_js_initialized:
            HtmlAnnViewerSerializer.init_javscript()
            gatenlpconfig.notebook_js_initialized = True
        html = self.save_mem(
            fmt=&#34;html-ann-viewer&#34;,
            notebook=True,
            add_js=False,
            offline=True,
            htmlid=htmlid,
            annsets=annsets,
        )
        if display:
            display_html(html, raw=True)
        else:
            return html</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gatenlp.document.MultiDocument" href="#gatenlp.document.MultiDocument">MultiDocument</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.document.Document.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>dictrepr, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a Document instance as represented by the dictionary dictrepr.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dictrepr</code></strong></dt>
<dd>return: the initialized Document instance</dd>
</dl>
<p>**kwargs:</p>
<h2 id="returns">Returns</h2>
<p>the initialized Document instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(dictrepr, **kwargs):
    &#34;&#34;&#34;Return a Document instance as represented by the dictionary dictrepr.

    Args:
      dictrepr: return: the initialized Document instance
      **kwargs:

    Returns:
      the initialized Document instance

    &#34;&#34;&#34;
    feats = dictrepr.get(&#34;features&#34;)
    doc = Document(dictrepr.get(&#34;text&#34;), features=feats)
    doc.name = dictrepr.get(&#34;name&#34;)
    doc.offset_type = dictrepr.get(&#34;offset_type&#34;)
    if (
        doc.offset_type != OFFSET_TYPE_JAVA
        and doc.offset_type != OFFSET_TYPE_PYTHON
    ):
        raise Exception(&#34;Invalid offset type, cannot load: &#34;, doc.offset_type)
    annsets = {
        name: AnnotationSet.from_dict(adict, owner_doc=doc)
        for name, adict in dictrepr.get(&#34;annotation_sets&#34;).items()
    }
    doc._annotation_sets = annsets
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>source, fmt=None, mod='gatenlp.serialization.default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Load or import a document from the given source. The source can be a file path or file name or
a URL. If the type of the source is str, then if it starts with "http[s]://" it will get treated
as a URL. In order to deliberatly use a file instead of a URL, create a pathlib Path, in order to
deliberately use URL instead of a file parse the URL using urllib.</p>
<p>Example: <code>Document.load(urllib.parse.urlparse(someurl), fmt=theformat)</code></p>
<p>Example: <code>Document.load(pathlib.Path(somepath), fmt=theformat)</code></p>
<p>NOTE: the offset type of the document is always converted to PYTHON when loading!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>the URL or file path to load from.</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>the format of the source. By default the format is inferred by the file extension.</dd>
</dl>
<p>The format can be a format memnonic like "json", "html", or a known mime type like "text/bdocjs".
mod: the name of a module where the document loader is implemented. (Default value = "gatenlp.serialization.default")
kwargs: additional format specific keyword arguments to pass to the loader
**kwargs:</p>
<h2 id="returns">Returns</h2>
<p>the loaded document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(source, fmt=None, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
    &#34;&#34;&#34;Load or import a document from the given source. The source can be a file path or file name or
    a URL. If the type of the source is str, then if it starts with &#34;http[s]://&#34; it will get treated
    as a URL. In order to deliberatly use a file instead of a URL, create a pathlib Path, in order to
    deliberately use URL instead of a file parse the URL using urllib.

    Example: `Document.load(urllib.parse.urlparse(someurl), fmt=theformat)`

    Example: `Document.load(pathlib.Path(somepath), fmt=theformat)`

    NOTE: the offset type of the document is always converted to PYTHON when loading!

    Args:
      source: the URL or file path to load from.
      fmt: the format of the source. By default the format is inferred by the file extension.
    The format can be a format memnonic like &#34;json&#34;, &#34;html&#34;, or a known mime type like &#34;text/bdocjs&#34;.
      mod: the name of a module where the document loader is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
      kwargs: additional format specific keyword arguments to pass to the loader
      **kwargs:

    Returns:
      the loaded document

    &#34;&#34;&#34;
    if fmt is None or isinstance(fmt, str):
        m = importlib.import_module(mod)
        loader = m.get_document_loader(source, fmt)
        doc = loader(Document, from_ext=source, **kwargs)
    else:
        doc = fmt(Document, from_ext=source, **kwargs)
    if doc.offset_type == OFFSET_TYPE_JAVA:
        doc.to_offset_type(OFFSET_TYPE_PYTHON)
    return doc</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.load_mem"><code class="name flex">
<span>def <span class="ident">load_mem</span></span>(<span>source, fmt='json', mod='gatenlp.serialization.default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a document from the in-memory serialization in source. Source can be a string or
bytes, depending on the format.</p>
<p>Note: the offset type is always converted to PYTHON when loading!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>the string/bytes to deserialize</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>the format (Default value = "json")</dd>
<dt><strong><code>mod</code></strong></dt>
<dd>the name of the module where the loader is implemented (Default value = "gatenlp.serialization.default")</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>additional arguments to pass to the loader</dd>
</dl>
<p>**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_mem(source, fmt=&#34;json&#34;, mod=&#34;gatenlp.serialization.default&#34;, **kwargs):
    &#34;&#34;&#34;Create a document from the in-memory serialization in source. Source can be a string or
    bytes, depending on the format.

    Note: the offset type is always converted to PYTHON when loading!

    Args:
      source: the string/bytes to deserialize
      fmt: the format (Default value = &#34;json&#34;)
      mod: the name of the module where the loader is implemented (Default value = &#34;gatenlp.serialization.default&#34;)
      kwargs: additional arguments to pass to the loader
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    if not fmt:
        raise Exception(&#34;Format required.&#34;)
    if isinstance(fmt, str):
        m = importlib.import_module(mod)
        loader = m.get_document_loader(None, fmt)
        doc = loader(Document, from_mem=source, **kwargs)
    else:
        doc = fmt(Document, from_mem=source, **kwargs)
    if doc.offset_type == OFFSET_TYPE_JAVA:
        doc.to_offset_type(OFFSET_TYPE_PYTHON)
    return doc</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="gatenlp.document.Document.changelog"><code class="name">property/get/set <span class="ident">changelog</span></code></dt>
<dd>
<div class="desc"><p>Get the ChangeLog or None if no ChangeLog has been set.</p>
<p>:return: the changelog</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def changelog(self):
    &#34;&#34;&#34;Get the ChangeLog or None if no ChangeLog has been set.

    :return: the changelog

    Args:

    Returns:

    &#34;&#34;&#34;
    return self._changelog</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.features"><code class="name">property/get <span class="ident">features</span></code></dt>
<dd>
<div class="desc"><p>Accesses the features as a FeatureViewer instance. Changes made on this object are
reflected in the document and recorded in the change log, if there is one.</p>
<p>:return: A FeatureViewer view of the document features.</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def features(self):
    &#34;&#34;&#34;Accesses the features as a FeatureViewer instance. Changes made on this object are
    reflected in the document and recorded in the change log, if there is one.

    :return: A FeatureViewer view of the document features.

    Args:

    Returns:

    &#34;&#34;&#34;
    return self._features</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.name"><code class="name">property/get/set <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34; &#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.text"><code class="name">property/get/set <span class="ident">text</span> : str</code></dt>
<dd>
<div class="desc"><p>Get the text of the document. For a partial document, the text may be None.</p>
<p>:return: the text of the document</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text(self) -&gt; str:
    &#34;&#34;&#34;Get the text of the document. For a partial document, the text may be None.

    :return: the text of the document

    Args:

    Returns:

    &#34;&#34;&#34;
    self._ensure_type_python()
    return self._text</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.document.Document.annset"><code class="name flex">
<span>def <span class="ident">annset</span></span>(<span>self, name: str = '') ‑> <a title="gatenlp.annotation_set.AnnotationSet" href="annotation_set.html#gatenlp.annotation_set.AnnotationSet">AnnotationSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the named annotation set, if name is not given or the empty string, the default annotation set.
If the annotation set does not already exist, it is created.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>the annotation set name, the empty string is used for the "default annotation set".</dd>
<dt><strong><code>name</code></strong></dt>
<dd>str:
(Default value = "")</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the specified annotation set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def annset(self, name: str = &#34;&#34;) -&gt; AnnotationSet:
    &#34;&#34;&#34;Get the named annotation set, if name is not given or the empty string, the default annotation set.
    If the annotation set does not already exist, it is created.

    Args:
      name: the annotation set name, the empty string is used for the &#34;default annotation set&#34;.
      name: str:  (Default value = &#34;&#34;)

    Returns:
      the specified annotation set.

    &#34;&#34;&#34;
    self._ensure_type_python()
    if name not in self._annotation_sets:
        annset = AnnotationSet(owner_doc=self, name=name)
        self._annotation_sets[name] = annset
        if self._changelog:
            self._changelog.append({&#34;command&#34;: &#34;annotations:add&#34;, &#34;set&#34;: name})
        return annset
    else:
        return self._annotation_sets[name]</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.annset_names"><code class="name flex">
<span>def <span class="ident">annset_names</span></span>(<span>self) ‑> KeysView[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Args:</p>
<h2 id="returns">Returns</h2>
<p>:return: annotation set names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def annset_names(self) -&gt; KeysView[str]:
    &#34;&#34;&#34;

    Args:

    Returns:
      :return: annotation set names

    &#34;&#34;&#34;
    self._ensure_type_python()
    return list(self._annotation_sets.keys())</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.apply_changes"><code class="name flex">
<span>def <span class="ident">apply_changes</span></span>(<span>self, changes, handle_existing_anns='add-with-new-id')</span>
</code></dt>
<dd>
<div class="desc"><p>Apply changes from a ChangeLog to this document. <code>changes</code> can be a ChangeLog instance,
a sequence of change objects (dicts) as stored in a ChangeLog instance, or a single change object.</p>
<p>The document is modified in-place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>changes</code></strong></dt>
<dd>one or more changes</dd>
<dt><strong><code>handle_existing_anns</code></strong></dt>
<dd>what to do if the change from the changelog tries to add an annotation</dd>
</dl>
<p>with an annotation id that already exists in the target set. (Default value = ADDANN_ADD_WITH_NEW_ID)</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_changes(self, changes, handle_existing_anns=ADDANN_ADD_WITH_NEW_ID):
    &#34;&#34;&#34;Apply changes from a ChangeLog to this document. `changes` can be a ChangeLog instance,
    a sequence of change objects (dicts) as stored in a ChangeLog instance, or a single change object.

    The document is modified in-place.

    Args:
      changes: one or more changes
      handle_existing_anns: what to do if the change from the changelog tries to add an annotation
    with an annotation id that already exists in the target set. (Default value = ADDANN_ADD_WITH_NEW_ID)

    Returns:

    &#34;&#34;&#34;
    if isinstance(changes, dict):
        changes = [changes]
    elif isinstance(changes, ChangeLog):
        changes = changes.changes
    for change in changes:
        cmd = change.get(&#34;command&#34;)
        fname = change.get(&#34;feature&#34;)
        fvalue = change.get(&#34;value&#34;)
        features = change.get(&#34;features&#34;)
        sname = change.get(&#34;set&#34;)
        annid = change.get(&#34;id&#34;)
        if cmd is None:
            raise Exception(&#34;Change without field &#39;command&#39;&#34;)
        if cmd == ACTION_ADD_ANNSET:
            assert sname is not None
            self.annset(sname)
        elif cmd == ACTION_ADD_ANN:
            assert sname is not None
            assert annid is not None
            anns = self.annset(sname)
            ann = anns.get(annid)
            start = change.get(&#34;start&#34;)
            end = change.get(&#34;end&#34;)
            anntype = change.get(&#34;type&#34;)

            if ann is None:
                anns.add(start, end, anntype, annid=annid, features=features)
            else:
                if handle_existing_anns == ADDANN_IGNORE:
                    pass
                elif handle_existing_anns == ADDANN_ADD_WITH_NEW_ID:
                    anns.add(start, end, anntype)
                elif handle_existing_anns == ADDANN_REPLACE_ANNOTATION:
                    anns.remove(annid)
                    anns.add(start, end, anntype, annid)
                elif handle_existing_anns == ADDANN_UPDATE_FEATURES:
                    ann.features.update(features)
                elif handle_existing_anns == ADDANN_REPLACE_FEATURES:
                    ann.features.clear()
                    ann.features.update(features)
                elif handle_existing_anns == ADDANN_ADD_NEW_FEATURES:
                    fns = ann.feature_names()
                    for f in features.keys():
                        if f not in fns:
                            ann.features[f] = features[f]

        elif cmd == ACTION_CLEAR_ANNS:
            assert sname is not None
            anns = self.annset(sname)
            anns.clear()
        elif cmd == ACTION_CLEAR_ANN_FEATURES:
            assert sname is not None
            assert annid is not None
            anns = self.annset(sname)
            ann = anns.get(annid)
            if ann is not None:
                ann.features.clear()
            else:
                pass  # ignore, could happen with a detached annotation
        elif cmd == ACTION_CLEAR_DOC_FEATURES:
            self.features.clear()
        elif cmd == ACTION_SET_ANN_FEATURE:
            assert fname is not None
            assert sname is not None
            assert annid is not None
            ann = self.annset(sname).get(annid)
            ann.features[fname] = fvalue
        elif cmd == ACTION_DEL_ANN_FEATURE:
            assert sname is not None
            assert annid is not None
            anns = self.annset(sname)
            ann = anns.get(annid)
            if ann is not None:
                if fname is not None:
                    ann.features.pop(fname, None)
            else:
                pass  # ignore, could happen with a detached annotation
        elif cmd == ACTION_DEL_DOC_FEATURE:
            assert fname is not None
            self.features.pop(fname, None)
        elif cmd == ACTION_DEL_ANN:
            assert sname is not None
            assert annid is not None
            anns = self.annset(sname)
            anns.remove(annid)
        elif cmd == ACTION_SET_DOC_FEATURE:
            assert fname is not None
            self.features[fname] = fvalue
        elif cmd == ACTION_CLEAR_DOC_FEATURES:
            self._features.clear()
        elif cmd == ACTION_DEL_DOC_FEATURE:
            assert fname is not None
            del self._features[fname]
        else:
            raise Exception(&#34;Unknown ChangeLog action: &#34;, cmd)</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a shallow copy except the changelog which is set to None.</p>
<p>:return: shallow copy of the document</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;Creates a shallow copy except the changelog which is set to None.

    :return: shallow copy of the document

    Args:

    Returns:

    &#34;&#34;&#34;
    return self.__copy__()</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.deepcopy"><code class="name flex">
<span>def <span class="ident">deepcopy</span></span>(<span>self, memo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a deep copy, except the changelog which is set to None.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>memo</code></strong></dt>
<dd>the memoization dictionary to use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a deep copy of the document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deepcopy(self, memo=None):
    &#34;&#34;&#34;Creates a deep copy, except the changelog which is set to None.

    Args:
      memo: the memoization dictionary to use.

    Returns:
      a deep copy of the document.

    &#34;&#34;&#34;
    return lib_copy.deepcopy(self, memo=memo)</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.remove_annset"><code class="name flex">
<span>def <span class="ident">remove_annset</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Completely remove the annotation set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name of the annotation set to remove</dd>
<dt><strong><code>name</code></strong></dt>
<dd>str:</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_annset(self, name: str):
    &#34;&#34;&#34;Completely remove the annotation set.

    Args:
      name: name of the annotation set to remove
      name: str:

    Returns:

    &#34;&#34;&#34;
    if name not in self._annotation_sets:
        raise Exception(f&#34;AnnotationSet with name {name} does not exist&#34;)
    del self._annotation_sets[name]
    if self._changelog:
        self._changelog.append({&#34;command&#34;: &#34;annotations:remove&#34;, &#34;set&#34;: name})</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, destination, fmt=None, offset_type=None, mod='gatenlp.serialization.default', annsets=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the document to the destination file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>destination</code></strong></dt>
<dd>either a file name or something that has a write(string) method.</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>serialization format, by default the format is inferred from the file extension.</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>store using the given offset type or keep the current if None (Default value = None)</dd>
<dt><strong><code>mod</code></strong></dt>
<dd>module where the document saver is implemented. (Default value = "gatenlp.serialization.default")</dd>
<dt><strong><code>annsets</code></strong></dt>
<dd>if not None, a list of annotation set names or tuples of set name and a list of annotation types
to include in the serialized document.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>additional parameters for the document saver.</dd>
</dl>
<p>**kwargs:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(
    self,
    destination,
    fmt=None,
    offset_type=None,
    mod=&#34;gatenlp.serialization.default&#34;,
    annsets=None,
    **kwargs,
):
    &#34;&#34;&#34;Save the document to the destination file.

    Args:
      destination: either a file name or something that has a write(string) method.
      fmt: serialization format, by default the format is inferred from the file extension.
      offset_type: store using the given offset type or keep the current if None (Default value = None)
      mod: module where the document saver is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
      annsets: if not None, a list of annotation set names or tuples of set name and a list of annotation types
          to include in the serialized document.
      kwargs: additional parameters for the document saver.
      **kwargs:
    &#34;&#34;&#34;
    if annsets is not None:
        kwargs[&#34;annsets&#34;] = annsets
    if fmt is None or isinstance(fmt, str):
        m = importlib.import_module(mod)
        saver = m.get_document_saver(destination, fmt)
        saver(Document, self, to_ext=destination, offset_type=offset_type, **kwargs)
    else:
        # assume fmt is a callable to get used directly
        fmt(Document, self, to_ext=destination, offset_type=offset_type, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.save_mem"><code class="name flex">
<span>def <span class="ident">save_mem</span></span>(<span>self, fmt='json', offset_type=None, mod='gatenlp.serialization.default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize to a string or bytes in the given format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fmt</code></strong></dt>
<dd>serialization format to use. (Default value = "json")</dd>
<dt><strong><code>offset_type</code></strong></dt>
<dd>store using the given offset type or keep the current if None (Default value = None)</dd>
<dt><strong><code>mod</code></strong></dt>
<dd>module where the document saver is implemented. (Default value = "gatenlp.serialization.default")</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>additional parameters for the format.</dd>
</dl>
<p>**kwargs:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_mem(
    self,
    fmt=&#34;json&#34;,
    offset_type=None,
    mod=&#34;gatenlp.serialization.default&#34;,
    **kwargs,
):
    &#34;&#34;&#34;Serialize to a string or bytes in the given format.

    Args:
      fmt: serialization format to use. (Default value = &#34;json&#34;)
      offset_type: store using the given offset type or keep the current if None (Default value = None)
      mod: module where the document saver is implemented. (Default value = &#34;gatenlp.serialization.default&#34;)
      kwargs: additional parameters for the format.
      **kwargs:

    Returns:

    &#34;&#34;&#34;
    if not fmt:
        raise Exception(&#34;Format required.&#34;)
    if isinstance(fmt, str):
        m = importlib.import_module(mod)
        saver = m.get_document_saver(None, fmt)
        return saver(Document, self, to_mem=True, offset_type=offset_type, **kwargs)
    else:
        fmt(Document, self, to_mem=True, offset_type=offset_type, **kwargs)</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, htmlid=None, annsets=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the document in a Jupyter notebook. This allows to assign a specific htmlid so
the generated HTML can be directly styled afterwards.
This directly sends the rendered document to the cell (no display/HTML necessary).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>htmlid</code></strong></dt>
<dd>the HTML id prefix to use for classes and element ids.</dd>
<dt><strong><code>annsets</code></strong></dt>
<dd>if not None, a list of annotation set/type specifications. Each element is either
the name of a set to fully include, or a tuple with the name of the set as the first element
and with a single type name or a list of type names as the second element</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, htmlid=None, annsets=None):
    &#34;&#34;&#34;
    Show the document in a Jupyter notebook. This allows to assign a specific htmlid so
    the generated HTML can be directly styled afterwards.
    This directly sends the rendered document to the cell (no display/HTML necessary).

    Args:
        htmlid: the HTML id prefix to use for classes and element ids.
        annsets: if not None, a list of annotation set/type specifications. Each element is either
            the name of a set to fully include, or a tuple with the name of the set as the first element
            and with a single type name or a list of type names as the second element

    &#34;&#34;&#34;
    if in_notebook():
        self._notebook_show(htmlid=htmlid, display=True, annsets=annsets)
    else:
        return self.__str__()</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, offset_type=None, annsets=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert this instance to a dictionary that can be used to re-create the instance with
from_dict.
NOTE: if there is an active changelog, it is not included in the output as this
field is considered a transient field!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offset_type</code></strong></dt>
<dd>convert to the given offset type on the fly (Default value = None)</dd>
<dt><strong><code>annsets</code></strong></dt>
<dd>if not None, a list of annotation set/type specifications: each element
is either a string, the name of the annotation set to include, or a tuple where the
first element is the annotation set name and the second element is either a type name or
a list of type names. The same annotation set name should not be used in more than one
specification.</dd>
</dl>
<p>**kwargs:</p>
<h2 id="returns">Returns</h2>
<p>the dictionary representation of this instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, offset_type=None, annsets=None, **kwargs):
    &#34;&#34;&#34;Convert this instance to a dictionary that can be used to re-create the instance with
    from_dict.
    NOTE: if there is an active changelog, it is not included in the output as this
    field is considered a transient field!

    Args:
      offset_type: convert to the given offset type on the fly (Default value = None)
      annsets: if not None, a list of annotation set/type specifications: each element
          is either a string, the name of the annotation set to include, or a tuple where the
          first element is the annotation set name and the second element is either a type name or
          a list of type names. The same annotation set name should not be used in more than one
          specification.
      **kwargs:

    Returns:
      the dictionary representation of this instance

    &#34;&#34;&#34;
    # if the specified offset type is equal to what we have, do nothing, otherwise
    # create an offset mapper and pass it down to where we actually convert the annotations

    om = None
    if offset_type is not None:
        assert offset_type == OFFSET_TYPE_JAVA or offset_type == OFFSET_TYPE_PYTHON
        if offset_type != self.offset_type:
            if self._text is not None:
                om = OffsetMapper(self._text)
                kwargs[&#34;offset_mapper&#34;] = om
                kwargs[&#34;offset_type&#34;] = offset_type
    else:
        offset_type = self.offset_type

    # create the annotation sets map
    if annsets is not None:
        annsets_dict = {}
        for spec in annsets:
            if isinstance(spec, str):
                annsets_dict[spec] = self._annotation_sets[spec].to_dict(**kwargs)
            else:
                setname, types = spec
                if isinstance(types, str):
                    types = [types]
                annsets_dict[setname] = self._annotation_sets[setname].to_dict(anntypes=types, **kwargs)
    else:
        annsets_dict = {
            name: aset.to_dict(**kwargs)
            for name, aset in self._annotation_sets.items()
        }

    return {
        &#34;annotation_sets&#34;: annsets_dict,
        &#34;text&#34;: self._text,
        &#34;features&#34;: self._features.to_dict(),
        &#34;offset_type&#34;: offset_type,
        &#34;name&#34;: self.name,
    }</code></pre>
</details>
</dd>
<dt id="gatenlp.document.Document.to_offset_type"><code class="name flex">
<span>def <span class="ident">to_offset_type</span></span>(<span>self, offsettype: str) ‑> <a title="gatenlp.offsetmapper.OffsetMapper" href="offsetmapper.html#gatenlp.offsetmapper.OffsetMapper">OffsetMapper</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert all the offsets of all the annotations in this document to the
required type, either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON. If the offsets
are already of that type, this does nothing.</p>
<p>NOTE: if the document has a ChangeLog, it is NOT also converted!</p>
<p>The method returns the offset mapper if anything actually was converted,
otherwise None.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offsettype</code></strong></dt>
<dd>either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON</dd>
<dt><strong><code>offsettype</code></strong></dt>
<dd>str:</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>offset mapper or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_offset_type(self, offsettype: str) -&gt; OffsetMapper:
    &#34;&#34;&#34;Convert all the offsets of all the annotations in this document to the
    required type, either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON. If the offsets
    are already of that type, this does nothing.

    NOTE: if the document has a ChangeLog, it is NOT also converted!

    The method returns the offset mapper if anything actually was converted,
    otherwise None.

    Args:
      offsettype: either OFFSET_TYPE_JAVA or OFFSET_TYPE_PYTHON
      offsettype: str:

    Returns:
      offset mapper or None

    &#34;&#34;&#34;
    om = None
    if offsettype == self.offset_type:
        return
    if offsettype == OFFSET_TYPE_JAVA and self.offset_type == OFFSET_TYPE_PYTHON:
        # convert from currently python to java
        om = OffsetMapper(self._text)
        self._fixup_annotations(om.convert_to_java)
        self.offset_type = OFFSET_TYPE_JAVA
    elif offsettype == OFFSET_TYPE_PYTHON and self.offset_type == OFFSET_TYPE_JAVA:
        # convert from currently java to python
        om = OffsetMapper(self._text)
        self._fixup_annotations(om.convert_to_python)
        self.offset_type = OFFSET_TYPE_PYTHON
    else:
        raise Exception(&#34;Odd offset type&#34;)
    return om</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gatenlp.document.MultiDocument"><code class="flex name class">
<span>class <span class="ident">MultiDocument</span></span>
<span>(</span><span>text: str = None, features=None, changelog: <a title="gatenlp.changelog.ChangeLog" href="changelog.html#gatenlp.changelog.ChangeLog">ChangeLog</a> = None, docid=0)</span>
</code></dt>
<dd>
<div class="desc"><p>NOTE: This is just experimental for now, DO NOT USE!</p>
<p>A MultiDocument can store more than one document, each identified by their ids. One of those
documents is always the "active" one and the MultiDocument can be used just like a Document
with that content. In addition, there are methods to make each of the other documents active
and to create mappings between annotations of pairs of documents.</p>
<p>An AnnotationMapping is something that maps annotations to annotations, either for the same
document, from the same or different sets, of for different documents. Once an annotation
becomes part of a mapping, that annotation is becoming immutable. Even if the original annotation
in the document changes or gets removed, the mapping retains the original copy of the annotation
until the mapping is modified or removed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiDocument(Document):
    &#34;&#34;&#34;
    NOTE: This is just experimental for now, DO NOT USE!

    A MultiDocument can store more than one document, each identified by their ids. One of those
    documents is always the &#34;active&#34; one and the MultiDocument can be used just like a Document
    with that content. In addition, there are methods to make each of the other documents active
    and to create mappings between annotations of pairs of documents.

    An AnnotationMapping is something that maps annotations to annotations, either for the same
    document, from the same or different sets, of for different documents. Once an annotation
    becomes part of a mapping, that annotation is becoming immutable. Even if the original annotation
    in the document changes or gets removed, the mapping retains the original copy of the annotation
    until the mapping is modified or removed.
    &#34;&#34;&#34;

    # TODO: ALL necessary fields of the document must be references of mutable objects so that
    # if something is changed for the active document the one stored in the documents map is
    # really updated as well, or we must override the updating method to change both!
    # A better way could be to override all methods to always directly change the document in the
    # documents map, and simply pass on all calls to the activated document.
    # In that case, to_dict and from_dict would actually generate the fields for normal document
    # readers and ignore them on restore
    def __init__(
        self, text: str = None, features=None, changelog: ChangeLog = None, docid=0
    ):
        logger.warning(&#34;Experimental feature, DO NOT USE&#34;)
        self.documents = {}  # map from document id to document
        self._mappings = None  # TODO: we need to implement this
        self._docid = None
        doc = Document(text, features=features, changelog=changelog)
        self.documents[docid] = doc
        self.activate(docid)

    @property
    def docid(self):
        return self._docid

    def activate(self, docid=0):
        if docid not in self.documents:
            raise Exception(f&#34;Cannot activate id {docid}, not in MultiDocument&#34;)
        doc = self.documents[docid]
        self._changelog = doc._changelog
        self._features = doc._features
        self._annotation_sets = doc._annotation_sets
        self._text = doc._text
        self.offset_type = OFFSET_TYPE_PYTHON
        self._name = doc._name
        self._docid = docid

    def add_document(self, doc, docid=None, activate=False):
        if docid is None:
            docid = len(self.documents)
        elif docid in self.documents:
            raise Exception(
                f&#34;Cannot add document to MultiDocument, id {docid} already exists&#34;
            )
        self.documents[docid] = doc
        if activate:
            self.activate(docid)
        return docid

    def to_dict(self, offset_type=None, **kwargs):
        # TODO: check what to do with the offset type parameter!
        # The basic strategy is that we simply create the dictionary for the active document plus
        # the entries for the documents map and the annotation mappings. That way, any reader of the
        # dict representation which just ignored unknown fields can still read this in as a normal
        # document from the active document.
        # The drawback is that the active document is represented twice, but OK
        thedict = {
            &#34;annotation_sets&#34;: {
                name: aset.to_dict() for name, aset in self._annotation_sets.items()
            },
            &#34;text&#34;: self._text,
            &#34;features&#34;: self._features.to_dict(),
            &#34;offset_type&#34;: self.offset_type,
            &#34;name&#34;: self.name,
        }
        thedict[&#34;documents&#34;] = {
            docid: doc.to_dict() for docid, doc in self.documents.items()
        }
        thedict[&#34;docid&#34;] = self._docid
        thedict[&#34;mappings&#34;] = self._mappings
        return thedict

    @staticmethod
    def from_dict(dictrepr, **kwargs):
        &#34;&#34;&#34;
        Create a MultiDocument from the dictionary representation.

        Args:
            dictrepr: the dictionary representation
            **kwargs: additional kwargs to pass on

        Returns:

        &#34;&#34;&#34;
        feats = dictrepr.get(&#34;features&#34;)
        docid = dictrepr.get(&#34;docid&#34;)
        doc = MultiDocument(dictrepr.get(&#34;text&#34;), features=feats, docid=docid)
        doc.name = dictrepr.get(&#34;name&#34;)
        doc.offset_type = dictrepr.get(&#34;offset_type&#34;)
        if (
            doc.offset_type != OFFSET_TYPE_JAVA
            and doc.offset_type != OFFSET_TYPE_PYTHON
        ):
            raise Exception(&#34;Invalid offset type, cannot load: &#34;, doc.offset_type)
        annsets = {
            name: AnnotationSet.from_dict(adict, owner_doc=doc)
            for name, adict in dictrepr.get(&#34;annotation_sets&#34;).items()
        }
        doc._annotation_sets = annsets
        doc.documents = {
            did: Document.from_dict(d)
            for did, d in dictrepr.get(&#34;documents&#34;, {}).items()
        }
        # TODO: get the mappings back!
        return doc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.document.Document" href="#gatenlp.document.Document">Document</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.document.MultiDocument.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>dictrepr, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a MultiDocument from the dictionary representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dictrepr</code></strong></dt>
<dd>the dictionary representation</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>additional kwargs to pass on</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(dictrepr, **kwargs):
    &#34;&#34;&#34;
    Create a MultiDocument from the dictionary representation.

    Args:
        dictrepr: the dictionary representation
        **kwargs: additional kwargs to pass on

    Returns:

    &#34;&#34;&#34;
    feats = dictrepr.get(&#34;features&#34;)
    docid = dictrepr.get(&#34;docid&#34;)
    doc = MultiDocument(dictrepr.get(&#34;text&#34;), features=feats, docid=docid)
    doc.name = dictrepr.get(&#34;name&#34;)
    doc.offset_type = dictrepr.get(&#34;offset_type&#34;)
    if (
        doc.offset_type != OFFSET_TYPE_JAVA
        and doc.offset_type != OFFSET_TYPE_PYTHON
    ):
        raise Exception(&#34;Invalid offset type, cannot load: &#34;, doc.offset_type)
    annsets = {
        name: AnnotationSet.from_dict(adict, owner_doc=doc)
        for name, adict in dictrepr.get(&#34;annotation_sets&#34;).items()
    }
    doc._annotation_sets = annsets
    doc.documents = {
        did: Document.from_dict(d)
        for did, d in dictrepr.get(&#34;documents&#34;, {}).items()
    }
    # TODO: get the mappings back!
    return doc</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="gatenlp.document.MultiDocument.docid"><code class="name">property/get <span class="ident">docid</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def docid(self):
    return self._docid</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.document.MultiDocument.activate"><code class="name flex">
<span>def <span class="ident">activate</span></span>(<span>self, docid=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def activate(self, docid=0):
    if docid not in self.documents:
        raise Exception(f&#34;Cannot activate id {docid}, not in MultiDocument&#34;)
    doc = self.documents[docid]
    self._changelog = doc._changelog
    self._features = doc._features
    self._annotation_sets = doc._annotation_sets
    self._text = doc._text
    self.offset_type = OFFSET_TYPE_PYTHON
    self._name = doc._name
    self._docid = docid</code></pre>
</details>
</dd>
<dt id="gatenlp.document.MultiDocument.add_document"><code class="name flex">
<span>def <span class="ident">add_document</span></span>(<span>self, doc, docid=None, activate=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_document(self, doc, docid=None, activate=False):
    if docid is None:
        docid = len(self.documents)
    elif docid in self.documents:
        raise Exception(
            f&#34;Cannot add document to MultiDocument, id {docid} already exists&#34;
        )
    self.documents[docid] = doc
    if activate:
        self.activate(docid)
    return docid</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.document.Document" href="#gatenlp.document.Document">Document</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.document.Document.annset" href="#gatenlp.document.Document.annset">annset</a></code></li>
<li><code><a title="gatenlp.document.Document.annset_names" href="#gatenlp.document.Document.annset_names">annset_names</a></code></li>
<li><code><a title="gatenlp.document.Document.apply_changes" href="#gatenlp.document.Document.apply_changes">apply_changes</a></code></li>
<li><code><a title="gatenlp.document.Document.changelog" href="#gatenlp.document.Document.changelog">changelog</a></code></li>
<li><code><a title="gatenlp.document.Document.copy" href="#gatenlp.document.Document.copy">copy</a></code></li>
<li><code><a title="gatenlp.document.Document.deepcopy" href="#gatenlp.document.Document.deepcopy">deepcopy</a></code></li>
<li><code><a title="gatenlp.document.Document.features" href="#gatenlp.document.Document.features">features</a></code></li>
<li><code><a title="gatenlp.document.Document.load" href="#gatenlp.document.Document.load">load</a></code></li>
<li><code><a title="gatenlp.document.Document.load_mem" href="#gatenlp.document.Document.load_mem">load_mem</a></code></li>
<li><code><a title="gatenlp.document.Document.remove_annset" href="#gatenlp.document.Document.remove_annset">remove_annset</a></code></li>
<li><code><a title="gatenlp.document.Document.save" href="#gatenlp.document.Document.save">save</a></code></li>
<li><code><a title="gatenlp.document.Document.save_mem" href="#gatenlp.document.Document.save_mem">save_mem</a></code></li>
<li><code><a title="gatenlp.document.Document.show" href="#gatenlp.document.Document.show">show</a></code></li>
<li><code><a title="gatenlp.document.Document.text" href="#gatenlp.document.Document.text">text</a></code></li>
<li><code><a title="gatenlp.document.Document.to_dict" href="#gatenlp.document.Document.to_dict">to_dict</a></code></li>
<li><code><a title="gatenlp.document.Document.to_offset_type" href="#gatenlp.document.Document.to_offset_type">to_offset_type</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp" href="index.html">gatenlp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.document.Document" href="#gatenlp.document.Document">Document</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.document.Document.annset" href="#gatenlp.document.Document.annset">annset</a></code></li>
<li><code><a title="gatenlp.document.Document.annset_names" href="#gatenlp.document.Document.annset_names">annset_names</a></code></li>
<li><code><a title="gatenlp.document.Document.apply_changes" href="#gatenlp.document.Document.apply_changes">apply_changes</a></code></li>
<li><code><a title="gatenlp.document.Document.changelog" href="#gatenlp.document.Document.changelog">changelog</a></code></li>
<li><code><a title="gatenlp.document.Document.copy" href="#gatenlp.document.Document.copy">copy</a></code></li>
<li><code><a title="gatenlp.document.Document.deepcopy" href="#gatenlp.document.Document.deepcopy">deepcopy</a></code></li>
<li><code><a title="gatenlp.document.Document.features" href="#gatenlp.document.Document.features">features</a></code></li>
<li><code><a title="gatenlp.document.Document.from_dict" href="#gatenlp.document.Document.from_dict">from_dict</a></code></li>
<li><code><a title="gatenlp.document.Document.load" href="#gatenlp.document.Document.load">load</a></code></li>
<li><code><a title="gatenlp.document.Document.load_mem" href="#gatenlp.document.Document.load_mem">load_mem</a></code></li>
<li><code><a title="gatenlp.document.Document.name" href="#gatenlp.document.Document.name">name</a></code></li>
<li><code><a title="gatenlp.document.Document.remove_annset" href="#gatenlp.document.Document.remove_annset">remove_annset</a></code></li>
<li><code><a title="gatenlp.document.Document.save" href="#gatenlp.document.Document.save">save</a></code></li>
<li><code><a title="gatenlp.document.Document.save_mem" href="#gatenlp.document.Document.save_mem">save_mem</a></code></li>
<li><code><a title="gatenlp.document.Document.show" href="#gatenlp.document.Document.show">show</a></code></li>
<li><code><a title="gatenlp.document.Document.text" href="#gatenlp.document.Document.text">text</a></code></li>
<li><code><a title="gatenlp.document.Document.to_dict" href="#gatenlp.document.Document.to_dict">to_dict</a></code></li>
<li><code><a title="gatenlp.document.Document.to_offset_type" href="#gatenlp.document.Document.to_offset_type">to_offset_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.document.MultiDocument" href="#gatenlp.document.MultiDocument">MultiDocument</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.document.MultiDocument.activate" href="#gatenlp.document.MultiDocument.activate">activate</a></code></li>
<li><code><a title="gatenlp.document.MultiDocument.add_document" href="#gatenlp.document.MultiDocument.add_document">add_document</a></code></li>
<li><code><a title="gatenlp.document.MultiDocument.docid" href="#gatenlp.document.MultiDocument.docid">docid</a></code></li>
<li><code><a title="gatenlp.document.MultiDocument.from_dict" href="#gatenlp.document.MultiDocument.from_dict">from_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev16+g8c2bb0d.d20201028</a>.</p>
</footer>
</body>
</html>