<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev16+g8c2bb0d.d20201028" />
<title>gatenlp.impl.sortedintvls API documentation</title>
<meta name="description" content="Module that provides a simple class that represents a collection of sorted intervals and allows for some
basic interval-based operations â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.impl.sortedintvls</code></h1>
</header>
<section id="section-intro">
<p>Module that provides a simple class that represents a collection of sorted intervals and allows for some
basic interval-based operations.</p>
<p>Internally this stores the intervals using standard sorted lists. This is not optimal and may
incur a O(n) overhead on some operations depending on the result set. It also may incur a significant overhead
for creating and maintaning the sorted lists.</p>
<p>NOTE: this stores a tuple (start, end, annid, object) in the sorted lists for the start
and end offsets
and uses a key function that returns which elements to use for sorting.</p>
<p>For the list sorted by start offset, we use the start offset and annotation id. For the end offset we use the
end offset of the annotation only.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module that provides a simple class that represents a collection of sorted intervals and allows for some
basic interval-based operations.

Internally this stores the intervals using standard sorted lists. This is not optimal and may
incur a O(n) overhead on some operations depending on the result set. It also may incur a significant overhead
for creating and maintaning the sorted lists.

NOTE: this stores a tuple (start, end, annid, object) in the sorted lists for the start  and end offsets
and uses a key function that returns which elements to use for sorting.

For the list sorted by start offset, we use the start offset and annotation id. For the end offset we use the
end offset of the annotation only.
&#34;&#34;&#34;

import sys
from sortedcontainers import SortedKeyList


class SortedIntvls:
    &#34;&#34;&#34; &#34;&#34;&#34;

    def __init__(self):
        # we sort by increasing start offset then increasing annotation id for this
        self._by_start = SortedKeyList(key=lambda x: (x[0], x[2]))
        # for this we sort by end offset only
        self._by_end = SortedKeyList(key=lambda x: x[1])

    def add(self, start, end, data):
        &#34;&#34;&#34;
        Adds an interval.
        &#34;&#34;&#34;
        self._by_start.add((start, end, data))
        self._by_end.add((start, end, data))

    def update(self, tupleiterable):
        &#34;&#34;&#34;
        Updates from an iterable of intervals.
        &#34;&#34;&#34;
        self._by_start.update(tupleiterable)
        self._by_end.update(tupleiterable)

    def remove(self, start, end, data):
        &#34;&#34;&#34;
        Removes an interval, exception if the interval does not exist.
        &#34;&#34;&#34;
        self._by_start.remove((start, end, data))
        self._by_end.remove((start, end, data))

    def discard(self, start, end, data):
        &#34;&#34;&#34;
        Removes and interval, do nothing if the interval does not exist.
        &#34;&#34;&#34;
        self._by_start.discard((start, end, data))
        self._by_end.discard((start, end, data))

    def __len__(self):
        &#34;&#34;&#34;
        Returns the number of intervals.
        &#34;&#34;&#34;
        return len(self._by_start)

    def starting_at(self, offset):
        &#34;&#34;&#34;
        Returns an iterable of (start, end, data) tuples where start==offset
        &#34;&#34;&#34;
        return self._by_start.irange_key(
            min_key=(offset, 0), max_key=(offset, sys.maxsize)
        )

    def ending_at(self, offset):
        &#34;&#34;&#34;
        Returns an iterable of (start, end, data) tuples where end==offset
        &#34;&#34;&#34;
        return self._by_end.irange_key(min_key=offset, max_key=offset)

    def at(self, start, end):
        &#34;&#34;&#34;
        Returns an iterable of tuples where start==start and end==end
        &#34;&#34;&#34;
        for intvl in self._by_start.irange_key(
            min_key=(start, 0), max_key=(start, sys.maxsize)
        ):
            if intvl[1] == end:
                yield intvl

    def within(self, start, end):
        &#34;&#34;&#34;
        Returns intervals which are fully contained within start...end
        &#34;&#34;&#34;
        # get all the intervals that start within the range, then keep those which also end within the range
        for intvl in self._by_start.irange_key(
            min_key=(start, 0), max_key=(end, sys.maxsize)
        ):
            if intvl[1] &lt;= end:
                yield intvl

    def starting_from(self, offset):
        &#34;&#34;&#34;
        Returns intervals that start at or after offset.
        &#34;&#34;&#34;
        return self._by_start.irange_key(min_key=(offset, 0))

    def starting_before(self, offset):
        &#34;&#34;&#34;
        Returns intervals  that start before offset.
        &#34;&#34;&#34;
        return self._by_start.irange_key(max_key=(offset - 1, sys.maxsize))

    def ending_to(self, offset):
        &#34;&#34;&#34;
        Returns intervals that end before or at the given end offset.
        &#34;&#34;&#34;
        return self._by_end.irange_key(max_key=offset)

    def ending_after(self, offset):
        &#34;&#34;&#34;
        Returns intervals the end after the given offset.
        &#34;&#34;&#34;
        return self._by_end.irange_key(min_key=offset + 1)

    def covering(self, start, end):
        &#34;&#34;&#34;
        Returns intervals that contain the given range.
        &#34;&#34;&#34;
        # All intervals that start at or before the start and end at or after the end offset
        # we do this by first getting the intervals the start before or atthe start
        # then filtering by end
        for intvl in self._by_start.irange_key(max_key=(start, sys.maxsize)):
            if intvl[1] &gt;= end:
                yield intvl

    def overlapping(self, start, end):
        &#34;&#34;&#34;
        Returns intervals that overlap with the given range.
        &#34;&#34;&#34;
        # All intervals where the start or end offset lies within the given range.
        # This excludes the ones where the end offset is before the start or
        # where the start offset is after the end of the range.
        # Here we do this by looking at all intervals where the start offset is before the
        # end of the range. This still includes those which also end before the start of the range
        # so we check in addition that the end is larger than the start of the range.
        for intvl in self._by_start.irange_key(max_key=(end - 1, sys.maxsize)):
            if intvl[1] &gt; start + 1:
                yield intvl

    def firsts(self):
        &#34;&#34;&#34;
        Yields all intervals which start at the smallest known offset.
        &#34;&#34;&#34;
        laststart = None
        # logger.info(&#34;DEBUG: set laststart to None&#34;)
        for intvl in self._by_start.irange_key():
            # logger.info(&#34;DEBUG: checking interval {}&#34;.format(intvl))
            if laststart is None:
                laststart = intvl[0]
                # logger.info(&#34;DEBUG: setting laststart to {} and yielding {}&#34;.format(intvl[0], intvl))
                yield intvl
            elif intvl[0] == laststart:
                # logger.info(&#34;DEBUG: yielding {}&#34;.format(intvl))
                yield intvl
            else:
                # logger.info(&#34;DEBUG: returning since we got {}&#34;.format(intvl))
                return

    def lasts(self):
        &#34;&#34;&#34;
        Yields all intervals which start at the last known start offset.
        &#34;&#34;&#34;
        laststart = None
        for intvl in reversed(self._by_start):
            if laststart is None:
                laststart = intvl[0]
                yield intvl
            elif intvl[0] == laststart:
                yield intvl
            else:
                return

    def min_start(self):
        &#34;&#34;&#34;
        Returns the smallest known start offset.
        &#34;&#34;&#34;
        return self._by_start[0][0]

    def max_end(self):
        &#34;&#34;&#34;
        Returns the biggest known end offset.
        &#34;&#34;&#34;
        return self._by_end[-1][1]

    def irange(self, minoff=None, maxoff=None, reverse=False, inclusive=(True, True)):
        &#34;&#34;&#34;
        Yields an iterator of intervals with a start offset between minoff and maxoff, inclusive.

        Args:
          minoff: minimum offset, default None indicates any
          maxoff: maximum offset, default None indicates any
          reverse: if `True` yield in reverse order
          inclusive: if the minoff and maxoff values should be inclusive, default is (True,True)

        Returns:

        &#34;&#34;&#34;
        return self._by_start.irange_key(
            min_key=minoff, max_key=maxoff, reverse=reverse, inclusive=inclusive
        )

    def __repr__(self):
        return &#34;SortedIntvls({},{})&#34;.format(self._by_start, self._by_end)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls"><code class="flex name class">
<span>class <span class="ident">SortedIntvls</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SortedIntvls:
    &#34;&#34;&#34; &#34;&#34;&#34;

    def __init__(self):
        # we sort by increasing start offset then increasing annotation id for this
        self._by_start = SortedKeyList(key=lambda x: (x[0], x[2]))
        # for this we sort by end offset only
        self._by_end = SortedKeyList(key=lambda x: x[1])

    def add(self, start, end, data):
        &#34;&#34;&#34;
        Adds an interval.
        &#34;&#34;&#34;
        self._by_start.add((start, end, data))
        self._by_end.add((start, end, data))

    def update(self, tupleiterable):
        &#34;&#34;&#34;
        Updates from an iterable of intervals.
        &#34;&#34;&#34;
        self._by_start.update(tupleiterable)
        self._by_end.update(tupleiterable)

    def remove(self, start, end, data):
        &#34;&#34;&#34;
        Removes an interval, exception if the interval does not exist.
        &#34;&#34;&#34;
        self._by_start.remove((start, end, data))
        self._by_end.remove((start, end, data))

    def discard(self, start, end, data):
        &#34;&#34;&#34;
        Removes and interval, do nothing if the interval does not exist.
        &#34;&#34;&#34;
        self._by_start.discard((start, end, data))
        self._by_end.discard((start, end, data))

    def __len__(self):
        &#34;&#34;&#34;
        Returns the number of intervals.
        &#34;&#34;&#34;
        return len(self._by_start)

    def starting_at(self, offset):
        &#34;&#34;&#34;
        Returns an iterable of (start, end, data) tuples where start==offset
        &#34;&#34;&#34;
        return self._by_start.irange_key(
            min_key=(offset, 0), max_key=(offset, sys.maxsize)
        )

    def ending_at(self, offset):
        &#34;&#34;&#34;
        Returns an iterable of (start, end, data) tuples where end==offset
        &#34;&#34;&#34;
        return self._by_end.irange_key(min_key=offset, max_key=offset)

    def at(self, start, end):
        &#34;&#34;&#34;
        Returns an iterable of tuples where start==start and end==end
        &#34;&#34;&#34;
        for intvl in self._by_start.irange_key(
            min_key=(start, 0), max_key=(start, sys.maxsize)
        ):
            if intvl[1] == end:
                yield intvl

    def within(self, start, end):
        &#34;&#34;&#34;
        Returns intervals which are fully contained within start...end
        &#34;&#34;&#34;
        # get all the intervals that start within the range, then keep those which also end within the range
        for intvl in self._by_start.irange_key(
            min_key=(start, 0), max_key=(end, sys.maxsize)
        ):
            if intvl[1] &lt;= end:
                yield intvl

    def starting_from(self, offset):
        &#34;&#34;&#34;
        Returns intervals that start at or after offset.
        &#34;&#34;&#34;
        return self._by_start.irange_key(min_key=(offset, 0))

    def starting_before(self, offset):
        &#34;&#34;&#34;
        Returns intervals  that start before offset.
        &#34;&#34;&#34;
        return self._by_start.irange_key(max_key=(offset - 1, sys.maxsize))

    def ending_to(self, offset):
        &#34;&#34;&#34;
        Returns intervals that end before or at the given end offset.
        &#34;&#34;&#34;
        return self._by_end.irange_key(max_key=offset)

    def ending_after(self, offset):
        &#34;&#34;&#34;
        Returns intervals the end after the given offset.
        &#34;&#34;&#34;
        return self._by_end.irange_key(min_key=offset + 1)

    def covering(self, start, end):
        &#34;&#34;&#34;
        Returns intervals that contain the given range.
        &#34;&#34;&#34;
        # All intervals that start at or before the start and end at or after the end offset
        # we do this by first getting the intervals the start before or atthe start
        # then filtering by end
        for intvl in self._by_start.irange_key(max_key=(start, sys.maxsize)):
            if intvl[1] &gt;= end:
                yield intvl

    def overlapping(self, start, end):
        &#34;&#34;&#34;
        Returns intervals that overlap with the given range.
        &#34;&#34;&#34;
        # All intervals where the start or end offset lies within the given range.
        # This excludes the ones where the end offset is before the start or
        # where the start offset is after the end of the range.
        # Here we do this by looking at all intervals where the start offset is before the
        # end of the range. This still includes those which also end before the start of the range
        # so we check in addition that the end is larger than the start of the range.
        for intvl in self._by_start.irange_key(max_key=(end - 1, sys.maxsize)):
            if intvl[1] &gt; start + 1:
                yield intvl

    def firsts(self):
        &#34;&#34;&#34;
        Yields all intervals which start at the smallest known offset.
        &#34;&#34;&#34;
        laststart = None
        # logger.info(&#34;DEBUG: set laststart to None&#34;)
        for intvl in self._by_start.irange_key():
            # logger.info(&#34;DEBUG: checking interval {}&#34;.format(intvl))
            if laststart is None:
                laststart = intvl[0]
                # logger.info(&#34;DEBUG: setting laststart to {} and yielding {}&#34;.format(intvl[0], intvl))
                yield intvl
            elif intvl[0] == laststart:
                # logger.info(&#34;DEBUG: yielding {}&#34;.format(intvl))
                yield intvl
            else:
                # logger.info(&#34;DEBUG: returning since we got {}&#34;.format(intvl))
                return

    def lasts(self):
        &#34;&#34;&#34;
        Yields all intervals which start at the last known start offset.
        &#34;&#34;&#34;
        laststart = None
        for intvl in reversed(self._by_start):
            if laststart is None:
                laststart = intvl[0]
                yield intvl
            elif intvl[0] == laststart:
                yield intvl
            else:
                return

    def min_start(self):
        &#34;&#34;&#34;
        Returns the smallest known start offset.
        &#34;&#34;&#34;
        return self._by_start[0][0]

    def max_end(self):
        &#34;&#34;&#34;
        Returns the biggest known end offset.
        &#34;&#34;&#34;
        return self._by_end[-1][1]

    def irange(self, minoff=None, maxoff=None, reverse=False, inclusive=(True, True)):
        &#34;&#34;&#34;
        Yields an iterator of intervals with a start offset between minoff and maxoff, inclusive.

        Args:
          minoff: minimum offset, default None indicates any
          maxoff: maximum offset, default None indicates any
          reverse: if `True` yield in reverse order
          inclusive: if the minoff and maxoff values should be inclusive, default is (True,True)

        Returns:

        &#34;&#34;&#34;
        return self._by_start.irange_key(
            min_key=minoff, max_key=maxoff, reverse=reverse, inclusive=inclusive
        )

    def __repr__(self):
        return &#34;SortedIntvls({},{})&#34;.format(self._by_start, self._by_end)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, start, end, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an interval.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, start, end, data):
    &#34;&#34;&#34;
    Adds an interval.
    &#34;&#34;&#34;
    self._by_start.add((start, end, data))
    self._by_end.add((start, end, data))</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an iterable of tuples where start==start and end==end</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, start, end):
    &#34;&#34;&#34;
    Returns an iterable of tuples where start==start and end==end
    &#34;&#34;&#34;
    for intvl in self._by_start.irange_key(
        min_key=(start, 0), max_key=(start, sys.maxsize)
    ):
        if intvl[1] == end:
            yield intvl</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.covering"><code class="name flex">
<span>def <span class="ident">covering</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns intervals that contain the given range.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def covering(self, start, end):
    &#34;&#34;&#34;
    Returns intervals that contain the given range.
    &#34;&#34;&#34;
    # All intervals that start at or before the start and end at or after the end offset
    # we do this by first getting the intervals the start before or atthe start
    # then filtering by end
    for intvl in self._by_start.irange_key(max_key=(start, sys.maxsize)):
        if intvl[1] &gt;= end:
            yield intvl</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.discard"><code class="name flex">
<span>def <span class="ident">discard</span></span>(<span>self, start, end, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes and interval, do nothing if the interval does not exist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discard(self, start, end, data):
    &#34;&#34;&#34;
    Removes and interval, do nothing if the interval does not exist.
    &#34;&#34;&#34;
    self._by_start.discard((start, end, data))
    self._by_end.discard((start, end, data))</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.ending_after"><code class="name flex">
<span>def <span class="ident">ending_after</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns intervals the end after the given offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ending_after(self, offset):
    &#34;&#34;&#34;
    Returns intervals the end after the given offset.
    &#34;&#34;&#34;
    return self._by_end.irange_key(min_key=offset + 1)</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.ending_at"><code class="name flex">
<span>def <span class="ident">ending_at</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an iterable of (start, end, data) tuples where end==offset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ending_at(self, offset):
    &#34;&#34;&#34;
    Returns an iterable of (start, end, data) tuples where end==offset
    &#34;&#34;&#34;
    return self._by_end.irange_key(min_key=offset, max_key=offset)</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.ending_to"><code class="name flex">
<span>def <span class="ident">ending_to</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns intervals that end before or at the given end offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ending_to(self, offset):
    &#34;&#34;&#34;
    Returns intervals that end before or at the given end offset.
    &#34;&#34;&#34;
    return self._by_end.irange_key(max_key=offset)</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.firsts"><code class="name flex">
<span>def <span class="ident">firsts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Yields all intervals which start at the smallest known offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def firsts(self):
    &#34;&#34;&#34;
    Yields all intervals which start at the smallest known offset.
    &#34;&#34;&#34;
    laststart = None
    # logger.info(&#34;DEBUG: set laststart to None&#34;)
    for intvl in self._by_start.irange_key():
        # logger.info(&#34;DEBUG: checking interval {}&#34;.format(intvl))
        if laststart is None:
            laststart = intvl[0]
            # logger.info(&#34;DEBUG: setting laststart to {} and yielding {}&#34;.format(intvl[0], intvl))
            yield intvl
        elif intvl[0] == laststart:
            # logger.info(&#34;DEBUG: yielding {}&#34;.format(intvl))
            yield intvl
        else:
            # logger.info(&#34;DEBUG: returning since we got {}&#34;.format(intvl))
            return</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.irange"><code class="name flex">
<span>def <span class="ident">irange</span></span>(<span>self, minoff=None, maxoff=None, reverse=False, inclusive=(True, True))</span>
</code></dt>
<dd>
<div class="desc"><p>Yields an iterator of intervals with a start offset between minoff and maxoff, inclusive.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>minoff</code></strong></dt>
<dd>minimum offset, default None indicates any</dd>
<dt><strong><code>maxoff</code></strong></dt>
<dd>maximum offset, default None indicates any</dd>
<dt><strong><code>reverse</code></strong></dt>
<dd>if <code>True</code> yield in reverse order</dd>
<dt><strong><code>inclusive</code></strong></dt>
<dd>if the minoff and maxoff values should be inclusive, default is (True,True)</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def irange(self, minoff=None, maxoff=None, reverse=False, inclusive=(True, True)):
    &#34;&#34;&#34;
    Yields an iterator of intervals with a start offset between minoff and maxoff, inclusive.

    Args:
      minoff: minimum offset, default None indicates any
      maxoff: maximum offset, default None indicates any
      reverse: if `True` yield in reverse order
      inclusive: if the minoff and maxoff values should be inclusive, default is (True,True)

    Returns:

    &#34;&#34;&#34;
    return self._by_start.irange_key(
        min_key=minoff, max_key=maxoff, reverse=reverse, inclusive=inclusive
    )</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.lasts"><code class="name flex">
<span>def <span class="ident">lasts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Yields all intervals which start at the last known start offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lasts(self):
    &#34;&#34;&#34;
    Yields all intervals which start at the last known start offset.
    &#34;&#34;&#34;
    laststart = None
    for intvl in reversed(self._by_start):
        if laststart is None:
            laststart = intvl[0]
            yield intvl
        elif intvl[0] == laststart:
            yield intvl
        else:
            return</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.max_end"><code class="name flex">
<span>def <span class="ident">max_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the biggest known end offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_end(self):
    &#34;&#34;&#34;
    Returns the biggest known end offset.
    &#34;&#34;&#34;
    return self._by_end[-1][1]</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.min_start"><code class="name flex">
<span>def <span class="ident">min_start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the smallest known start offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_start(self):
    &#34;&#34;&#34;
    Returns the smallest known start offset.
    &#34;&#34;&#34;
    return self._by_start[0][0]</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.overlapping"><code class="name flex">
<span>def <span class="ident">overlapping</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns intervals that overlap with the given range.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlapping(self, start, end):
    &#34;&#34;&#34;
    Returns intervals that overlap with the given range.
    &#34;&#34;&#34;
    # All intervals where the start or end offset lies within the given range.
    # This excludes the ones where the end offset is before the start or
    # where the start offset is after the end of the range.
    # Here we do this by looking at all intervals where the start offset is before the
    # end of the range. This still includes those which also end before the start of the range
    # so we check in addition that the end is larger than the start of the range.
    for intvl in self._by_start.irange_key(max_key=(end - 1, sys.maxsize)):
        if intvl[1] &gt; start + 1:
            yield intvl</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, start, end, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes an interval, exception if the interval does not exist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, start, end, data):
    &#34;&#34;&#34;
    Removes an interval, exception if the interval does not exist.
    &#34;&#34;&#34;
    self._by_start.remove((start, end, data))
    self._by_end.remove((start, end, data))</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.starting_at"><code class="name flex">
<span>def <span class="ident">starting_at</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an iterable of (start, end, data) tuples where start==offset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def starting_at(self, offset):
    &#34;&#34;&#34;
    Returns an iterable of (start, end, data) tuples where start==offset
    &#34;&#34;&#34;
    return self._by_start.irange_key(
        min_key=(offset, 0), max_key=(offset, sys.maxsize)
    )</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.starting_before"><code class="name flex">
<span>def <span class="ident">starting_before</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns intervals
that start before offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def starting_before(self, offset):
    &#34;&#34;&#34;
    Returns intervals  that start before offset.
    &#34;&#34;&#34;
    return self._by_start.irange_key(max_key=(offset - 1, sys.maxsize))</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.starting_from"><code class="name flex">
<span>def <span class="ident">starting_from</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns intervals that start at or after offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def starting_from(self, offset):
    &#34;&#34;&#34;
    Returns intervals that start at or after offset.
    &#34;&#34;&#34;
    return self._by_start.irange_key(min_key=(offset, 0))</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, tupleiterable)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates from an iterable of intervals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, tupleiterable):
    &#34;&#34;&#34;
    Updates from an iterable of intervals.
    &#34;&#34;&#34;
    self._by_start.update(tupleiterable)
    self._by_end.update(tupleiterable)</code></pre>
</details>
</dd>
<dt id="gatenlp.impl.sortedintvls.SortedIntvls.within"><code class="name flex">
<span>def <span class="ident">within</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns intervals which are fully contained within start&hellip;end</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def within(self, start, end):
    &#34;&#34;&#34;
    Returns intervals which are fully contained within start...end
    &#34;&#34;&#34;
    # get all the intervals that start within the range, then keep those which also end within the range
    for intvl in self._by_start.irange_key(
        min_key=(start, 0), max_key=(end, sys.maxsize)
    ):
        if intvl[1] &lt;= end:
            yield intvl</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp.impl" href="index.html">gatenlp.impl</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.impl.sortedintvls.SortedIntvls" href="#gatenlp.impl.sortedintvls.SortedIntvls">SortedIntvls</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.add" href="#gatenlp.impl.sortedintvls.SortedIntvls.add">add</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.at" href="#gatenlp.impl.sortedintvls.SortedIntvls.at">at</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.covering" href="#gatenlp.impl.sortedintvls.SortedIntvls.covering">covering</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.discard" href="#gatenlp.impl.sortedintvls.SortedIntvls.discard">discard</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.ending_after" href="#gatenlp.impl.sortedintvls.SortedIntvls.ending_after">ending_after</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.ending_at" href="#gatenlp.impl.sortedintvls.SortedIntvls.ending_at">ending_at</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.ending_to" href="#gatenlp.impl.sortedintvls.SortedIntvls.ending_to">ending_to</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.firsts" href="#gatenlp.impl.sortedintvls.SortedIntvls.firsts">firsts</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.irange" href="#gatenlp.impl.sortedintvls.SortedIntvls.irange">irange</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.lasts" href="#gatenlp.impl.sortedintvls.SortedIntvls.lasts">lasts</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.max_end" href="#gatenlp.impl.sortedintvls.SortedIntvls.max_end">max_end</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.min_start" href="#gatenlp.impl.sortedintvls.SortedIntvls.min_start">min_start</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.overlapping" href="#gatenlp.impl.sortedintvls.SortedIntvls.overlapping">overlapping</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.remove" href="#gatenlp.impl.sortedintvls.SortedIntvls.remove">remove</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.starting_at" href="#gatenlp.impl.sortedintvls.SortedIntvls.starting_at">starting_at</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.starting_before" href="#gatenlp.impl.sortedintvls.SortedIntvls.starting_before">starting_before</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.starting_from" href="#gatenlp.impl.sortedintvls.SortedIntvls.starting_from">starting_from</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.update" href="#gatenlp.impl.sortedintvls.SortedIntvls.update">update</a></code></li>
<li><code><a title="gatenlp.impl.sortedintvls.SortedIntvls.within" href="#gatenlp.impl.sortedintvls.SortedIntvls.within">within</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev16+g8c2bb0d.d20201028</a>.</p>
</footer>
</body>
</html>