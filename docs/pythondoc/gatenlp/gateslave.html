<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev16+g8c2bb0d.d20201028" />
<title>gatenlp.gateslave API documentation</title>
<meta name="description" content="Module for interacting with a Java GATE process, running API commands on it and
exchanging data with it." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.gateslave</code></h1>
</header>
<section id="section-intro">
<p>Module for interacting with a Java GATE process, running API commands on it and
exchanging data with it.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
&#34;&#34;&#34;
Module for interacting with a Java GATE process, running API commands on it and
exchanging data with it.
&#34;&#34;&#34;

import sys
import subprocess
import os
import platform as sysplatform
import logging
import atexit
import secrets
import argparse
import signal

# NOTE: we delay imporint py4j to the class initializer. This allows us to make GateSlave available via gatenlp
# but does not force everyone to actually have py4j installed if they do not use the GateSlave
# from py4j.java_gateway import JavaGateway, GatewayParameters
from gatenlp import Document

JARVERSION = &#34;1.0&#34;

logging.basicConfig()
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


def classpath_sep(platform=None):
    &#34;&#34;&#34;

    Args:
      platform:  (Default value = None)

    Returns:
      :return: classpath separator character

    &#34;&#34;&#34;
    if not platform:
        myplatform = sysplatform.system()
        if not myplatform:
            raise Exception(&#34;Could not determine operating system, please use platform parameter&#34;)
        platform = myplatform
    if platform.lower() == &#34;windows&#34; or platform.lower() == &#34;win&#34;:
        return &#34;;&#34;
    else:
        return &#34;:&#34;


def gate_classpath(gatehome, platform=None):
    &#34;&#34;&#34;Return the GATE classpath components as a string, with the element seperator characters appropriate
    for the operating system.

    Args:
      gatehome: where GATE is installed, either as a cloned git repo or a downloaded installation dir.
      platform:  (Default value = None)

    Returns:
      GATE classpath

    &#34;&#34;&#34;
    # check which kind of GATE home we have: if there is a distro subdirectory, assume cloned git repo
    if not os.path.exists(gatehome):
        raise Exception(&#34;GATE home directory does not exist: {}&#34;.format(gatehome))
    if not os.path.isdir(gatehome):
        raise Exception(&#34;GATE home directory does not a directory: {}&#34;.format(gatehome))
    cpsep = classpath_sep(platform)
    cpfile = os.path.join(gatehome, &#34;gate.classpath&#34;)
    bindir = os.path.join(gatehome, &#34;bin&#34;)
    # logger.info(&#34;DEBUG checking for {}&#34;.format(cpfile))
    if os.path.exists(cpfile):
        if not os.path.exists(cpfile):
            raise Exception(&#34;File not found {}, distribution may need compiling&#34;.format(cpfile))
        with open(cpfile, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as fp:
            cp = fp.read()
            return cp + cpsep + bindir
    else:
        # logger.info(&#34;DEBUG {} does not exist&#34;.format(cpfile))
        libdir = os.path.join(gatehome, &#34;lib&#34;)
        bindir = os.path.join(gatehome, &#34;bin&#34;)
        if not os.path.isdir(libdir):
            raise Exception(&#34;Could not determine class path from {}, no lib directory&#34;.format(gatehome))
        # jars = glob.glob(os.path.join(libdir,&#34;*.jar&#34;))
        # return cpsep.join(jars)
        return libdir + cpsep + bindir


def start_gate_slave(
        port=25333,
        host=&#34;127.0.0.1&#34;,
        auth_token=None,
        use_auth_token=True,
        java=&#34;java&#34;,
        platform=None,
        gatehome=None,
        log_actions=False,
        keep=False,
):
    &#34;&#34;&#34;

    Args:
      port:  (Default value = 25333)
      host:  (Default value = &#34;127.0.0.1&#34;)
      auth_token:  (Default value = None)
      use_auth_token:  (Default value = True)
      java:  (Default value = &#34;java&#34;)
      platform:  (Default value = None)
      gatehome:  (Default value = None)
      log_actions:  (Default value = False)
      keep:  (Default value = False)

    Returns:

    &#34;&#34;&#34;
    if gatehome is None:
        gatehome = os.environ.get(&#34;GATE_HOME&#34;)
        if gatehome is None:
            raise Exception(&#34;Parameter gatehome is None and environment var GATE_HOME not set&#34;)
    if use_auth_token:
        if not auth_token:
            auth_token = secrets.token_urlsafe(20)
        else:
            auth_token = auth_token
    else:
        auth_token = &#34;&#34;
    if log_actions:
        log_actions = &#34;1&#34;
    else:
        log_actions = &#34;0&#34;
    if keep:
        keep = &#34;1&#34;
    else:
        keep = &#34;0&#34;
    jarloc = os.path.join(os.path.dirname(__file__), &#34;_jars&#34;, f&#34;gatetools-gatenlpslave-{JARVERSION}.jar&#34;)
    if not os.path.exists(jarloc):
        raise Exception(&#34;Could not find jar, {} does not exist&#34;.format(jarloc))
    cmdandparms = [java, &#34;-cp&#34;]
    cpsep = classpath_sep(platform=platform)
    cmdandparms.append(jarloc + cpsep + gate_classpath(gatehome, platform=platform))
    cmdandparms.append(&#34;gate.tools.gatenlpslave.GatenlpSlave&#34;)
    cmdandparms.append(str(port))
    cmdandparms.append(host)
    cmdandparms.append(log_actions)
    cmdandparms.append(keep)
    os.environ[&#34;GATENLP_SLAVE_TOKEN_&#34; + str(port)] = auth_token
    # logger.info(f&#34;DEBUG: running slave with port={port}, host={host},auth={auth_token},log={log_actions},keep={keep}&#34;)
    subproc = subprocess.Popen(cmdandparms, stderr=subprocess.PIPE, bufsize=0, encoding=&#34;utf-8&#34;)

    def shutdown():
        &#34;&#34;&#34; &#34;&#34;&#34;
        subproc.send_signal(signal.SIGINT)
        for line in subproc.stderr:
            print(line, file=sys.stderr, end=&#34;&#34;)

    atexit.register(shutdown)
    while True:
        line = subproc.stderr.readline().strip()
        if line == &#34;PythonSlaveRunner.java: server start OK&#34;:
            break
        if line == &#34;PythonSlaveRunner.java: server start NOT OK&#34;:
            raise Exception(&#34;Could not start server, giving up&#34;)
        print(line, file=sys.stderr)
    try:
        subproc.wait()
    except KeyboardInterrupt:
        print(&#34;Received keyboard interrupt, shutting down server...&#34;)
        shutdown()


class GateSlave:
    &#34;&#34;&#34; &#34;&#34;&#34;
    def __init__(self, port=25333,
                 start=True,
                 java=&#34;java&#34;,
                 host=&#34;127.0.0.1&#34;,
                 gatehome=None,
                 platform=None,
                 auth_token=None,
                 use_auth_token=True,
                 log_actions=False,
                 keep=False,
                 ):
        &#34;&#34;&#34;
        Create an instance of the GateSlave and either start our own Java GATE process for it to use
        (start=True) or connect to an existing one (start=False).

        After the GateSlave instance has been create successfully, it is possible to:

        * Use one of the methods of the instance to perform operations on the Java side or exchange data

        * use GateSlave.slave to invoke methods from the PythonSlave class on the Java side

        * use GateSlave.jvm to directly construct objects or call instance or static methods

        NOTE: the GATE process must not output anything important/big to stderr because everything from
        stderr gets captured and used for communication between the Java and Python processes. At least
        part of the output to stderr may only be passed on after the GATE process has ended.

        Example: ::

            gs = GateSlave()
            pipeline = gs.slave.loadPipelineFromFile(&#34;thePipeline.xgapp&#34;)
            doc = gs.slave.createDocument(&#34;Some document text&#34;)
            gs.slave.run4doc(pipeline,doc)
            pdoc = gs.gdoc2pdoc(doc)
            gs.slave.deleteResource(doc)
            # process the gatenlp Document pdoc ...

        :param port: port to use
        :param start: if True, try to start our own GATE process, otherwise expect an already started
           process at the host/port address
        :param java: path to the java binary to run or the java command to use from the PATH (for start=True)
        :param host: host an existing Java GATE process is running on (only relevant for start=False)
        :param gatehome: where GATE is installed (only relevant if start=True). If None, expects
               environment variable GATE_HOME to be set.
        :param platform: system platform we run on, one of Windows, Linux (also for MacOs) or Java
        :param auth_token: if None or &#34;&#34; and use_auth_token is True, generate a random token which
               is then accessible via the auth_token attribute, otherwise use the given auth token.
        :param use_auth_token: if False, do not use an auth token, otherwise either use the one specified
               via auth_token or generate a random one.
        :param log_actions: if the gate slave should log the actions it is doing
        :param keep: normally if gs.close() is called and we are not connected to the PythonSlaveLr,
               the slave will be shut down. If this is True, the gs.close() method does not shut down
               the slave.
        &#34;&#34;&#34;
        from py4j.java_gateway import JavaGateway, GatewayParameters

        self.gatehome = gatehome
        self.port = port
        self.host = host
        self.start = start
        self.gatehome = gatehome
        self.platform = platform
        self.gateprocess = None
        self.gateway = None
        self.slave = None
        self.closed = False
        self.keep = keep
        self.log_actions = log_actions
        if use_auth_token:
            if not auth_token:
                self.auth_token = secrets.token_urlsafe(20)
            else:
                self.auth_token = auth_token
        else:
            self.auth_token = &#34;&#34;
        if gatehome is None and start:
            gatehome = os.environ.get(&#34;GATE_HOME&#34;)
            if gatehome is None:
                raise Exception(&#34;Parameter gatehome is None and environment var GATE_HOME not set&#34;)
            self.gatehome = gatehome
        if start:
            # make sure we find the jar we need
            # logger.info(&#34;DEBUG: file location: {}&#34;.format(__file__))
            jarloc = os.path.join(os.path.dirname(__file__), &#34;_jars&#34;, f&#34;gatetools-gatenlpslave-{JARVERSION}.jar&#34;)
            if not os.path.exists(jarloc):
                raise Exception(&#34;Could not find jar, {} does not exist&#34;.format(jarloc))
            cmdandparms = [java, &#34;-cp&#34;]
            cpsep = classpath_sep(platform=platform)
            cmdandparms.append(jarloc + cpsep + gate_classpath(self.gatehome, platform=platform))
            cmdandparms.append(&#34;gate.tools.gatenlpslave.GatenlpSlave&#34;)
            cmdandparms.append(str(port))
            cmdandparms.append(host)
            if log_actions:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            if keep:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            os.environ[&#34;GATENLP_SLAVE_TOKEN_&#34;+str(self.port)] = self.auth_token
            # logger.info(f&#34;Running cmd: {cmdandparms}&#34;)
            subproc = subprocess.Popen(cmdandparms, stderr=subprocess.PIPE, bufsize=0, encoding=&#34;utf-8&#34;)
            self.gateprocess = subproc
            while True:
                line = subproc.stderr.readline().strip()
                if line == &#34;PythonSlaveRunner.java: server start OK&#34;:
                    break
                if line == &#34;PythonSlaveRunner.java: server start NOT OK&#34;:
                    raise Exception(&#34;Could not start server, giving up&#34;)
                print(line, file=sys.stderr)
            atexit.register(self.close)
        self.gateway = JavaGateway(
            gateway_parameters=GatewayParameters(port=port, auth_token=self.auth_token))
        self.jvm = self.gateway.jvm
        self.slave = self.gateway.entry_point

    def close(self):
        &#34;&#34;&#34;
        Clean up: if the gate slave process was started by us, we will shut it down.
        Otherwise we can still close it if it was started by the slaverunner, not the Lr
        Note: if it was started by us, it was started via the slaverunner.
        
        :return:

        Args:

        Returns:

        &#34;&#34;&#34;
        canclose = self.slave.isClosable()
        if canclose and not self.closed:
            self.closed = True
            self.gateway.shutdown()
            if self.gateprocess is not None:
                for line in self.gateprocess.stderr:
                    print(line, file=sys.stderr, end=&#34;&#34;)
                self.gateprocess.wait()

    def log_actions(self, onoff):
        &#34;&#34;&#34;Swith logging actions at the slave on or off.

        Args:
          onoff: True to log actions, False to not log them

        Returns:

        &#34;&#34;&#34;
        self.slave.logActions(onoff)

    def load_gdoc(self, path, mimetype=None):
        &#34;&#34;&#34;Let GATE load a document from the given path and return a handle to it.

        Args:
          path: path to the gate document to load.
          mimetype: a mimetype to use when loading. (Default value = None)

        Returns:
          a handle to the GATE document

        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        return self.slave.loadDocumentFromFile(path, mimetype)

    def save_gdoc(self, gdoc, path, mimetype=None):
        &#34;&#34;&#34;Save GATE document to the given path.

        Args:
          gdoc: GATE document handle
          path: destination path
          mimetype: mimtetype, only the following types are allowed: &#34;&#34;/None: GATE XML,
        application/fastinfoset, and all mimetypes supported by the Format_Bdoc plugin. (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        self.slave.saveDocumentToFile(path, mimetype)

    def gdoc2pdoc(self, gdoc):
        &#34;&#34;&#34;Convert the GATE document to a python document and return it.

        Args:
          gdoc: the handle to a GATE document

        Returns:
          a gatenlp Document instance

        &#34;&#34;&#34;
        bjs = self.slave.getBdocJson(gdoc)
        return Document.load_mem(bjs, fmt=&#34;bdocjs&#34;)

    def pdoc2gdoc(self, pdoc):
        &#34;&#34;&#34;Convert the Python gatenlp document to a GATE document and return a handle to it.

        Args:
          pdoc: python gatenlp Document

        Returns:
          handle to GATE document

        &#34;&#34;&#34;
        json = pdoc.save_mem(fmt=&#34;bdocjs&#34;)
        return self.slave.getDocument4BdocJson(json)

    def load_pdoc(self, path, mimetype=None):
        &#34;&#34;&#34;Load a document from the given path, using GATE and convert and return as gatenlp Python document.

        Args:
          path: path to load document from
          mimetype: mime type to use (Default value = None)

        Returns:
          gatenlp document

        &#34;&#34;&#34;
        gdoc = self.load_gdoc(path, mimetype)
        return self.gdoc2pdoc(gdoc)

    def del_gdoc(self, gdoc):
        &#34;&#34;&#34;Delete/unload the GATE document from GATE.
        This is necessary to do for each GATE document that is not used anymore, otherwise the documents
        will accumulate in the Java process and eat up all memory. NOTE: just removing all references to the
        GATE document does not delete/unload the document!

        Args:
          gdoc: the document to remove

        Returns:

        &#34;&#34;&#34;
        self.jvm.gate.Factory.deleteResource(gdoc)

    def show_gui(self):
        &#34;&#34;&#34;Show the GUI for the started GATE process. NOTE: this is more of a hack and may cause sync problems
        when closing down the GATE slave.
        
        :return:

        Args:

        Returns:

        &#34;&#34;&#34;
        self.slave.showGui()


def main():
    &#34;&#34;&#34; &#34;&#34;&#34;
    ap = argparse.ArgumentParser(description=&#34;Start Java GATE Slave&#34;)
    ap.add_argument(&#34;--port&#34;, default=25333, type=int, help=&#34;Port (25333)&#34;)
    ap.add_argument(&#34;--host&#34;, default=&#34;127.0.0.1&#34;, type=str, help=&#34;Host to bind to (127.0.0.1)&#34;)
    ap.add_argument(&#34;--auth&#34;, default=None, type=str, help=&#34;Auth token to use (generate random)&#34;)
    ap.add_argument(&#34;--noauth&#34;, action=&#34;store_true&#34;, help=&#34;Do not use auth token&#34;)
    ap.add_argument(&#34;--gatehome&#34;, default=None, type=str, help=&#34;Location of GATE (environment variable GATE_HOME)&#34;)
    ap.add_argument(&#34;--platform&#34;, default=None, type=str, help=&#34;OS/Platform: windows or linux (autodetect)&#34;)
    ap.add_argument(&#34;--log_actions&#34;, action=&#34;store_true&#34;, help=&#34;If slave actions should be logged&#34;)
    ap.add_argument(&#34;--keep&#34;, action=&#34;store_true&#34;, help=&#34;Prevent shutting down the slave&#34;)
    args = ap.parse_args()
    start_gate_slave(
        port=args.port,
        host=args.host,
        auth_token=args.auth,
        use_auth_token=not args.noauth,
        gatehome=args.gatehome,
        platform=args.platform,
        log_actions=args.log_actions,
        keep=args.keep,
    )


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gatenlp.gateslave.classpath_sep"><code class="name flex">
<span>def <span class="ident">classpath_sep</span></span>(<span>platform=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>platform</code></strong></dt>
<dd>(Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>:return: classpath separator character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def classpath_sep(platform=None):
    &#34;&#34;&#34;

    Args:
      platform:  (Default value = None)

    Returns:
      :return: classpath separator character

    &#34;&#34;&#34;
    if not platform:
        myplatform = sysplatform.system()
        if not myplatform:
            raise Exception(&#34;Could not determine operating system, please use platform parameter&#34;)
        platform = myplatform
    if platform.lower() == &#34;windows&#34; or platform.lower() == &#34;win&#34;:
        return &#34;;&#34;
    else:
        return &#34;:&#34;</code></pre>
</details>
</dd>
<dt id="gatenlp.gateslave.gate_classpath"><code class="name flex">
<span>def <span class="ident">gate_classpath</span></span>(<span>gatehome, platform=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the GATE classpath components as a string, with the element seperator characters appropriate
for the operating system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gatehome</code></strong></dt>
<dd>where GATE is installed, either as a cloned git repo or a downloaded installation dir.</dd>
<dt><strong><code>platform</code></strong></dt>
<dd>(Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>GATE classpath</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gate_classpath(gatehome, platform=None):
    &#34;&#34;&#34;Return the GATE classpath components as a string, with the element seperator characters appropriate
    for the operating system.

    Args:
      gatehome: where GATE is installed, either as a cloned git repo or a downloaded installation dir.
      platform:  (Default value = None)

    Returns:
      GATE classpath

    &#34;&#34;&#34;
    # check which kind of GATE home we have: if there is a distro subdirectory, assume cloned git repo
    if not os.path.exists(gatehome):
        raise Exception(&#34;GATE home directory does not exist: {}&#34;.format(gatehome))
    if not os.path.isdir(gatehome):
        raise Exception(&#34;GATE home directory does not a directory: {}&#34;.format(gatehome))
    cpsep = classpath_sep(platform)
    cpfile = os.path.join(gatehome, &#34;gate.classpath&#34;)
    bindir = os.path.join(gatehome, &#34;bin&#34;)
    # logger.info(&#34;DEBUG checking for {}&#34;.format(cpfile))
    if os.path.exists(cpfile):
        if not os.path.exists(cpfile):
            raise Exception(&#34;File not found {}, distribution may need compiling&#34;.format(cpfile))
        with open(cpfile, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as fp:
            cp = fp.read()
            return cp + cpsep + bindir
    else:
        # logger.info(&#34;DEBUG {} does not exist&#34;.format(cpfile))
        libdir = os.path.join(gatehome, &#34;lib&#34;)
        bindir = os.path.join(gatehome, &#34;bin&#34;)
        if not os.path.isdir(libdir):
            raise Exception(&#34;Could not determine class path from {}, no lib directory&#34;.format(gatehome))
        # jars = glob.glob(os.path.join(libdir,&#34;*.jar&#34;))
        # return cpsep.join(jars)
        return libdir + cpsep + bindir</code></pre>
</details>
</dd>
<dt id="gatenlp.gateslave.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34; &#34;&#34;&#34;
    ap = argparse.ArgumentParser(description=&#34;Start Java GATE Slave&#34;)
    ap.add_argument(&#34;--port&#34;, default=25333, type=int, help=&#34;Port (25333)&#34;)
    ap.add_argument(&#34;--host&#34;, default=&#34;127.0.0.1&#34;, type=str, help=&#34;Host to bind to (127.0.0.1)&#34;)
    ap.add_argument(&#34;--auth&#34;, default=None, type=str, help=&#34;Auth token to use (generate random)&#34;)
    ap.add_argument(&#34;--noauth&#34;, action=&#34;store_true&#34;, help=&#34;Do not use auth token&#34;)
    ap.add_argument(&#34;--gatehome&#34;, default=None, type=str, help=&#34;Location of GATE (environment variable GATE_HOME)&#34;)
    ap.add_argument(&#34;--platform&#34;, default=None, type=str, help=&#34;OS/Platform: windows or linux (autodetect)&#34;)
    ap.add_argument(&#34;--log_actions&#34;, action=&#34;store_true&#34;, help=&#34;If slave actions should be logged&#34;)
    ap.add_argument(&#34;--keep&#34;, action=&#34;store_true&#34;, help=&#34;Prevent shutting down the slave&#34;)
    args = ap.parse_args()
    start_gate_slave(
        port=args.port,
        host=args.host,
        auth_token=args.auth,
        use_auth_token=not args.noauth,
        gatehome=args.gatehome,
        platform=args.platform,
        log_actions=args.log_actions,
        keep=args.keep,
    )</code></pre>
</details>
</dd>
<dt id="gatenlp.gateslave.start_gate_slave"><code class="name flex">
<span>def <span class="ident">start_gate_slave</span></span>(<span>port=25333, host='127.0.0.1', auth_token=None, use_auth_token=True, java='java', platform=None, gatehome=None, log_actions=False, keep=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>port</code></strong></dt>
<dd>(Default value = 25333)</dd>
<dt><strong><code>host</code></strong></dt>
<dd>(Default value = "127.0.0.1")</dd>
<dt><strong><code>auth_token</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>use_auth_token</code></strong></dt>
<dd>(Default value = True)</dd>
<dt><strong><code>java</code></strong></dt>
<dd>(Default value = "java")</dd>
<dt><strong><code>platform</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>gatehome</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>log_actions</code></strong></dt>
<dd>(Default value = False)</dd>
<dt><strong><code>keep</code></strong></dt>
<dd>(Default value = False)</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_gate_slave(
        port=25333,
        host=&#34;127.0.0.1&#34;,
        auth_token=None,
        use_auth_token=True,
        java=&#34;java&#34;,
        platform=None,
        gatehome=None,
        log_actions=False,
        keep=False,
):
    &#34;&#34;&#34;

    Args:
      port:  (Default value = 25333)
      host:  (Default value = &#34;127.0.0.1&#34;)
      auth_token:  (Default value = None)
      use_auth_token:  (Default value = True)
      java:  (Default value = &#34;java&#34;)
      platform:  (Default value = None)
      gatehome:  (Default value = None)
      log_actions:  (Default value = False)
      keep:  (Default value = False)

    Returns:

    &#34;&#34;&#34;
    if gatehome is None:
        gatehome = os.environ.get(&#34;GATE_HOME&#34;)
        if gatehome is None:
            raise Exception(&#34;Parameter gatehome is None and environment var GATE_HOME not set&#34;)
    if use_auth_token:
        if not auth_token:
            auth_token = secrets.token_urlsafe(20)
        else:
            auth_token = auth_token
    else:
        auth_token = &#34;&#34;
    if log_actions:
        log_actions = &#34;1&#34;
    else:
        log_actions = &#34;0&#34;
    if keep:
        keep = &#34;1&#34;
    else:
        keep = &#34;0&#34;
    jarloc = os.path.join(os.path.dirname(__file__), &#34;_jars&#34;, f&#34;gatetools-gatenlpslave-{JARVERSION}.jar&#34;)
    if not os.path.exists(jarloc):
        raise Exception(&#34;Could not find jar, {} does not exist&#34;.format(jarloc))
    cmdandparms = [java, &#34;-cp&#34;]
    cpsep = classpath_sep(platform=platform)
    cmdandparms.append(jarloc + cpsep + gate_classpath(gatehome, platform=platform))
    cmdandparms.append(&#34;gate.tools.gatenlpslave.GatenlpSlave&#34;)
    cmdandparms.append(str(port))
    cmdandparms.append(host)
    cmdandparms.append(log_actions)
    cmdandparms.append(keep)
    os.environ[&#34;GATENLP_SLAVE_TOKEN_&#34; + str(port)] = auth_token
    # logger.info(f&#34;DEBUG: running slave with port={port}, host={host},auth={auth_token},log={log_actions},keep={keep}&#34;)
    subproc = subprocess.Popen(cmdandparms, stderr=subprocess.PIPE, bufsize=0, encoding=&#34;utf-8&#34;)

    def shutdown():
        &#34;&#34;&#34; &#34;&#34;&#34;
        subproc.send_signal(signal.SIGINT)
        for line in subproc.stderr:
            print(line, file=sys.stderr, end=&#34;&#34;)

    atexit.register(shutdown)
    while True:
        line = subproc.stderr.readline().strip()
        if line == &#34;PythonSlaveRunner.java: server start OK&#34;:
            break
        if line == &#34;PythonSlaveRunner.java: server start NOT OK&#34;:
            raise Exception(&#34;Could not start server, giving up&#34;)
        print(line, file=sys.stderr)
    try:
        subproc.wait()
    except KeyboardInterrupt:
        print(&#34;Received keyboard interrupt, shutting down server...&#34;)
        shutdown()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.gateslave.GateSlave"><code class="flex name class">
<span>class <span class="ident">GateSlave</span></span>
<span>(</span><span>port=25333, start=True, java='java', host='127.0.0.1', gatehome=None, platform=None, auth_token=None, use_auth_token=True, log_actions=False, keep=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an instance of the GateSlave and either start our own Java GATE process for it to use
(start=True) or connect to an existing one (start=False).</p>
<p>After the GateSlave instance has been create successfully, it is possible to:</p>
<ul>
<li>
<p>Use one of the methods of the instance to perform operations on the Java side or exchange data</p>
</li>
<li>
<p>use GateSlave.slave to invoke methods from the PythonSlave class on the Java side</p>
</li>
<li>
<p>use GateSlave.jvm to directly construct objects or call instance or static methods</p>
</li>
</ul>
<p>NOTE: the GATE process must not output anything important/big to stderr because everything from
stderr gets captured and used for communication between the Java and Python processes. At least
part of the output to stderr may only be passed on after the GATE process has ended.</p>
<p>Example: ::</p>
<pre><code>gs = GateSlave()
pipeline = gs.slave.loadPipelineFromFile("thePipeline.xgapp")
doc = gs.slave.createDocument("Some document text")
gs.slave.run4doc(pipeline,doc)
pdoc = gs.gdoc2pdoc(doc)
gs.slave.deleteResource(doc)
# process the gatenlp Document pdoc ...
</code></pre>
<p>:param port: port to use
:param start: if True, try to start our own GATE process, otherwise expect an already started
process at the host/port address
:param java: path to the java binary to run or the java command to use from the PATH (for start=True)
:param host: host an existing Java GATE process is running on (only relevant for start=False)
:param gatehome: where GATE is installed (only relevant if start=True). If None, expects
environment variable GATE_HOME to be set.
:param platform: system platform we run on, one of Windows, Linux (also for MacOs) or Java
:param auth_token: if None or "" and use_auth_token is True, generate a random token which
is then accessible via the auth_token attribute, otherwise use the given auth token.
:param use_auth_token: if False, do not use an auth token, otherwise either use the one specified
via auth_token or generate a random one.
:param log_actions: if the gate slave should log the actions it is doing
:param keep: normally if gs.close() is called and we are not connected to the PythonSlaveLr,
the slave will be shut down. If this is True, the gs.close() method does not shut down
the slave.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GateSlave:
    &#34;&#34;&#34; &#34;&#34;&#34;
    def __init__(self, port=25333,
                 start=True,
                 java=&#34;java&#34;,
                 host=&#34;127.0.0.1&#34;,
                 gatehome=None,
                 platform=None,
                 auth_token=None,
                 use_auth_token=True,
                 log_actions=False,
                 keep=False,
                 ):
        &#34;&#34;&#34;
        Create an instance of the GateSlave and either start our own Java GATE process for it to use
        (start=True) or connect to an existing one (start=False).

        After the GateSlave instance has been create successfully, it is possible to:

        * Use one of the methods of the instance to perform operations on the Java side or exchange data

        * use GateSlave.slave to invoke methods from the PythonSlave class on the Java side

        * use GateSlave.jvm to directly construct objects or call instance or static methods

        NOTE: the GATE process must not output anything important/big to stderr because everything from
        stderr gets captured and used for communication between the Java and Python processes. At least
        part of the output to stderr may only be passed on after the GATE process has ended.

        Example: ::

            gs = GateSlave()
            pipeline = gs.slave.loadPipelineFromFile(&#34;thePipeline.xgapp&#34;)
            doc = gs.slave.createDocument(&#34;Some document text&#34;)
            gs.slave.run4doc(pipeline,doc)
            pdoc = gs.gdoc2pdoc(doc)
            gs.slave.deleteResource(doc)
            # process the gatenlp Document pdoc ...

        :param port: port to use
        :param start: if True, try to start our own GATE process, otherwise expect an already started
           process at the host/port address
        :param java: path to the java binary to run or the java command to use from the PATH (for start=True)
        :param host: host an existing Java GATE process is running on (only relevant for start=False)
        :param gatehome: where GATE is installed (only relevant if start=True). If None, expects
               environment variable GATE_HOME to be set.
        :param platform: system platform we run on, one of Windows, Linux (also for MacOs) or Java
        :param auth_token: if None or &#34;&#34; and use_auth_token is True, generate a random token which
               is then accessible via the auth_token attribute, otherwise use the given auth token.
        :param use_auth_token: if False, do not use an auth token, otherwise either use the one specified
               via auth_token or generate a random one.
        :param log_actions: if the gate slave should log the actions it is doing
        :param keep: normally if gs.close() is called and we are not connected to the PythonSlaveLr,
               the slave will be shut down. If this is True, the gs.close() method does not shut down
               the slave.
        &#34;&#34;&#34;
        from py4j.java_gateway import JavaGateway, GatewayParameters

        self.gatehome = gatehome
        self.port = port
        self.host = host
        self.start = start
        self.gatehome = gatehome
        self.platform = platform
        self.gateprocess = None
        self.gateway = None
        self.slave = None
        self.closed = False
        self.keep = keep
        self.log_actions = log_actions
        if use_auth_token:
            if not auth_token:
                self.auth_token = secrets.token_urlsafe(20)
            else:
                self.auth_token = auth_token
        else:
            self.auth_token = &#34;&#34;
        if gatehome is None and start:
            gatehome = os.environ.get(&#34;GATE_HOME&#34;)
            if gatehome is None:
                raise Exception(&#34;Parameter gatehome is None and environment var GATE_HOME not set&#34;)
            self.gatehome = gatehome
        if start:
            # make sure we find the jar we need
            # logger.info(&#34;DEBUG: file location: {}&#34;.format(__file__))
            jarloc = os.path.join(os.path.dirname(__file__), &#34;_jars&#34;, f&#34;gatetools-gatenlpslave-{JARVERSION}.jar&#34;)
            if not os.path.exists(jarloc):
                raise Exception(&#34;Could not find jar, {} does not exist&#34;.format(jarloc))
            cmdandparms = [java, &#34;-cp&#34;]
            cpsep = classpath_sep(platform=platform)
            cmdandparms.append(jarloc + cpsep + gate_classpath(self.gatehome, platform=platform))
            cmdandparms.append(&#34;gate.tools.gatenlpslave.GatenlpSlave&#34;)
            cmdandparms.append(str(port))
            cmdandparms.append(host)
            if log_actions:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            if keep:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            os.environ[&#34;GATENLP_SLAVE_TOKEN_&#34;+str(self.port)] = self.auth_token
            # logger.info(f&#34;Running cmd: {cmdandparms}&#34;)
            subproc = subprocess.Popen(cmdandparms, stderr=subprocess.PIPE, bufsize=0, encoding=&#34;utf-8&#34;)
            self.gateprocess = subproc
            while True:
                line = subproc.stderr.readline().strip()
                if line == &#34;PythonSlaveRunner.java: server start OK&#34;:
                    break
                if line == &#34;PythonSlaveRunner.java: server start NOT OK&#34;:
                    raise Exception(&#34;Could not start server, giving up&#34;)
                print(line, file=sys.stderr)
            atexit.register(self.close)
        self.gateway = JavaGateway(
            gateway_parameters=GatewayParameters(port=port, auth_token=self.auth_token))
        self.jvm = self.gateway.jvm
        self.slave = self.gateway.entry_point

    def close(self):
        &#34;&#34;&#34;
        Clean up: if the gate slave process was started by us, we will shut it down.
        Otherwise we can still close it if it was started by the slaverunner, not the Lr
        Note: if it was started by us, it was started via the slaverunner.
        
        :return:

        Args:

        Returns:

        &#34;&#34;&#34;
        canclose = self.slave.isClosable()
        if canclose and not self.closed:
            self.closed = True
            self.gateway.shutdown()
            if self.gateprocess is not None:
                for line in self.gateprocess.stderr:
                    print(line, file=sys.stderr, end=&#34;&#34;)
                self.gateprocess.wait()

    def log_actions(self, onoff):
        &#34;&#34;&#34;Swith logging actions at the slave on or off.

        Args:
          onoff: True to log actions, False to not log them

        Returns:

        &#34;&#34;&#34;
        self.slave.logActions(onoff)

    def load_gdoc(self, path, mimetype=None):
        &#34;&#34;&#34;Let GATE load a document from the given path and return a handle to it.

        Args:
          path: path to the gate document to load.
          mimetype: a mimetype to use when loading. (Default value = None)

        Returns:
          a handle to the GATE document

        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        return self.slave.loadDocumentFromFile(path, mimetype)

    def save_gdoc(self, gdoc, path, mimetype=None):
        &#34;&#34;&#34;Save GATE document to the given path.

        Args:
          gdoc: GATE document handle
          path: destination path
          mimetype: mimtetype, only the following types are allowed: &#34;&#34;/None: GATE XML,
        application/fastinfoset, and all mimetypes supported by the Format_Bdoc plugin. (Default value = None)

        Returns:

        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        self.slave.saveDocumentToFile(path, mimetype)

    def gdoc2pdoc(self, gdoc):
        &#34;&#34;&#34;Convert the GATE document to a python document and return it.

        Args:
          gdoc: the handle to a GATE document

        Returns:
          a gatenlp Document instance

        &#34;&#34;&#34;
        bjs = self.slave.getBdocJson(gdoc)
        return Document.load_mem(bjs, fmt=&#34;bdocjs&#34;)

    def pdoc2gdoc(self, pdoc):
        &#34;&#34;&#34;Convert the Python gatenlp document to a GATE document and return a handle to it.

        Args:
          pdoc: python gatenlp Document

        Returns:
          handle to GATE document

        &#34;&#34;&#34;
        json = pdoc.save_mem(fmt=&#34;bdocjs&#34;)
        return self.slave.getDocument4BdocJson(json)

    def load_pdoc(self, path, mimetype=None):
        &#34;&#34;&#34;Load a document from the given path, using GATE and convert and return as gatenlp Python document.

        Args:
          path: path to load document from
          mimetype: mime type to use (Default value = None)

        Returns:
          gatenlp document

        &#34;&#34;&#34;
        gdoc = self.load_gdoc(path, mimetype)
        return self.gdoc2pdoc(gdoc)

    def del_gdoc(self, gdoc):
        &#34;&#34;&#34;Delete/unload the GATE document from GATE.
        This is necessary to do for each GATE document that is not used anymore, otherwise the documents
        will accumulate in the Java process and eat up all memory. NOTE: just removing all references to the
        GATE document does not delete/unload the document!

        Args:
          gdoc: the document to remove

        Returns:

        &#34;&#34;&#34;
        self.jvm.gate.Factory.deleteResource(gdoc)

    def show_gui(self):
        &#34;&#34;&#34;Show the GUI for the started GATE process. NOTE: this is more of a hack and may cause sync problems
        when closing down the GATE slave.
        
        :return:

        Args:

        Returns:

        &#34;&#34;&#34;
        self.slave.showGui()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.gateslave.GateSlave.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clean up: if the gate slave process was started by us, we will shut it down.
Otherwise we can still close it if it was started by the slaverunner, not the Lr
Note: if it was started by us, it was started via the slaverunner.</p>
<p>:return:</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Clean up: if the gate slave process was started by us, we will shut it down.
    Otherwise we can still close it if it was started by the slaverunner, not the Lr
    Note: if it was started by us, it was started via the slaverunner.
    
    :return:

    Args:

    Returns:

    &#34;&#34;&#34;
    canclose = self.slave.isClosable()
    if canclose and not self.closed:
        self.closed = True
        self.gateway.shutdown()
        if self.gateprocess is not None:
            for line in self.gateprocess.stderr:
                print(line, file=sys.stderr, end=&#34;&#34;)
            self.gateprocess.wait()</code></pre>
</details>
</dd>
<dt id="gatenlp.gateslave.GateSlave.del_gdoc"><code class="name flex">
<span>def <span class="ident">del_gdoc</span></span>(<span>self, gdoc)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete/unload the GATE document from GATE.
This is necessary to do for each GATE document that is not used anymore, otherwise the documents
will accumulate in the Java process and eat up all memory. NOTE: just removing all references to the
GATE document does not delete/unload the document!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>the document to remove</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_gdoc(self, gdoc):
    &#34;&#34;&#34;Delete/unload the GATE document from GATE.
    This is necessary to do for each GATE document that is not used anymore, otherwise the documents
    will accumulate in the Java process and eat up all memory. NOTE: just removing all references to the
    GATE document does not delete/unload the document!

    Args:
      gdoc: the document to remove

    Returns:

    &#34;&#34;&#34;
    self.jvm.gate.Factory.deleteResource(gdoc)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateslave.GateSlave.gdoc2pdoc"><code class="name flex">
<span>def <span class="ident">gdoc2pdoc</span></span>(<span>self, gdoc)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the GATE document to a python document and return it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>the handle to a GATE document</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a gatenlp Document instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gdoc2pdoc(self, gdoc):
    &#34;&#34;&#34;Convert the GATE document to a python document and return it.

    Args:
      gdoc: the handle to a GATE document

    Returns:
      a gatenlp Document instance

    &#34;&#34;&#34;
    bjs = self.slave.getBdocJson(gdoc)
    return Document.load_mem(bjs, fmt=&#34;bdocjs&#34;)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateslave.GateSlave.load_gdoc"><code class="name flex">
<span>def <span class="ident">load_gdoc</span></span>(<span>self, path, mimetype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Let GATE load a document from the given path and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>path to the gate document to load.</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>a mimetype to use when loading. (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the GATE document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_gdoc(self, path, mimetype=None):
    &#34;&#34;&#34;Let GATE load a document from the given path and return a handle to it.

    Args:
      path: path to the gate document to load.
      mimetype: a mimetype to use when loading. (Default value = None)

    Returns:
      a handle to the GATE document

    &#34;&#34;&#34;
    if mimetype is None:
        mimetype = &#34;&#34;
    return self.slave.loadDocumentFromFile(path, mimetype)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateslave.GateSlave.load_pdoc"><code class="name flex">
<span>def <span class="ident">load_pdoc</span></span>(<span>self, path, mimetype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a document from the given path, using GATE and convert and return as gatenlp Python document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>path to load document from</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>mime type to use (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>gatenlp document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_pdoc(self, path, mimetype=None):
    &#34;&#34;&#34;Load a document from the given path, using GATE and convert and return as gatenlp Python document.

    Args:
      path: path to load document from
      mimetype: mime type to use (Default value = None)

    Returns:
      gatenlp document

    &#34;&#34;&#34;
    gdoc = self.load_gdoc(path, mimetype)
    return self.gdoc2pdoc(gdoc)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateslave.GateSlave.log_actions"><code class="name flex">
<span>def <span class="ident">log_actions</span></span>(<span>self, onoff)</span>
</code></dt>
<dd>
<div class="desc"><p>Swith logging actions at the slave on or off.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>onoff</code></strong></dt>
<dd>True to log actions, False to not log them</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_actions(self, onoff):
    &#34;&#34;&#34;Swith logging actions at the slave on or off.

    Args:
      onoff: True to log actions, False to not log them

    Returns:

    &#34;&#34;&#34;
    self.slave.logActions(onoff)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateslave.GateSlave.pdoc2gdoc"><code class="name flex">
<span>def <span class="ident">pdoc2gdoc</span></span>(<span>self, pdoc)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the Python gatenlp document to a GATE document and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdoc</code></strong></dt>
<dd>python gatenlp Document</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>handle to GATE document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdoc2gdoc(self, pdoc):
    &#34;&#34;&#34;Convert the Python gatenlp document to a GATE document and return a handle to it.

    Args:
      pdoc: python gatenlp Document

    Returns:
      handle to GATE document

    &#34;&#34;&#34;
    json = pdoc.save_mem(fmt=&#34;bdocjs&#34;)
    return self.slave.getDocument4BdocJson(json)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateslave.GateSlave.save_gdoc"><code class="name flex">
<span>def <span class="ident">save_gdoc</span></span>(<span>self, gdoc, path, mimetype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save GATE document to the given path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>GATE document handle</dd>
<dt><strong><code>path</code></strong></dt>
<dd>destination path</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>mimtetype, only the following types are allowed: ""/None: GATE XML,</dd>
</dl>
<p>application/fastinfoset, and all mimetypes supported by the Format_Bdoc plugin. (Default value = None)</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_gdoc(self, gdoc, path, mimetype=None):
    &#34;&#34;&#34;Save GATE document to the given path.

    Args:
      gdoc: GATE document handle
      path: destination path
      mimetype: mimtetype, only the following types are allowed: &#34;&#34;/None: GATE XML,
    application/fastinfoset, and all mimetypes supported by the Format_Bdoc plugin. (Default value = None)

    Returns:

    &#34;&#34;&#34;
    if mimetype is None:
        mimetype = &#34;&#34;
    self.slave.saveDocumentToFile(path, mimetype)</code></pre>
</details>
</dd>
<dt id="gatenlp.gateslave.GateSlave.show_gui"><code class="name flex">
<span>def <span class="ident">show_gui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the GUI for the started GATE process. NOTE: this is more of a hack and may cause sync problems
when closing down the GATE slave.</p>
<p>:return:</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_gui(self):
    &#34;&#34;&#34;Show the GUI for the started GATE process. NOTE: this is more of a hack and may cause sync problems
    when closing down the GATE slave.
    
    :return:

    Args:

    Returns:

    &#34;&#34;&#34;
    self.slave.showGui()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp" href="index.html">gatenlp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gatenlp.gateslave.classpath_sep" href="#gatenlp.gateslave.classpath_sep">classpath_sep</a></code></li>
<li><code><a title="gatenlp.gateslave.gate_classpath" href="#gatenlp.gateslave.gate_classpath">gate_classpath</a></code></li>
<li><code><a title="gatenlp.gateslave.main" href="#gatenlp.gateslave.main">main</a></code></li>
<li><code><a title="gatenlp.gateslave.start_gate_slave" href="#gatenlp.gateslave.start_gate_slave">start_gate_slave</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.gateslave.GateSlave" href="#gatenlp.gateslave.GateSlave">GateSlave</a></code></h4>
<ul class="two-column">
<li><code><a title="gatenlp.gateslave.GateSlave.close" href="#gatenlp.gateslave.GateSlave.close">close</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.del_gdoc" href="#gatenlp.gateslave.GateSlave.del_gdoc">del_gdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.gdoc2pdoc" href="#gatenlp.gateslave.GateSlave.gdoc2pdoc">gdoc2pdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.load_gdoc" href="#gatenlp.gateslave.GateSlave.load_gdoc">load_gdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.load_pdoc" href="#gatenlp.gateslave.GateSlave.load_pdoc">load_pdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.log_actions" href="#gatenlp.gateslave.GateSlave.log_actions">log_actions</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.pdoc2gdoc" href="#gatenlp.gateslave.GateSlave.pdoc2gdoc">pdoc2gdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.save_gdoc" href="#gatenlp.gateslave.GateSlave.save_gdoc">save_gdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.show_gui" href="#gatenlp.gateslave.GateSlave.show_gui">show_gui</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev16+g8c2bb0d.d20201028</a>.</p>
</footer>
</body>
</html>