<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2.dev22+gf4251dd" />
<title>gatenlp.gateslave API documentation</title>
<meta name="description" content="Module for interacting with a Java GATE process, running API commands on it and
exchanging data with it." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gatenlp.gateslave</code></h1>
</header>
<section id="section-intro">
<p>Module for interacting with a Java GATE process, running API commands on it and
exchanging data with it.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
&#34;&#34;&#34;
Module for interacting with a Java GATE process, running API commands on it and
exchanging data with it.
&#34;&#34;&#34;

import sys
import subprocess
import os
import platform as sysplatform
import logging
import atexit
import secrets
import argparse
import signal
import glob
import json
from gatenlp.annotation_set import AnnotationSet

# NOTE: we delay importing py4j to the class initializer. This allows us to make GateSlave available via gatenlp
# but does not force everyone to actually have py4j installed if they do not use the GateSlave
# from py4j.java_gateway import JavaGateway, GatewayParameters
from gatenlp import Document
from gatenlp.utils import init_logger
from gatenlp.processing.annotator import Annotator

JARVERSION = &#34;1.0&#34;

logging.basicConfig()
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

__pdoc__ = {&#34;GateSlaveAnnotator.__call__&#34;: True}


def classpath_sep(platform=None):
    &#34;&#34;&#34;
    Get the system-specific classpath separator character.

    Args:
      platform:  (Default value = None) win/windows for Windows, anything else for non-windows
        If not specified, tries to determine automatically (which may fail)

    Returns:
      classpath separator character

    &#34;&#34;&#34;
    if not platform:
        myplatform = sysplatform.system()
        if not myplatform:
            raise Exception(
                &#34;Could not determine operating system, please use platform parameter&#34;
            )
        platform = myplatform
    if platform.lower() == &#34;windows&#34; or platform.lower() == &#34;win&#34;:
        return &#34;;&#34;
    else:
        return &#34;:&#34;


def gate_classpath(gatehome, platform=None):
    &#34;&#34;&#34;
    Return the GATE classpath components as a string, with the path seperator characters appropriate
    for the operating system.

    Args:
      gatehome: where GATE is installed, either as a cloned git repo or a downloaded installation dir.
      platform:  (Default value = None) win/windows for Windows, anything else for non-Windows.

    Returns:
      GATE classpath

    Raises:
        Exception if classpath could not be determined.

    &#34;&#34;&#34;
    # check which kind of GATE home we have: if there is a distro subdirectory, assume cloned git repo
    if not os.path.exists(gatehome):
        raise Exception(&#34;GATE home directory does not exist: {}&#34;.format(gatehome))
    if not os.path.isdir(gatehome):
        raise Exception(&#34;GATE home directory does not a directory: {}&#34;.format(gatehome))
    cpsep = classpath_sep(platform)
    cpfile = os.path.join(gatehome, &#34;gate.classpath&#34;)
    bindir = os.path.join(gatehome, &#34;bin&#34;)
    # logger.info(&#34;DEBUG checking for {}&#34;.format(cpfile))
    if os.path.exists(cpfile):
        if not os.path.exists(cpfile):
            raise Exception(
                &#34;File not found {}, distribution may need compiling&#34;.format(cpfile)
            )
        with open(cpfile, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as fp:
            cp = fp.read()
            return cp + cpsep + bindir
    else:
        # logger.info(&#34;DEBUG {} does not exist&#34;.format(cpfile))
        libdir = os.path.join(gatehome, &#34;lib&#34;)
        bindir = os.path.join(gatehome, &#34;bin&#34;)
        if not os.path.isdir(libdir):
            raise Exception(
                &#34;Could not determine class path from {}, no lib directory&#34;.format(
                    gatehome
                )
            )
        jars = glob.glob(os.path.join(libdir, &#34;*.jar&#34;))
        libcp = cpsep.join(jars)

        return libcp + cpsep + bindir


def start_gate_slave(
    port=25333,
    host=&#34;127.0.0.1&#34;,
    auth_token=None,
    use_auth_token=True,
    java=&#34;java&#34;,
    platform=None,
    gatehome=None,
    log_actions=False,
    keep=False,
    debug=False,
):
    &#34;&#34;&#34;
    Run the gate slave program. This starts the Java program included with gatenlp to
    run GATE and execute the gate slave within GATE so that Python can connect to it.

    Args:
      port:  (Default value = 25333) Port number to use
      host:  (Default value = &#34;127.0.0.1&#34;) Host address to bind to
      auth_token:  (Default value = None)  Authorization token to use. If None, creates a random token.
      use_auth_token:  (Default value = True) If False, do not aue an authorization token at all.
         This allows anyone who can connect to the host address to connect and use the gate slave process.
      java:  (Default value = &#34;java&#34;) Java command (if on the binary path) or full path to the binary
         to use for running the gate slave program.
      platform:  (Default value = None) &#34;win&#34;/&#34;windows&#34; for Windows, anything else for non-Windows.
         If None, tries to determine automatically.
      gatehome:  (Default value = None) The path to where GATE is installed. If None, the environment
         variable &#34;GATE_HOME&#34; is used.
      log_actions:  (Default value = False) If True, the GATE Slave process will log everything it is
         ordered to do.
      keep:  (Default value = False) passed on to the gate slave process and tells the process if it should
         report to the using Pythong process that it can be closed or not.
      debug: (Default valuye = False) Show debug messages.
    &#34;&#34;&#34;
    logger = init_logger(__name__)
    if debug:
        logger.setLevel(logging.DEBUG)

    if gatehome is None:
        gatehome = os.environ.get(&#34;GATE_HOME&#34;)
        if gatehome is None:
            raise Exception(
                &#34;Parameter gatehome is None and environment var GATE_HOME not set&#34;
            )
    if use_auth_token:
        if not auth_token:
            auth_token = secrets.token_urlsafe(20)
        else:
            auth_token = auth_token
    else:
        auth_token = &#34;&#34;
    if log_actions:
        log_actions = &#34;1&#34;
    else:
        log_actions = &#34;0&#34;
    if keep:
        keep = &#34;1&#34;
    else:
        keep = &#34;0&#34;
    logger.debug(
        f&#34;Starting gate slave, gatehome={gatehome}, auth_token={auth_token}, log_actions={log_actions}, keep={keep}&#34;
    )
    jarloc = os.path.join(
        os.path.dirname(__file__), &#34;_jars&#34;, f&#34;gatetools-gatenlpslave-{JARVERSION}.jar&#34;
    )
    if not os.path.exists(jarloc):
        raise Exception(&#34;Could not find jar, {} does not exist&#34;.format(jarloc))
    logger.debug(f&#34;Using JAR: {jarloc}&#34;)
    cmdandparms = [java, &#34;-cp&#34;]
    cpsep = classpath_sep(platform=platform)
    cmdandparms.append(jarloc + cpsep + gate_classpath(gatehome, platform=platform))
    cmdandparms.append(&#34;gate.tools.gatenlpslave.GatenlpSlave&#34;)
    cmdandparms.append(str(port))
    cmdandparms.append(host)
    cmdandparms.append(log_actions)
    cmdandparms.append(keep)
    os.environ[&#34;GATENLP_SLAVE_TOKEN_&#34; + str(port)] = auth_token
    cmd = &#34; &#34;.join(cmdandparms)
    logger.debug(f&#34;Running command: {cmd}&#34;)
    subproc = subprocess.Popen(
        cmdandparms, stderr=subprocess.PIPE, bufsize=0, encoding=&#34;utf-8&#34;
    )

    def shutdown():
        &#34;&#34;&#34;
        Handler that gets invoked when the calling Python program exits.
        This terminates the gate slave by sending the SIGINT signal to it.
        &#34;&#34;&#34;
        subproc.send_signal(signal.SIGINT)
        for line in subproc.stderr:
            print(line, file=sys.stderr, end=&#34;&#34;)

    atexit.register(shutdown)
    while True:
        line = subproc.stderr.readline()
        if line == &#34;&#34;:
            break
        line = line.rstrip(&#34;\n\r&#34;)
        if line == &#34;PythonSlaveRunner.java: server start OK&#34;:
            break
        if line == &#34;PythonSlaveRunner.java: server start NOT OK&#34;:
            raise Exception(&#34;Could not start server, giving up&#34;)
        print(line, file=sys.stderr)
    try:
        subproc.wait()
    except KeyboardInterrupt:
        print(&#34;Received keyboard interrupt, shutting down server...&#34;)
        shutdown()


class GateSlave:
    &#34;&#34;&#34;
    Gate slave for remotely running arbitrary GATE and other JAVA operations in a separate
    Java GATE process.
    &#34;&#34;&#34;

    def __init__(
        self,
        port=25333,
        start=True,
        java=&#34;java&#34;,
        host=&#34;127.0.0.1&#34;,
        gatehome=None,
        platform=None,
        auth_token=None,
        use_auth_token=True,
        log_actions=False,
        keep=False,
        debug=False,
    ):
        &#34;&#34;&#34;
        Create an instance of the GateSlave and either start our own Java GATE process for it to use
        (start=True) or connect to an existing one (start=False).

        After the GateSlave instance has been create successfully, it is possible to:

        * Use one of the methods of the instance to perform operations on the Java side or exchange data

        * use GateSlave.slave to invoke methods from the PythonSlave class on the Java side

        * use GateSlave.jvm to directly construct objects or call instance or static methods

        NOTE: the GATE process must not output anything important/big to stderr because everything from
        stderr gets captured and used for communication between the Java and Python processes. At least
        part of the output to stderr may only be passed on after the GATE process has ended.

        Example:

            ```python
            gs = GateSlave()
            pipeline = gs.slave.loadPipelineFromFile(&#34;thePipeline.xgapp&#34;)
            doc = gs.slave.createDocument(&#34;Some document text&#34;)
            gs.slave.run4doc(pipeline,doc)
            pdoc = gs.gdoc2pdoc(doc)
            gs.slave.deleteResource(doc)
            # process the document pdoc ...
            ```

        port: port to use
        start: if True, try to start our own GATE process, otherwise expect an already started
           process at the host/port address
        java: path to the java binary to run or the java command to use from the PATH (for start=True)
        host: host an existing Java GATE process is running on (only relevant for start=False)
        gatehome: where GATE is installed (only relevant if start=True). If None, expects
               environment variable GATE_HOME to be set.
        platform: system platform we run on, one of Windows, Linux (also for MacOs) or Java
        auth_token: if None or &#34;&#34; and use_auth_token is True, generate a random token which
               is then accessible via the auth_token attribute, otherwise use the given auth token.
        use_auth_token: if False, do not use an auth token, otherwise either use the one specified
               via auth_token or generate a random one.
        log_actions: if the gate slave should log the actions it is doing
        keep: normally if gs.close() is called and we are not connected to the PythonSlaveLr,
               the slave will be shut down. If this is True, the gs.close() method does not shut down
               the slave.
        debug: show debug messages (default: False)
        &#34;&#34;&#34;
        self.logger = init_logger(__name__)

        from py4j.java_gateway import JavaGateway, GatewayParameters

        self.gatehome = gatehome
        self.port = port
        self.host = host
        self.start = start
        self.gatehome = gatehome
        self.platform = platform
        self.gateprocess = None
        self.gateway = None
        self.slave = None
        self.closed = False
        self.keep = keep
        self.debug = debug
        self.log_actions = log_actions
        if use_auth_token:
            if not auth_token:
                self.auth_token = secrets.token_urlsafe(20)
            else:
                self.auth_token = auth_token
        else:
            self.auth_token = &#34;&#34;
        if gatehome is None and start:
            gatehome = os.environ.get(&#34;GATE_HOME&#34;)
            if gatehome is None:
                raise Exception(
                    &#34;Parameter gatehome is None and environment var GATE_HOME not set&#34;
                )
            self.gatehome = gatehome
        if start:
            # make sure we find the jar we need
            # logger.info(&#34;DEBUG: file location: {}&#34;.format(__file__))
            jarloc = os.path.join(
                os.path.dirname(__file__),
                &#34;_jars&#34;,
                f&#34;gatetools-gatenlpslave-{JARVERSION}.jar&#34;,
            )
            if not os.path.exists(jarloc):
                raise Exception(&#34;Could not find jar, {} does not exist&#34;.format(jarloc))
            cmdandparms = [java, &#34;-cp&#34;]
            cpsep = classpath_sep(platform=platform)
            cmdandparms.append(
                jarloc + cpsep + gate_classpath(self.gatehome, platform=platform)
            )
            cmdandparms.append(&#34;gate.tools.gatenlpslave.GatenlpSlave&#34;)
            cmdandparms.append(str(port))
            cmdandparms.append(host)
            if log_actions:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            if keep:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            os.environ[&#34;GATENLP_SLAVE_TOKEN_&#34; + str(self.port)] = self.auth_token
            cmd = &#34; &#34;.join(cmdandparms)
            self.logger.debug(f&#34;Running command: {cmd}&#34;)
            subproc = subprocess.Popen(
                cmdandparms, stderr=subprocess.PIPE, bufsize=0, encoding=&#34;utf-8&#34;
            )
            self.gateprocess = subproc
            while True:
                line = subproc.stderr.readline()
                if line == &#34;&#34;:
                    break
                line = line.rstrip(&#34;\n\r&#34;)
                if line == &#34;PythonSlaveRunner.java: server start OK&#34;:
                    break
                if line == &#34;PythonSlaveRunner.java: server start NOT OK&#34;:
                    raise Exception(&#34;Could not start server, giving up&#34;)
                print(line, file=sys.stderr)
            atexit.register(self.close)
        self.gateway = JavaGateway(
            gateway_parameters=GatewayParameters(port=port, auth_token=self.auth_token)
        )
        self.jvm = self.gateway.jvm
        self.slave = self.gateway.entry_point
        self.gate_version = self.jvm.gate.Main.version
        self.gate_build = self.jvm.gate.Main.build
        self.slave_version = self.slave.pluginVersion()
        self.slave_build = self.slave.pluginBuild()

    @staticmethod
    def download():
        &#34;&#34;&#34;
        Download GATE libraries into a standard location so we can run the GATE slave even if GATE_HOME
        is not set.

        NOTE YET IMPLEMENTED.
        &#34;&#34;&#34;
        # TODO: this should use the command and bootstrapping jar in gate-downloader:
        # copy the whole directory into the standard per-user config directory for the system
        # run the command
        # use the generated gate.classpath as for a compiled local git repo
        # NOTE: should change error message if GATE_HOME is not set to hint at this! (option --downlaod for the script)
        # NOTE: add to documentation
        raise Exception(&#34;Not yet implemented&#34;)

    def close(self):
        &#34;&#34;&#34;
        Clean up: if the gate slave process was started by us, we will shut it down.
        Otherwise we can still close it if it was started by the slaverunner, not the Lr
        Note: if it was started by us, it was started via the slaverunner.
        &#34;&#34;&#34;
        if not self.closed and self.slave.isClosable():
            self.closed = True
            self.gateway.shutdown()
            if self.gateprocess is not None:
                for line in self.gateprocess.stderr:
                    print(line, file=sys.stderr, end=&#34;&#34;)
                self.gateprocess.wait()

    def log_actions(self, onoff):
        &#34;&#34;&#34;
        Swith logging actions at the slave on or off.

        Args:
          onoff: True to log actions, False to not log them
        &#34;&#34;&#34;
        self.slave.logActions(onoff)

    def load_gdoc(self, path, mimetype=None):
        &#34;&#34;&#34;
        Let GATE load a document from the given path and return a handle to it.

        Args:
          path: path to the gate document to load.
          mimetype: a mimetype to use when loading. (Default value = None)

        Returns:
          a handle to the Java GATE document
        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        return self.slave.loadDocumentFromFile(path, mimetype)

    def save_gdoc(self, gdoc, path, mimetype=None):
        &#34;&#34;&#34;
        Save GATE document to the given path.

        Args:
          gdoc: GATE document handle
          path: destination path
          mimetype: mimtetype, only the following types are allowed: &#34;&#34;/None: GATE XML,
                application/fastinfoset, and all mimetypes supported by the
                Format_Bdoc plugin. (Default value = None)
        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        self.slave.saveDocumentToFile(path, mimetype)

    def gdoc2pdoc(self, gdoc):
        &#34;&#34;&#34;
        Convert the GATE document to a python document and return it.

        Args:
          gdoc: the handle to a GATE document

        Returns:
          a gatenlp Document instance
        &#34;&#34;&#34;
        bjs = self.slave.getBdocJson(gdoc)
        return Document.load_mem(bjs, fmt=&#34;bdocjs&#34;)

    def pdoc2gdoc(self, pdoc, annsets=None):
        &#34;&#34;&#34;
        Convert the Python gatenlp document to a GATE document and return a handle to it.

        Args:
            pdoc: python gatenlp Document
            annsets: a list of either set names, or tuples where the first element is a set name and the
                second element is either a type name or a list of type names.

        Returns:
            handle to GATE document
        &#34;&#34;&#34;
        json = pdoc.save_mem(fmt=&#34;bdocjs&#34;, annsets=annsets)
        return self.slave.getDocument4BdocJson(json)

    def gdocanns2pdoc(self, gdoc, pdoc, annsets=None, replace=False):
        &#34;&#34;&#34;
        Retrieve the annotations from the GATE document and add them to the python gatenlp document.
        This modifies the pdoc in place and returns it.

        Args:
            gdoc: a handle to a Java GATE document
            pdoc: Python gatenlp document
            annsets: if not None, an annotation specification: a list of set names or tuples where the first
                element is a set name and the second element is either a type name or a list of type names
            replace: if True, replaces all annotations with the same set and annotation id, otherwise adds
                annotaitons with potentially a new annotation id.

        Returns:
            the modified pdoc
        &#34;&#34;&#34;
        # to make it easier on the Java side to interpret the annsets specification, convert it so that
        # all elements are a list where first element is always the set name and all remaining elements
        # are tyepe names. If there is one remaining element which is null, include all types for that set.
        newannsets = self.pannsets2gannsets(annsets)
        # now retrieve the BDOC JSON representation of the annotations
        thejson = self.jsonAnnsets4Doc(gdoc, newannsets);
        dictrep = json.loads(thejson)
        for name, adict in dictrep.items():
            annset = AnnotationSet.from_dict(adict, owner_doc=None)
            targetset = pdoc.annset(name)
            # add the annotations in annset to the pdoc, depending on replace
            for ann in annset._annotations.values():
                # if the annotation id already exists in the target set, proceed according to replace,
                # if not, just add it as is
                if ann.id in targetset._annotations:
                    if replace:
                        # for now, the simplified version: remove existing add new
                        targetset.remove(ann.id)
                        targetset.add_ann(ann, annid=ann.id)
                    else:
                        targetset.add_ann(ann)
                else:
                    targetset.add_ann(ann)
        return pdoc

    def load_pdoc(self, path, mimetype=None):
        &#34;&#34;&#34;
        Load a document from the given path, using GATE and convert and return as gatenlp Python document.

        Args:
          path: path to load document from
          mimetype: mime type to use (Default value = None)

        Returns:
          gatenlp document
        &#34;&#34;&#34;
        gdoc = self.load_gdoc(path, mimetype)
        return self.gdoc2pdoc(gdoc)

    def del_resource(self, resource):
        &#34;&#34;&#34;
        Delete/unload a GATE resource (Document, Corpus, ProcessingResource etc) from GATE.
        This is particularly important to do when processing a large number of documents for each document
        that is finished processing, otherwise the documents
        will accumulate in the Java process and eat up all memory. NOTE: just removing all references to a
        GATE document does not delete/unload the document!

        Args:
          resource: the Java GATE resource, e.g. a document to remove
        &#34;&#34;&#34;
        self.jvm.gate.Factory.deleteResource(resource)

    def show_gui(self):
        &#34;&#34;&#34;
        Show the GUI for the started GATE process.

        NOTE: this is more of a hack and may cause sync problems
        when closing down the GATE slave.
        &#34;&#34;&#34;
        self.slave.showGui()

    # methods that mirror the methods from the Java gate.plugin.python.PythonSlave methods
    # These could get called directly via gs.slave.METHODNAME calls but are implemented here
    # to provide easier discovery and better documentation on the Python side
    # Since these are really local mirrors of Java methods, they follow Java naming conventions
    def createDocument(self, content):
        &#34;&#34;&#34;
        Create a Java GATE document from the content string and return a handle to it.

        Args:
            content: the text of the document

        Returns:
            handle to Java GATE document
        &#34;&#34;&#34;
        return self.slave.createDocument(content)

    def deleteResource(self, resource):
        &#34;&#34;&#34;
        Remove a Java GATE resource and release its memory.

        Args:
            resource: a handle to some Java GATE resource
        &#34;&#34;&#34;
        self.slave.deleteResource(resource)

    def findMavenPlugin(self, group, artifact):
        &#34;&#34;&#34;
        Find a Java GATE Maven plugin and return a handle to it, or None if nothing found.

        Args:
            group: the Maven group for the plugin
            artifact: the artifact name for the plugin

        Returns:
            a handle to the plugin or None if not found
        &#34;&#34;&#34;
        return self.slave.findMavenPlugin(group, artifact)

    def gate_build(self):
        &#34;&#34;&#34;
        Return the short commit id of the Java GATE we are connected to.

        Returns:
            short commit id string
        &#34;&#34;&#34;
        return self.slave.gate_build()

    def gate_version(self):
        &#34;&#34;&#34;
        Return the version string of the Java GATE we are connected to.

        Returns:
            version string
        &#34;&#34;&#34;
        return self.slave.gate_version()

    def getBdocJson(self, gdoc):
        &#34;&#34;&#34;
        Return the Bdoc JSON serialization of a Java GATE document as string.

        Args:
            gdoc: a handle to a GATE document

        Returns:
            BDOC serialization JSON string
        &#34;&#34;&#34;
        return self.slave.getBdocJson(gdoc)

    def getCorpus4Name(self, name):
        &#34;&#34;&#34;
        Return a handle to the first Java GATE corpus with the given name or None if none found.

        Args:
            name: corpus name

        Returns:
            first matching corpus or None
        &#34;&#34;&#34;
        return self.slave.getCorpus4Name(name)

    def getCorpusNames(self):
        &#34;&#34;&#34;
        Return a list of all Java GATE corpus names known.

        Returns:
            list of corpus names
        &#34;&#34;&#34;
        return self.slave.getCorpusNames()

    def getDocument4BdocJson(self, bdocjson):
        &#34;&#34;&#34;
        Returns a handle to a Java GATE document created from the Bdoc JSON string.

        Args:
            bdocjson: a BDOC JSON string

        Returns:
            handle to the Java GATE document
        &#34;&#34;&#34;
        return self.slave.getDocument4BdocJson

    def getDocument4Name(self, name):
        &#34;&#34;&#34;
        Return a handle to the first Java GATE document that has the given name or None if none found.

        Args:
            name: the document name

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.slave.getDocument4Name(name)

    def getDocumentNames(self):
        &#34;&#34;&#34;
        Return a list of known Java GATE document names.

        Returns:
            list of Java GATE document names
        &#34;&#34;&#34;
        return self.slave.getDocumentNames()

    def getPipeline4Name(self, name):
        &#34;&#34;&#34;
        Return a handle to the first Java GATE pipeline/controller that has the given name or
        None if none found.

        Args:
            name: name of the pipeline

        Returns:
            handle to the pipeline
        &#34;&#34;&#34;
        return self.slave.getPipeline4Name(name)

    def getPipelineNames(self):
        &#34;&#34;&#34;
        Return a list of all know Java GATE pipeline names.

        Returns:
            list of pipeline names
        &#34;&#34;&#34;
        return self.slave.getPipelineNames()

    def getPr4Name(self, name):
        &#34;&#34;&#34;
        Return a handle to the first Java GATE processing resource that has the given name
        or None if none found.

        Args:
            name: the name of the processing resource

        Returns:
            a handle to the processing resource or None
        &#34;&#34;&#34;
        return self.slave.getPr4Name(name)

    def getPrNames(self):
        &#34;&#34;&#34;
        Return a list of known Java GATE  processing resource names.

        Returns:
            list of PR names
        &#34;&#34;&#34;
        return self.slave.getPrNames()

    def getResources4Name(self, name):
        &#34;&#34;&#34;
        Return a (possibly empty) list of all Java GATE resources with the given name.

        Args:
            name: name of the resources

        Returns:
            list of matching resources
        &#34;&#34;&#34;
        return self.slave.getResources4Name(name)


    def getResources4NameClass(self, name, clazz):
        &#34;&#34;&#34;
        Return a (possibly empty) list of all Java GATE resources with the given name and class name.

        Args:
            name: name of the resources
            clazz: the name of the java class the resource must be an instance of

        Returns:
            list of matching resources
        &#34;&#34;&#34;
        return self.slave.getResources4Name(name, clazz)

    def loadDocumentFromFile(self, filename):
        &#34;&#34;&#34;
        Load a Java GATE document from the given file name and return a handle to it.

        Args:
            filename: the file name/path of the Java GATE document to load.

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.slave.loadDocumentFromFile(filename)

    def loadDocumentFromFile4Mime(self, filename, mimetype):
        &#34;&#34;&#34;
        Load a Java GATE document from the given file name, using the given mime type
        and return a handle to it.

        Args:
            filename: the file name/path of the Java GATE document to load.
            mimetype: the mimetype to use

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.slave.loadDocumentFromFile(filename, mimetype)

    def loadMavenPlugin(self, group, artifact, version):
        &#34;&#34;&#34;
        Load the given Maven plugin into Java GATE.

        Args:
            group: group id of the plugin
            artifact:  artifact id of the plugin
            version: version of the plugin
        &#34;&#34;&#34;
        self.slave.loadMavenPlugin(group, artifact, version)

    def loadPipelineFromFile(self, filename):
        &#34;&#34;&#34;
        Load a pipeline/controller from the given file into Java GATE and return a CorpusController handle to it.

        Args:
            filename: the filename/path of the pipeline file

        Returns:
            a CorpusController handle to the loaded Java GATE pipeline
        &#34;&#34;&#34;
        return self.slave.loadPipelineFromFile(filename)

    def loadPipelineFromPlugin(self, group, artifact, path):
        &#34;&#34;&#34;
        Load a prepared pipeline from the given loaded GATE Mave plugin into Java GATE and return
        a CorpusController handle to it.

        Args:
            group: maven group id the plugin
            artifact: artifact id of the plugin
            path: path of the pipeline in the JAR

        Returns:
            a CorpusController handle to the pipeline
        &#34;&#34;&#34;
        return self.slave.loadPipelineFromPlugin(group, artifact, path)

    def logActions(self, flag):
        &#34;&#34;&#34;
        Enable/disable logging of actions carried out on the Java GATE side to the Java GATE logger.

        Args:
            flag: True to enable logging of actions
        &#34;&#34;&#34;
        self.slave.logActions(flag)

    def newCorpus(self):
        &#34;&#34;&#34;
        Create and return a handle to a new Java GATE corpus.

        Returns:
            handle to the Java GATE corpus
        &#34;&#34;&#34;
        return self.slave.newCorpus()

    def pluginBuild(self):
        &#34;&#34;&#34;
        Return the short commit id of the Python plugin on the Java GATE side.

        Returns:
            commit id of Python plugin
        &#34;&#34;&#34;
        return self.slave.pluginBuild()


    def pluginVersion(self):
        &#34;&#34;&#34;
        Return the version string of the Python plugin on the Java GATE side.

        Returns:
            version string of Python plugin
        &#34;&#34;&#34;
        return self.slave.pluginVersion()

    def print2err(self, message):
        &#34;&#34;&#34;
        Output the given message to System.err on the Java GATE side.

        Args:
            message: string to output
        &#34;&#34;&#34;
        self.slave.print2err(message)


    def print2out(self, message):
        &#34;&#34;&#34;
        Output the given message to System.out on the Java GATE side.

        Args:
            message: string to output
        &#34;&#34;&#34;
        self.slave.print2out(message)

    def run4Corpus(self, pipeline, corpus):
        &#34;&#34;&#34;
        Run the given Java GATE pipeline on the given Java GATE corpus.

        Args:
            pipeline: handle to a Java GATE pipeline
            corpus: handle to a Java GATE corpus
        &#34;&#34;&#34;
        self.slave.run4Corpus(pipeline, corpus)

    def run4Document(self, pipeline, gdoc):
        &#34;&#34;&#34;
        Run the given Java GATE pipeline on the given Java GATE document.

        Args:
            pipeline: handle to a Java GATE pipeline
            gdoc: handle to a Java GATE document
        &#34;&#34;&#34;
        self.slave.run4Document(pipeline, gdoc)

    def runExcecutionFinished(self, pipeline):
        &#34;&#34;&#34;
        Run the execution finished method for the given Java GATE pipeline.

        Args:
            pipeline: handle to a Java GATE pipeline
        &#34;&#34;&#34;
        self.slave.runExecutionFinished(pipeline)

    def runExcecutionStarted(self, pipeline):
        &#34;&#34;&#34;
        Run the execution started method for the given Java GATE pipeline.

        Args:
            pipeline: handle to a Java GATE pipeline
        &#34;&#34;&#34;
        self.slave.runExecutionStarted(pipeline)

    def saveDocumentToFile(self, gdoc, filename, mimetype):
        &#34;&#34;&#34;
        Save the Java GATE document to the given file, using the given mime type.
        At the moment this supports the GATE XML format (mimetype=&#34;&#34;) as well as
        formats supported by the FastInfoset  FormatBdoc plugins.

        Args:
            gdoc: handle to Java GATE document
            filename: name/path of the file to save to
            mimetype: the mime type to determine the format, &#34;&#34; for GATE XML
        &#34;&#34;&#34;
        self.slave.saveDocumentToFile(gdoc, filename, mimetype)

    def pannsets2gannsets(self, annsets=None):
        &#34;&#34;&#34;
        Convert from our convention to specifiy annotation sets and types to a Java list.
        This is necessary because py4j does not by default convert lists properly and also
        because our Java representation of the annsets specification has a different structure.
        The list returned from this is already a Java list!

        Args:
            annsets: annsets specification to convert

        Returns:
            java representation of the annsets specification (or None)
        &#34;&#34;&#34;
        if annsets is None:
            return None
        # annsets is a python collection and cannot be passed directly to Java
        # see https://www.py4j.org/advanced_topics.html#collections-conversion
        from py4j.java_collections import ListConverter
        newannsets = []
        for spec in annsets:
            if isinstance(spec, str):
                plist = [spec, None]
            else:
                setname, types = spec
                if isinstance(types, str):
                    plist = [setname, types]
                else:
                    # types must be a list:
                    plist = [setname]
                    plist.extend(types)
            jlist = ListConverter().convert(plist, self.gateway._gateway_client)
            newannsets.append(jlist)
        jnewannsets = ListConverter().convert(newannsets, self.gateway._gateway_client)
        return jnewannsets

    def jsonAnnsets4Doc(self, gdoc, jannsets=None):
        &#34;&#34;&#34;
        Return the JSON representation of the annotation sets in the GATE document, optionally
        filtered by the given annsets specification.

        The annsets specification should have the format as expected on the Java side: a list
        of lists of string. Each inner list has the set name to include as the first element
        and either null as the second element to include all types, or the types to include
        as the 2nd and subsequent elements.

        The method pannsets2gannsets(annsets) can be used to convert from our standard annset
        specification to the Java annsets specification.

        Args:
            gdoc: handle to Java GATE document
            jannsets: the annotation specification list as a Java list

        Returns:

        &#34;&#34;&#34;
        return self.slave.jsonAnnsets4Doc(gdoc, jannsets);

    def showGui(self):
        &#34;&#34;&#34;
        (CAUTION: EXPERIMENTAL) this shows the GATE GUI if we a re connected to a GATE process that runs without
        showing the GUI.
        &#34;&#34;&#34;
        self.slave.showGui()


class GateSlaveAnnotator(Annotator):
    # TODO: something that starts a gate slave when created, loads pipeline in Java GATE,
    # sends over document
    # or document and selection of annotation sets/annotation types, runs pipeline,
    # and then fetches one or more annotation sets and updates the local document with them.
    # TODO: parameter to influence how exceptions are handled
    def __init__(
        self,
        pipeline,
        gatehome=None,
        port=25333,
        annsets_send=None,
        annsets_receive=None,
        replace_anns=False,
    ):
        &#34;&#34;&#34;
        Create a GateSlave annotator.

        This starts the gate slave, loads the pipeline and
        can then be used to annotate Python gatenlp Document instances with the Java GATE
        pipeline.

        Note: to make sure that start/finish callbacks on the Java side are invoked, the annotator
        start() method should be invoked once before processing documents and finish() should
        get called once after processing documents. (Any Executor implementation shoudl do this
        autimatically)

        If the GateSlaveAnnotator is not used any more, close() should be invoked to terminate
        the Java GATE Slave process.

        Example:

            ```python
            pipeline = GateSlaveAnnotator(&#34;annie.xgapp&#34;)
            for idx, doc in enumerate(mycorpus):
                corpus[idx] = pipeline(doc)
            ```

        Args:
            pipeline: the path to a Java GATE pipeline to load into the GATE slave
            gatehome: the gate home directory to use, if not set, uses environment variable GATE_HOME
            port: the port to use (25333)
            annsets_send: a list of either annotation set names, or tuples where the first element
                is the name of an annotation set and the second element is either the name of a type
                or a list of type names. If not None, only the sets/types specified are sent to Java GATE.
                If an empty list is specified, no annotations are sent at all.
            annsets_receive: same format as annsets_send to specify which annotation sets/types are
                sent back to Python after the document has been processed on the Java side.
            replace_anns: if True and an annotation is received which already exists (same set and annotation id)
              then the existing annotation is replaced (if offsets and type are also same, only the features are
              replaced). If False, all received annotations are added which may change their annotation id.
        &#34;&#34;&#34;
        self.pipeline = pipeline
        self.annsets_send = annsets_send
        self.annsets_receive = annsets_receive
        self.replace_anns = replace_anns
        self.gs = GateSlave(port=port, start=True, gatehome=gatehome)
        self.controller = self.gs.slave.loadPipelineFromFile(self.pipeline)
        self.corpus = self.gs.slave.newCorpus()
        self.controller.setCorpus(self.corpus)
        self.controller.setControllerCallbacksEnabled(False)

    def close(self):
        &#34;&#34;&#34;
        Shut down the GateSlave used by this annotator.

        After calling this, the GateSlaveAnnotator instance cannot be used any more.
        &#34;&#34;&#34;
        self.gs.close()

    def start(self):
        &#34;&#34;&#34;
        Invoke the controller execution started method on the GATE controller.
        &#34;&#34;&#34;
        self.controller.invokeControllerExecutionStarted()

    def finish(self):
        &#34;&#34;&#34;
        Invoke the controller execution finished method on the GATE controller.
        &#34;&#34;&#34;
        self.controller.invokeControllerExecutionFinished()

    def __call__(self, doc, **kwargs):
        &#34;&#34;&#34;
        Run the GATE controller on the given document.

        This runs the GATE pipeline (controller) on the given document by first sending the document
        to the GATE process and coverting it to a GATE document there, running the pipeline on it,
        and sending the document back and converting back to a new gatenlp Document.

        Args:
            doc: the document to process
            **kwargs: ignored so far

        Returns:
            the processed gatenlp document
        &#34;&#34;&#34;
        if self.annsets_send is not None:
            # create shallow copy, we only need it for reading!
            tmpdoc = doc.copy(annsets=self.annsets_send)
        else:
            tmpdoc = doc
        gdoc = self.gs.pdoc2gdoc(tmpdoc)
        self.gs.slave.run4Document(self.controller, gdoc)
        self.gs.gdocanns2pdoc(gdoc, doc, annsets=self.annsets_receive, replace=self.replace_anns)
        self.gs.del_resource(gdoc)
        return doc


def main():
    &#34;&#34;&#34;
    Start a GATE slave from the command line.

    This is available as command `gatenlp-gate-slave`.
    Use option `--help` to get help about command line arguments.
    &#34;&#34;&#34;
    ap = argparse.ArgumentParser(description=&#34;Start Java GATE Slave&#34;)
    ap.add_argument(
        &#34;--download&#34;,
        action=&#34;store_true&#34;,
        help=&#34;Download GATE libraries to run GATE slave&#34;,
    )
    ap.add_argument(&#34;--port&#34;, default=25333, type=int, help=&#34;Port (25333)&#34;)
    ap.add_argument(
        &#34;--host&#34;, default=&#34;127.0.0.1&#34;, type=str, help=&#34;Host to bind to (127.0.0.1)&#34;
    )
    ap.add_argument(
        &#34;--auth&#34;, default=None, type=str, help=&#34;Auth token to use (generate random)&#34;
    )
    ap.add_argument(&#34;--noauth&#34;, action=&#34;store_true&#34;, help=&#34;Do not use auth token&#34;)
    ap.add_argument(
        &#34;--gatehome&#34;,
        default=None,
        type=str,
        help=&#34;Location of GATE (environment variable GATE_HOME)&#34;,
    )
    ap.add_argument(
        &#34;--platform&#34;,
        default=None,
        type=str,
        help=&#34;OS/Platform: windows or linux (autodetect)&#34;,
    )
    ap.add_argument(
        &#34;--log_actions&#34;, action=&#34;store_true&#34;, help=&#34;If slave actions should be logged&#34;
    )
    ap.add_argument(
        &#34;--keep&#34;, action=&#34;store_true&#34;, help=&#34;Prevent shutting down the slave&#34;
    )
    ap.add_argument(&#34;--debug&#34;, action=&#34;store_true&#34;, help=&#34;Show debug messages&#34;)
    args = ap.parse_args()
    if args.download:
        GateSlave.download()
    else:
        start_gate_slave(
            port=args.port,
            host=args.host,
            auth_token=args.auth,
            use_auth_token=not args.noauth,
            gatehome=args.gatehome,
            platform=args.platform,
            log_actions=args.log_actions,
            keep=args.keep,
            debug=args.debug,
        )


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gatenlp.gateslave.classpath_sep"><code class="name flex">
<span>def <span class="ident">classpath_sep</span></span>(<span>platform=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the system-specific classpath separator character.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>platform</code></strong></dt>
<dd>(Default value = None) win/windows for Windows, anything else for non-windows
If not specified, tries to determine automatically (which may fail)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>classpath separator character</p></div>
</dd>
<dt id="gatenlp.gateslave.gate_classpath"><code class="name flex">
<span>def <span class="ident">gate_classpath</span></span>(<span>gatehome, platform=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the GATE classpath components as a string, with the path seperator characters appropriate
for the operating system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gatehome</code></strong></dt>
<dd>where GATE is installed, either as a cloned git repo or a downloaded installation dir.</dd>
<dt><strong><code>platform</code></strong></dt>
<dd>(Default value = None) win/windows for Windows, anything else for non-Windows.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>GATE classpath</p>
<h2 id="raises">Raises</h2>
<p>Exception if classpath could not be determined.</p></div>
</dd>
<dt id="gatenlp.gateslave.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a GATE slave from the command line.</p>
<p>This is available as command <code>gatenlp-gate-slave</code>.
Use option <code>--help</code> to get help about command line arguments.</p></div>
</dd>
<dt id="gatenlp.gateslave.start_gate_slave"><code class="name flex">
<span>def <span class="ident">start_gate_slave</span></span>(<span>port=25333, host='127.0.0.1', auth_token=None, use_auth_token=True, java='java', platform=None, gatehome=None, log_actions=False, keep=False, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the gate slave program. This starts the Java program included with gatenlp to
run GATE and execute the gate slave within GATE so that Python can connect to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>port</code></strong></dt>
<dd>(Default value = 25333) Port number to use</dd>
<dt><strong><code>host</code></strong></dt>
<dd>(Default value = "127.0.0.1") Host address to bind to</dd>
<dt><strong><code>auth_token</code></strong></dt>
<dd>(Default value = None)
Authorization token to use. If None, creates a random token.</dd>
<dt><strong><code>use_auth_token</code></strong></dt>
<dd>(Default value = True) If False, do not aue an authorization token at all.
This allows anyone who can connect to the host address to connect and use the gate slave process.</dd>
<dt><strong><code>java</code></strong></dt>
<dd>(Default value = "java") Java command (if on the binary path) or full path to the binary
to use for running the gate slave program.</dd>
<dt><strong><code>platform</code></strong></dt>
<dd>(Default value = None) "win"/"windows" for Windows, anything else for non-Windows.
If None, tries to determine automatically.</dd>
<dt><strong><code>gatehome</code></strong></dt>
<dd>(Default value = None) The path to where GATE is installed. If None, the environment
variable "GATE_HOME" is used.</dd>
<dt><strong><code>log_actions</code></strong></dt>
<dd>(Default value = False) If True, the GATE Slave process will log everything it is
ordered to do.</dd>
<dt><strong><code>keep</code></strong></dt>
<dd>(Default value = False) passed on to the gate slave process and tells the process if it should
report to the using Pythong process that it can be closed or not.</dd>
<dt><strong><code>debug</code></strong></dt>
<dd>(Default valuye = False) Show debug messages.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gatenlp.gateslave.GateSlave"><code class="flex name class">
<span>class <span class="ident">GateSlave</span></span>
<span>(</span><span>port=25333, start=True, java='java', host='127.0.0.1', gatehome=None, platform=None, auth_token=None, use_auth_token=True, log_actions=False, keep=False, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gate slave for remotely running arbitrary GATE and other JAVA operations in a separate
Java GATE process.</p>
<p>Create an instance of the GateSlave and either start our own Java GATE process for it to use
(start=True) or connect to an existing one (start=False).</p>
<p>After the GateSlave instance has been create successfully, it is possible to:</p>
<ul>
<li>
<p>Use one of the methods of the instance to perform operations on the Java side or exchange data</p>
</li>
<li>
<p>use GateSlave.slave to invoke methods from the PythonSlave class on the Java side</p>
</li>
<li>
<p>use GateSlave.jvm to directly construct objects or call instance or static methods</p>
</li>
</ul>
<p>NOTE: the GATE process must not output anything important/big to stderr because everything from
stderr gets captured and used for communication between the Java and Python processes. At least
part of the output to stderr may only be passed on after the GATE process has ended.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">gs = GateSlave()
pipeline = gs.slave.loadPipelineFromFile(&quot;thePipeline.xgapp&quot;)
doc = gs.slave.createDocument(&quot;Some document text&quot;)
gs.slave.run4doc(pipeline,doc)
pdoc = gs.gdoc2pdoc(doc)
gs.slave.deleteResource(doc)
# process the document pdoc ...
</code></pre>
<p>port: port to use
start: if True, try to start our own GATE process, otherwise expect an already started
process at the host/port address
java: path to the java binary to run or the java command to use from the PATH (for start=True)
host: host an existing Java GATE process is running on (only relevant for start=False)
gatehome: where GATE is installed (only relevant if start=True). If None, expects
environment variable GATE_HOME to be set.
platform: system platform we run on, one of Windows, Linux (also for MacOs) or Java
auth_token: if None or "" and use_auth_token is True, generate a random token which
is then accessible via the auth_token attribute, otherwise use the given auth token.
use_auth_token: if False, do not use an auth token, otherwise either use the one specified
via auth_token or generate a random one.
log_actions: if the gate slave should log the actions it is doing
keep: normally if gs.close() is called and we are not connected to the PythonSlaveLr,
the slave will be shut down. If this is True, the gs.close() method does not shut down
the slave.
debug: show debug messages (default: False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GateSlave:
    &#34;&#34;&#34;
    Gate slave for remotely running arbitrary GATE and other JAVA operations in a separate
    Java GATE process.
    &#34;&#34;&#34;

    def __init__(
        self,
        port=25333,
        start=True,
        java=&#34;java&#34;,
        host=&#34;127.0.0.1&#34;,
        gatehome=None,
        platform=None,
        auth_token=None,
        use_auth_token=True,
        log_actions=False,
        keep=False,
        debug=False,
    ):
        &#34;&#34;&#34;
        Create an instance of the GateSlave and either start our own Java GATE process for it to use
        (start=True) or connect to an existing one (start=False).

        After the GateSlave instance has been create successfully, it is possible to:

        * Use one of the methods of the instance to perform operations on the Java side or exchange data

        * use GateSlave.slave to invoke methods from the PythonSlave class on the Java side

        * use GateSlave.jvm to directly construct objects or call instance or static methods

        NOTE: the GATE process must not output anything important/big to stderr because everything from
        stderr gets captured and used for communication between the Java and Python processes. At least
        part of the output to stderr may only be passed on after the GATE process has ended.

        Example:

            ```python
            gs = GateSlave()
            pipeline = gs.slave.loadPipelineFromFile(&#34;thePipeline.xgapp&#34;)
            doc = gs.slave.createDocument(&#34;Some document text&#34;)
            gs.slave.run4doc(pipeline,doc)
            pdoc = gs.gdoc2pdoc(doc)
            gs.slave.deleteResource(doc)
            # process the document pdoc ...
            ```

        port: port to use
        start: if True, try to start our own GATE process, otherwise expect an already started
           process at the host/port address
        java: path to the java binary to run or the java command to use from the PATH (for start=True)
        host: host an existing Java GATE process is running on (only relevant for start=False)
        gatehome: where GATE is installed (only relevant if start=True). If None, expects
               environment variable GATE_HOME to be set.
        platform: system platform we run on, one of Windows, Linux (also for MacOs) or Java
        auth_token: if None or &#34;&#34; and use_auth_token is True, generate a random token which
               is then accessible via the auth_token attribute, otherwise use the given auth token.
        use_auth_token: if False, do not use an auth token, otherwise either use the one specified
               via auth_token or generate a random one.
        log_actions: if the gate slave should log the actions it is doing
        keep: normally if gs.close() is called and we are not connected to the PythonSlaveLr,
               the slave will be shut down. If this is True, the gs.close() method does not shut down
               the slave.
        debug: show debug messages (default: False)
        &#34;&#34;&#34;
        self.logger = init_logger(__name__)

        from py4j.java_gateway import JavaGateway, GatewayParameters

        self.gatehome = gatehome
        self.port = port
        self.host = host
        self.start = start
        self.gatehome = gatehome
        self.platform = platform
        self.gateprocess = None
        self.gateway = None
        self.slave = None
        self.closed = False
        self.keep = keep
        self.debug = debug
        self.log_actions = log_actions
        if use_auth_token:
            if not auth_token:
                self.auth_token = secrets.token_urlsafe(20)
            else:
                self.auth_token = auth_token
        else:
            self.auth_token = &#34;&#34;
        if gatehome is None and start:
            gatehome = os.environ.get(&#34;GATE_HOME&#34;)
            if gatehome is None:
                raise Exception(
                    &#34;Parameter gatehome is None and environment var GATE_HOME not set&#34;
                )
            self.gatehome = gatehome
        if start:
            # make sure we find the jar we need
            # logger.info(&#34;DEBUG: file location: {}&#34;.format(__file__))
            jarloc = os.path.join(
                os.path.dirname(__file__),
                &#34;_jars&#34;,
                f&#34;gatetools-gatenlpslave-{JARVERSION}.jar&#34;,
            )
            if not os.path.exists(jarloc):
                raise Exception(&#34;Could not find jar, {} does not exist&#34;.format(jarloc))
            cmdandparms = [java, &#34;-cp&#34;]
            cpsep = classpath_sep(platform=platform)
            cmdandparms.append(
                jarloc + cpsep + gate_classpath(self.gatehome, platform=platform)
            )
            cmdandparms.append(&#34;gate.tools.gatenlpslave.GatenlpSlave&#34;)
            cmdandparms.append(str(port))
            cmdandparms.append(host)
            if log_actions:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            if keep:
                cmdandparms.append(&#34;1&#34;)
            else:
                cmdandparms.append(&#34;0&#34;)
            os.environ[&#34;GATENLP_SLAVE_TOKEN_&#34; + str(self.port)] = self.auth_token
            cmd = &#34; &#34;.join(cmdandparms)
            self.logger.debug(f&#34;Running command: {cmd}&#34;)
            subproc = subprocess.Popen(
                cmdandparms, stderr=subprocess.PIPE, bufsize=0, encoding=&#34;utf-8&#34;
            )
            self.gateprocess = subproc
            while True:
                line = subproc.stderr.readline()
                if line == &#34;&#34;:
                    break
                line = line.rstrip(&#34;\n\r&#34;)
                if line == &#34;PythonSlaveRunner.java: server start OK&#34;:
                    break
                if line == &#34;PythonSlaveRunner.java: server start NOT OK&#34;:
                    raise Exception(&#34;Could not start server, giving up&#34;)
                print(line, file=sys.stderr)
            atexit.register(self.close)
        self.gateway = JavaGateway(
            gateway_parameters=GatewayParameters(port=port, auth_token=self.auth_token)
        )
        self.jvm = self.gateway.jvm
        self.slave = self.gateway.entry_point
        self.gate_version = self.jvm.gate.Main.version
        self.gate_build = self.jvm.gate.Main.build
        self.slave_version = self.slave.pluginVersion()
        self.slave_build = self.slave.pluginBuild()

    @staticmethod
    def download():
        &#34;&#34;&#34;
        Download GATE libraries into a standard location so we can run the GATE slave even if GATE_HOME
        is not set.

        NOTE YET IMPLEMENTED.
        &#34;&#34;&#34;
        # TODO: this should use the command and bootstrapping jar in gate-downloader:
        # copy the whole directory into the standard per-user config directory for the system
        # run the command
        # use the generated gate.classpath as for a compiled local git repo
        # NOTE: should change error message if GATE_HOME is not set to hint at this! (option --downlaod for the script)
        # NOTE: add to documentation
        raise Exception(&#34;Not yet implemented&#34;)

    def close(self):
        &#34;&#34;&#34;
        Clean up: if the gate slave process was started by us, we will shut it down.
        Otherwise we can still close it if it was started by the slaverunner, not the Lr
        Note: if it was started by us, it was started via the slaverunner.
        &#34;&#34;&#34;
        if not self.closed and self.slave.isClosable():
            self.closed = True
            self.gateway.shutdown()
            if self.gateprocess is not None:
                for line in self.gateprocess.stderr:
                    print(line, file=sys.stderr, end=&#34;&#34;)
                self.gateprocess.wait()

    def log_actions(self, onoff):
        &#34;&#34;&#34;
        Swith logging actions at the slave on or off.

        Args:
          onoff: True to log actions, False to not log them
        &#34;&#34;&#34;
        self.slave.logActions(onoff)

    def load_gdoc(self, path, mimetype=None):
        &#34;&#34;&#34;
        Let GATE load a document from the given path and return a handle to it.

        Args:
          path: path to the gate document to load.
          mimetype: a mimetype to use when loading. (Default value = None)

        Returns:
          a handle to the Java GATE document
        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        return self.slave.loadDocumentFromFile(path, mimetype)

    def save_gdoc(self, gdoc, path, mimetype=None):
        &#34;&#34;&#34;
        Save GATE document to the given path.

        Args:
          gdoc: GATE document handle
          path: destination path
          mimetype: mimtetype, only the following types are allowed: &#34;&#34;/None: GATE XML,
                application/fastinfoset, and all mimetypes supported by the
                Format_Bdoc plugin. (Default value = None)
        &#34;&#34;&#34;
        if mimetype is None:
            mimetype = &#34;&#34;
        self.slave.saveDocumentToFile(path, mimetype)

    def gdoc2pdoc(self, gdoc):
        &#34;&#34;&#34;
        Convert the GATE document to a python document and return it.

        Args:
          gdoc: the handle to a GATE document

        Returns:
          a gatenlp Document instance
        &#34;&#34;&#34;
        bjs = self.slave.getBdocJson(gdoc)
        return Document.load_mem(bjs, fmt=&#34;bdocjs&#34;)

    def pdoc2gdoc(self, pdoc, annsets=None):
        &#34;&#34;&#34;
        Convert the Python gatenlp document to a GATE document and return a handle to it.

        Args:
            pdoc: python gatenlp Document
            annsets: a list of either set names, or tuples where the first element is a set name and the
                second element is either a type name or a list of type names.

        Returns:
            handle to GATE document
        &#34;&#34;&#34;
        json = pdoc.save_mem(fmt=&#34;bdocjs&#34;, annsets=annsets)
        return self.slave.getDocument4BdocJson(json)

    def gdocanns2pdoc(self, gdoc, pdoc, annsets=None, replace=False):
        &#34;&#34;&#34;
        Retrieve the annotations from the GATE document and add them to the python gatenlp document.
        This modifies the pdoc in place and returns it.

        Args:
            gdoc: a handle to a Java GATE document
            pdoc: Python gatenlp document
            annsets: if not None, an annotation specification: a list of set names or tuples where the first
                element is a set name and the second element is either a type name or a list of type names
            replace: if True, replaces all annotations with the same set and annotation id, otherwise adds
                annotaitons with potentially a new annotation id.

        Returns:
            the modified pdoc
        &#34;&#34;&#34;
        # to make it easier on the Java side to interpret the annsets specification, convert it so that
        # all elements are a list where first element is always the set name and all remaining elements
        # are tyepe names. If there is one remaining element which is null, include all types for that set.
        newannsets = self.pannsets2gannsets(annsets)
        # now retrieve the BDOC JSON representation of the annotations
        thejson = self.jsonAnnsets4Doc(gdoc, newannsets);
        dictrep = json.loads(thejson)
        for name, adict in dictrep.items():
            annset = AnnotationSet.from_dict(adict, owner_doc=None)
            targetset = pdoc.annset(name)
            # add the annotations in annset to the pdoc, depending on replace
            for ann in annset._annotations.values():
                # if the annotation id already exists in the target set, proceed according to replace,
                # if not, just add it as is
                if ann.id in targetset._annotations:
                    if replace:
                        # for now, the simplified version: remove existing add new
                        targetset.remove(ann.id)
                        targetset.add_ann(ann, annid=ann.id)
                    else:
                        targetset.add_ann(ann)
                else:
                    targetset.add_ann(ann)
        return pdoc

    def load_pdoc(self, path, mimetype=None):
        &#34;&#34;&#34;
        Load a document from the given path, using GATE and convert and return as gatenlp Python document.

        Args:
          path: path to load document from
          mimetype: mime type to use (Default value = None)

        Returns:
          gatenlp document
        &#34;&#34;&#34;
        gdoc = self.load_gdoc(path, mimetype)
        return self.gdoc2pdoc(gdoc)

    def del_resource(self, resource):
        &#34;&#34;&#34;
        Delete/unload a GATE resource (Document, Corpus, ProcessingResource etc) from GATE.
        This is particularly important to do when processing a large number of documents for each document
        that is finished processing, otherwise the documents
        will accumulate in the Java process and eat up all memory. NOTE: just removing all references to a
        GATE document does not delete/unload the document!

        Args:
          resource: the Java GATE resource, e.g. a document to remove
        &#34;&#34;&#34;
        self.jvm.gate.Factory.deleteResource(resource)

    def show_gui(self):
        &#34;&#34;&#34;
        Show the GUI for the started GATE process.

        NOTE: this is more of a hack and may cause sync problems
        when closing down the GATE slave.
        &#34;&#34;&#34;
        self.slave.showGui()

    # methods that mirror the methods from the Java gate.plugin.python.PythonSlave methods
    # These could get called directly via gs.slave.METHODNAME calls but are implemented here
    # to provide easier discovery and better documentation on the Python side
    # Since these are really local mirrors of Java methods, they follow Java naming conventions
    def createDocument(self, content):
        &#34;&#34;&#34;
        Create a Java GATE document from the content string and return a handle to it.

        Args:
            content: the text of the document

        Returns:
            handle to Java GATE document
        &#34;&#34;&#34;
        return self.slave.createDocument(content)

    def deleteResource(self, resource):
        &#34;&#34;&#34;
        Remove a Java GATE resource and release its memory.

        Args:
            resource: a handle to some Java GATE resource
        &#34;&#34;&#34;
        self.slave.deleteResource(resource)

    def findMavenPlugin(self, group, artifact):
        &#34;&#34;&#34;
        Find a Java GATE Maven plugin and return a handle to it, or None if nothing found.

        Args:
            group: the Maven group for the plugin
            artifact: the artifact name for the plugin

        Returns:
            a handle to the plugin or None if not found
        &#34;&#34;&#34;
        return self.slave.findMavenPlugin(group, artifact)

    def gate_build(self):
        &#34;&#34;&#34;
        Return the short commit id of the Java GATE we are connected to.

        Returns:
            short commit id string
        &#34;&#34;&#34;
        return self.slave.gate_build()

    def gate_version(self):
        &#34;&#34;&#34;
        Return the version string of the Java GATE we are connected to.

        Returns:
            version string
        &#34;&#34;&#34;
        return self.slave.gate_version()

    def getBdocJson(self, gdoc):
        &#34;&#34;&#34;
        Return the Bdoc JSON serialization of a Java GATE document as string.

        Args:
            gdoc: a handle to a GATE document

        Returns:
            BDOC serialization JSON string
        &#34;&#34;&#34;
        return self.slave.getBdocJson(gdoc)

    def getCorpus4Name(self, name):
        &#34;&#34;&#34;
        Return a handle to the first Java GATE corpus with the given name or None if none found.

        Args:
            name: corpus name

        Returns:
            first matching corpus or None
        &#34;&#34;&#34;
        return self.slave.getCorpus4Name(name)

    def getCorpusNames(self):
        &#34;&#34;&#34;
        Return a list of all Java GATE corpus names known.

        Returns:
            list of corpus names
        &#34;&#34;&#34;
        return self.slave.getCorpusNames()

    def getDocument4BdocJson(self, bdocjson):
        &#34;&#34;&#34;
        Returns a handle to a Java GATE document created from the Bdoc JSON string.

        Args:
            bdocjson: a BDOC JSON string

        Returns:
            handle to the Java GATE document
        &#34;&#34;&#34;
        return self.slave.getDocument4BdocJson

    def getDocument4Name(self, name):
        &#34;&#34;&#34;
        Return a handle to the first Java GATE document that has the given name or None if none found.

        Args:
            name: the document name

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.slave.getDocument4Name(name)

    def getDocumentNames(self):
        &#34;&#34;&#34;
        Return a list of known Java GATE document names.

        Returns:
            list of Java GATE document names
        &#34;&#34;&#34;
        return self.slave.getDocumentNames()

    def getPipeline4Name(self, name):
        &#34;&#34;&#34;
        Return a handle to the first Java GATE pipeline/controller that has the given name or
        None if none found.

        Args:
            name: name of the pipeline

        Returns:
            handle to the pipeline
        &#34;&#34;&#34;
        return self.slave.getPipeline4Name(name)

    def getPipelineNames(self):
        &#34;&#34;&#34;
        Return a list of all know Java GATE pipeline names.

        Returns:
            list of pipeline names
        &#34;&#34;&#34;
        return self.slave.getPipelineNames()

    def getPr4Name(self, name):
        &#34;&#34;&#34;
        Return a handle to the first Java GATE processing resource that has the given name
        or None if none found.

        Args:
            name: the name of the processing resource

        Returns:
            a handle to the processing resource or None
        &#34;&#34;&#34;
        return self.slave.getPr4Name(name)

    def getPrNames(self):
        &#34;&#34;&#34;
        Return a list of known Java GATE  processing resource names.

        Returns:
            list of PR names
        &#34;&#34;&#34;
        return self.slave.getPrNames()

    def getResources4Name(self, name):
        &#34;&#34;&#34;
        Return a (possibly empty) list of all Java GATE resources with the given name.

        Args:
            name: name of the resources

        Returns:
            list of matching resources
        &#34;&#34;&#34;
        return self.slave.getResources4Name(name)


    def getResources4NameClass(self, name, clazz):
        &#34;&#34;&#34;
        Return a (possibly empty) list of all Java GATE resources with the given name and class name.

        Args:
            name: name of the resources
            clazz: the name of the java class the resource must be an instance of

        Returns:
            list of matching resources
        &#34;&#34;&#34;
        return self.slave.getResources4Name(name, clazz)

    def loadDocumentFromFile(self, filename):
        &#34;&#34;&#34;
        Load a Java GATE document from the given file name and return a handle to it.

        Args:
            filename: the file name/path of the Java GATE document to load.

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.slave.loadDocumentFromFile(filename)

    def loadDocumentFromFile4Mime(self, filename, mimetype):
        &#34;&#34;&#34;
        Load a Java GATE document from the given file name, using the given mime type
        and return a handle to it.

        Args:
            filename: the file name/path of the Java GATE document to load.
            mimetype: the mimetype to use

        Returns:
            a handle to the Java GATE document
        &#34;&#34;&#34;
        return self.slave.loadDocumentFromFile(filename, mimetype)

    def loadMavenPlugin(self, group, artifact, version):
        &#34;&#34;&#34;
        Load the given Maven plugin into Java GATE.

        Args:
            group: group id of the plugin
            artifact:  artifact id of the plugin
            version: version of the plugin
        &#34;&#34;&#34;
        self.slave.loadMavenPlugin(group, artifact, version)

    def loadPipelineFromFile(self, filename):
        &#34;&#34;&#34;
        Load a pipeline/controller from the given file into Java GATE and return a CorpusController handle to it.

        Args:
            filename: the filename/path of the pipeline file

        Returns:
            a CorpusController handle to the loaded Java GATE pipeline
        &#34;&#34;&#34;
        return self.slave.loadPipelineFromFile(filename)

    def loadPipelineFromPlugin(self, group, artifact, path):
        &#34;&#34;&#34;
        Load a prepared pipeline from the given loaded GATE Mave plugin into Java GATE and return
        a CorpusController handle to it.

        Args:
            group: maven group id the plugin
            artifact: artifact id of the plugin
            path: path of the pipeline in the JAR

        Returns:
            a CorpusController handle to the pipeline
        &#34;&#34;&#34;
        return self.slave.loadPipelineFromPlugin(group, artifact, path)

    def logActions(self, flag):
        &#34;&#34;&#34;
        Enable/disable logging of actions carried out on the Java GATE side to the Java GATE logger.

        Args:
            flag: True to enable logging of actions
        &#34;&#34;&#34;
        self.slave.logActions(flag)

    def newCorpus(self):
        &#34;&#34;&#34;
        Create and return a handle to a new Java GATE corpus.

        Returns:
            handle to the Java GATE corpus
        &#34;&#34;&#34;
        return self.slave.newCorpus()

    def pluginBuild(self):
        &#34;&#34;&#34;
        Return the short commit id of the Python plugin on the Java GATE side.

        Returns:
            commit id of Python plugin
        &#34;&#34;&#34;
        return self.slave.pluginBuild()


    def pluginVersion(self):
        &#34;&#34;&#34;
        Return the version string of the Python plugin on the Java GATE side.

        Returns:
            version string of Python plugin
        &#34;&#34;&#34;
        return self.slave.pluginVersion()

    def print2err(self, message):
        &#34;&#34;&#34;
        Output the given message to System.err on the Java GATE side.

        Args:
            message: string to output
        &#34;&#34;&#34;
        self.slave.print2err(message)


    def print2out(self, message):
        &#34;&#34;&#34;
        Output the given message to System.out on the Java GATE side.

        Args:
            message: string to output
        &#34;&#34;&#34;
        self.slave.print2out(message)

    def run4Corpus(self, pipeline, corpus):
        &#34;&#34;&#34;
        Run the given Java GATE pipeline on the given Java GATE corpus.

        Args:
            pipeline: handle to a Java GATE pipeline
            corpus: handle to a Java GATE corpus
        &#34;&#34;&#34;
        self.slave.run4Corpus(pipeline, corpus)

    def run4Document(self, pipeline, gdoc):
        &#34;&#34;&#34;
        Run the given Java GATE pipeline on the given Java GATE document.

        Args:
            pipeline: handle to a Java GATE pipeline
            gdoc: handle to a Java GATE document
        &#34;&#34;&#34;
        self.slave.run4Document(pipeline, gdoc)

    def runExcecutionFinished(self, pipeline):
        &#34;&#34;&#34;
        Run the execution finished method for the given Java GATE pipeline.

        Args:
            pipeline: handle to a Java GATE pipeline
        &#34;&#34;&#34;
        self.slave.runExecutionFinished(pipeline)

    def runExcecutionStarted(self, pipeline):
        &#34;&#34;&#34;
        Run the execution started method for the given Java GATE pipeline.

        Args:
            pipeline: handle to a Java GATE pipeline
        &#34;&#34;&#34;
        self.slave.runExecutionStarted(pipeline)

    def saveDocumentToFile(self, gdoc, filename, mimetype):
        &#34;&#34;&#34;
        Save the Java GATE document to the given file, using the given mime type.
        At the moment this supports the GATE XML format (mimetype=&#34;&#34;) as well as
        formats supported by the FastInfoset  FormatBdoc plugins.

        Args:
            gdoc: handle to Java GATE document
            filename: name/path of the file to save to
            mimetype: the mime type to determine the format, &#34;&#34; for GATE XML
        &#34;&#34;&#34;
        self.slave.saveDocumentToFile(gdoc, filename, mimetype)

    def pannsets2gannsets(self, annsets=None):
        &#34;&#34;&#34;
        Convert from our convention to specifiy annotation sets and types to a Java list.
        This is necessary because py4j does not by default convert lists properly and also
        because our Java representation of the annsets specification has a different structure.
        The list returned from this is already a Java list!

        Args:
            annsets: annsets specification to convert

        Returns:
            java representation of the annsets specification (or None)
        &#34;&#34;&#34;
        if annsets is None:
            return None
        # annsets is a python collection and cannot be passed directly to Java
        # see https://www.py4j.org/advanced_topics.html#collections-conversion
        from py4j.java_collections import ListConverter
        newannsets = []
        for spec in annsets:
            if isinstance(spec, str):
                plist = [spec, None]
            else:
                setname, types = spec
                if isinstance(types, str):
                    plist = [setname, types]
                else:
                    # types must be a list:
                    plist = [setname]
                    plist.extend(types)
            jlist = ListConverter().convert(plist, self.gateway._gateway_client)
            newannsets.append(jlist)
        jnewannsets = ListConverter().convert(newannsets, self.gateway._gateway_client)
        return jnewannsets

    def jsonAnnsets4Doc(self, gdoc, jannsets=None):
        &#34;&#34;&#34;
        Return the JSON representation of the annotation sets in the GATE document, optionally
        filtered by the given annsets specification.

        The annsets specification should have the format as expected on the Java side: a list
        of lists of string. Each inner list has the set name to include as the first element
        and either null as the second element to include all types, or the types to include
        as the 2nd and subsequent elements.

        The method pannsets2gannsets(annsets) can be used to convert from our standard annset
        specification to the Java annsets specification.

        Args:
            gdoc: handle to Java GATE document
            jannsets: the annotation specification list as a Java list

        Returns:

        &#34;&#34;&#34;
        return self.slave.jsonAnnsets4Doc(gdoc, jannsets);

    def showGui(self):
        &#34;&#34;&#34;
        (CAUTION: EXPERIMENTAL) this shows the GATE GUI if we a re connected to a GATE process that runs without
        showing the GUI.
        &#34;&#34;&#34;
        self.slave.showGui()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gatenlp.gateslave.GateSlave.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Download GATE libraries into a standard location so we can run the GATE slave even if GATE_HOME
is not set.</p>
<p>NOTE YET IMPLEMENTED.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.gateslave.GateSlave.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clean up: if the gate slave process was started by us, we will shut it down.
Otherwise we can still close it if it was started by the slaverunner, not the Lr
Note: if it was started by us, it was started via the slaverunner.</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.createDocument"><code class="name flex">
<span>def <span class="ident">createDocument</span></span>(<span>self, content)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Java GATE document from the content string and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>content</code></strong></dt>
<dd>the text of the document</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>handle to Java GATE document</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.del_resource"><code class="name flex">
<span>def <span class="ident">del_resource</span></span>(<span>self, resource)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete/unload a GATE resource (Document, Corpus, ProcessingResource etc) from GATE.
This is particularly important to do when processing a large number of documents for each document
that is finished processing, otherwise the documents
will accumulate in the Java process and eat up all memory. NOTE: just removing all references to a
GATE document does not delete/unload the document!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource</code></strong></dt>
<dd>the Java GATE resource, e.g. a document to remove</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.deleteResource"><code class="name flex">
<span>def <span class="ident">deleteResource</span></span>(<span>self, resource)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a Java GATE resource and release its memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource</code></strong></dt>
<dd>a handle to some Java GATE resource</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.findMavenPlugin"><code class="name flex">
<span>def <span class="ident">findMavenPlugin</span></span>(<span>self, group, artifact)</span>
</code></dt>
<dd>
<div class="desc"><p>Find a Java GATE Maven plugin and return a handle to it, or None if nothing found.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>group</code></strong></dt>
<dd>the Maven group for the plugin</dd>
<dt><strong><code>artifact</code></strong></dt>
<dd>the artifact name for the plugin</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the plugin or None if not found</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.gate_build"><code class="name flex">
<span>def <span class="ident">gate_build</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the short commit id of the Java GATE we are connected to.</p>
<h2 id="returns">Returns</h2>
<p>short commit id string</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.gate_version"><code class="name flex">
<span>def <span class="ident">gate_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the version string of the Java GATE we are connected to.</p>
<h2 id="returns">Returns</h2>
<p>version string</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.gdoc2pdoc"><code class="name flex">
<span>def <span class="ident">gdoc2pdoc</span></span>(<span>self, gdoc)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the GATE document to a python document and return it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>the handle to a GATE document</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a gatenlp Document instance</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.gdocanns2pdoc"><code class="name flex">
<span>def <span class="ident">gdocanns2pdoc</span></span>(<span>self, gdoc, pdoc, annsets=None, replace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the annotations from the GATE document and add them to the python gatenlp document.
This modifies the pdoc in place and returns it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>a handle to a Java GATE document</dd>
<dt><strong><code>pdoc</code></strong></dt>
<dd>Python gatenlp document</dd>
<dt><strong><code>annsets</code></strong></dt>
<dd>if not None, an annotation specification: a list of set names or tuples where the first
element is a set name and the second element is either a type name or a list of type names</dd>
<dt><strong><code>replace</code></strong></dt>
<dd>if True, replaces all annotations with the same set and annotation id, otherwise adds
annotaitons with potentially a new annotation id.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the modified pdoc</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getBdocJson"><code class="name flex">
<span>def <span class="ident">getBdocJson</span></span>(<span>self, gdoc)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the Bdoc JSON serialization of a Java GATE document as string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>a handle to a GATE document</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>BDOC serialization JSON string</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getCorpus4Name"><code class="name flex">
<span>def <span class="ident">getCorpus4Name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a handle to the first Java GATE corpus with the given name or None if none found.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>corpus name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>first matching corpus or None</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getCorpusNames"><code class="name flex">
<span>def <span class="ident">getCorpusNames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of all Java GATE corpus names known.</p>
<h2 id="returns">Returns</h2>
<p>list of corpus names</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getDocument4BdocJson"><code class="name flex">
<span>def <span class="ident">getDocument4BdocJson</span></span>(<span>self, bdocjson)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a handle to a Java GATE document created from the Bdoc JSON string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bdocjson</code></strong></dt>
<dd>a BDOC JSON string</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>handle to the Java GATE document</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getDocument4Name"><code class="name flex">
<span>def <span class="ident">getDocument4Name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a handle to the first Java GATE document that has the given name or None if none found.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>the document name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the Java GATE document</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getDocumentNames"><code class="name flex">
<span>def <span class="ident">getDocumentNames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of known Java GATE document names.</p>
<h2 id="returns">Returns</h2>
<p>list of Java GATE document names</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getPipeline4Name"><code class="name flex">
<span>def <span class="ident">getPipeline4Name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a handle to the first Java GATE pipeline/controller that has the given name or
None if none found.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name of the pipeline</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>handle to the pipeline</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getPipelineNames"><code class="name flex">
<span>def <span class="ident">getPipelineNames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of all know Java GATE pipeline names.</p>
<h2 id="returns">Returns</h2>
<p>list of pipeline names</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getPr4Name"><code class="name flex">
<span>def <span class="ident">getPr4Name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a handle to the first Java GATE processing resource that has the given name
or None if none found.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the processing resource</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the processing resource or None</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getPrNames"><code class="name flex">
<span>def <span class="ident">getPrNames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of known Java GATE
processing resource names.</p>
<h2 id="returns">Returns</h2>
<p>list of PR names</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getResources4Name"><code class="name flex">
<span>def <span class="ident">getResources4Name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a (possibly empty) list of all Java GATE resources with the given name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name of the resources</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of matching resources</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.getResources4NameClass"><code class="name flex">
<span>def <span class="ident">getResources4NameClass</span></span>(<span>self, name, clazz)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a (possibly empty) list of all Java GATE resources with the given name and class name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name of the resources</dd>
<dt><strong><code>clazz</code></strong></dt>
<dd>the name of the java class the resource must be an instance of</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of matching resources</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.jsonAnnsets4Doc"><code class="name flex">
<span>def <span class="ident">jsonAnnsets4Doc</span></span>(<span>self, gdoc, jannsets=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the JSON representation of the annotation sets in the GATE document, optionally
filtered by the given annsets specification.</p>
<p>The annsets specification should have the format as expected on the Java side: a list
of lists of string. Each inner list has the set name to include as the first element
and either null as the second element to include all types, or the types to include
as the 2nd and subsequent elements.</p>
<p>The method pannsets2gannsets(annsets) can be used to convert from our standard annset
specification to the Java annsets specification.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>handle to Java GATE document</dd>
<dt><strong><code>jannsets</code></strong></dt>
<dd>the annotation specification list as a Java list</dd>
</dl>
<p>Returns:</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.loadDocumentFromFile"><code class="name flex">
<span>def <span class="ident">loadDocumentFromFile</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a Java GATE document from the given file name and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>the file name/path of the Java GATE document to load.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the Java GATE document</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.loadDocumentFromFile4Mime"><code class="name flex">
<span>def <span class="ident">loadDocumentFromFile4Mime</span></span>(<span>self, filename, mimetype)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a Java GATE document from the given file name, using the given mime type
and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>the file name/path of the Java GATE document to load.</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>the mimetype to use</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the Java GATE document</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.loadMavenPlugin"><code class="name flex">
<span>def <span class="ident">loadMavenPlugin</span></span>(<span>self, group, artifact, version)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the given Maven plugin into Java GATE.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>group</code></strong></dt>
<dd>group id of the plugin</dd>
<dt><strong><code>artifact</code></strong></dt>
<dd>artifact id of the plugin</dd>
<dt><strong><code>version</code></strong></dt>
<dd>version of the plugin</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.loadPipelineFromFile"><code class="name flex">
<span>def <span class="ident">loadPipelineFromFile</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a pipeline/controller from the given file into Java GATE and return a CorpusController handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>the filename/path of the pipeline file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a CorpusController handle to the loaded Java GATE pipeline</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.loadPipelineFromPlugin"><code class="name flex">
<span>def <span class="ident">loadPipelineFromPlugin</span></span>(<span>self, group, artifact, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a prepared pipeline from the given loaded GATE Mave plugin into Java GATE and return
a CorpusController handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>group</code></strong></dt>
<dd>maven group id the plugin</dd>
<dt><strong><code>artifact</code></strong></dt>
<dd>artifact id of the plugin</dd>
<dt><strong><code>path</code></strong></dt>
<dd>path of the pipeline in the JAR</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a CorpusController handle to the pipeline</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.load_gdoc"><code class="name flex">
<span>def <span class="ident">load_gdoc</span></span>(<span>self, path, mimetype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Let GATE load a document from the given path and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>path to the gate document to load.</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>a mimetype to use when loading. (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a handle to the Java GATE document</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.load_pdoc"><code class="name flex">
<span>def <span class="ident">load_pdoc</span></span>(<span>self, path, mimetype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a document from the given path, using GATE and convert and return as gatenlp Python document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>path to load document from</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>mime type to use (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>gatenlp document</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.logActions"><code class="name flex">
<span>def <span class="ident">logActions</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable/disable logging of actions carried out on the Java GATE side to the Java GATE logger.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flag</code></strong></dt>
<dd>True to enable logging of actions</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.log_actions"><code class="name flex">
<span>def <span class="ident">log_actions</span></span>(<span>self, onoff)</span>
</code></dt>
<dd>
<div class="desc"><p>Swith logging actions at the slave on or off.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>onoff</code></strong></dt>
<dd>True to log actions, False to not log them</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.newCorpus"><code class="name flex">
<span>def <span class="ident">newCorpus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a handle to a new Java GATE corpus.</p>
<h2 id="returns">Returns</h2>
<p>handle to the Java GATE corpus</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.pannsets2gannsets"><code class="name flex">
<span>def <span class="ident">pannsets2gannsets</span></span>(<span>self, annsets=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from our convention to specifiy annotation sets and types to a Java list.
This is necessary because py4j does not by default convert lists properly and also
because our Java representation of the annsets specification has a different structure.
The list returned from this is already a Java list!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annsets</code></strong></dt>
<dd>annsets specification to convert</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>java representation of the annsets specification (or None)</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.pdoc2gdoc"><code class="name flex">
<span>def <span class="ident">pdoc2gdoc</span></span>(<span>self, pdoc, annsets=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the Python gatenlp document to a GATE document and return a handle to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdoc</code></strong></dt>
<dd>python gatenlp Document</dd>
<dt><strong><code>annsets</code></strong></dt>
<dd>a list of either set names, or tuples where the first element is a set name and the
second element is either a type name or a list of type names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>handle to GATE document</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.pluginBuild"><code class="name flex">
<span>def <span class="ident">pluginBuild</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the short commit id of the Python plugin on the Java GATE side.</p>
<h2 id="returns">Returns</h2>
<p>commit id of Python plugin</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.pluginVersion"><code class="name flex">
<span>def <span class="ident">pluginVersion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the version string of the Python plugin on the Java GATE side.</p>
<h2 id="returns">Returns</h2>
<p>version string of Python plugin</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.print2err"><code class="name flex">
<span>def <span class="ident">print2err</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Output the given message to System.err on the Java GATE side.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>string to output</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.print2out"><code class="name flex">
<span>def <span class="ident">print2out</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Output the given message to System.out on the Java GATE side.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>string to output</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.run4Corpus"><code class="name flex">
<span>def <span class="ident">run4Corpus</span></span>(<span>self, pipeline, corpus)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the given Java GATE pipeline on the given Java GATE corpus.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pipeline</code></strong></dt>
<dd>handle to a Java GATE pipeline</dd>
<dt><strong><code>corpus</code></strong></dt>
<dd>handle to a Java GATE corpus</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.run4Document"><code class="name flex">
<span>def <span class="ident">run4Document</span></span>(<span>self, pipeline, gdoc)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the given Java GATE pipeline on the given Java GATE document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pipeline</code></strong></dt>
<dd>handle to a Java GATE pipeline</dd>
<dt><strong><code>gdoc</code></strong></dt>
<dd>handle to a Java GATE document</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.runExcecutionFinished"><code class="name flex">
<span>def <span class="ident">runExcecutionFinished</span></span>(<span>self, pipeline)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the execution finished method for the given Java GATE pipeline.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pipeline</code></strong></dt>
<dd>handle to a Java GATE pipeline</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.runExcecutionStarted"><code class="name flex">
<span>def <span class="ident">runExcecutionStarted</span></span>(<span>self, pipeline)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the execution started method for the given Java GATE pipeline.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pipeline</code></strong></dt>
<dd>handle to a Java GATE pipeline</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.saveDocumentToFile"><code class="name flex">
<span>def <span class="ident">saveDocumentToFile</span></span>(<span>self, gdoc, filename, mimetype)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the Java GATE document to the given file, using the given mime type.
At the moment this supports the GATE XML format (mimetype="") as well as
formats supported by the FastInfoset
FormatBdoc plugins.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>handle to Java GATE document</dd>
<dt><strong><code>filename</code></strong></dt>
<dd>name/path of the file to save to</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>the mime type to determine the format, "" for GATE XML</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.save_gdoc"><code class="name flex">
<span>def <span class="ident">save_gdoc</span></span>(<span>self, gdoc, path, mimetype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save GATE document to the given path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdoc</code></strong></dt>
<dd>GATE document handle</dd>
<dt><strong><code>path</code></strong></dt>
<dd>destination path</dd>
<dt><strong><code>mimetype</code></strong></dt>
<dd>mimtetype, only the following types are allowed: ""/None: GATE XML,
application/fastinfoset, and all mimetypes supported by the
Format_Bdoc plugin. (Default value = None)</dd>
</dl></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.showGui"><code class="name flex">
<span>def <span class="ident">showGui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>(CAUTION: EXPERIMENTAL) this shows the GATE GUI if we a re connected to a GATE process that runs without
showing the GUI.</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlave.show_gui"><code class="name flex">
<span>def <span class="ident">show_gui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the GUI for the started GATE process.</p>
<p>NOTE: this is more of a hack and may cause sync problems
when closing down the GATE slave.</p></div>
</dd>
</dl>
</dd>
<dt id="gatenlp.gateslave.GateSlaveAnnotator"><code class="flex name class">
<span>class <span class="ident">GateSlaveAnnotator</span></span>
<span>(</span><span>pipeline, gatehome=None, port=25333, annsets_send=None, annsets_receive=None, replace_anns=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Create a GateSlave annotator.</p>
<p>This starts the gate slave, loads the pipeline and
can then be used to annotate Python gatenlp Document instances with the Java GATE
pipeline.</p>
<p>Note: to make sure that start/finish callbacks on the Java side are invoked, the annotator
start() method should be invoked once before processing documents and finish() should
get called once after processing documents. (Any Executor implementation shoudl do this
autimatically)</p>
<p>If the GateSlaveAnnotator is not used any more, close() should be invoked to terminate
the Java GATE Slave process.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">pipeline = GateSlaveAnnotator(&quot;annie.xgapp&quot;)
for idx, doc in enumerate(mycorpus):
    corpus[idx] = pipeline(doc)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pipeline</code></strong></dt>
<dd>the path to a Java GATE pipeline to load into the GATE slave</dd>
<dt><strong><code>gatehome</code></strong></dt>
<dd>the gate home directory to use, if not set, uses environment variable GATE_HOME</dd>
<dt><strong><code>port</code></strong></dt>
<dd>the port to use (25333)</dd>
<dt><strong><code>annsets_send</code></strong></dt>
<dd>a list of either annotation set names, or tuples where the first element
is the name of an annotation set and the second element is either the name of a type
or a list of type names. If not None, only the sets/types specified are sent to Java GATE.
If an empty list is specified, no annotations are sent at all.</dd>
<dt><strong><code>annsets_receive</code></strong></dt>
<dd>same format as annsets_send to specify which annotation sets/types are
sent back to Python after the document has been processed on the Java side.</dd>
<dt><strong><code>replace_anns</code></strong></dt>
<dd>if True and an annotation is received which already exists (same set and annotation id)
then the existing annotation is replaced (if offsets and type are also same, only the features are
replaced). If False, all received annotations are added which may change their annotation id.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GateSlaveAnnotator(Annotator):
    # TODO: something that starts a gate slave when created, loads pipeline in Java GATE,
    # sends over document
    # or document and selection of annotation sets/annotation types, runs pipeline,
    # and then fetches one or more annotation sets and updates the local document with them.
    # TODO: parameter to influence how exceptions are handled
    def __init__(
        self,
        pipeline,
        gatehome=None,
        port=25333,
        annsets_send=None,
        annsets_receive=None,
        replace_anns=False,
    ):
        &#34;&#34;&#34;
        Create a GateSlave annotator.

        This starts the gate slave, loads the pipeline and
        can then be used to annotate Python gatenlp Document instances with the Java GATE
        pipeline.

        Note: to make sure that start/finish callbacks on the Java side are invoked, the annotator
        start() method should be invoked once before processing documents and finish() should
        get called once after processing documents. (Any Executor implementation shoudl do this
        autimatically)

        If the GateSlaveAnnotator is not used any more, close() should be invoked to terminate
        the Java GATE Slave process.

        Example:

            ```python
            pipeline = GateSlaveAnnotator(&#34;annie.xgapp&#34;)
            for idx, doc in enumerate(mycorpus):
                corpus[idx] = pipeline(doc)
            ```

        Args:
            pipeline: the path to a Java GATE pipeline to load into the GATE slave
            gatehome: the gate home directory to use, if not set, uses environment variable GATE_HOME
            port: the port to use (25333)
            annsets_send: a list of either annotation set names, or tuples where the first element
                is the name of an annotation set and the second element is either the name of a type
                or a list of type names. If not None, only the sets/types specified are sent to Java GATE.
                If an empty list is specified, no annotations are sent at all.
            annsets_receive: same format as annsets_send to specify which annotation sets/types are
                sent back to Python after the document has been processed on the Java side.
            replace_anns: if True and an annotation is received which already exists (same set and annotation id)
              then the existing annotation is replaced (if offsets and type are also same, only the features are
              replaced). If False, all received annotations are added which may change their annotation id.
        &#34;&#34;&#34;
        self.pipeline = pipeline
        self.annsets_send = annsets_send
        self.annsets_receive = annsets_receive
        self.replace_anns = replace_anns
        self.gs = GateSlave(port=port, start=True, gatehome=gatehome)
        self.controller = self.gs.slave.loadPipelineFromFile(self.pipeline)
        self.corpus = self.gs.slave.newCorpus()
        self.controller.setCorpus(self.corpus)
        self.controller.setControllerCallbacksEnabled(False)

    def close(self):
        &#34;&#34;&#34;
        Shut down the GateSlave used by this annotator.

        After calling this, the GateSlaveAnnotator instance cannot be used any more.
        &#34;&#34;&#34;
        self.gs.close()

    def start(self):
        &#34;&#34;&#34;
        Invoke the controller execution started method on the GATE controller.
        &#34;&#34;&#34;
        self.controller.invokeControllerExecutionStarted()

    def finish(self):
        &#34;&#34;&#34;
        Invoke the controller execution finished method on the GATE controller.
        &#34;&#34;&#34;
        self.controller.invokeControllerExecutionFinished()

    def __call__(self, doc, **kwargs):
        &#34;&#34;&#34;
        Run the GATE controller on the given document.

        This runs the GATE pipeline (controller) on the given document by first sending the document
        to the GATE process and coverting it to a GATE document there, running the pipeline on it,
        and sending the document back and converting back to a new gatenlp Document.

        Args:
            doc: the document to process
            **kwargs: ignored so far

        Returns:
            the processed gatenlp document
        &#34;&#34;&#34;
        if self.annsets_send is not None:
            # create shallow copy, we only need it for reading!
            tmpdoc = doc.copy(annsets=self.annsets_send)
        else:
            tmpdoc = doc
        gdoc = self.gs.pdoc2gdoc(tmpdoc)
        self.gs.slave.run4Document(self.controller, gdoc)
        self.gs.gdocanns2pdoc(gdoc, doc, annsets=self.annsets_receive, replace=self.replace_anns)
        self.gs.del_resource(gdoc)
        return doc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gatenlp.processing.annotator.Annotator" href="processing/annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gatenlp.gateslave.GateSlaveAnnotator.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, doc, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the GATE controller on the given document.</p>
<p>This runs the GATE pipeline (controller) on the given document by first sending the document
to the GATE process and coverting it to a GATE document there, running the pipeline on it,
and sending the document back and converting back to a new gatenlp Document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>doc</code></strong></dt>
<dd>the document to process</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>ignored so far</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the processed gatenlp document</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlaveAnnotator.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Shut down the GateSlave used by this annotator.</p>
<p>After calling this, the GateSlaveAnnotator instance cannot be used any more.</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlaveAnnotator.finish"><code class="name flex">
<span>def <span class="ident">finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invoke the controller execution finished method on the GATE controller.</p></div>
</dd>
<dt id="gatenlp.gateslave.GateSlaveAnnotator.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invoke the controller execution started method on the GATE controller.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gatenlp.processing.annotator.Annotator" href="processing/annotator.html#gatenlp.processing.annotator.Annotator">Annotator</a></b></code>:
<ul class="hlist">
<li><code><a title="gatenlp.processing.annotator.Annotator.pipe" href="processing/annotator.html#gatenlp.processing.annotator.Annotator.pipe">pipe</a></code></li>
<li><code><a title="gatenlp.processing.annotator.Annotator.reduce" href="processing/annotator.html#gatenlp.processing.annotator.Annotator.reduce">reduce</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gatenlp" href="index.html">gatenlp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gatenlp.gateslave.classpath_sep" href="#gatenlp.gateslave.classpath_sep">classpath_sep</a></code></li>
<li><code><a title="gatenlp.gateslave.gate_classpath" href="#gatenlp.gateslave.gate_classpath">gate_classpath</a></code></li>
<li><code><a title="gatenlp.gateslave.main" href="#gatenlp.gateslave.main">main</a></code></li>
<li><code><a title="gatenlp.gateslave.start_gate_slave" href="#gatenlp.gateslave.start_gate_slave">start_gate_slave</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gatenlp.gateslave.GateSlave" href="#gatenlp.gateslave.GateSlave">GateSlave</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.gateslave.GateSlave.close" href="#gatenlp.gateslave.GateSlave.close">close</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.createDocument" href="#gatenlp.gateslave.GateSlave.createDocument">createDocument</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.del_resource" href="#gatenlp.gateslave.GateSlave.del_resource">del_resource</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.deleteResource" href="#gatenlp.gateslave.GateSlave.deleteResource">deleteResource</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.download" href="#gatenlp.gateslave.GateSlave.download">download</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.findMavenPlugin" href="#gatenlp.gateslave.GateSlave.findMavenPlugin">findMavenPlugin</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.gate_build" href="#gatenlp.gateslave.GateSlave.gate_build">gate_build</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.gate_version" href="#gatenlp.gateslave.GateSlave.gate_version">gate_version</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.gdoc2pdoc" href="#gatenlp.gateslave.GateSlave.gdoc2pdoc">gdoc2pdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.gdocanns2pdoc" href="#gatenlp.gateslave.GateSlave.gdocanns2pdoc">gdocanns2pdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getBdocJson" href="#gatenlp.gateslave.GateSlave.getBdocJson">getBdocJson</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getCorpus4Name" href="#gatenlp.gateslave.GateSlave.getCorpus4Name">getCorpus4Name</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getCorpusNames" href="#gatenlp.gateslave.GateSlave.getCorpusNames">getCorpusNames</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getDocument4BdocJson" href="#gatenlp.gateslave.GateSlave.getDocument4BdocJson">getDocument4BdocJson</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getDocument4Name" href="#gatenlp.gateslave.GateSlave.getDocument4Name">getDocument4Name</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getDocumentNames" href="#gatenlp.gateslave.GateSlave.getDocumentNames">getDocumentNames</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getPipeline4Name" href="#gatenlp.gateslave.GateSlave.getPipeline4Name">getPipeline4Name</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getPipelineNames" href="#gatenlp.gateslave.GateSlave.getPipelineNames">getPipelineNames</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getPr4Name" href="#gatenlp.gateslave.GateSlave.getPr4Name">getPr4Name</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getPrNames" href="#gatenlp.gateslave.GateSlave.getPrNames">getPrNames</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getResources4Name" href="#gatenlp.gateslave.GateSlave.getResources4Name">getResources4Name</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.getResources4NameClass" href="#gatenlp.gateslave.GateSlave.getResources4NameClass">getResources4NameClass</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.jsonAnnsets4Doc" href="#gatenlp.gateslave.GateSlave.jsonAnnsets4Doc">jsonAnnsets4Doc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.loadDocumentFromFile" href="#gatenlp.gateslave.GateSlave.loadDocumentFromFile">loadDocumentFromFile</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.loadDocumentFromFile4Mime" href="#gatenlp.gateslave.GateSlave.loadDocumentFromFile4Mime">loadDocumentFromFile4Mime</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.loadMavenPlugin" href="#gatenlp.gateslave.GateSlave.loadMavenPlugin">loadMavenPlugin</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.loadPipelineFromFile" href="#gatenlp.gateslave.GateSlave.loadPipelineFromFile">loadPipelineFromFile</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.loadPipelineFromPlugin" href="#gatenlp.gateslave.GateSlave.loadPipelineFromPlugin">loadPipelineFromPlugin</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.load_gdoc" href="#gatenlp.gateslave.GateSlave.load_gdoc">load_gdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.load_pdoc" href="#gatenlp.gateslave.GateSlave.load_pdoc">load_pdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.logActions" href="#gatenlp.gateslave.GateSlave.logActions">logActions</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.log_actions" href="#gatenlp.gateslave.GateSlave.log_actions">log_actions</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.newCorpus" href="#gatenlp.gateslave.GateSlave.newCorpus">newCorpus</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.pannsets2gannsets" href="#gatenlp.gateslave.GateSlave.pannsets2gannsets">pannsets2gannsets</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.pdoc2gdoc" href="#gatenlp.gateslave.GateSlave.pdoc2gdoc">pdoc2gdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.pluginBuild" href="#gatenlp.gateslave.GateSlave.pluginBuild">pluginBuild</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.pluginVersion" href="#gatenlp.gateslave.GateSlave.pluginVersion">pluginVersion</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.print2err" href="#gatenlp.gateslave.GateSlave.print2err">print2err</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.print2out" href="#gatenlp.gateslave.GateSlave.print2out">print2out</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.run4Corpus" href="#gatenlp.gateslave.GateSlave.run4Corpus">run4Corpus</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.run4Document" href="#gatenlp.gateslave.GateSlave.run4Document">run4Document</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.runExcecutionFinished" href="#gatenlp.gateslave.GateSlave.runExcecutionFinished">runExcecutionFinished</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.runExcecutionStarted" href="#gatenlp.gateslave.GateSlave.runExcecutionStarted">runExcecutionStarted</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.saveDocumentToFile" href="#gatenlp.gateslave.GateSlave.saveDocumentToFile">saveDocumentToFile</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.save_gdoc" href="#gatenlp.gateslave.GateSlave.save_gdoc">save_gdoc</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.showGui" href="#gatenlp.gateslave.GateSlave.showGui">showGui</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlave.show_gui" href="#gatenlp.gateslave.GateSlave.show_gui">show_gui</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gatenlp.gateslave.GateSlaveAnnotator" href="#gatenlp.gateslave.GateSlaveAnnotator">GateSlaveAnnotator</a></code></h4>
<ul class="">
<li><code><a title="gatenlp.gateslave.GateSlaveAnnotator.__call__" href="#gatenlp.gateslave.GateSlaveAnnotator.__call__">__call__</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlaveAnnotator.close" href="#gatenlp.gateslave.GateSlaveAnnotator.close">close</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlaveAnnotator.finish" href="#gatenlp.gateslave.GateSlaveAnnotator.finish">finish</a></code></li>
<li><code><a title="gatenlp.gateslave.GateSlaveAnnotator.start" href="#gatenlp.gateslave.GateSlaveAnnotator.start">start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2.dev22+gf4251dd</a>.</p>
</footer>
</body>
</html>